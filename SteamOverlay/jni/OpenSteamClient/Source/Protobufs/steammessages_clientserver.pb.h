// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_clientserver.proto

#ifndef PROTOBUF_steammessages_5fclientserver_2eproto__INCLUDED
#define PROTOBUF_steammessages_5fclientserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "steammessages_base.pb.h"
#include "encrypted_app_ticket.pb.h"
// @@protoc_insertion_point(includes)

namespace Sc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

class CMsgClientHeartBeat;
class CMsgClientSubscribeToPersonaFeed;
class CMsgClientSubscribeToPersonaFeed_PersonaFeed;
class CMsgClientUDSP2PSessionStarted;
class CMsgClientUDSP2PSessionEnded;
class CMsgClientRegisterAuthTicketWithCM;
class CMsgClientTicketAuthComplete;
class CMsgClientLogon;
class CMsgClientLogonResponse;
class CMsgClientRequestWebAPIAuthenticateUserNonce;
class CMsgClientRequestWebAPIAuthenticateUserNonceResponse;
class CMsgClientLogOff;
class CMsgClientLoggedOff;
class CMsgClientCMList;
class CMsgClientP2PConnectionInfo;
class CMsgClientP2PConnectionFailInfo;
class CMsgClientGetAppOwnershipTicket;
class CMsgClientGetAppOwnershipTicketResponse;
class CMsgClientSessionToken;
class CMsgClientGameConnectTokens;
class CMsgGSServerType;
class CMsgGSStatusReply;
class CMsgGSPlayerList;
class CMsgGSPlayerList_Player;
class CMsgGSUserPlaying;
class CMsgGSDisconnectNotice;
class CMsgClientGamesPlayed;
class CMsgClientGamesPlayed_GamePlayed;
class CMsgGSApprove;
class CMsgGSDeny;
class CMsgGSKick;
class CMsgClientAuthList;
class CMsgClientAuthListAck;
class CMsgClientFriendsList;
class CMsgClientFriendsList_Friend;
class CMsgClientFriendsGroupsList;
class CMsgClientFriendsGroupsList_FriendGroup;
class CMsgClientFriendsGroupsList_FriendGroupsMembership;
class CMsgClientPlayerNicknameList;
class CMsgClientPlayerNicknameList_PlayerNickname;
class CMsgClientSetPlayerNickname;
class CMsgClientSetPlayerNicknameResponse;
class CMsgClientLicenseList;
class CMsgClientLicenseList_License;
class CMsgClientLBSSetScore;
class CMsgClientLBSSetScoreResponse;
class CMsgClientLBSSetUGC;
class CMsgClientLBSSetUGCResponse;
class CMsgClientLBSFindOrCreateLB;
class CMsgClientLBSFindOrCreateLBResponse;
class CMsgClientLBSGetLBEntries;
class CMsgClientLBSGetLBEntriesResponse;
class CMsgClientLBSGetLBEntriesResponse_Entry;
class CMsgClientAccountInfo;
class CMsgClientAppMinutesPlayedData;
class CMsgClientAppMinutesPlayedData_AppMinutesPlayedData;
class CMsgClientIsLimitedAccount;
class CMsgClientRequestFriendData;
class CMsgClientChangeStatus;
class CMsgPersonaChangeResponse;
class CMsgClientPersonaState;
class CMsgClientPersonaState_Friend;
class CMsgClientFriendProfileInfo;
class CMsgClientFriendProfileInfoResponse;
class CMsgClientServerList;
class CMsgClientServerList_Server;
class CMsgClientRequestedClientStats;
class CMsgClientRequestedClientStats_StatsToSend;
class CMsgClientStat2;
class CMsgClientStat2_StatDetail;
class CMsgClientMMSCreateLobby;
class CMsgClientMMSCreateLobbyResponse;
class CMsgClientMMSJoinLobby;
class CMsgClientMMSJoinLobbyResponse;
class CMsgClientMMSJoinLobbyResponse_Member;
class CMsgClientMMSLeaveLobby;
class CMsgClientMMSLeaveLobbyResponse;
class CMsgClientMMSGetLobbyList;
class CMsgClientMMSGetLobbyList_Filter;
class CMsgClientMMSGetLobbyListResponse;
class CMsgClientMMSGetLobbyListResponse_Lobby;
class CMsgClientMMSSetLobbyData;
class CMsgClientMMSSetLobbyDataResponse;
class CMsgClientMMSGetLobbyData;
class CMsgClientMMSLobbyData;
class CMsgClientMMSLobbyData_Member;
class CMsgClientMMSSendLobbyChatMsg;
class CMsgClientMMSLobbyChatMsg;
class CMsgClientMMSSetLobbyOwner;
class CMsgClientMMSSetLobbyOwnerResponse;
class CMsgClientMMSSetLobbyLinked;
class CMsgClientMMSSetLobbyGameServer;
class CMsgClientMMSLobbyGameServerSet;
class CMsgClientMMSUserJoinedLobby;
class CMsgClientMMSUserLeftLobby;
class CMsgClientMMSInviteToLobby;
class CMsgClientUDSInviteToGame;
class CMsgClientChatInvite;
class CMsgClientConnectionStats;
class CMsgClientConnectionStats_Stats_Logon;
class CMsgClientConnectionStats_Stats_UDP;
class CMsgClientConnectionStats_Stats_VConn;
class CMsgClientServersAvailable;
class CMsgClientServersAvailable_Server_Types_Available;
class CMsgClientGetUserStats;
class CMsgClientGetUserStatsResponse;
class CMsgClientGetUserStatsResponse_Stats;
class CMsgClientGetUserStatsResponse_Achievement_Blocks;
class CMsgClientStoreUserStatsResponse;
class CMsgClientStoreUserStatsResponse_Stats_Failed_Validation;
class CMsgClientStoreUserStats2;
class CMsgClientStoreUserStats2_Stats;
class CMsgClientStatsUpdated;
class CMsgClientStatsUpdated_Updated_Stats;
class CMsgClientStoreUserStats;
class CMsgClientStoreUserStats_Stats_To_Store;
class CMsgClientGetClientDetails;
class CMsgClientReportOverlayDetourFailure;
class CMsgClientGetClientDetailsResponse;
class CMsgClientGetClientDetailsResponse_Game;
class CMsgClientGetClientAppList;
class CMsgClientGetClientAppListResponse;
class CMsgClientGetClientAppListResponse_App;
class CMsgClientGetClientAppListResponse_App_DLC;
class CMsgClientInstallClientApp;
class CMsgClientInstallClientAppResponse;
class CMsgClientUninstallClientApp;
class CMsgClientUninstallClientAppResponse;
class CMsgClientSetClientAppUpdateState;
class CMsgClientSetClientAppUpdateStateResponse;
class CMsgClientUFSUploadFileRequest;
class CMsgClientUFSUploadFileResponse;
class CMsgClientUFSFileChunk;
class CMsgClientUFSTransferHeartbeat;
class CMsgClientUFSUploadFileFinished;
class CMsgClientUFSDeleteFileRequest;
class CMsgClientUFSDeleteFileResponse;
class CMsgClientUFSGetFileListForApp;
class CMsgClientUFSGetFileListForAppResponse;
class CMsgClientUFSGetFileListForAppResponse_File;
class CMsgClientUFSDownloadRequest;
class CMsgClientUFSDownloadResponse;
class CMsgClientUFSLoginRequest;
class CMsgClientUFSLoginResponse;
class CMsgClientRequestEncryptedAppTicket;
class CMsgClientRequestEncryptedAppTicketResponse;
class CMsgClientRequestOAuthTokenForApp;
class CMsgClientRequestOAuthTokenForAppResponse;
class CMsgClientWalletInfoUpdate;
class CMsgClientAppInfoUpdate;
class CMsgClientAppInfoChanges;
class CMsgClientAppInfoRequest;
class CMsgClientAppInfoRequest_App;
class CMsgClientAppInfoResponse;
class CMsgClientAppInfoResponse_App;
class CMsgClientAppInfoResponse_App_Section;
class CMsgClientPackageInfoRequest;
class CMsgClientPackageInfoResponse;
class CMsgClientPackageInfoResponse_Package;
class CMsgPICSChangesSinceRequest;
class CMsgPICSChangesSinceResponse;
class CMsgPICSChangesSinceResponse_PackageChange;
class CMsgPICSChangesSinceResponse_AppChange;
class CMsgPICSProductInfoRequest;
class CMsgPICSProductInfoRequest_AppInfo;
class CMsgPICSProductInfoRequest_PackageInfo;
class CMsgPICSProductInfoResponse;
class CMsgPICSProductInfoResponse_AppInfo;
class CMsgPICSProductInfoResponse_PackageInfo;
class CMsgPICSAccessTokenRequest;
class CMsgPICSAccessTokenResponse;
class CMsgPICSAccessTokenResponse_PackageToken;
class CMsgPICSAccessTokenResponse_AppToken;
class CMsgClientUFSGetUGCDetails;
class CMsgClientUFSGetUGCDetailsResponse;
class CMsgClientUFSGetSingleFileInfo;
class CMsgClientUFSGetSingleFileInfoResponse;
class CMsgClientUFSShareFile;
class CMsgClientUFSShareFileResponse;
class CMsgClientNewLoginKey;
class CMsgClientNewLoginKeyAccepted;
class CMsgClientAMGetClanOfficers;
class CMsgClientAMGetClanOfficersResponse;
class CMsgClientAMGetPersonaNameHistory;
class CMsgClientAMGetPersonaNameHistory_IdInstance;
class CMsgClientAMGetPersonaNameHistoryResponse;
class CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance;
class CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance;
class CMsgClientDeregisterWithServer;
class CMsgClientClanState;
class CMsgClientClanState_NameInfo;
class CMsgClientClanState_UserCounts;
class CMsgClientClanState_Event;
class CMsgClientFriendMsg;
class CMsgClientFriendMsgIncoming;
class CMsgClientAddFriend;
class CMsgClientAddFriendResponse;
class CMsgClientRemoveFriend;
class CMsgClientHideFriend;
class CMsgClientUCMAddScreenshot;
class CMsgClientUCMAddScreenshot_Tag;
class CMsgClientUCMAddScreenshotResponse;
class CMsgClientUCMDeleteScreenshot;
class CMsgClientUCMDeleteScreenshotResponse;
class CMsgClientUCMPublishFile;
class CMsgClientUCMPublishFileResponse;
class CMsgClientUCMUpdatePublishedFile;
class CMsgClientUCMUpdatePublishedFileResponse;
class CMsgClientUCMGetPublishedFileDetails;
class CMsgClientUCMGetPublishedFileDetailsResponse;
class CMsgClientUCMDeletePublishedFile;
class CMsgClientUCMDeletePublishedFileResponse;
class CMsgClientUCMEnumerateUserPublishedFiles;
class CMsgClientUCMEnumerateUserPublishedFilesResponse;
class CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId;
class CMsgClientUCMSubscribePublishedFile;
class CMsgClientUCMSubscribePublishedFileResponse;
class CMsgClientUCMEnumerateUserSubscribedFiles;
class CMsgClientUCMEnumerateUserSubscribedFilesResponse;
class CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId;
class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates;
class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse;
class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId;
class CMsgClientUCMUnsubscribePublishedFile;
class CMsgClientUCMUnsubscribePublishedFileResponse;
class CMsgClientUCMPublishedFileSubscribed;
class CMsgClientUCMPublishedFileUnsubscribed;
class CMsgClientUCMPublishedFileDeleted;
class CMsgClientUCMGetPublishedFilesForUser;
class CMsgClientUCMGetPublishedFilesForUserResponse;
class CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId;
class CMsgClientUCMSetUserPublishedFileAction;
class CMsgClientUCMSetUserPublishedFileActionResponse;
class CMsgClientUCMEnumeratePublishedFilesByUserAction;
class CMsgClientUCMEnumeratePublishedFilesByUserActionResponse;
class CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId;
class CMsgClientScreenshotsChanged;
class CMsgClientUpdateUserGameInfo;
class CMsgClientRichPresenceUpload;
class CMsgClientRichPresenceRequest;
class CMsgClientRichPresenceInfo;
class CMsgClientRichPresenceInfo_RichPresence;
class CMsgClientCheckFileSignature;
class CMsgClientCheckFileSignatureResponse;
class CMsgClientReadMachineAuth;
class CMsgClientReadMachineAuthResponse;
class CMsgClientUpdateMachineAuth;
class CMsgClientUpdateMachineAuthResponse;
class CMsgClientRequestMachineAuth;
class CMsgClientRequestMachineAuthResponse;
class CMsgClientChangeSteamGuardOptions;
class CMsgClientChangeSteamGuardOptionsResponse;
class CMsgClientCreateFriendsGroup;
class CMsgClientCreateFriendsGroupResponse;
class CMsgClientDeleteFriendsGroup;
class CMsgClientDeleteFriendsGroupResponse;
class CMsgClientRenameFriendsGroup;
class CMsgClientRenameFriendsGroupResponse;
class CMsgClientAddFriendToGroup;
class CMsgClientAddFriendToGroupResponse;
class CMsgClientRemoveFriendFromGroup;
class CMsgClientRemoveFriendFromGroupResponse;
class CMsgClientRegisterKey;
class CMsgClientPurchaseResponse;
class CMsgClientActivateOEMLicense;
class CMsgClientPurchaseWithMachineID;
class CMsgTrading_InitiateTradeRequest;
class CMsgTrading_InitiateTradeResponse;
class CMsgTrading_CancelTradeRequest;
class CMsgTrading_StartSession;
class CMsgClientMDSInitDepotBuildRequest;
class CMsgClientMDSInitDepotBuildResponse;
class CMsgClientMDSLoginRequest;
class CMsgClientMDSLoginResponse;
class CMsgClientMDSUploadDepotChunks;
class CMsgClientMDSUploadDepotChunks_ChunkUploadData;
class CMsgClientMDSUploadDepotChunksResponse;
class CMsgClientMDSUploadRateTest;
class CMsgClientMDSUploadRateTestResponse;
class CMsgClientMDSTransmitManifestDataChunk;
class CMsgClientMDSUploadManifestRequest;
class CMsgClientMDSUploadManifestResponse;
class CMsgClientMDSGetDepotManifest;
class CMsgClientMDSGetDepotManifestResponse;
class CMsgClientMDSGetDepotManifestChunk;
class CMsgClientMDSRegisterAppBuild;
class CMsgClientMDSRegisterAppBuildResponse;
class CMsgMDSSetAppBuildLive;
class CMsgMDSSetAppBuildLiveResponse;
class CMsgClientMDSSignInstallScript;
class CMsgClientMDSSignInstallScriptResponse;
class CMsgClientEmailChange;
class CMsgClientEmailChangeResponse;
class CMsgClientGetCDNAuthToken;
class CMsgClientGetDepotDecryptionKey;
class CMsgClientGetDepotDecryptionKeyResponse;
class CMsgClientGetAppBetaPasswords;
class CMsgClientGetAppBetaPasswordsResponse;
class CMsgClientGetAppBetaPasswordsResponse_BetaPassword;
class CMsgClientUpdateAppJobReport;
class CMsgClientGetCDNAuthTokenResponse;
class CMsgDownloadRateStatistics;
class CMsgDownloadRateStatistics_StatsInfo;
class CMsgClientRequestAccountData;
class CMsgClientRequestAccountDataResponse;
class CMsgClientUGSGetGlobalStats;
class CMsgClientUGSGetGlobalStatsResponse;
class CMsgClientUGSGetGlobalStatsResponse_Day;
class CMsgClientUGSGetGlobalStatsResponse_Day_Stat;
class CMsgGameServerData;
class CMsgGameServerData_Player;
class CMsgGameServerRemove;
class CMsgClientGMSServerQuery;
class CMsgGMSClientServerQueryResponse;
class CMsgGMSClientServerQueryResponse_Server;
class CMsgGameServerOutOfDate;
class CMsgClientRedeemGuestPass;
class CMsgClientRedeemGuestPassResponse;
class CMsgClientGetClanActivityCounts;
class CMsgClientGetClanActivityCountsResponse;
class CMsgClientOGSReportString;
class CMsgClientOGSReportBug;
class CMsgGSAssociateWithClan;
class CMsgGSAssociateWithClanResponse;
class CMsgGSComputeNewPlayerCompatibility;
class CMsgGSComputeNewPlayerCompatibilityResponse;
class CMsgClientSentLogs;
class CMsgGCClient;
class CMsgClientRequestFreeLicense;
class CMsgClientRequestFreeLicenseResponse;
class CMsgDRMDownloadRequestWithCrashData;
class CMsgDRMDownloadResponse;
class CMsgDRMFinalResult;
class CMsgClientDPCheckSpecialSurvey;
class CMsgClientDPCheckSpecialSurveyResponse;
class CMsgClientDPSendSpecialSurveyResponse;
class CMsgClientDPSendSpecialSurveyResponseReply;
class CMsgClientRequestForgottenPasswordEmail;
class CMsgClientRequestForgottenPasswordEmailResponse;
class CMsgClientItemAnnouncements;
class CMsgClientRequestItemAnnouncements;
class CMsgClientCommentNotifications;
class CMsgClientRequestCommentNotifications;
class CMsgClientOfflineMessageNotification;
class CMsgClientRequestOfflineMessageCount;
class CMsgClientFSGetFriendMessageHistory;
class CMsgClientFSGetFriendMessageHistoryResponse;
class CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage;
class CMsgClientFSGetFriendMessageHistoryForOfflineMessages;
class CMsgClientFSGetFriendsSteamLevels;
class CMsgClientFSGetFriendsSteamLevelsResponse;
class CMsgClientFSGetFriendsSteamLevelsResponse_Friend;
class CMsgClientEmailAddrInfo;
class CMsgCREEnumeratePublishedFiles;
class CMsgCREEnumeratePublishedFilesResponse;
class CMsgCREEnumeratePublishedFilesResponse_PublishedFileId;
class CMsgCRERankByVote;
class CMsgCRERankByVoteResponse;
class CMsgCRERankByVoteResponse_PublishedFileId;
class CMsgCRERankByTrend;
class CMsgCRERankByTrendResponse;
class CMsgCRERankByTrendResponse_PublishedFileId;
class CMsgCREItemVoteSummary;
class CMsgCREItemVoteSummary_PublishedFileId;
class CMsgCREItemVoteSummaryResponse;
class CMsgCREItemVoteSummaryResponse_ItemVoteSummary;
class CMsgCREUpdateUserPublishedItemVote;
class CMsgCREUpdateUserPublishedItemVoteResponse;
class CMsgCREGetUserPublishedItemVoteDetails;
class CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId;
class CMsgCREGetUserPublishedItemVoteDetailsResponse;
class CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail;
class CMsgGameServerPingSample;
class CMsgGameServerPingSample_Sample;
class CMsgFSGetFollowerCount;
class CMsgFSGetFollowerCountResponse;
class CMsgFSGetIsFollowing;
class CMsgFSGetIsFollowingResponse;
class CMsgFSEnumerateFollowingList;
class CMsgFSEnumerateFollowingListResponse;
class CMsgDPGetNumberOfCurrentPlayers;
class CMsgDPGetNumberOfCurrentPlayersResponse;
class CMsgClientFriendUserStatusPublished;
class CMsgClientServiceMethod;
class CMsgClientServiceMethodResponse;
class CMsgClientUIMode;

// ===================================================================

class CMsgClientHeartBeat : public ::google::protobuf::MessageLite {
 public:
  CMsgClientHeartBeat();
  virtual ~CMsgClientHeartBeat();

  CMsgClientHeartBeat(const CMsgClientHeartBeat& from);

  inline CMsgClientHeartBeat& operator=(const CMsgClientHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientHeartBeat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientHeartBeat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientHeartBeat* other);

  // implements Message ----------------------------------------------

  CMsgClientHeartBeat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientHeartBeat& from);
  void MergeFrom(const CMsgClientHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientHeartBeat)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSubscribeToPersonaFeed_PersonaFeed : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSubscribeToPersonaFeed_PersonaFeed();
  virtual ~CMsgClientSubscribeToPersonaFeed_PersonaFeed();

  CMsgClientSubscribeToPersonaFeed_PersonaFeed(const CMsgClientSubscribeToPersonaFeed_PersonaFeed& from);

  inline CMsgClientSubscribeToPersonaFeed_PersonaFeed& operator=(const CMsgClientSubscribeToPersonaFeed_PersonaFeed& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSubscribeToPersonaFeed_PersonaFeed& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSubscribeToPersonaFeed_PersonaFeed* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSubscribeToPersonaFeed_PersonaFeed* other);

  // implements Message ----------------------------------------------

  CMsgClientSubscribeToPersonaFeed_PersonaFeed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSubscribeToPersonaFeed_PersonaFeed& from);
  void MergeFrom(const CMsgClientSubscribeToPersonaFeed_PersonaFeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamID = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamIDFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional bool subscribe = 2;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 2;
  inline bool subscribe() const;
  inline void set_subscribe(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSubscribeToPersonaFeed.PersonaFeed)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_subscribe();
  inline void clear_has_subscribe();

  ::google::protobuf::uint64 steamid_;
  bool subscribe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSubscribeToPersonaFeed_PersonaFeed* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSubscribeToPersonaFeed : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSubscribeToPersonaFeed();
  virtual ~CMsgClientSubscribeToPersonaFeed();

  CMsgClientSubscribeToPersonaFeed(const CMsgClientSubscribeToPersonaFeed& from);

  inline CMsgClientSubscribeToPersonaFeed& operator=(const CMsgClientSubscribeToPersonaFeed& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSubscribeToPersonaFeed& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSubscribeToPersonaFeed* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSubscribeToPersonaFeed* other);

  // implements Message ----------------------------------------------

  CMsgClientSubscribeToPersonaFeed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSubscribeToPersonaFeed& from);
  void MergeFrom(const CMsgClientSubscribeToPersonaFeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientSubscribeToPersonaFeed_PersonaFeed PersonaFeed;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientSubscribeToPersonaFeed.PersonaFeed persona_feeds = 1;
  inline int persona_feeds_size() const;
  inline void clear_persona_feeds();
  static const int kPersonaFeedsFieldNumber = 1;
  inline const ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed& persona_feeds(int index) const;
  inline ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed* mutable_persona_feeds(int index);
  inline ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed* add_persona_feeds();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed >&
      persona_feeds() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed >*
      mutable_persona_feeds();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSubscribeToPersonaFeed)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed > persona_feeds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSubscribeToPersonaFeed* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUDSP2PSessionStarted : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUDSP2PSessionStarted();
  virtual ~CMsgClientUDSP2PSessionStarted();

  CMsgClientUDSP2PSessionStarted(const CMsgClientUDSP2PSessionStarted& from);

  inline CMsgClientUDSP2PSessionStarted& operator=(const CMsgClientUDSP2PSessionStarted& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUDSP2PSessionStarted& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUDSP2PSessionStarted* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUDSP2PSessionStarted* other);

  // implements Message ----------------------------------------------

  CMsgClientUDSP2PSessionStarted* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUDSP2PSessionStarted& from);
  void MergeFrom(const CMsgClientUDSP2PSessionStarted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_remote = 1;
  inline bool has_steamid_remote() const;
  inline void clear_steamid_remote();
  static const int kSteamidRemoteFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_remote() const;
  inline void set_steamid_remote(::google::protobuf::uint64 value);

  // optional int32 appid = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUDSP2PSessionStarted)
 private:
  inline void set_has_steamid_remote();
  inline void clear_has_steamid_remote();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::uint64 steamid_remote_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUDSP2PSessionStarted* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUDSP2PSessionEnded : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUDSP2PSessionEnded();
  virtual ~CMsgClientUDSP2PSessionEnded();

  CMsgClientUDSP2PSessionEnded(const CMsgClientUDSP2PSessionEnded& from);

  inline CMsgClientUDSP2PSessionEnded& operator=(const CMsgClientUDSP2PSessionEnded& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUDSP2PSessionEnded& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUDSP2PSessionEnded* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUDSP2PSessionEnded* other);

  // implements Message ----------------------------------------------

  CMsgClientUDSP2PSessionEnded* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUDSP2PSessionEnded& from);
  void MergeFrom(const CMsgClientUDSP2PSessionEnded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_remote = 1;
  inline bool has_steamid_remote() const;
  inline void clear_steamid_remote();
  static const int kSteamidRemoteFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_remote() const;
  inline void set_steamid_remote(::google::protobuf::uint64 value);

  // optional int32 appid = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 session_length_sec = 3;
  inline bool has_session_length_sec() const;
  inline void clear_session_length_sec();
  static const int kSessionLengthSecFieldNumber = 3;
  inline ::google::protobuf::int32 session_length_sec() const;
  inline void set_session_length_sec(::google::protobuf::int32 value);

  // optional int32 session_error = 4;
  inline bool has_session_error() const;
  inline void clear_session_error();
  static const int kSessionErrorFieldNumber = 4;
  inline ::google::protobuf::int32 session_error() const;
  inline void set_session_error(::google::protobuf::int32 value);

  // optional int32 nattype = 5;
  inline bool has_nattype() const;
  inline void clear_nattype();
  static const int kNattypeFieldNumber = 5;
  inline ::google::protobuf::int32 nattype() const;
  inline void set_nattype(::google::protobuf::int32 value);

  // optional int32 bytes_recv = 6;
  inline bool has_bytes_recv() const;
  inline void clear_bytes_recv();
  static const int kBytesRecvFieldNumber = 6;
  inline ::google::protobuf::int32 bytes_recv() const;
  inline void set_bytes_recv(::google::protobuf::int32 value);

  // optional int32 bytes_sent = 7;
  inline bool has_bytes_sent() const;
  inline void clear_bytes_sent();
  static const int kBytesSentFieldNumber = 7;
  inline ::google::protobuf::int32 bytes_sent() const;
  inline void set_bytes_sent(::google::protobuf::int32 value);

  // optional int32 bytes_sent_relay = 8;
  inline bool has_bytes_sent_relay() const;
  inline void clear_bytes_sent_relay();
  static const int kBytesSentRelayFieldNumber = 8;
  inline ::google::protobuf::int32 bytes_sent_relay() const;
  inline void set_bytes_sent_relay(::google::protobuf::int32 value);

  // optional int32 bytes_recv_relay = 9;
  inline bool has_bytes_recv_relay() const;
  inline void clear_bytes_recv_relay();
  static const int kBytesRecvRelayFieldNumber = 9;
  inline ::google::protobuf::int32 bytes_recv_relay() const;
  inline void set_bytes_recv_relay(::google::protobuf::int32 value);

  // optional int32 time_to_connect_ms = 10;
  inline bool has_time_to_connect_ms() const;
  inline void clear_time_to_connect_ms();
  static const int kTimeToConnectMsFieldNumber = 10;
  inline ::google::protobuf::int32 time_to_connect_ms() const;
  inline void set_time_to_connect_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUDSP2PSessionEnded)
 private:
  inline void set_has_steamid_remote();
  inline void clear_has_steamid_remote();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_session_length_sec();
  inline void clear_has_session_length_sec();
  inline void set_has_session_error();
  inline void clear_has_session_error();
  inline void set_has_nattype();
  inline void clear_has_nattype();
  inline void set_has_bytes_recv();
  inline void clear_has_bytes_recv();
  inline void set_has_bytes_sent();
  inline void clear_has_bytes_sent();
  inline void set_has_bytes_sent_relay();
  inline void clear_has_bytes_sent_relay();
  inline void set_has_bytes_recv_relay();
  inline void clear_has_bytes_recv_relay();
  inline void set_has_time_to_connect_ms();
  inline void clear_has_time_to_connect_ms();

  ::google::protobuf::uint64 steamid_remote_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 session_length_sec_;
  ::google::protobuf::int32 session_error_;
  ::google::protobuf::int32 nattype_;
  ::google::protobuf::int32 bytes_recv_;
  ::google::protobuf::int32 bytes_sent_;
  ::google::protobuf::int32 bytes_sent_relay_;
  ::google::protobuf::int32 bytes_recv_relay_;
  ::google::protobuf::int32 time_to_connect_ms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUDSP2PSessionEnded* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRegisterAuthTicketWithCM : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRegisterAuthTicketWithCM();
  virtual ~CMsgClientRegisterAuthTicketWithCM();

  CMsgClientRegisterAuthTicketWithCM(const CMsgClientRegisterAuthTicketWithCM& from);

  inline CMsgClientRegisterAuthTicketWithCM& operator=(const CMsgClientRegisterAuthTicketWithCM& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRegisterAuthTicketWithCM& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRegisterAuthTicketWithCM* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRegisterAuthTicketWithCM* other);

  // implements Message ----------------------------------------------

  CMsgClientRegisterAuthTicketWithCM* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRegisterAuthTicketWithCM& from);
  void MergeFrom(const CMsgClientRegisterAuthTicketWithCM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // optional bytes ticket = 3;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 3;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRegisterAuthTicketWithCM)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_ticket();
  inline void clear_has_ticket();

  ::std::string* ticket_;
  ::google::protobuf::uint32 protocol_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRegisterAuthTicketWithCM* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientTicketAuthComplete : public ::google::protobuf::MessageLite {
 public:
  CMsgClientTicketAuthComplete();
  virtual ~CMsgClientTicketAuthComplete();

  CMsgClientTicketAuthComplete(const CMsgClientTicketAuthComplete& from);

  inline CMsgClientTicketAuthComplete& operator=(const CMsgClientTicketAuthComplete& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientTicketAuthComplete& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientTicketAuthComplete* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientTicketAuthComplete* other);

  // implements Message ----------------------------------------------

  CMsgClientTicketAuthComplete* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientTicketAuthComplete& from);
  void MergeFrom(const CMsgClientTicketAuthComplete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional fixed64 game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional uint32 estate = 3;
  inline bool has_estate() const;
  inline void clear_estate();
  static const int kEstateFieldNumber = 3;
  inline ::google::protobuf::uint32 estate() const;
  inline void set_estate(::google::protobuf::uint32 value);

  // optional uint32 eauth_session_response = 4;
  inline bool has_eauth_session_response() const;
  inline void clear_eauth_session_response();
  static const int kEauthSessionResponseFieldNumber = 4;
  inline ::google::protobuf::uint32 eauth_session_response() const;
  inline void set_eauth_session_response(::google::protobuf::uint32 value);

  // optional bytes DEPRECATED_ticket = 5;
  inline bool has_deprecated_ticket() const;
  inline void clear_deprecated_ticket();
  static const int kDEPRECATEDTicketFieldNumber = 5;
  inline const ::std::string& deprecated_ticket() const;
  inline void set_deprecated_ticket(const ::std::string& value);
  inline void set_deprecated_ticket(const char* value);
  inline void set_deprecated_ticket(const void* value, size_t size);
  inline ::std::string* mutable_deprecated_ticket();
  inline ::std::string* release_deprecated_ticket();
  inline void set_allocated_deprecated_ticket(::std::string* deprecated_ticket);

  // optional uint32 ticket_crc = 6;
  inline bool has_ticket_crc() const;
  inline void clear_ticket_crc();
  static const int kTicketCrcFieldNumber = 6;
  inline ::google::protobuf::uint32 ticket_crc() const;
  inline void set_ticket_crc(::google::protobuf::uint32 value);

  // optional uint32 ticket_sequence = 7;
  inline bool has_ticket_sequence() const;
  inline void clear_ticket_sequence();
  static const int kTicketSequenceFieldNumber = 7;
  inline ::google::protobuf::uint32 ticket_sequence() const;
  inline void set_ticket_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientTicketAuthComplete)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_estate();
  inline void clear_has_estate();
  inline void set_has_eauth_session_response();
  inline void clear_has_eauth_session_response();
  inline void set_has_deprecated_ticket();
  inline void clear_has_deprecated_ticket();
  inline void set_has_ticket_crc();
  inline void clear_has_ticket_crc();
  inline void set_has_ticket_sequence();
  inline void clear_has_ticket_sequence();

  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::uint32 estate_;
  ::google::protobuf::uint32 eauth_session_response_;
  ::std::string* deprecated_ticket_;
  ::google::protobuf::uint32 ticket_crc_;
  ::google::protobuf::uint32 ticket_sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientTicketAuthComplete* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLogon : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLogon();
  virtual ~CMsgClientLogon();

  CMsgClientLogon(const CMsgClientLogon& from);

  inline CMsgClientLogon& operator=(const CMsgClientLogon& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLogon& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLogon* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLogon* other);

  // implements Message ----------------------------------------------

  CMsgClientLogon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLogon& from);
  void MergeFrom(const CMsgClientLogon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // optional uint32 obfustucated_private_ip = 2;
  inline bool has_obfustucated_private_ip() const;
  inline void clear_obfustucated_private_ip();
  static const int kObfustucatedPrivateIpFieldNumber = 2;
  inline ::google::protobuf::uint32 obfustucated_private_ip() const;
  inline void set_obfustucated_private_ip(::google::protobuf::uint32 value);

  // optional uint32 cell_id = 3;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 3;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional uint32 last_session_id = 4;
  inline bool has_last_session_id() const;
  inline void clear_last_session_id();
  static const int kLastSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 last_session_id() const;
  inline void set_last_session_id(::google::protobuf::uint32 value);

  // optional uint32 client_package_version = 5;
  inline bool has_client_package_version() const;
  inline void clear_client_package_version();
  static const int kClientPackageVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 client_package_version() const;
  inline void set_client_package_version(::google::protobuf::uint32 value);

  // optional string client_language = 6;
  inline bool has_client_language() const;
  inline void clear_client_language();
  static const int kClientLanguageFieldNumber = 6;
  inline const ::std::string& client_language() const;
  inline void set_client_language(const ::std::string& value);
  inline void set_client_language(const char* value);
  inline void set_client_language(const char* value, size_t size);
  inline ::std::string* mutable_client_language();
  inline ::std::string* release_client_language();
  inline void set_allocated_client_language(::std::string* client_language);

  // optional uint32 client_os_type = 7;
  inline bool has_client_os_type() const;
  inline void clear_client_os_type();
  static const int kClientOsTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 client_os_type() const;
  inline void set_client_os_type(::google::protobuf::uint32 value);

  // optional bool should_remember_password = 8 [default = false];
  inline bool has_should_remember_password() const;
  inline void clear_should_remember_password();
  static const int kShouldRememberPasswordFieldNumber = 8;
  inline bool should_remember_password() const;
  inline void set_should_remember_password(bool value);

  // optional string wine_version = 9;
  inline bool has_wine_version() const;
  inline void clear_wine_version();
  static const int kWineVersionFieldNumber = 9;
  inline const ::std::string& wine_version() const;
  inline void set_wine_version(const ::std::string& value);
  inline void set_wine_version(const char* value);
  inline void set_wine_version(const char* value, size_t size);
  inline ::std::string* mutable_wine_version();
  inline ::std::string* release_wine_version();
  inline void set_allocated_wine_version(::std::string* wine_version);

  // optional uint32 ping_ms_from_cell_search = 10;
  inline bool has_ping_ms_from_cell_search() const;
  inline void clear_ping_ms_from_cell_search();
  static const int kPingMsFromCellSearchFieldNumber = 10;
  inline ::google::protobuf::uint32 ping_ms_from_cell_search() const;
  inline void set_ping_ms_from_cell_search(::google::protobuf::uint32 value);

  // optional uint32 public_ip = 20;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 20;
  inline ::google::protobuf::uint32 public_ip() const;
  inline void set_public_ip(::google::protobuf::uint32 value);

  // optional uint32 qos_level = 21;
  inline bool has_qos_level() const;
  inline void clear_qos_level();
  static const int kQosLevelFieldNumber = 21;
  inline ::google::protobuf::uint32 qos_level() const;
  inline void set_qos_level(::google::protobuf::uint32 value);

  // optional fixed64 client_supplied_steam_id = 22;
  inline bool has_client_supplied_steam_id() const;
  inline void clear_client_supplied_steam_id();
  static const int kClientSuppliedSteamIdFieldNumber = 22;
  inline ::google::protobuf::uint64 client_supplied_steam_id() const;
  inline void set_client_supplied_steam_id(::google::protobuf::uint64 value);

  // optional bytes machine_id = 30;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 30;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const void* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional bytes steam2_auth_ticket = 41;
  inline bool has_steam2_auth_ticket() const;
  inline void clear_steam2_auth_ticket();
  static const int kSteam2AuthTicketFieldNumber = 41;
  inline const ::std::string& steam2_auth_ticket() const;
  inline void set_steam2_auth_ticket(const ::std::string& value);
  inline void set_steam2_auth_ticket(const char* value);
  inline void set_steam2_auth_ticket(const void* value, size_t size);
  inline ::std::string* mutable_steam2_auth_ticket();
  inline ::std::string* release_steam2_auth_ticket();
  inline void set_allocated_steam2_auth_ticket(::std::string* steam2_auth_ticket);

  // optional string email_address = 42;
  inline bool has_email_address() const;
  inline void clear_email_address();
  static const int kEmailAddressFieldNumber = 42;
  inline const ::std::string& email_address() const;
  inline void set_email_address(const ::std::string& value);
  inline void set_email_address(const char* value);
  inline void set_email_address(const char* value, size_t size);
  inline ::std::string* mutable_email_address();
  inline ::std::string* release_email_address();
  inline void set_allocated_email_address(::std::string* email_address);

  // optional fixed32 rtime32_account_creation = 43;
  inline bool has_rtime32_account_creation() const;
  inline void clear_rtime32_account_creation();
  static const int kRtime32AccountCreationFieldNumber = 43;
  inline ::google::protobuf::uint32 rtime32_account_creation() const;
  inline void set_rtime32_account_creation(::google::protobuf::uint32 value);

  // optional string account_name = 50;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 50;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const char* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // optional string password = 51;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 51;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string login_key = 60;
  inline bool has_login_key() const;
  inline void clear_login_key();
  static const int kLoginKeyFieldNumber = 60;
  inline const ::std::string& login_key() const;
  inline void set_login_key(const ::std::string& value);
  inline void set_login_key(const char* value);
  inline void set_login_key(const char* value, size_t size);
  inline ::std::string* mutable_login_key();
  inline ::std::string* release_login_key();
  inline void set_allocated_login_key(::std::string* login_key);

  // optional bytes sony_psn_ticket = 90;
  inline bool has_sony_psn_ticket() const;
  inline void clear_sony_psn_ticket();
  static const int kSonyPsnTicketFieldNumber = 90;
  inline const ::std::string& sony_psn_ticket() const;
  inline void set_sony_psn_ticket(const ::std::string& value);
  inline void set_sony_psn_ticket(const char* value);
  inline void set_sony_psn_ticket(const void* value, size_t size);
  inline ::std::string* mutable_sony_psn_ticket();
  inline ::std::string* release_sony_psn_ticket();
  inline void set_allocated_sony_psn_ticket(::std::string* sony_psn_ticket);

  // optional string sony_psn_service_id = 91;
  inline bool has_sony_psn_service_id() const;
  inline void clear_sony_psn_service_id();
  static const int kSonyPsnServiceIdFieldNumber = 91;
  inline const ::std::string& sony_psn_service_id() const;
  inline void set_sony_psn_service_id(const ::std::string& value);
  inline void set_sony_psn_service_id(const char* value);
  inline void set_sony_psn_service_id(const char* value, size_t size);
  inline ::std::string* mutable_sony_psn_service_id();
  inline ::std::string* release_sony_psn_service_id();
  inline void set_allocated_sony_psn_service_id(::std::string* sony_psn_service_id);

  // optional bool create_new_psn_linked_account_if_needed = 92 [default = false];
  inline bool has_create_new_psn_linked_account_if_needed() const;
  inline void clear_create_new_psn_linked_account_if_needed();
  static const int kCreateNewPsnLinkedAccountIfNeededFieldNumber = 92;
  inline bool create_new_psn_linked_account_if_needed() const;
  inline void set_create_new_psn_linked_account_if_needed(bool value);

  // optional string sony_psn_name = 93;
  inline bool has_sony_psn_name() const;
  inline void clear_sony_psn_name();
  static const int kSonyPsnNameFieldNumber = 93;
  inline const ::std::string& sony_psn_name() const;
  inline void set_sony_psn_name(const ::std::string& value);
  inline void set_sony_psn_name(const char* value);
  inline void set_sony_psn_name(const char* value, size_t size);
  inline ::std::string* mutable_sony_psn_name();
  inline ::std::string* release_sony_psn_name();
  inline void set_allocated_sony_psn_name(::std::string* sony_psn_name);

  // optional bool was_converted_deprecated_msg = 70 [default = false];
  inline bool has_was_converted_deprecated_msg() const;
  inline void clear_was_converted_deprecated_msg();
  static const int kWasConvertedDeprecatedMsgFieldNumber = 70;
  inline bool was_converted_deprecated_msg() const;
  inline void set_was_converted_deprecated_msg(bool value);

  // optional string anon_user_target_account_name = 80;
  inline bool has_anon_user_target_account_name() const;
  inline void clear_anon_user_target_account_name();
  static const int kAnonUserTargetAccountNameFieldNumber = 80;
  inline const ::std::string& anon_user_target_account_name() const;
  inline void set_anon_user_target_account_name(const ::std::string& value);
  inline void set_anon_user_target_account_name(const char* value);
  inline void set_anon_user_target_account_name(const char* value, size_t size);
  inline ::std::string* mutable_anon_user_target_account_name();
  inline ::std::string* release_anon_user_target_account_name();
  inline void set_allocated_anon_user_target_account_name(::std::string* anon_user_target_account_name);

  // optional fixed64 resolved_user_steam_id = 81;
  inline bool has_resolved_user_steam_id() const;
  inline void clear_resolved_user_steam_id();
  static const int kResolvedUserSteamIdFieldNumber = 81;
  inline ::google::protobuf::uint64 resolved_user_steam_id() const;
  inline void set_resolved_user_steam_id(::google::protobuf::uint64 value);

  // optional int32 eresult_sentryfile = 82;
  inline bool has_eresult_sentryfile() const;
  inline void clear_eresult_sentryfile();
  static const int kEresultSentryfileFieldNumber = 82;
  inline ::google::protobuf::int32 eresult_sentryfile() const;
  inline void set_eresult_sentryfile(::google::protobuf::int32 value);

  // optional bytes sha_sentryfile = 83;
  inline bool has_sha_sentryfile() const;
  inline void clear_sha_sentryfile();
  static const int kShaSentryfileFieldNumber = 83;
  inline const ::std::string& sha_sentryfile() const;
  inline void set_sha_sentryfile(const ::std::string& value);
  inline void set_sha_sentryfile(const char* value);
  inline void set_sha_sentryfile(const void* value, size_t size);
  inline ::std::string* mutable_sha_sentryfile();
  inline ::std::string* release_sha_sentryfile();
  inline void set_allocated_sha_sentryfile(::std::string* sha_sentryfile);

  // optional string auth_code = 84;
  inline bool has_auth_code() const;
  inline void clear_auth_code();
  static const int kAuthCodeFieldNumber = 84;
  inline const ::std::string& auth_code() const;
  inline void set_auth_code(const ::std::string& value);
  inline void set_auth_code(const char* value);
  inline void set_auth_code(const char* value, size_t size);
  inline ::std::string* mutable_auth_code();
  inline ::std::string* release_auth_code();
  inline void set_allocated_auth_code(::std::string* auth_code);

  // optional int32 otp_type = 85;
  inline bool has_otp_type() const;
  inline void clear_otp_type();
  static const int kOtpTypeFieldNumber = 85;
  inline ::google::protobuf::int32 otp_type() const;
  inline void set_otp_type(::google::protobuf::int32 value);

  // optional uint32 otp_value = 86;
  inline bool has_otp_value() const;
  inline void clear_otp_value();
  static const int kOtpValueFieldNumber = 86;
  inline ::google::protobuf::uint32 otp_value() const;
  inline void set_otp_value(::google::protobuf::uint32 value);

  // optional string otp_identifier = 87;
  inline bool has_otp_identifier() const;
  inline void clear_otp_identifier();
  static const int kOtpIdentifierFieldNumber = 87;
  inline const ::std::string& otp_identifier() const;
  inline void set_otp_identifier(const ::std::string& value);
  inline void set_otp_identifier(const char* value);
  inline void set_otp_identifier(const char* value, size_t size);
  inline ::std::string* mutable_otp_identifier();
  inline ::std::string* release_otp_identifier();
  inline void set_allocated_otp_identifier(::std::string* otp_identifier);

  // optional bool steam2_ticket_request = 88;
  inline bool has_steam2_ticket_request() const;
  inline void clear_steam2_ticket_request();
  static const int kSteam2TicketRequestFieldNumber = 88;
  inline bool steam2_ticket_request() const;
  inline void set_steam2_ticket_request(bool value);

  // optional int32 game_server_app_id = 94;
  inline bool has_game_server_app_id() const;
  inline void clear_game_server_app_id();
  static const int kGameServerAppIdFieldNumber = 94;
  inline ::google::protobuf::int32 game_server_app_id() const;
  inline void set_game_server_app_id(::google::protobuf::int32 value);

  // optional bool steamguard_dont_remember_computer = 95;
  inline bool has_steamguard_dont_remember_computer() const;
  inline void clear_steamguard_dont_remember_computer();
  static const int kSteamguardDontRememberComputerFieldNumber = 95;
  inline bool steamguard_dont_remember_computer() const;
  inline void set_steamguard_dont_remember_computer(bool value);

  // optional string machine_name = 96;
  inline bool has_machine_name() const;
  inline void clear_machine_name();
  static const int kMachineNameFieldNumber = 96;
  inline const ::std::string& machine_name() const;
  inline void set_machine_name(const ::std::string& value);
  inline void set_machine_name(const char* value);
  inline void set_machine_name(const char* value, size_t size);
  inline ::std::string* mutable_machine_name();
  inline ::std::string* release_machine_name();
  inline void set_allocated_machine_name(::std::string* machine_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLogon)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_obfustucated_private_ip();
  inline void clear_has_obfustucated_private_ip();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_last_session_id();
  inline void clear_has_last_session_id();
  inline void set_has_client_package_version();
  inline void clear_has_client_package_version();
  inline void set_has_client_language();
  inline void clear_has_client_language();
  inline void set_has_client_os_type();
  inline void clear_has_client_os_type();
  inline void set_has_should_remember_password();
  inline void clear_has_should_remember_password();
  inline void set_has_wine_version();
  inline void clear_has_wine_version();
  inline void set_has_ping_ms_from_cell_search();
  inline void clear_has_ping_ms_from_cell_search();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_qos_level();
  inline void clear_has_qos_level();
  inline void set_has_client_supplied_steam_id();
  inline void clear_has_client_supplied_steam_id();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_steam2_auth_ticket();
  inline void clear_has_steam2_auth_ticket();
  inline void set_has_email_address();
  inline void clear_has_email_address();
  inline void set_has_rtime32_account_creation();
  inline void clear_has_rtime32_account_creation();
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_login_key();
  inline void clear_has_login_key();
  inline void set_has_sony_psn_ticket();
  inline void clear_has_sony_psn_ticket();
  inline void set_has_sony_psn_service_id();
  inline void clear_has_sony_psn_service_id();
  inline void set_has_create_new_psn_linked_account_if_needed();
  inline void clear_has_create_new_psn_linked_account_if_needed();
  inline void set_has_sony_psn_name();
  inline void clear_has_sony_psn_name();
  inline void set_has_was_converted_deprecated_msg();
  inline void clear_has_was_converted_deprecated_msg();
  inline void set_has_anon_user_target_account_name();
  inline void clear_has_anon_user_target_account_name();
  inline void set_has_resolved_user_steam_id();
  inline void clear_has_resolved_user_steam_id();
  inline void set_has_eresult_sentryfile();
  inline void clear_has_eresult_sentryfile();
  inline void set_has_sha_sentryfile();
  inline void clear_has_sha_sentryfile();
  inline void set_has_auth_code();
  inline void clear_has_auth_code();
  inline void set_has_otp_type();
  inline void clear_has_otp_type();
  inline void set_has_otp_value();
  inline void clear_has_otp_value();
  inline void set_has_otp_identifier();
  inline void clear_has_otp_identifier();
  inline void set_has_steam2_ticket_request();
  inline void clear_has_steam2_ticket_request();
  inline void set_has_game_server_app_id();
  inline void clear_has_game_server_app_id();
  inline void set_has_steamguard_dont_remember_computer();
  inline void clear_has_steamguard_dont_remember_computer();
  inline void set_has_machine_name();
  inline void clear_has_machine_name();

  ::google::protobuf::uint32 protocol_version_;
  ::google::protobuf::uint32 obfustucated_private_ip_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::uint32 last_session_id_;
  ::std::string* client_language_;
  ::google::protobuf::uint32 client_package_version_;
  ::google::protobuf::uint32 client_os_type_;
  ::std::string* wine_version_;
  ::google::protobuf::uint32 ping_ms_from_cell_search_;
  ::google::protobuf::uint32 public_ip_;
  ::google::protobuf::uint64 client_supplied_steam_id_;
  ::std::string* machine_id_;
  ::google::protobuf::uint32 qos_level_;
  ::google::protobuf::uint32 rtime32_account_creation_;
  ::std::string* steam2_auth_ticket_;
  ::std::string* email_address_;
  ::std::string* account_name_;
  ::std::string* password_;
  ::std::string* login_key_;
  ::std::string* sony_psn_ticket_;
  ::std::string* sony_psn_service_id_;
  bool should_remember_password_;
  bool create_new_psn_linked_account_if_needed_;
  bool was_converted_deprecated_msg_;
  bool steam2_ticket_request_;
  ::google::protobuf::int32 eresult_sentryfile_;
  ::std::string* sony_psn_name_;
  ::std::string* anon_user_target_account_name_;
  ::google::protobuf::uint64 resolved_user_steam_id_;
  ::std::string* sha_sentryfile_;
  ::std::string* auth_code_;
  ::google::protobuf::int32 otp_type_;
  ::google::protobuf::uint32 otp_value_;
  ::std::string* otp_identifier_;
  ::google::protobuf::int32 game_server_app_id_;
  bool steamguard_dont_remember_computer_;
  ::std::string* machine_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLogon* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLogonResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLogonResponse();
  virtual ~CMsgClientLogonResponse();

  CMsgClientLogonResponse(const CMsgClientLogonResponse& from);

  inline CMsgClientLogonResponse& operator=(const CMsgClientLogonResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLogonResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLogonResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLogonResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientLogonResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLogonResponse& from);
  void MergeFrom(const CMsgClientLogonResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 out_of_game_heartbeat_seconds = 2;
  inline bool has_out_of_game_heartbeat_seconds() const;
  inline void clear_out_of_game_heartbeat_seconds();
  static const int kOutOfGameHeartbeatSecondsFieldNumber = 2;
  inline ::google::protobuf::int32 out_of_game_heartbeat_seconds() const;
  inline void set_out_of_game_heartbeat_seconds(::google::protobuf::int32 value);

  // optional int32 in_game_heartbeat_seconds = 3;
  inline bool has_in_game_heartbeat_seconds() const;
  inline void clear_in_game_heartbeat_seconds();
  static const int kInGameHeartbeatSecondsFieldNumber = 3;
  inline ::google::protobuf::int32 in_game_heartbeat_seconds() const;
  inline void set_in_game_heartbeat_seconds(::google::protobuf::int32 value);

  // optional uint32 public_ip = 4;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 4;
  inline ::google::protobuf::uint32 public_ip() const;
  inline void set_public_ip(::google::protobuf::uint32 value);

  // optional fixed32 rtime32_server_time = 5;
  inline bool has_rtime32_server_time() const;
  inline void clear_rtime32_server_time();
  static const int kRtime32ServerTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 rtime32_server_time() const;
  inline void set_rtime32_server_time(::google::protobuf::uint32 value);

  // optional uint32 account_flags = 6;
  inline bool has_account_flags() const;
  inline void clear_account_flags();
  static const int kAccountFlagsFieldNumber = 6;
  inline ::google::protobuf::uint32 account_flags() const;
  inline void set_account_flags(::google::protobuf::uint32 value);

  // optional uint32 cell_id = 7;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 7;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional string email_domain = 8;
  inline bool has_email_domain() const;
  inline void clear_email_domain();
  static const int kEmailDomainFieldNumber = 8;
  inline const ::std::string& email_domain() const;
  inline void set_email_domain(const ::std::string& value);
  inline void set_email_domain(const char* value);
  inline void set_email_domain(const char* value, size_t size);
  inline ::std::string* mutable_email_domain();
  inline ::std::string* release_email_domain();
  inline void set_allocated_email_domain(::std::string* email_domain);

  // optional bytes steam2_ticket = 9;
  inline bool has_steam2_ticket() const;
  inline void clear_steam2_ticket();
  static const int kSteam2TicketFieldNumber = 9;
  inline const ::std::string& steam2_ticket() const;
  inline void set_steam2_ticket(const ::std::string& value);
  inline void set_steam2_ticket(const char* value);
  inline void set_steam2_ticket(const void* value, size_t size);
  inline ::std::string* mutable_steam2_ticket();
  inline ::std::string* release_steam2_ticket();
  inline void set_allocated_steam2_ticket(::std::string* steam2_ticket);

  // optional int32 eresult_extended = 10;
  inline bool has_eresult_extended() const;
  inline void clear_eresult_extended();
  static const int kEresultExtendedFieldNumber = 10;
  inline ::google::protobuf::int32 eresult_extended() const;
  inline void set_eresult_extended(::google::protobuf::int32 value);

  // optional string webapi_authenticate_user_nonce = 11;
  inline bool has_webapi_authenticate_user_nonce() const;
  inline void clear_webapi_authenticate_user_nonce();
  static const int kWebapiAuthenticateUserNonceFieldNumber = 11;
  inline const ::std::string& webapi_authenticate_user_nonce() const;
  inline void set_webapi_authenticate_user_nonce(const ::std::string& value);
  inline void set_webapi_authenticate_user_nonce(const char* value);
  inline void set_webapi_authenticate_user_nonce(const char* value, size_t size);
  inline ::std::string* mutable_webapi_authenticate_user_nonce();
  inline ::std::string* release_webapi_authenticate_user_nonce();
  inline void set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce);

  // optional uint32 cell_id_ping_threshold = 12;
  inline bool has_cell_id_ping_threshold() const;
  inline void clear_cell_id_ping_threshold();
  static const int kCellIdPingThresholdFieldNumber = 12;
  inline ::google::protobuf::uint32 cell_id_ping_threshold() const;
  inline void set_cell_id_ping_threshold(::google::protobuf::uint32 value);

  // optional bool use_pics = 13;
  inline bool has_use_pics() const;
  inline void clear_use_pics();
  static const int kUsePicsFieldNumber = 13;
  inline bool use_pics() const;
  inline void set_use_pics(bool value);

  // optional fixed64 client_supplied_steamid = 20;
  inline bool has_client_supplied_steamid() const;
  inline void clear_client_supplied_steamid();
  static const int kClientSuppliedSteamidFieldNumber = 20;
  inline ::google::protobuf::uint64 client_supplied_steamid() const;
  inline void set_client_supplied_steamid(::google::protobuf::uint64 value);

  // optional string ip_country_code = 21;
  inline bool has_ip_country_code() const;
  inline void clear_ip_country_code();
  static const int kIpCountryCodeFieldNumber = 21;
  inline const ::std::string& ip_country_code() const;
  inline void set_ip_country_code(const ::std::string& value);
  inline void set_ip_country_code(const char* value);
  inline void set_ip_country_code(const char* value, size_t size);
  inline ::std::string* mutable_ip_country_code();
  inline ::std::string* release_ip_country_code();
  inline void set_allocated_ip_country_code(::std::string* ip_country_code);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLogonResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_out_of_game_heartbeat_seconds();
  inline void clear_has_out_of_game_heartbeat_seconds();
  inline void set_has_in_game_heartbeat_seconds();
  inline void clear_has_in_game_heartbeat_seconds();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_rtime32_server_time();
  inline void clear_has_rtime32_server_time();
  inline void set_has_account_flags();
  inline void clear_has_account_flags();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_email_domain();
  inline void clear_has_email_domain();
  inline void set_has_steam2_ticket();
  inline void clear_has_steam2_ticket();
  inline void set_has_eresult_extended();
  inline void clear_has_eresult_extended();
  inline void set_has_webapi_authenticate_user_nonce();
  inline void clear_has_webapi_authenticate_user_nonce();
  inline void set_has_cell_id_ping_threshold();
  inline void clear_has_cell_id_ping_threshold();
  inline void set_has_use_pics();
  inline void clear_has_use_pics();
  inline void set_has_client_supplied_steamid();
  inline void clear_has_client_supplied_steamid();
  inline void set_has_ip_country_code();
  inline void clear_has_ip_country_code();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 out_of_game_heartbeat_seconds_;
  ::google::protobuf::int32 in_game_heartbeat_seconds_;
  ::google::protobuf::uint32 public_ip_;
  ::google::protobuf::uint32 rtime32_server_time_;
  ::google::protobuf::uint32 account_flags_;
  ::std::string* email_domain_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::int32 eresult_extended_;
  ::std::string* steam2_ticket_;
  ::std::string* webapi_authenticate_user_nonce_;
  ::google::protobuf::uint32 cell_id_ping_threshold_;
  bool use_pics_;
  ::google::protobuf::uint64 client_supplied_steamid_;
  ::std::string* ip_country_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLogonResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestWebAPIAuthenticateUserNonce : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestWebAPIAuthenticateUserNonce();
  virtual ~CMsgClientRequestWebAPIAuthenticateUserNonce();

  CMsgClientRequestWebAPIAuthenticateUserNonce(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);

  inline CMsgClientRequestWebAPIAuthenticateUserNonce& operator=(const CMsgClientRequestWebAPIAuthenticateUserNonce& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestWebAPIAuthenticateUserNonce& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestWebAPIAuthenticateUserNonce* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestWebAPIAuthenticateUserNonce* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestWebAPIAuthenticateUserNonce* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);
  void MergeFrom(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestWebAPIAuthenticateUserNonce)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestWebAPIAuthenticateUserNonce* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestWebAPIAuthenticateUserNonceResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestWebAPIAuthenticateUserNonceResponse();
  virtual ~CMsgClientRequestWebAPIAuthenticateUserNonceResponse();

  CMsgClientRequestWebAPIAuthenticateUserNonceResponse(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);

  inline CMsgClientRequestWebAPIAuthenticateUserNonceResponse& operator=(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestWebAPIAuthenticateUserNonceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestWebAPIAuthenticateUserNonceResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestWebAPIAuthenticateUserNonceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);
  void MergeFrom(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string webapi_authenticate_user_nonce = 11;
  inline bool has_webapi_authenticate_user_nonce() const;
  inline void clear_webapi_authenticate_user_nonce();
  static const int kWebapiAuthenticateUserNonceFieldNumber = 11;
  inline const ::std::string& webapi_authenticate_user_nonce() const;
  inline void set_webapi_authenticate_user_nonce(const ::std::string& value);
  inline void set_webapi_authenticate_user_nonce(const char* value);
  inline void set_webapi_authenticate_user_nonce(const char* value, size_t size);
  inline ::std::string* mutable_webapi_authenticate_user_nonce();
  inline ::std::string* release_webapi_authenticate_user_nonce();
  inline void set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestWebAPIAuthenticateUserNonceResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_webapi_authenticate_user_nonce();
  inline void clear_has_webapi_authenticate_user_nonce();

  ::std::string* webapi_authenticate_user_nonce_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestWebAPIAuthenticateUserNonceResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLogOff : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLogOff();
  virtual ~CMsgClientLogOff();

  CMsgClientLogOff(const CMsgClientLogOff& from);

  inline CMsgClientLogOff& operator=(const CMsgClientLogOff& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLogOff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLogOff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLogOff* other);

  // implements Message ----------------------------------------------

  CMsgClientLogOff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLogOff& from);
  void MergeFrom(const CMsgClientLogOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLogOff)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLogOff* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLoggedOff : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLoggedOff();
  virtual ~CMsgClientLoggedOff();

  CMsgClientLoggedOff(const CMsgClientLoggedOff& from);

  inline CMsgClientLoggedOff& operator=(const CMsgClientLoggedOff& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLoggedOff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLoggedOff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLoggedOff* other);

  // implements Message ----------------------------------------------

  CMsgClientLoggedOff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLoggedOff& from);
  void MergeFrom(const CMsgClientLoggedOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLoggedOff)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLoggedOff* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientCMList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientCMList();
  virtual ~CMsgClientCMList();

  CMsgClientCMList(const CMsgClientCMList& from);

  inline CMsgClientCMList& operator=(const CMsgClientCMList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientCMList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientCMList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientCMList* other);

  // implements Message ----------------------------------------------

  CMsgClientCMList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientCMList& from);
  void MergeFrom(const CMsgClientCMList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 cm_addresses = 1;
  inline int cm_addresses_size() const;
  inline void clear_cm_addresses();
  static const int kCmAddressesFieldNumber = 1;
  inline ::google::protobuf::uint32 cm_addresses(int index) const;
  inline void set_cm_addresses(int index, ::google::protobuf::uint32 value);
  inline void add_cm_addresses(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cm_addresses() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cm_addresses();

  // repeated uint32 cm_ports = 2;
  inline int cm_ports_size() const;
  inline void clear_cm_ports();
  static const int kCmPortsFieldNumber = 2;
  inline ::google::protobuf::uint32 cm_ports(int index) const;
  inline void set_cm_ports(int index, ::google::protobuf::uint32 value);
  inline void add_cm_ports(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cm_ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cm_ports();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientCMList)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cm_addresses_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cm_ports_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientCMList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientP2PConnectionInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientP2PConnectionInfo();
  virtual ~CMsgClientP2PConnectionInfo();

  CMsgClientP2PConnectionInfo(const CMsgClientP2PConnectionInfo& from);

  inline CMsgClientP2PConnectionInfo& operator=(const CMsgClientP2PConnectionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientP2PConnectionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientP2PConnectionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientP2PConnectionInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientP2PConnectionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientP2PConnectionInfo& from);
  void MergeFrom(const CMsgClientP2PConnectionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_dest = 1;
  inline bool has_steam_id_dest() const;
  inline void clear_steam_id_dest();
  static const int kSteamIdDestFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_dest() const;
  inline void set_steam_id_dest(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_src = 2;
  inline bool has_steam_id_src() const;
  inline void clear_steam_id_src();
  static const int kSteamIdSrcFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_src() const;
  inline void set_steam_id_src(::google::protobuf::uint64 value);

  // optional uint32 app_id = 3;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 3;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional bytes candidate = 4;
  inline bool has_candidate() const;
  inline void clear_candidate();
  static const int kCandidateFieldNumber = 4;
  inline const ::std::string& candidate() const;
  inline void set_candidate(const ::std::string& value);
  inline void set_candidate(const char* value);
  inline void set_candidate(const void* value, size_t size);
  inline ::std::string* mutable_candidate();
  inline ::std::string* release_candidate();
  inline void set_allocated_candidate(::std::string* candidate);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientP2PConnectionInfo)
 private:
  inline void set_has_steam_id_dest();
  inline void clear_has_steam_id_dest();
  inline void set_has_steam_id_src();
  inline void clear_has_steam_id_src();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_candidate();
  inline void clear_has_candidate();

  ::google::protobuf::uint64 steam_id_dest_;
  ::google::protobuf::uint64 steam_id_src_;
  ::std::string* candidate_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientP2PConnectionInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientP2PConnectionFailInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientP2PConnectionFailInfo();
  virtual ~CMsgClientP2PConnectionFailInfo();

  CMsgClientP2PConnectionFailInfo(const CMsgClientP2PConnectionFailInfo& from);

  inline CMsgClientP2PConnectionFailInfo& operator=(const CMsgClientP2PConnectionFailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientP2PConnectionFailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientP2PConnectionFailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientP2PConnectionFailInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientP2PConnectionFailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientP2PConnectionFailInfo& from);
  void MergeFrom(const CMsgClientP2PConnectionFailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_dest = 1;
  inline bool has_steam_id_dest() const;
  inline void clear_steam_id_dest();
  static const int kSteamIdDestFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_dest() const;
  inline void set_steam_id_dest(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_src = 2;
  inline bool has_steam_id_src() const;
  inline void clear_steam_id_src();
  static const int kSteamIdSrcFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_src() const;
  inline void set_steam_id_src(::google::protobuf::uint64 value);

  // optional uint32 app_id = 3;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 3;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 ep2p_session_error = 4;
  inline bool has_ep2p_session_error() const;
  inline void clear_ep2p_session_error();
  static const int kEp2PSessionErrorFieldNumber = 4;
  inline ::google::protobuf::uint32 ep2p_session_error() const;
  inline void set_ep2p_session_error(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientP2PConnectionFailInfo)
 private:
  inline void set_has_steam_id_dest();
  inline void clear_has_steam_id_dest();
  inline void set_has_steam_id_src();
  inline void clear_has_steam_id_src();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_ep2p_session_error();
  inline void clear_has_ep2p_session_error();

  ::google::protobuf::uint64 steam_id_dest_;
  ::google::protobuf::uint64 steam_id_src_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 ep2p_session_error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientP2PConnectionFailInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetAppOwnershipTicket : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetAppOwnershipTicket();
  virtual ~CMsgClientGetAppOwnershipTicket();

  CMsgClientGetAppOwnershipTicket(const CMsgClientGetAppOwnershipTicket& from);

  inline CMsgClientGetAppOwnershipTicket& operator=(const CMsgClientGetAppOwnershipTicket& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetAppOwnershipTicket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetAppOwnershipTicket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetAppOwnershipTicket* other);

  // implements Message ----------------------------------------------

  CMsgClientGetAppOwnershipTicket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetAppOwnershipTicket& from);
  void MergeFrom(const CMsgClientGetAppOwnershipTicket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetAppOwnershipTicket)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetAppOwnershipTicket* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetAppOwnershipTicketResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetAppOwnershipTicketResponse();
  virtual ~CMsgClientGetAppOwnershipTicketResponse();

  CMsgClientGetAppOwnershipTicketResponse(const CMsgClientGetAppOwnershipTicketResponse& from);

  inline CMsgClientGetAppOwnershipTicketResponse& operator=(const CMsgClientGetAppOwnershipTicketResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetAppOwnershipTicketResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetAppOwnershipTicketResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetAppOwnershipTicketResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetAppOwnershipTicketResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetAppOwnershipTicketResponse& from);
  void MergeFrom(const CMsgClientGetAppOwnershipTicketResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional bytes ticket = 3;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 3;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetAppOwnershipTicketResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_ticket();
  inline void clear_has_ticket();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* ticket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetAppOwnershipTicketResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSessionToken : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSessionToken();
  virtual ~CMsgClientSessionToken();

  CMsgClientSessionToken(const CMsgClientSessionToken& from);

  inline CMsgClientSessionToken& operator=(const CMsgClientSessionToken& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSessionToken& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSessionToken* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSessionToken* other);

  // implements Message ----------------------------------------------

  CMsgClientSessionToken* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSessionToken& from);
  void MergeFrom(const CMsgClientSessionToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSessionToken)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::uint64 token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSessionToken* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGameConnectTokens : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGameConnectTokens();
  virtual ~CMsgClientGameConnectTokens();

  CMsgClientGameConnectTokens(const CMsgClientGameConnectTokens& from);

  inline CMsgClientGameConnectTokens& operator=(const CMsgClientGameConnectTokens& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGameConnectTokens& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGameConnectTokens* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGameConnectTokens* other);

  // implements Message ----------------------------------------------

  CMsgClientGameConnectTokens* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGameConnectTokens& from);
  void MergeFrom(const CMsgClientGameConnectTokens& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 max_tokens_to_keep = 1 [default = 10];
  inline bool has_max_tokens_to_keep() const;
  inline void clear_max_tokens_to_keep();
  static const int kMaxTokensToKeepFieldNumber = 1;
  inline ::google::protobuf::uint32 max_tokens_to_keep() const;
  inline void set_max_tokens_to_keep(::google::protobuf::uint32 value);

  // repeated bytes tokens = 2;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 2;
  inline const ::std::string& tokens(int index) const;
  inline ::std::string* mutable_tokens(int index);
  inline void set_tokens(int index, const ::std::string& value);
  inline void set_tokens(int index, const char* value);
  inline void set_tokens(int index, const void* value, size_t size);
  inline ::std::string* add_tokens();
  inline void add_tokens(const ::std::string& value);
  inline void add_tokens(const char* value);
  inline void add_tokens(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGameConnectTokens)
 private:
  inline void set_has_max_tokens_to_keep();
  inline void clear_has_max_tokens_to_keep();

  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  ::google::protobuf::uint32 max_tokens_to_keep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGameConnectTokens* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSServerType : public ::google::protobuf::MessageLite {
 public:
  CMsgGSServerType();
  virtual ~CMsgGSServerType();

  CMsgGSServerType(const CMsgGSServerType& from);

  inline CMsgGSServerType& operator=(const CMsgGSServerType& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSServerType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSServerType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSServerType* other);

  // implements Message ----------------------------------------------

  CMsgGSServerType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSServerType& from);
  void MergeFrom(const CMsgGSServerType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id_served = 1;
  inline bool has_app_id_served() const;
  inline void clear_app_id_served();
  static const int kAppIdServedFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id_served() const;
  inline void set_app_id_served(::google::protobuf::uint32 value);

  // optional uint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional uint32 game_ip_address = 3;
  inline bool has_game_ip_address() const;
  inline void clear_game_ip_address();
  static const int kGameIpAddressFieldNumber = 3;
  inline ::google::protobuf::uint32 game_ip_address() const;
  inline void set_game_ip_address(::google::protobuf::uint32 value);

  // optional uint32 game_port = 4;
  inline bool has_game_port() const;
  inline void clear_game_port();
  static const int kGamePortFieldNumber = 4;
  inline ::google::protobuf::uint32 game_port() const;
  inline void set_game_port(::google::protobuf::uint32 value);

  // optional string game_dir = 5;
  inline bool has_game_dir() const;
  inline void clear_game_dir();
  static const int kGameDirFieldNumber = 5;
  inline const ::std::string& game_dir() const;
  inline void set_game_dir(const ::std::string& value);
  inline void set_game_dir(const char* value);
  inline void set_game_dir(const char* value, size_t size);
  inline ::std::string* mutable_game_dir();
  inline ::std::string* release_game_dir();
  inline void set_allocated_game_dir(::std::string* game_dir);

  // optional string game_version = 6;
  inline bool has_game_version() const;
  inline void clear_game_version();
  static const int kGameVersionFieldNumber = 6;
  inline const ::std::string& game_version() const;
  inline void set_game_version(const ::std::string& value);
  inline void set_game_version(const char* value);
  inline void set_game_version(const char* value, size_t size);
  inline ::std::string* mutable_game_version();
  inline ::std::string* release_game_version();
  inline void set_allocated_game_version(::std::string* game_version);

  // optional uint32 game_query_port = 7;
  inline bool has_game_query_port() const;
  inline void clear_game_query_port();
  static const int kGameQueryPortFieldNumber = 7;
  inline ::google::protobuf::uint32 game_query_port() const;
  inline void set_game_query_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSServerType)
 private:
  inline void set_has_app_id_served();
  inline void clear_has_app_id_served();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_game_ip_address();
  inline void clear_has_game_ip_address();
  inline void set_has_game_port();
  inline void clear_has_game_port();
  inline void set_has_game_dir();
  inline void clear_has_game_dir();
  inline void set_has_game_version();
  inline void clear_has_game_version();
  inline void set_has_game_query_port();
  inline void clear_has_game_query_port();

  ::google::protobuf::uint32 app_id_served_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 game_ip_address_;
  ::google::protobuf::uint32 game_port_;
  ::std::string* game_dir_;
  ::std::string* game_version_;
  ::google::protobuf::uint32 game_query_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSServerType* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSStatusReply : public ::google::protobuf::MessageLite {
 public:
  CMsgGSStatusReply();
  virtual ~CMsgGSStatusReply();

  CMsgGSStatusReply(const CMsgGSStatusReply& from);

  inline CMsgGSStatusReply& operator=(const CMsgGSStatusReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSStatusReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSStatusReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSStatusReply* other);

  // implements Message ----------------------------------------------

  CMsgGSStatusReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSStatusReply& from);
  void MergeFrom(const CMsgGSStatusReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_secure = 1;
  inline bool has_is_secure() const;
  inline void clear_is_secure();
  static const int kIsSecureFieldNumber = 1;
  inline bool is_secure() const;
  inline void set_is_secure(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSStatusReply)
 private:
  inline void set_has_is_secure();
  inline void clear_has_is_secure();

  bool is_secure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSStatusReply* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSPlayerList_Player : public ::google::protobuf::MessageLite {
 public:
  CMsgGSPlayerList_Player();
  virtual ~CMsgGSPlayerList_Player();

  CMsgGSPlayerList_Player(const CMsgGSPlayerList_Player& from);

  inline CMsgGSPlayerList_Player& operator=(const CMsgGSPlayerList_Player& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSPlayerList_Player& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSPlayerList_Player* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSPlayerList_Player* other);

  // implements Message ----------------------------------------------

  CMsgGSPlayerList_Player* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSPlayerList_Player& from);
  void MergeFrom(const CMsgGSPlayerList_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional uint32 public_ip = 2;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 2;
  inline ::google::protobuf::uint32 public_ip() const;
  inline void set_public_ip(::google::protobuf::uint32 value);

  // optional bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSPlayerList.Player)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::uint64 steam_id_;
  ::std::string* token_;
  ::google::protobuf::uint32 public_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSPlayerList_Player* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSPlayerList : public ::google::protobuf::MessageLite {
 public:
  CMsgGSPlayerList();
  virtual ~CMsgGSPlayerList();

  CMsgGSPlayerList(const CMsgGSPlayerList& from);

  inline CMsgGSPlayerList& operator=(const CMsgGSPlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSPlayerList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSPlayerList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSPlayerList* other);

  // implements Message ----------------------------------------------

  CMsgGSPlayerList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSPlayerList& from);
  void MergeFrom(const CMsgGSPlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgGSPlayerList_Player Player;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgGSPlayerList.Player players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::Sc::CMsgGSPlayerList_Player& players(int index) const;
  inline ::Sc::CMsgGSPlayerList_Player* mutable_players(int index);
  inline ::Sc::CMsgGSPlayerList_Player* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGSPlayerList_Player >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGSPlayerList_Player >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSPlayerList)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGSPlayerList_Player > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSPlayerList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSUserPlaying : public ::google::protobuf::MessageLite {
 public:
  CMsgGSUserPlaying();
  virtual ~CMsgGSUserPlaying();

  CMsgGSUserPlaying(const CMsgGSUserPlaying& from);

  inline CMsgGSUserPlaying& operator=(const CMsgGSUserPlaying& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSUserPlaying& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSUserPlaying* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSUserPlaying* other);

  // implements Message ----------------------------------------------

  CMsgGSUserPlaying* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSUserPlaying& from);
  void MergeFrom(const CMsgGSUserPlaying& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional uint32 public_ip = 2;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 2;
  inline ::google::protobuf::uint32 public_ip() const;
  inline void set_public_ip(::google::protobuf::uint32 value);

  // optional bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSUserPlaying)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::uint64 steam_id_;
  ::std::string* token_;
  ::google::protobuf::uint32 public_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSUserPlaying* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSDisconnectNotice : public ::google::protobuf::MessageLite {
 public:
  CMsgGSDisconnectNotice();
  virtual ~CMsgGSDisconnectNotice();

  CMsgGSDisconnectNotice(const CMsgGSDisconnectNotice& from);

  inline CMsgGSDisconnectNotice& operator=(const CMsgGSDisconnectNotice& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSDisconnectNotice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSDisconnectNotice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSDisconnectNotice* other);

  // implements Message ----------------------------------------------

  CMsgGSDisconnectNotice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSDisconnectNotice& from);
  void MergeFrom(const CMsgGSDisconnectNotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSDisconnectNotice)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();

  ::google::protobuf::uint64 steam_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSDisconnectNotice* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGamesPlayed_GamePlayed : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGamesPlayed_GamePlayed();
  virtual ~CMsgClientGamesPlayed_GamePlayed();

  CMsgClientGamesPlayed_GamePlayed(const CMsgClientGamesPlayed_GamePlayed& from);

  inline CMsgClientGamesPlayed_GamePlayed& operator=(const CMsgClientGamesPlayed_GamePlayed& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGamesPlayed_GamePlayed& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGamesPlayed_GamePlayed* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGamesPlayed_GamePlayed* other);

  // implements Message ----------------------------------------------

  CMsgClientGamesPlayed_GamePlayed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGamesPlayed_GamePlayed& from);
  void MergeFrom(const CMsgClientGamesPlayed_GamePlayed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 steam_id_gs = 1;
  inline bool has_steam_id_gs() const;
  inline void clear_steam_id_gs();
  static const int kSteamIdGsFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_gs() const;
  inline void set_steam_id_gs(::google::protobuf::uint64 value);

  // optional fixed64 game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional uint32 game_ip_address = 3;
  inline bool has_game_ip_address() const;
  inline void clear_game_ip_address();
  static const int kGameIpAddressFieldNumber = 3;
  inline ::google::protobuf::uint32 game_ip_address() const;
  inline void set_game_ip_address(::google::protobuf::uint32 value);

  // optional uint32 game_port = 4;
  inline bool has_game_port() const;
  inline void clear_game_port();
  static const int kGamePortFieldNumber = 4;
  inline ::google::protobuf::uint32 game_port() const;
  inline void set_game_port(::google::protobuf::uint32 value);

  // optional bool is_secure = 5;
  inline bool has_is_secure() const;
  inline void clear_is_secure();
  static const int kIsSecureFieldNumber = 5;
  inline bool is_secure() const;
  inline void set_is_secure(bool value);

  // optional bytes token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string game_extra_info = 7;
  inline bool has_game_extra_info() const;
  inline void clear_game_extra_info();
  static const int kGameExtraInfoFieldNumber = 7;
  inline const ::std::string& game_extra_info() const;
  inline void set_game_extra_info(const ::std::string& value);
  inline void set_game_extra_info(const char* value);
  inline void set_game_extra_info(const char* value, size_t size);
  inline ::std::string* mutable_game_extra_info();
  inline ::std::string* release_game_extra_info();
  inline void set_allocated_game_extra_info(::std::string* game_extra_info);

  // optional bytes game_data_blob = 8;
  inline bool has_game_data_blob() const;
  inline void clear_game_data_blob();
  static const int kGameDataBlobFieldNumber = 8;
  inline const ::std::string& game_data_blob() const;
  inline void set_game_data_blob(const ::std::string& value);
  inline void set_game_data_blob(const char* value);
  inline void set_game_data_blob(const void* value, size_t size);
  inline ::std::string* mutable_game_data_blob();
  inline ::std::string* release_game_data_blob();
  inline void set_allocated_game_data_blob(::std::string* game_data_blob);

  // optional uint32 process_id = 9;
  inline bool has_process_id() const;
  inline void clear_process_id();
  static const int kProcessIdFieldNumber = 9;
  inline ::google::protobuf::uint32 process_id() const;
  inline void set_process_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGamesPlayed.GamePlayed)
 private:
  inline void set_has_steam_id_gs();
  inline void clear_has_steam_id_gs();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_game_ip_address();
  inline void clear_has_game_ip_address();
  inline void set_has_game_port();
  inline void clear_has_game_port();
  inline void set_has_is_secure();
  inline void clear_has_is_secure();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_game_extra_info();
  inline void clear_has_game_extra_info();
  inline void set_has_game_data_blob();
  inline void clear_has_game_data_blob();
  inline void set_has_process_id();
  inline void clear_has_process_id();

  ::google::protobuf::uint64 steam_id_gs_;
  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::uint32 game_ip_address_;
  ::google::protobuf::uint32 game_port_;
  ::std::string* token_;
  ::std::string* game_extra_info_;
  bool is_secure_;
  ::google::protobuf::uint32 process_id_;
  ::std::string* game_data_blob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGamesPlayed_GamePlayed* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGamesPlayed : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGamesPlayed();
  virtual ~CMsgClientGamesPlayed();

  CMsgClientGamesPlayed(const CMsgClientGamesPlayed& from);

  inline CMsgClientGamesPlayed& operator=(const CMsgClientGamesPlayed& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGamesPlayed& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGamesPlayed* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGamesPlayed* other);

  // implements Message ----------------------------------------------

  CMsgClientGamesPlayed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGamesPlayed& from);
  void MergeFrom(const CMsgClientGamesPlayed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientGamesPlayed_GamePlayed GamePlayed;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientGamesPlayed.GamePlayed games_played = 1;
  inline int games_played_size() const;
  inline void clear_games_played();
  static const int kGamesPlayedFieldNumber = 1;
  inline const ::Sc::CMsgClientGamesPlayed_GamePlayed& games_played(int index) const;
  inline ::Sc::CMsgClientGamesPlayed_GamePlayed* mutable_games_played(int index);
  inline ::Sc::CMsgClientGamesPlayed_GamePlayed* add_games_played();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGamesPlayed_GamePlayed >&
      games_played() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGamesPlayed_GamePlayed >*
      mutable_games_played();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGamesPlayed)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGamesPlayed_GamePlayed > games_played_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGamesPlayed* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSApprove : public ::google::protobuf::MessageLite {
 public:
  CMsgGSApprove();
  virtual ~CMsgGSApprove();

  CMsgGSApprove(const CMsgGSApprove& from);

  inline CMsgGSApprove& operator=(const CMsgGSApprove& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSApprove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSApprove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSApprove* other);

  // implements Message ----------------------------------------------

  CMsgGSApprove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSApprove& from);
  void MergeFrom(const CMsgGSApprove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSApprove)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();

  ::google::protobuf::uint64 steam_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSApprove* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSDeny : public ::google::protobuf::MessageLite {
 public:
  CMsgGSDeny();
  virtual ~CMsgGSDeny();

  CMsgGSDeny(const CMsgGSDeny& from);

  inline CMsgGSDeny& operator=(const CMsgGSDeny& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSDeny& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSDeny* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSDeny* other);

  // implements Message ----------------------------------------------

  CMsgGSDeny* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSDeny& from);
  void MergeFrom(const CMsgGSDeny& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional int32 edeny_reason = 2;
  inline bool has_edeny_reason() const;
  inline void clear_edeny_reason();
  static const int kEdenyReasonFieldNumber = 2;
  inline ::google::protobuf::int32 edeny_reason() const;
  inline void set_edeny_reason(::google::protobuf::int32 value);

  // optional string deny_string = 3;
  inline bool has_deny_string() const;
  inline void clear_deny_string();
  static const int kDenyStringFieldNumber = 3;
  inline const ::std::string& deny_string() const;
  inline void set_deny_string(const ::std::string& value);
  inline void set_deny_string(const char* value);
  inline void set_deny_string(const char* value, size_t size);
  inline ::std::string* mutable_deny_string();
  inline ::std::string* release_deny_string();
  inline void set_allocated_deny_string(::std::string* deny_string);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSDeny)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_edeny_reason();
  inline void clear_has_edeny_reason();
  inline void set_has_deny_string();
  inline void clear_has_deny_string();

  ::google::protobuf::uint64 steam_id_;
  ::std::string* deny_string_;
  ::google::protobuf::int32 edeny_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSDeny* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSKick : public ::google::protobuf::MessageLite {
 public:
  CMsgGSKick();
  virtual ~CMsgGSKick();

  CMsgGSKick(const CMsgGSKick& from);

  inline CMsgGSKick& operator=(const CMsgGSKick& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSKick& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSKick* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSKick* other);

  // implements Message ----------------------------------------------

  CMsgGSKick* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSKick& from);
  void MergeFrom(const CMsgGSKick& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional int32 edeny_reason = 2;
  inline bool has_edeny_reason() const;
  inline void clear_edeny_reason();
  static const int kEdenyReasonFieldNumber = 2;
  inline ::google::protobuf::int32 edeny_reason() const;
  inline void set_edeny_reason(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSKick)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_edeny_reason();
  inline void clear_has_edeny_reason();

  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::int32 edeny_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSKick* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAuthList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAuthList();
  virtual ~CMsgClientAuthList();

  CMsgClientAuthList(const CMsgClientAuthList& from);

  inline CMsgClientAuthList& operator=(const CMsgClientAuthList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAuthList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAuthList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAuthList* other);

  // implements Message ----------------------------------------------

  CMsgClientAuthList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAuthList& from);
  void MergeFrom(const CMsgClientAuthList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tokens_left = 1;
  inline bool has_tokens_left() const;
  inline void clear_tokens_left();
  static const int kTokensLeftFieldNumber = 1;
  inline ::google::protobuf::uint32 tokens_left() const;
  inline void set_tokens_left(::google::protobuf::uint32 value);

  // optional uint32 last_request_seq = 2;
  inline bool has_last_request_seq() const;
  inline void clear_last_request_seq();
  static const int kLastRequestSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 last_request_seq() const;
  inline void set_last_request_seq(::google::protobuf::uint32 value);

  // optional uint32 last_request_seq_from_server = 3;
  inline bool has_last_request_seq_from_server() const;
  inline void clear_last_request_seq_from_server();
  static const int kLastRequestSeqFromServerFieldNumber = 3;
  inline ::google::protobuf::uint32 last_request_seq_from_server() const;
  inline void set_last_request_seq_from_server(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgAuthTicket tickets = 4;
  inline int tickets_size() const;
  inline void clear_tickets();
  static const int kTicketsFieldNumber = 4;
  inline const ::Sc::CMsgAuthTicket& tickets(int index) const;
  inline ::Sc::CMsgAuthTicket* mutable_tickets(int index);
  inline ::Sc::CMsgAuthTicket* add_tickets();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgAuthTicket >&
      tickets() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgAuthTicket >*
      mutable_tickets();

  // repeated uint32 app_ids = 5;
  inline int app_ids_size() const;
  inline void clear_app_ids();
  static const int kAppIdsFieldNumber = 5;
  inline ::google::protobuf::uint32 app_ids(int index) const;
  inline void set_app_ids(int index, ::google::protobuf::uint32 value);
  inline void add_app_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      app_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_app_ids();

  // optional uint32 message_sequence = 6;
  inline bool has_message_sequence() const;
  inline void clear_message_sequence();
  static const int kMessageSequenceFieldNumber = 6;
  inline ::google::protobuf::uint32 message_sequence() const;
  inline void set_message_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAuthList)
 private:
  inline void set_has_tokens_left();
  inline void clear_has_tokens_left();
  inline void set_has_last_request_seq();
  inline void clear_has_last_request_seq();
  inline void set_has_last_request_seq_from_server();
  inline void clear_has_last_request_seq_from_server();
  inline void set_has_message_sequence();
  inline void clear_has_message_sequence();

  ::google::protobuf::uint32 tokens_left_;
  ::google::protobuf::uint32 last_request_seq_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgAuthTicket > tickets_;
  ::google::protobuf::uint32 last_request_seq_from_server_;
  ::google::protobuf::uint32 message_sequence_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > app_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAuthList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAuthListAck : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAuthListAck();
  virtual ~CMsgClientAuthListAck();

  CMsgClientAuthListAck(const CMsgClientAuthListAck& from);

  inline CMsgClientAuthListAck& operator=(const CMsgClientAuthListAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAuthListAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAuthListAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAuthListAck* other);

  // implements Message ----------------------------------------------

  CMsgClientAuthListAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAuthListAck& from);
  void MergeFrom(const CMsgClientAuthListAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ticket_crc = 1;
  inline int ticket_crc_size() const;
  inline void clear_ticket_crc();
  static const int kTicketCrcFieldNumber = 1;
  inline ::google::protobuf::uint32 ticket_crc(int index) const;
  inline void set_ticket_crc(int index, ::google::protobuf::uint32 value);
  inline void add_ticket_crc(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ticket_crc() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ticket_crc();

  // repeated uint32 app_ids = 2;
  inline int app_ids_size() const;
  inline void clear_app_ids();
  static const int kAppIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 app_ids(int index) const;
  inline void set_app_ids(int index, ::google::protobuf::uint32 value);
  inline void add_app_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      app_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_app_ids();

  // optional uint32 message_sequence = 3;
  inline bool has_message_sequence() const;
  inline void clear_message_sequence();
  static const int kMessageSequenceFieldNumber = 3;
  inline ::google::protobuf::uint32 message_sequence() const;
  inline void set_message_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAuthListAck)
 private:
  inline void set_has_message_sequence();
  inline void clear_has_message_sequence();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ticket_crc_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > app_ids_;
  ::google::protobuf::uint32 message_sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAuthListAck* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendsList_Friend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendsList_Friend();
  virtual ~CMsgClientFriendsList_Friend();

  CMsgClientFriendsList_Friend(const CMsgClientFriendsList_Friend& from);

  inline CMsgClientFriendsList_Friend& operator=(const CMsgClientFriendsList_Friend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendsList_Friend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendsList_Friend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendsList_Friend* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendsList_Friend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendsList_Friend& from);
  void MergeFrom(const CMsgClientFriendsList_Friend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 ulfriendid = 1;
  inline bool has_ulfriendid() const;
  inline void clear_ulfriendid();
  static const int kUlfriendidFieldNumber = 1;
  inline ::google::protobuf::uint64 ulfriendid() const;
  inline void set_ulfriendid(::google::protobuf::uint64 value);

  // optional uint32 efriendrelationship = 2;
  inline bool has_efriendrelationship() const;
  inline void clear_efriendrelationship();
  static const int kEfriendrelationshipFieldNumber = 2;
  inline ::google::protobuf::uint32 efriendrelationship() const;
  inline void set_efriendrelationship(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendsList.Friend)
 private:
  inline void set_has_ulfriendid();
  inline void clear_has_ulfriendid();
  inline void set_has_efriendrelationship();
  inline void clear_has_efriendrelationship();

  ::google::protobuf::uint64 ulfriendid_;
  ::google::protobuf::uint32 efriendrelationship_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendsList_Friend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendsList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendsList();
  virtual ~CMsgClientFriendsList();

  CMsgClientFriendsList(const CMsgClientFriendsList& from);

  inline CMsgClientFriendsList& operator=(const CMsgClientFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendsList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendsList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendsList* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendsList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendsList& from);
  void MergeFrom(const CMsgClientFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientFriendsList_Friend Friend;

  // accessors -------------------------------------------------------

  // optional bool bincremental = 1;
  inline bool has_bincremental() const;
  inline void clear_bincremental();
  static const int kBincrementalFieldNumber = 1;
  inline bool bincremental() const;
  inline void set_bincremental(bool value);

  // repeated .Sc.CMsgClientFriendsList.Friend friends = 2;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 2;
  inline const ::Sc::CMsgClientFriendsList_Friend& friends(int index) const;
  inline ::Sc::CMsgClientFriendsList_Friend* mutable_friends(int index);
  inline ::Sc::CMsgClientFriendsList_Friend* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsList_Friend >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsList_Friend >*
      mutable_friends();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendsList)
 private:
  inline void set_has_bincremental();
  inline void clear_has_bincremental();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsList_Friend > friends_;
  bool bincremental_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendsGroupsList_FriendGroup : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendsGroupsList_FriendGroup();
  virtual ~CMsgClientFriendsGroupsList_FriendGroup();

  CMsgClientFriendsGroupsList_FriendGroup(const CMsgClientFriendsGroupsList_FriendGroup& from);

  inline CMsgClientFriendsGroupsList_FriendGroup& operator=(const CMsgClientFriendsGroupsList_FriendGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendsGroupsList_FriendGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendsGroupsList_FriendGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendsGroupsList_FriendGroup* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendsGroupsList_FriendGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendsGroupsList_FriendGroup& from);
  void MergeFrom(const CMsgClientFriendsGroupsList_FriendGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 nGroupID = 1;
  inline bool has_ngroupid() const;
  inline void clear_ngroupid();
  static const int kNGroupIDFieldNumber = 1;
  inline ::google::protobuf::int32 ngroupid() const;
  inline void set_ngroupid(::google::protobuf::int32 value);

  // optional string strGroupName = 2;
  inline bool has_strgroupname() const;
  inline void clear_strgroupname();
  static const int kStrGroupNameFieldNumber = 2;
  inline const ::std::string& strgroupname() const;
  inline void set_strgroupname(const ::std::string& value);
  inline void set_strgroupname(const char* value);
  inline void set_strgroupname(const char* value, size_t size);
  inline ::std::string* mutable_strgroupname();
  inline ::std::string* release_strgroupname();
  inline void set_allocated_strgroupname(::std::string* strgroupname);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendsGroupsList.FriendGroup)
 private:
  inline void set_has_ngroupid();
  inline void clear_has_ngroupid();
  inline void set_has_strgroupname();
  inline void clear_has_strgroupname();

  ::std::string* strgroupname_;
  ::google::protobuf::int32 ngroupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendsGroupsList_FriendGroup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendsGroupsList_FriendGroupsMembership : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendsGroupsList_FriendGroupsMembership();
  virtual ~CMsgClientFriendsGroupsList_FriendGroupsMembership();

  CMsgClientFriendsGroupsList_FriendGroupsMembership(const CMsgClientFriendsGroupsList_FriendGroupsMembership& from);

  inline CMsgClientFriendsGroupsList_FriendGroupsMembership& operator=(const CMsgClientFriendsGroupsList_FriendGroupsMembership& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendsGroupsList_FriendGroupsMembership& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendsGroupsList_FriendGroupsMembership* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendsGroupsList_FriendGroupsMembership* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendsGroupsList_FriendGroupsMembership* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendsGroupsList_FriendGroupsMembership& from);
  void MergeFrom(const CMsgClientFriendsGroupsList_FriendGroupsMembership& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 ulSteamID = 1;
  inline bool has_ulsteamid() const;
  inline void clear_ulsteamid();
  static const int kUlSteamIDFieldNumber = 1;
  inline ::google::protobuf::uint64 ulsteamid() const;
  inline void set_ulsteamid(::google::protobuf::uint64 value);

  // optional int32 nGroupID = 2;
  inline bool has_ngroupid() const;
  inline void clear_ngroupid();
  static const int kNGroupIDFieldNumber = 2;
  inline ::google::protobuf::int32 ngroupid() const;
  inline void set_ngroupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendsGroupsList.FriendGroupsMembership)
 private:
  inline void set_has_ulsteamid();
  inline void clear_has_ulsteamid();
  inline void set_has_ngroupid();
  inline void clear_has_ngroupid();

  ::google::protobuf::uint64 ulsteamid_;
  ::google::protobuf::int32 ngroupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendsGroupsList_FriendGroupsMembership* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendsGroupsList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendsGroupsList();
  virtual ~CMsgClientFriendsGroupsList();

  CMsgClientFriendsGroupsList(const CMsgClientFriendsGroupsList& from);

  inline CMsgClientFriendsGroupsList& operator=(const CMsgClientFriendsGroupsList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendsGroupsList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendsGroupsList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendsGroupsList* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendsGroupsList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendsGroupsList& from);
  void MergeFrom(const CMsgClientFriendsGroupsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientFriendsGroupsList_FriendGroup FriendGroup;
  typedef CMsgClientFriendsGroupsList_FriendGroupsMembership FriendGroupsMembership;

  // accessors -------------------------------------------------------

  // optional bool bremoval = 1;
  inline bool has_bremoval() const;
  inline void clear_bremoval();
  static const int kBremovalFieldNumber = 1;
  inline bool bremoval() const;
  inline void set_bremoval(bool value);

  // optional bool bincremental = 2;
  inline bool has_bincremental() const;
  inline void clear_bincremental();
  static const int kBincrementalFieldNumber = 2;
  inline bool bincremental() const;
  inline void set_bincremental(bool value);

  // repeated .Sc.CMsgClientFriendsGroupsList.FriendGroup friendGroups = 3;
  inline int friendgroups_size() const;
  inline void clear_friendgroups();
  static const int kFriendGroupsFieldNumber = 3;
  inline const ::Sc::CMsgClientFriendsGroupsList_FriendGroup& friendgroups(int index) const;
  inline ::Sc::CMsgClientFriendsGroupsList_FriendGroup* mutable_friendgroups(int index);
  inline ::Sc::CMsgClientFriendsGroupsList_FriendGroup* add_friendgroups();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroup >&
      friendgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroup >*
      mutable_friendgroups();

  // repeated .Sc.CMsgClientFriendsGroupsList.FriendGroupsMembership memberships = 4;
  inline int memberships_size() const;
  inline void clear_memberships();
  static const int kMembershipsFieldNumber = 4;
  inline const ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership& memberships(int index) const;
  inline ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership* mutable_memberships(int index);
  inline ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership* add_memberships();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership >&
      memberships() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership >*
      mutable_memberships();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendsGroupsList)
 private:
  inline void set_has_bremoval();
  inline void clear_has_bremoval();
  inline void set_has_bincremental();
  inline void clear_has_bincremental();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroup > friendgroups_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership > memberships_;
  bool bremoval_;
  bool bincremental_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendsGroupsList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPlayerNicknameList_PlayerNickname : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPlayerNicknameList_PlayerNickname();
  virtual ~CMsgClientPlayerNicknameList_PlayerNickname();

  CMsgClientPlayerNicknameList_PlayerNickname(const CMsgClientPlayerNicknameList_PlayerNickname& from);

  inline CMsgClientPlayerNicknameList_PlayerNickname& operator=(const CMsgClientPlayerNicknameList_PlayerNickname& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPlayerNicknameList_PlayerNickname& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPlayerNicknameList_PlayerNickname* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPlayerNicknameList_PlayerNickname* other);

  // implements Message ----------------------------------------------

  CMsgClientPlayerNicknameList_PlayerNickname* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPlayerNicknameList_PlayerNickname& from);
  void MergeFrom(const CMsgClientPlayerNicknameList_PlayerNickname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPlayerNicknameList.PlayerNickname)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::uint64 steamid_;
  ::std::string* nickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPlayerNicknameList_PlayerNickname* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPlayerNicknameList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPlayerNicknameList();
  virtual ~CMsgClientPlayerNicknameList();

  CMsgClientPlayerNicknameList(const CMsgClientPlayerNicknameList& from);

  inline CMsgClientPlayerNicknameList& operator=(const CMsgClientPlayerNicknameList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPlayerNicknameList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPlayerNicknameList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPlayerNicknameList* other);

  // implements Message ----------------------------------------------

  CMsgClientPlayerNicknameList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPlayerNicknameList& from);
  void MergeFrom(const CMsgClientPlayerNicknameList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientPlayerNicknameList_PlayerNickname PlayerNickname;

  // accessors -------------------------------------------------------

  // optional bool removal = 1;
  inline bool has_removal() const;
  inline void clear_removal();
  static const int kRemovalFieldNumber = 1;
  inline bool removal() const;
  inline void set_removal(bool value);

  // optional bool incremental = 2;
  inline bool has_incremental() const;
  inline void clear_incremental();
  static const int kIncrementalFieldNumber = 2;
  inline bool incremental() const;
  inline void set_incremental(bool value);

  // repeated .Sc.CMsgClientPlayerNicknameList.PlayerNickname nicknames = 3;
  inline int nicknames_size() const;
  inline void clear_nicknames();
  static const int kNicknamesFieldNumber = 3;
  inline const ::Sc::CMsgClientPlayerNicknameList_PlayerNickname& nicknames(int index) const;
  inline ::Sc::CMsgClientPlayerNicknameList_PlayerNickname* mutable_nicknames(int index);
  inline ::Sc::CMsgClientPlayerNicknameList_PlayerNickname* add_nicknames();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPlayerNicknameList_PlayerNickname >&
      nicknames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPlayerNicknameList_PlayerNickname >*
      mutable_nicknames();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPlayerNicknameList)
 private:
  inline void set_has_removal();
  inline void clear_has_removal();
  inline void set_has_incremental();
  inline void clear_has_incremental();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPlayerNicknameList_PlayerNickname > nicknames_;
  bool removal_;
  bool incremental_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPlayerNicknameList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSetPlayerNickname : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSetPlayerNickname();
  virtual ~CMsgClientSetPlayerNickname();

  CMsgClientSetPlayerNickname(const CMsgClientSetPlayerNickname& from);

  inline CMsgClientSetPlayerNickname& operator=(const CMsgClientSetPlayerNickname& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSetPlayerNickname& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSetPlayerNickname* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSetPlayerNickname* other);

  // implements Message ----------------------------------------------

  CMsgClientSetPlayerNickname* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSetPlayerNickname& from);
  void MergeFrom(const CMsgClientSetPlayerNickname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSetPlayerNickname)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::uint64 steamid_;
  ::std::string* nickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSetPlayerNickname* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSetPlayerNicknameResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSetPlayerNicknameResponse();
  virtual ~CMsgClientSetPlayerNicknameResponse();

  CMsgClientSetPlayerNicknameResponse(const CMsgClientSetPlayerNicknameResponse& from);

  inline CMsgClientSetPlayerNicknameResponse& operator=(const CMsgClientSetPlayerNicknameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSetPlayerNicknameResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSetPlayerNicknameResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSetPlayerNicknameResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientSetPlayerNicknameResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSetPlayerNicknameResponse& from);
  void MergeFrom(const CMsgClientSetPlayerNicknameResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSetPlayerNicknameResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSetPlayerNicknameResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLicenseList_License : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLicenseList_License();
  virtual ~CMsgClientLicenseList_License();

  CMsgClientLicenseList_License(const CMsgClientLicenseList_License& from);

  inline CMsgClientLicenseList_License& operator=(const CMsgClientLicenseList_License& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLicenseList_License& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLicenseList_License* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLicenseList_License* other);

  // implements Message ----------------------------------------------

  CMsgClientLicenseList_License* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLicenseList_License& from);
  void MergeFrom(const CMsgClientLicenseList_License& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 package_id = 1;
  inline bool has_package_id() const;
  inline void clear_package_id();
  static const int kPackageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 package_id() const;
  inline void set_package_id(::google::protobuf::uint32 value);

  // optional fixed32 time_created = 2;
  inline bool has_time_created() const;
  inline void clear_time_created();
  static const int kTimeCreatedFieldNumber = 2;
  inline ::google::protobuf::uint32 time_created() const;
  inline void set_time_created(::google::protobuf::uint32 value);

  // optional fixed32 time_next_process = 3;
  inline bool has_time_next_process() const;
  inline void clear_time_next_process();
  static const int kTimeNextProcessFieldNumber = 3;
  inline ::google::protobuf::uint32 time_next_process() const;
  inline void set_time_next_process(::google::protobuf::uint32 value);

  // optional int32 minute_limit = 4;
  inline bool has_minute_limit() const;
  inline void clear_minute_limit();
  static const int kMinuteLimitFieldNumber = 4;
  inline ::google::protobuf::int32 minute_limit() const;
  inline void set_minute_limit(::google::protobuf::int32 value);

  // optional int32 minutes_used = 5;
  inline bool has_minutes_used() const;
  inline void clear_minutes_used();
  static const int kMinutesUsedFieldNumber = 5;
  inline ::google::protobuf::int32 minutes_used() const;
  inline void set_minutes_used(::google::protobuf::int32 value);

  // optional uint32 payment_method = 6;
  inline bool has_payment_method() const;
  inline void clear_payment_method();
  static const int kPaymentMethodFieldNumber = 6;
  inline ::google::protobuf::uint32 payment_method() const;
  inline void set_payment_method(::google::protobuf::uint32 value);

  // optional uint32 flags = 7;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional string purchase_country_code = 8;
  inline bool has_purchase_country_code() const;
  inline void clear_purchase_country_code();
  static const int kPurchaseCountryCodeFieldNumber = 8;
  inline const ::std::string& purchase_country_code() const;
  inline void set_purchase_country_code(const ::std::string& value);
  inline void set_purchase_country_code(const char* value);
  inline void set_purchase_country_code(const char* value, size_t size);
  inline ::std::string* mutable_purchase_country_code();
  inline ::std::string* release_purchase_country_code();
  inline void set_allocated_purchase_country_code(::std::string* purchase_country_code);

  // optional uint32 license_type = 9;
  inline bool has_license_type() const;
  inline void clear_license_type();
  static const int kLicenseTypeFieldNumber = 9;
  inline ::google::protobuf::uint32 license_type() const;
  inline void set_license_type(::google::protobuf::uint32 value);

  // optional int32 territory_code = 10;
  inline bool has_territory_code() const;
  inline void clear_territory_code();
  static const int kTerritoryCodeFieldNumber = 10;
  inline ::google::protobuf::int32 territory_code() const;
  inline void set_territory_code(::google::protobuf::int32 value);

  // optional int32 change_number = 11;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 11;
  inline ::google::protobuf::int32 change_number() const;
  inline void set_change_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLicenseList.License)
 private:
  inline void set_has_package_id();
  inline void clear_has_package_id();
  inline void set_has_time_created();
  inline void clear_has_time_created();
  inline void set_has_time_next_process();
  inline void clear_has_time_next_process();
  inline void set_has_minute_limit();
  inline void clear_has_minute_limit();
  inline void set_has_minutes_used();
  inline void clear_has_minutes_used();
  inline void set_has_payment_method();
  inline void clear_has_payment_method();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_purchase_country_code();
  inline void clear_has_purchase_country_code();
  inline void set_has_license_type();
  inline void clear_has_license_type();
  inline void set_has_territory_code();
  inline void clear_has_territory_code();
  inline void set_has_change_number();
  inline void clear_has_change_number();

  ::google::protobuf::uint32 package_id_;
  ::google::protobuf::uint32 time_created_;
  ::google::protobuf::uint32 time_next_process_;
  ::google::protobuf::int32 minute_limit_;
  ::google::protobuf::int32 minutes_used_;
  ::google::protobuf::uint32 payment_method_;
  ::std::string* purchase_country_code_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 license_type_;
  ::google::protobuf::int32 territory_code_;
  ::google::protobuf::int32 change_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLicenseList_License* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLicenseList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLicenseList();
  virtual ~CMsgClientLicenseList();

  CMsgClientLicenseList(const CMsgClientLicenseList& from);

  inline CMsgClientLicenseList& operator=(const CMsgClientLicenseList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLicenseList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLicenseList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLicenseList* other);

  // implements Message ----------------------------------------------

  CMsgClientLicenseList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLicenseList& from);
  void MergeFrom(const CMsgClientLicenseList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientLicenseList_License License;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientLicenseList.License licenses = 2;
  inline int licenses_size() const;
  inline void clear_licenses();
  static const int kLicensesFieldNumber = 2;
  inline const ::Sc::CMsgClientLicenseList_License& licenses(int index) const;
  inline ::Sc::CMsgClientLicenseList_License* mutable_licenses(int index);
  inline ::Sc::CMsgClientLicenseList_License* add_licenses();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLicenseList_License >&
      licenses() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLicenseList_License >*
      mutable_licenses();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLicenseList)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLicenseList_License > licenses_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLicenseList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSSetScore : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSSetScore();
  virtual ~CMsgClientLBSSetScore();

  CMsgClientLBSSetScore(const CMsgClientLBSSetScore& from);

  inline CMsgClientLBSSetScore& operator=(const CMsgClientLBSSetScore& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSSetScore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSSetScore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSSetScore* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSSetScore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSSetScore& from);
  void MergeFrom(const CMsgClientLBSSetScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 leaderboard_id = 2;
  inline bool has_leaderboard_id() const;
  inline void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_id() const;
  inline void set_leaderboard_id(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional bytes details = 4;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 4;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const void* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // optional int32 upload_score_method = 5;
  inline bool has_upload_score_method() const;
  inline void clear_upload_score_method();
  static const int kUploadScoreMethodFieldNumber = 5;
  inline ::google::protobuf::int32 upload_score_method() const;
  inline void set_upload_score_method(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSSetScore)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_leaderboard_id();
  inline void clear_has_leaderboard_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_upload_score_method();
  inline void clear_has_upload_score_method();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 leaderboard_id_;
  ::std::string* details_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 upload_score_method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSSetScore* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSSetScoreResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSSetScoreResponse();
  virtual ~CMsgClientLBSSetScoreResponse();

  CMsgClientLBSSetScoreResponse(const CMsgClientLBSSetScoreResponse& from);

  inline CMsgClientLBSSetScoreResponse& operator=(const CMsgClientLBSSetScoreResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSSetScoreResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSSetScoreResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSSetScoreResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSSetScoreResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSSetScoreResponse& from);
  void MergeFrom(const CMsgClientLBSSetScoreResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 leaderboard_entry_count = 2;
  inline bool has_leaderboard_entry_count() const;
  inline void clear_leaderboard_entry_count();
  static const int kLeaderboardEntryCountFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_entry_count() const;
  inline void set_leaderboard_entry_count(::google::protobuf::int32 value);

  // optional bool score_changed = 3;
  inline bool has_score_changed() const;
  inline void clear_score_changed();
  static const int kScoreChangedFieldNumber = 3;
  inline bool score_changed() const;
  inline void set_score_changed(bool value);

  // optional int32 global_rank_previous = 4;
  inline bool has_global_rank_previous() const;
  inline void clear_global_rank_previous();
  static const int kGlobalRankPreviousFieldNumber = 4;
  inline ::google::protobuf::int32 global_rank_previous() const;
  inline void set_global_rank_previous(::google::protobuf::int32 value);

  // optional int32 global_rank_new = 5;
  inline bool has_global_rank_new() const;
  inline void clear_global_rank_new();
  static const int kGlobalRankNewFieldNumber = 5;
  inline ::google::protobuf::int32 global_rank_new() const;
  inline void set_global_rank_new(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSSetScoreResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_leaderboard_entry_count();
  inline void clear_has_leaderboard_entry_count();
  inline void set_has_score_changed();
  inline void clear_has_score_changed();
  inline void set_has_global_rank_previous();
  inline void clear_has_global_rank_previous();
  inline void set_has_global_rank_new();
  inline void clear_has_global_rank_new();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 leaderboard_entry_count_;
  bool score_changed_;
  ::google::protobuf::int32 global_rank_previous_;
  ::google::protobuf::int32 global_rank_new_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSSetScoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSSetUGC : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSSetUGC();
  virtual ~CMsgClientLBSSetUGC();

  CMsgClientLBSSetUGC(const CMsgClientLBSSetUGC& from);

  inline CMsgClientLBSSetUGC& operator=(const CMsgClientLBSSetUGC& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSSetUGC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSSetUGC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSSetUGC* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSSetUGC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSSetUGC& from);
  void MergeFrom(const CMsgClientLBSSetUGC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 leaderboard_id = 2;
  inline bool has_leaderboard_id() const;
  inline void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_id() const;
  inline void set_leaderboard_id(::google::protobuf::int32 value);

  // optional fixed64 ugc_id = 3;
  inline bool has_ugc_id() const;
  inline void clear_ugc_id();
  static const int kUgcIdFieldNumber = 3;
  inline ::google::protobuf::uint64 ugc_id() const;
  inline void set_ugc_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSSetUGC)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_leaderboard_id();
  inline void clear_has_leaderboard_id();
  inline void set_has_ugc_id();
  inline void clear_has_ugc_id();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 leaderboard_id_;
  ::google::protobuf::uint64 ugc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSSetUGC* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSSetUGCResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSSetUGCResponse();
  virtual ~CMsgClientLBSSetUGCResponse();

  CMsgClientLBSSetUGCResponse(const CMsgClientLBSSetUGCResponse& from);

  inline CMsgClientLBSSetUGCResponse& operator=(const CMsgClientLBSSetUGCResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSSetUGCResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSSetUGCResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSSetUGCResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSSetUGCResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSSetUGCResponse& from);
  void MergeFrom(const CMsgClientLBSSetUGCResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSSetUGCResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSSetUGCResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSFindOrCreateLB : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSFindOrCreateLB();
  virtual ~CMsgClientLBSFindOrCreateLB();

  CMsgClientLBSFindOrCreateLB(const CMsgClientLBSFindOrCreateLB& from);

  inline CMsgClientLBSFindOrCreateLB& operator=(const CMsgClientLBSFindOrCreateLB& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSFindOrCreateLB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSFindOrCreateLB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSFindOrCreateLB* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSFindOrCreateLB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSFindOrCreateLB& from);
  void MergeFrom(const CMsgClientLBSFindOrCreateLB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 leaderboard_sort_method = 2;
  inline bool has_leaderboard_sort_method() const;
  inline void clear_leaderboard_sort_method();
  static const int kLeaderboardSortMethodFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_sort_method() const;
  inline void set_leaderboard_sort_method(::google::protobuf::int32 value);

  // optional int32 leaderboard_display_type = 3;
  inline bool has_leaderboard_display_type() const;
  inline void clear_leaderboard_display_type();
  static const int kLeaderboardDisplayTypeFieldNumber = 3;
  inline ::google::protobuf::int32 leaderboard_display_type() const;
  inline void set_leaderboard_display_type(::google::protobuf::int32 value);

  // optional bool create_if_not_found = 4;
  inline bool has_create_if_not_found() const;
  inline void clear_create_if_not_found();
  static const int kCreateIfNotFoundFieldNumber = 4;
  inline bool create_if_not_found() const;
  inline void set_create_if_not_found(bool value);

  // optional string leaderboard_name = 5;
  inline bool has_leaderboard_name() const;
  inline void clear_leaderboard_name();
  static const int kLeaderboardNameFieldNumber = 5;
  inline const ::std::string& leaderboard_name() const;
  inline void set_leaderboard_name(const ::std::string& value);
  inline void set_leaderboard_name(const char* value);
  inline void set_leaderboard_name(const char* value, size_t size);
  inline ::std::string* mutable_leaderboard_name();
  inline ::std::string* release_leaderboard_name();
  inline void set_allocated_leaderboard_name(::std::string* leaderboard_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSFindOrCreateLB)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_leaderboard_sort_method();
  inline void clear_has_leaderboard_sort_method();
  inline void set_has_leaderboard_display_type();
  inline void clear_has_leaderboard_display_type();
  inline void set_has_create_if_not_found();
  inline void clear_has_create_if_not_found();
  inline void set_has_leaderboard_name();
  inline void clear_has_leaderboard_name();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 leaderboard_sort_method_;
  ::google::protobuf::int32 leaderboard_display_type_;
  bool create_if_not_found_;
  ::std::string* leaderboard_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSFindOrCreateLB* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSFindOrCreateLBResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSFindOrCreateLBResponse();
  virtual ~CMsgClientLBSFindOrCreateLBResponse();

  CMsgClientLBSFindOrCreateLBResponse(const CMsgClientLBSFindOrCreateLBResponse& from);

  inline CMsgClientLBSFindOrCreateLBResponse& operator=(const CMsgClientLBSFindOrCreateLBResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSFindOrCreateLBResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSFindOrCreateLBResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSFindOrCreateLBResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSFindOrCreateLBResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSFindOrCreateLBResponse& from);
  void MergeFrom(const CMsgClientLBSFindOrCreateLBResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 leaderboard_id = 2;
  inline bool has_leaderboard_id() const;
  inline void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_id() const;
  inline void set_leaderboard_id(::google::protobuf::int32 value);

  // optional int32 leaderboard_entry_count = 3;
  inline bool has_leaderboard_entry_count() const;
  inline void clear_leaderboard_entry_count();
  static const int kLeaderboardEntryCountFieldNumber = 3;
  inline ::google::protobuf::int32 leaderboard_entry_count() const;
  inline void set_leaderboard_entry_count(::google::protobuf::int32 value);

  // optional int32 leaderboard_sort_method = 4 [default = 0];
  inline bool has_leaderboard_sort_method() const;
  inline void clear_leaderboard_sort_method();
  static const int kLeaderboardSortMethodFieldNumber = 4;
  inline ::google::protobuf::int32 leaderboard_sort_method() const;
  inline void set_leaderboard_sort_method(::google::protobuf::int32 value);

  // optional int32 leaderboard_display_type = 5 [default = 0];
  inline bool has_leaderboard_display_type() const;
  inline void clear_leaderboard_display_type();
  static const int kLeaderboardDisplayTypeFieldNumber = 5;
  inline ::google::protobuf::int32 leaderboard_display_type() const;
  inline void set_leaderboard_display_type(::google::protobuf::int32 value);

  // optional string leaderboard_name = 6;
  inline bool has_leaderboard_name() const;
  inline void clear_leaderboard_name();
  static const int kLeaderboardNameFieldNumber = 6;
  inline const ::std::string& leaderboard_name() const;
  inline void set_leaderboard_name(const ::std::string& value);
  inline void set_leaderboard_name(const char* value);
  inline void set_leaderboard_name(const char* value, size_t size);
  inline ::std::string* mutable_leaderboard_name();
  inline ::std::string* release_leaderboard_name();
  inline void set_allocated_leaderboard_name(::std::string* leaderboard_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSFindOrCreateLBResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_leaderboard_id();
  inline void clear_has_leaderboard_id();
  inline void set_has_leaderboard_entry_count();
  inline void clear_has_leaderboard_entry_count();
  inline void set_has_leaderboard_sort_method();
  inline void clear_has_leaderboard_sort_method();
  inline void set_has_leaderboard_display_type();
  inline void clear_has_leaderboard_display_type();
  inline void set_has_leaderboard_name();
  inline void clear_has_leaderboard_name();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 leaderboard_id_;
  ::google::protobuf::int32 leaderboard_entry_count_;
  ::google::protobuf::int32 leaderboard_sort_method_;
  ::std::string* leaderboard_name_;
  ::google::protobuf::int32 leaderboard_display_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSFindOrCreateLBResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSGetLBEntries : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSGetLBEntries();
  virtual ~CMsgClientLBSGetLBEntries();

  CMsgClientLBSGetLBEntries(const CMsgClientLBSGetLBEntries& from);

  inline CMsgClientLBSGetLBEntries& operator=(const CMsgClientLBSGetLBEntries& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSGetLBEntries& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSGetLBEntries* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSGetLBEntries* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSGetLBEntries* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSGetLBEntries& from);
  void MergeFrom(const CMsgClientLBSGetLBEntries& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int32 app_id() const;
  inline void set_app_id(::google::protobuf::int32 value);

  // optional int32 leaderboard_id = 2;
  inline bool has_leaderboard_id() const;
  inline void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_id() const;
  inline void set_leaderboard_id(::google::protobuf::int32 value);

  // optional int32 range_start = 3;
  inline bool has_range_start() const;
  inline void clear_range_start();
  static const int kRangeStartFieldNumber = 3;
  inline ::google::protobuf::int32 range_start() const;
  inline void set_range_start(::google::protobuf::int32 value);

  // optional int32 range_end = 4;
  inline bool has_range_end() const;
  inline void clear_range_end();
  static const int kRangeEndFieldNumber = 4;
  inline ::google::protobuf::int32 range_end() const;
  inline void set_range_end(::google::protobuf::int32 value);

  // optional int32 leaderboard_data_request = 5;
  inline bool has_leaderboard_data_request() const;
  inline void clear_leaderboard_data_request();
  static const int kLeaderboardDataRequestFieldNumber = 5;
  inline ::google::protobuf::int32 leaderboard_data_request() const;
  inline void set_leaderboard_data_request(::google::protobuf::int32 value);

  // repeated fixed64 steamids = 6;
  inline int steamids_size() const;
  inline void clear_steamids();
  static const int kSteamidsFieldNumber = 6;
  inline ::google::protobuf::uint64 steamids(int index) const;
  inline void set_steamids(int index, ::google::protobuf::uint64 value);
  inline void add_steamids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      steamids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_steamids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSGetLBEntries)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_leaderboard_id();
  inline void clear_has_leaderboard_id();
  inline void set_has_range_start();
  inline void clear_has_range_start();
  inline void set_has_range_end();
  inline void clear_has_range_end();
  inline void set_has_leaderboard_data_request();
  inline void clear_has_leaderboard_data_request();

  ::google::protobuf::int32 app_id_;
  ::google::protobuf::int32 leaderboard_id_;
  ::google::protobuf::int32 range_start_;
  ::google::protobuf::int32 range_end_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > steamids_;
  ::google::protobuf::int32 leaderboard_data_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSGetLBEntries* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSGetLBEntriesResponse_Entry : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSGetLBEntriesResponse_Entry();
  virtual ~CMsgClientLBSGetLBEntriesResponse_Entry();

  CMsgClientLBSGetLBEntriesResponse_Entry(const CMsgClientLBSGetLBEntriesResponse_Entry& from);

  inline CMsgClientLBSGetLBEntriesResponse_Entry& operator=(const CMsgClientLBSGetLBEntriesResponse_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSGetLBEntriesResponse_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSGetLBEntriesResponse_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSGetLBEntriesResponse_Entry* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSGetLBEntriesResponse_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSGetLBEntriesResponse_Entry& from);
  void MergeFrom(const CMsgClientLBSGetLBEntriesResponse_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_user = 1;
  inline bool has_steam_id_user() const;
  inline void clear_steam_id_user();
  static const int kSteamIdUserFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_user() const;
  inline void set_steam_id_user(::google::protobuf::uint64 value);

  // optional int32 global_rank = 2;
  inline bool has_global_rank() const;
  inline void clear_global_rank();
  static const int kGlobalRankFieldNumber = 2;
  inline ::google::protobuf::int32 global_rank() const;
  inline void set_global_rank(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional bytes details = 4;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 4;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const void* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // optional fixed64 ugc_id = 5;
  inline bool has_ugc_id() const;
  inline void clear_ugc_id();
  static const int kUgcIdFieldNumber = 5;
  inline ::google::protobuf::uint64 ugc_id() const;
  inline void set_ugc_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSGetLBEntriesResponse.Entry)
 private:
  inline void set_has_steam_id_user();
  inline void clear_has_steam_id_user();
  inline void set_has_global_rank();
  inline void clear_has_global_rank();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_ugc_id();
  inline void clear_has_ugc_id();

  ::google::protobuf::uint64 steam_id_user_;
  ::google::protobuf::int32 global_rank_;
  ::google::protobuf::int32 score_;
  ::std::string* details_;
  ::google::protobuf::uint64 ugc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSGetLBEntriesResponse_Entry* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLBSGetLBEntriesResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientLBSGetLBEntriesResponse();
  virtual ~CMsgClientLBSGetLBEntriesResponse();

  CMsgClientLBSGetLBEntriesResponse(const CMsgClientLBSGetLBEntriesResponse& from);

  inline CMsgClientLBSGetLBEntriesResponse& operator=(const CMsgClientLBSGetLBEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientLBSGetLBEntriesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientLBSGetLBEntriesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientLBSGetLBEntriesResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientLBSGetLBEntriesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientLBSGetLBEntriesResponse& from);
  void MergeFrom(const CMsgClientLBSGetLBEntriesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientLBSGetLBEntriesResponse_Entry Entry;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 leaderboard_entry_count = 2;
  inline bool has_leaderboard_entry_count() const;
  inline void clear_leaderboard_entry_count();
  static const int kLeaderboardEntryCountFieldNumber = 2;
  inline ::google::protobuf::int32 leaderboard_entry_count() const;
  inline void set_leaderboard_entry_count(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientLBSGetLBEntriesResponse.Entry entries = 3;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline const ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry& entries(int index) const;
  inline ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry* mutable_entries(int index);
  inline ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientLBSGetLBEntriesResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_leaderboard_entry_count();
  inline void clear_has_leaderboard_entry_count();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 leaderboard_entry_count_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLBSGetLBEntriesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAccountInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAccountInfo();
  virtual ~CMsgClientAccountInfo();

  CMsgClientAccountInfo(const CMsgClientAccountInfo& from);

  inline CMsgClientAccountInfo& operator=(const CMsgClientAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAccountInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAccountInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAccountInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientAccountInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAccountInfo& from);
  void MergeFrom(const CMsgClientAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string persona_name = 1;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 1;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // optional string ip_country = 2;
  inline bool has_ip_country() const;
  inline void clear_ip_country();
  static const int kIpCountryFieldNumber = 2;
  inline const ::std::string& ip_country() const;
  inline void set_ip_country(const ::std::string& value);
  inline void set_ip_country(const char* value);
  inline void set_ip_country(const char* value, size_t size);
  inline ::std::string* mutable_ip_country();
  inline ::std::string* release_ip_country();
  inline void set_allocated_ip_country(::std::string* ip_country);

  // optional bytes salt_password = 3;
  inline bool has_salt_password() const;
  inline void clear_salt_password();
  static const int kSaltPasswordFieldNumber = 3;
  inline const ::std::string& salt_password() const;
  inline void set_salt_password(const ::std::string& value);
  inline void set_salt_password(const char* value);
  inline void set_salt_password(const void* value, size_t size);
  inline ::std::string* mutable_salt_password();
  inline ::std::string* release_salt_password();
  inline void set_allocated_salt_password(::std::string* salt_password);

  // optional bytes sha_digest_Password = 4;
  inline bool has_sha_digest_password() const;
  inline void clear_sha_digest_password();
  static const int kShaDigestPasswordFieldNumber = 4;
  inline const ::std::string& sha_digest_password() const;
  inline void set_sha_digest_password(const ::std::string& value);
  inline void set_sha_digest_password(const char* value);
  inline void set_sha_digest_password(const void* value, size_t size);
  inline ::std::string* mutable_sha_digest_password();
  inline ::std::string* release_sha_digest_password();
  inline void set_allocated_sha_digest_password(::std::string* sha_digest_password);

  // optional int32 count_authed_computers = 5;
  inline bool has_count_authed_computers() const;
  inline void clear_count_authed_computers();
  static const int kCountAuthedComputersFieldNumber = 5;
  inline ::google::protobuf::int32 count_authed_computers() const;
  inline void set_count_authed_computers(::google::protobuf::int32 value);

  // optional bool locked_with_ipt = 6;
  inline bool has_locked_with_ipt() const;
  inline void clear_locked_with_ipt();
  static const int kLockedWithIptFieldNumber = 6;
  inline bool locked_with_ipt() const;
  inline void set_locked_with_ipt(bool value);

  // optional uint32 account_flags = 7;
  inline bool has_account_flags() const;
  inline void clear_account_flags();
  static const int kAccountFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 account_flags() const;
  inline void set_account_flags(::google::protobuf::uint32 value);

  // optional uint64 facebook_id = 8;
  inline bool has_facebook_id() const;
  inline void clear_facebook_id();
  static const int kFacebookIdFieldNumber = 8;
  inline ::google::protobuf::uint64 facebook_id() const;
  inline void set_facebook_id(::google::protobuf::uint64 value);

  // optional string facebook_name = 9;
  inline bool has_facebook_name() const;
  inline void clear_facebook_name();
  static const int kFacebookNameFieldNumber = 9;
  inline const ::std::string& facebook_name() const;
  inline void set_facebook_name(const ::std::string& value);
  inline void set_facebook_name(const char* value);
  inline void set_facebook_name(const char* value, size_t size);
  inline ::std::string* mutable_facebook_name();
  inline ::std::string* release_facebook_name();
  inline void set_allocated_facebook_name(::std::string* facebook_name);

  // optional int32 steam_guard_provider = 10;
  inline bool has_steam_guard_provider() const;
  inline void clear_steam_guard_provider();
  static const int kSteamGuardProviderFieldNumber = 10;
  inline ::google::protobuf::int32 steam_guard_provider() const;
  inline void set_steam_guard_provider(::google::protobuf::int32 value);

  // optional bool steamguard_require_code_default = 11;
  inline bool has_steamguard_require_code_default() const;
  inline void clear_steamguard_require_code_default();
  static const int kSteamguardRequireCodeDefaultFieldNumber = 11;
  inline bool steamguard_require_code_default() const;
  inline void set_steamguard_require_code_default(bool value);

  // optional bool steamguard_show_providers = 12;
  inline bool has_steamguard_show_providers() const;
  inline void clear_steamguard_show_providers();
  static const int kSteamguardShowProvidersFieldNumber = 12;
  inline bool steamguard_show_providers() const;
  inline void set_steamguard_show_providers(bool value);

  // optional bool steamguard_can_use_mobile_provider = 13;
  inline bool has_steamguard_can_use_mobile_provider() const;
  inline void clear_steamguard_can_use_mobile_provider();
  static const int kSteamguardCanUseMobileProviderFieldNumber = 13;
  inline bool steamguard_can_use_mobile_provider() const;
  inline void set_steamguard_can_use_mobile_provider(bool value);

  // optional bool steamguard_notify_newmachines = 14;
  inline bool has_steamguard_notify_newmachines() const;
  inline void clear_steamguard_notify_newmachines();
  static const int kSteamguardNotifyNewmachinesFieldNumber = 14;
  inline bool steamguard_notify_newmachines() const;
  inline void set_steamguard_notify_newmachines(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAccountInfo)
 private:
  inline void set_has_persona_name();
  inline void clear_has_persona_name();
  inline void set_has_ip_country();
  inline void clear_has_ip_country();
  inline void set_has_salt_password();
  inline void clear_has_salt_password();
  inline void set_has_sha_digest_password();
  inline void clear_has_sha_digest_password();
  inline void set_has_count_authed_computers();
  inline void clear_has_count_authed_computers();
  inline void set_has_locked_with_ipt();
  inline void clear_has_locked_with_ipt();
  inline void set_has_account_flags();
  inline void clear_has_account_flags();
  inline void set_has_facebook_id();
  inline void clear_has_facebook_id();
  inline void set_has_facebook_name();
  inline void clear_has_facebook_name();
  inline void set_has_steam_guard_provider();
  inline void clear_has_steam_guard_provider();
  inline void set_has_steamguard_require_code_default();
  inline void clear_has_steamguard_require_code_default();
  inline void set_has_steamguard_show_providers();
  inline void clear_has_steamguard_show_providers();
  inline void set_has_steamguard_can_use_mobile_provider();
  inline void clear_has_steamguard_can_use_mobile_provider();
  inline void set_has_steamguard_notify_newmachines();
  inline void clear_has_steamguard_notify_newmachines();

  ::std::string* persona_name_;
  ::std::string* ip_country_;
  ::std::string* salt_password_;
  ::std::string* sha_digest_password_;
  ::google::protobuf::int32 count_authed_computers_;
  ::google::protobuf::uint32 account_flags_;
  ::google::protobuf::uint64 facebook_id_;
  ::std::string* facebook_name_;
  ::google::protobuf::int32 steam_guard_provider_;
  bool locked_with_ipt_;
  bool steamguard_require_code_default_;
  bool steamguard_show_providers_;
  bool steamguard_can_use_mobile_provider_;
  bool steamguard_notify_newmachines_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppMinutesPlayedData_AppMinutesPlayedData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppMinutesPlayedData_AppMinutesPlayedData();
  virtual ~CMsgClientAppMinutesPlayedData_AppMinutesPlayedData();

  CMsgClientAppMinutesPlayedData_AppMinutesPlayedData(const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& from);

  inline CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& operator=(const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* other);

  // implements Message ----------------------------------------------

  CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& from);
  void MergeFrom(const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 forever = 2;
  inline bool has_forever() const;
  inline void clear_forever();
  static const int kForeverFieldNumber = 2;
  inline ::google::protobuf::int32 forever() const;
  inline void set_forever(::google::protobuf::int32 value);

  // optional int32 last_two_weeks = 3;
  inline bool has_last_two_weeks() const;
  inline void clear_last_two_weeks();
  static const int kLastTwoWeeksFieldNumber = 3;
  inline ::google::protobuf::int32 last_two_weeks() const;
  inline void set_last_two_weeks(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppMinutesPlayedData.AppMinutesPlayedData)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_forever();
  inline void clear_has_forever();
  inline void set_has_last_two_weeks();
  inline void clear_has_last_two_weeks();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 forever_;
  ::google::protobuf::int32 last_two_weeks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppMinutesPlayedData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppMinutesPlayedData();
  virtual ~CMsgClientAppMinutesPlayedData();

  CMsgClientAppMinutesPlayedData(const CMsgClientAppMinutesPlayedData& from);

  inline CMsgClientAppMinutesPlayedData& operator=(const CMsgClientAppMinutesPlayedData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppMinutesPlayedData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppMinutesPlayedData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppMinutesPlayedData* other);

  // implements Message ----------------------------------------------

  CMsgClientAppMinutesPlayedData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppMinutesPlayedData& from);
  void MergeFrom(const CMsgClientAppMinutesPlayedData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAppMinutesPlayedData_AppMinutesPlayedData AppMinutesPlayedData;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientAppMinutesPlayedData.AppMinutesPlayedData minutes_played = 1;
  inline int minutes_played_size() const;
  inline void clear_minutes_played();
  static const int kMinutesPlayedFieldNumber = 1;
  inline const ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& minutes_played(int index) const;
  inline ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* mutable_minutes_played(int index);
  inline ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* add_minutes_played();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData >&
      minutes_played() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData >*
      mutable_minutes_played();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppMinutesPlayedData)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData > minutes_played_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppMinutesPlayedData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientIsLimitedAccount : public ::google::protobuf::MessageLite {
 public:
  CMsgClientIsLimitedAccount();
  virtual ~CMsgClientIsLimitedAccount();

  CMsgClientIsLimitedAccount(const CMsgClientIsLimitedAccount& from);

  inline CMsgClientIsLimitedAccount& operator=(const CMsgClientIsLimitedAccount& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientIsLimitedAccount& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientIsLimitedAccount* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientIsLimitedAccount* other);

  // implements Message ----------------------------------------------

  CMsgClientIsLimitedAccount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientIsLimitedAccount& from);
  void MergeFrom(const CMsgClientIsLimitedAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bis_limited_account = 1;
  inline bool has_bis_limited_account() const;
  inline void clear_bis_limited_account();
  static const int kBisLimitedAccountFieldNumber = 1;
  inline bool bis_limited_account() const;
  inline void set_bis_limited_account(bool value);

  // optional bool bis_community_banned = 2;
  inline bool has_bis_community_banned() const;
  inline void clear_bis_community_banned();
  static const int kBisCommunityBannedFieldNumber = 2;
  inline bool bis_community_banned() const;
  inline void set_bis_community_banned(bool value);

  // optional bool bis_locked_account = 3;
  inline bool has_bis_locked_account() const;
  inline void clear_bis_locked_account();
  static const int kBisLockedAccountFieldNumber = 3;
  inline bool bis_locked_account() const;
  inline void set_bis_locked_account(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientIsLimitedAccount)
 private:
  inline void set_has_bis_limited_account();
  inline void clear_has_bis_limited_account();
  inline void set_has_bis_community_banned();
  inline void clear_has_bis_community_banned();
  inline void set_has_bis_locked_account();
  inline void clear_has_bis_locked_account();

  bool bis_limited_account_;
  bool bis_community_banned_;
  bool bis_locked_account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientIsLimitedAccount* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestFriendData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestFriendData();
  virtual ~CMsgClientRequestFriendData();

  CMsgClientRequestFriendData(const CMsgClientRequestFriendData& from);

  inline CMsgClientRequestFriendData& operator=(const CMsgClientRequestFriendData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestFriendData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestFriendData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestFriendData* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestFriendData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestFriendData& from);
  void MergeFrom(const CMsgClientRequestFriendData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 persona_state_requested = 1;
  inline bool has_persona_state_requested() const;
  inline void clear_persona_state_requested();
  static const int kPersonaStateRequestedFieldNumber = 1;
  inline ::google::protobuf::uint32 persona_state_requested() const;
  inline void set_persona_state_requested(::google::protobuf::uint32 value);

  // repeated fixed64 friends = 2;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 2;
  inline ::google::protobuf::uint64 friends(int index) const;
  inline void set_friends(int index, ::google::protobuf::uint64 value);
  inline void add_friends(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      friends() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_friends();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestFriendData)
 private:
  inline void set_has_persona_state_requested();
  inline void clear_has_persona_state_requested();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > friends_;
  ::google::protobuf::uint32 persona_state_requested_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestFriendData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientChangeStatus : public ::google::protobuf::MessageLite {
 public:
  CMsgClientChangeStatus();
  virtual ~CMsgClientChangeStatus();

  CMsgClientChangeStatus(const CMsgClientChangeStatus& from);

  inline CMsgClientChangeStatus& operator=(const CMsgClientChangeStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientChangeStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientChangeStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientChangeStatus* other);

  // implements Message ----------------------------------------------

  CMsgClientChangeStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientChangeStatus& from);
  void MergeFrom(const CMsgClientChangeStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 persona_state = 1;
  inline bool has_persona_state() const;
  inline void clear_persona_state();
  static const int kPersonaStateFieldNumber = 1;
  inline ::google::protobuf::uint32 persona_state() const;
  inline void set_persona_state(::google::protobuf::uint32 value);

  // optional string player_name = 2;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // optional bool is_auto_generated_name = 3;
  inline bool has_is_auto_generated_name() const;
  inline void clear_is_auto_generated_name();
  static const int kIsAutoGeneratedNameFieldNumber = 3;
  inline bool is_auto_generated_name() const;
  inline void set_is_auto_generated_name(bool value);

  // optional bool high_priority = 4;
  inline bool has_high_priority() const;
  inline void clear_high_priority();
  static const int kHighPriorityFieldNumber = 4;
  inline bool high_priority() const;
  inline void set_high_priority(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientChangeStatus)
 private:
  inline void set_has_persona_state();
  inline void clear_has_persona_state();
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_is_auto_generated_name();
  inline void clear_has_is_auto_generated_name();
  inline void set_has_high_priority();
  inline void clear_has_high_priority();

  ::std::string* player_name_;
  ::google::protobuf::uint32 persona_state_;
  bool is_auto_generated_name_;
  bool high_priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientChangeStatus* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPersonaChangeResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgPersonaChangeResponse();
  virtual ~CMsgPersonaChangeResponse();

  CMsgPersonaChangeResponse(const CMsgPersonaChangeResponse& from);

  inline CMsgPersonaChangeResponse& operator=(const CMsgPersonaChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPersonaChangeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPersonaChangeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPersonaChangeResponse* other);

  // implements Message ----------------------------------------------

  CMsgPersonaChangeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPersonaChangeResponse& from);
  void MergeFrom(const CMsgPersonaChangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional string player_name = 2;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPersonaChangeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_player_name();
  inline void clear_has_player_name();

  ::std::string* player_name_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPersonaChangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPersonaState_Friend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPersonaState_Friend();
  virtual ~CMsgClientPersonaState_Friend();

  CMsgClientPersonaState_Friend(const CMsgClientPersonaState_Friend& from);

  inline CMsgClientPersonaState_Friend& operator=(const CMsgClientPersonaState_Friend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPersonaState_Friend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPersonaState_Friend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPersonaState_Friend* other);

  // implements Message ----------------------------------------------

  CMsgClientPersonaState_Friend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPersonaState_Friend& from);
  void MergeFrom(const CMsgClientPersonaState_Friend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 friendid = 1;
  inline bool has_friendid() const;
  inline void clear_friendid();
  static const int kFriendidFieldNumber = 1;
  inline ::google::protobuf::uint64 friendid() const;
  inline void set_friendid(::google::protobuf::uint64 value);

  // optional uint32 persona_state = 2;
  inline bool has_persona_state() const;
  inline void clear_persona_state();
  static const int kPersonaStateFieldNumber = 2;
  inline ::google::protobuf::uint32 persona_state() const;
  inline void set_persona_state(::google::protobuf::uint32 value);

  // optional uint32 game_played_app_id = 3;
  inline bool has_game_played_app_id() const;
  inline void clear_game_played_app_id();
  static const int kGamePlayedAppIdFieldNumber = 3;
  inline ::google::protobuf::uint32 game_played_app_id() const;
  inline void set_game_played_app_id(::google::protobuf::uint32 value);

  // optional uint32 game_server_ip = 4;
  inline bool has_game_server_ip() const;
  inline void clear_game_server_ip();
  static const int kGameServerIpFieldNumber = 4;
  inline ::google::protobuf::uint32 game_server_ip() const;
  inline void set_game_server_ip(::google::protobuf::uint32 value);

  // optional uint32 game_server_port = 5;
  inline bool has_game_server_port() const;
  inline void clear_game_server_port();
  static const int kGameServerPortFieldNumber = 5;
  inline ::google::protobuf::uint32 game_server_port() const;
  inline void set_game_server_port(::google::protobuf::uint32 value);

  // optional uint32 persona_state_flags = 6;
  inline bool has_persona_state_flags() const;
  inline void clear_persona_state_flags();
  static const int kPersonaStateFlagsFieldNumber = 6;
  inline ::google::protobuf::uint32 persona_state_flags() const;
  inline void set_persona_state_flags(::google::protobuf::uint32 value);

  // optional uint32 online_session_instances = 7;
  inline bool has_online_session_instances() const;
  inline void clear_online_session_instances();
  static const int kOnlineSessionInstancesFieldNumber = 7;
  inline ::google::protobuf::uint32 online_session_instances() const;
  inline void set_online_session_instances(::google::protobuf::uint32 value);

  // optional uint32 published_instance_id = 8;
  inline bool has_published_instance_id() const;
  inline void clear_published_instance_id();
  static const int kPublishedInstanceIdFieldNumber = 8;
  inline ::google::protobuf::uint32 published_instance_id() const;
  inline void set_published_instance_id(::google::protobuf::uint32 value);

  // optional string player_name = 15;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 15;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // optional uint32 query_port = 20;
  inline bool has_query_port() const;
  inline void clear_query_port();
  static const int kQueryPortFieldNumber = 20;
  inline ::google::protobuf::uint32 query_port() const;
  inline void set_query_port(::google::protobuf::uint32 value);

  // optional fixed64 steamid_source = 25;
  inline bool has_steamid_source() const;
  inline void clear_steamid_source();
  static const int kSteamidSourceFieldNumber = 25;
  inline ::google::protobuf::uint64 steamid_source() const;
  inline void set_steamid_source(::google::protobuf::uint64 value);

  // optional bytes avatar_hash = 31;
  inline bool has_avatar_hash() const;
  inline void clear_avatar_hash();
  static const int kAvatarHashFieldNumber = 31;
  inline const ::std::string& avatar_hash() const;
  inline void set_avatar_hash(const ::std::string& value);
  inline void set_avatar_hash(const char* value);
  inline void set_avatar_hash(const void* value, size_t size);
  inline ::std::string* mutable_avatar_hash();
  inline ::std::string* release_avatar_hash();
  inline void set_allocated_avatar_hash(::std::string* avatar_hash);

  // optional uint32 last_logoff = 45;
  inline bool has_last_logoff() const;
  inline void clear_last_logoff();
  static const int kLastLogoffFieldNumber = 45;
  inline ::google::protobuf::uint32 last_logoff() const;
  inline void set_last_logoff(::google::protobuf::uint32 value);

  // optional uint32 last_logon = 46;
  inline bool has_last_logon() const;
  inline void clear_last_logon();
  static const int kLastLogonFieldNumber = 46;
  inline ::google::protobuf::uint32 last_logon() const;
  inline void set_last_logon(::google::protobuf::uint32 value);

  // optional uint32 clan_rank = 50;
  inline bool has_clan_rank() const;
  inline void clear_clan_rank();
  static const int kClanRankFieldNumber = 50;
  inline ::google::protobuf::uint32 clan_rank() const;
  inline void set_clan_rank(::google::protobuf::uint32 value);

  // optional string game_name = 55;
  inline bool has_game_name() const;
  inline void clear_game_name();
  static const int kGameNameFieldNumber = 55;
  inline const ::std::string& game_name() const;
  inline void set_game_name(const ::std::string& value);
  inline void set_game_name(const char* value);
  inline void set_game_name(const char* value, size_t size);
  inline ::std::string* mutable_game_name();
  inline ::std::string* release_game_name();
  inline void set_allocated_game_name(::std::string* game_name);

  // optional fixed64 gameid = 56;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 56;
  inline ::google::protobuf::uint64 gameid() const;
  inline void set_gameid(::google::protobuf::uint64 value);

  // optional bytes game_data_blob = 60;
  inline bool has_game_data_blob() const;
  inline void clear_game_data_blob();
  static const int kGameDataBlobFieldNumber = 60;
  inline const ::std::string& game_data_blob() const;
  inline void set_game_data_blob(const ::std::string& value);
  inline void set_game_data_blob(const char* value);
  inline void set_game_data_blob(const void* value, size_t size);
  inline ::std::string* mutable_game_data_blob();
  inline ::std::string* release_game_data_blob();
  inline void set_allocated_game_data_blob(::std::string* game_data_blob);

  // optional string clan_tag = 65;
  inline bool has_clan_tag() const;
  inline void clear_clan_tag();
  static const int kClanTagFieldNumber = 65;
  inline const ::std::string& clan_tag() const;
  inline void set_clan_tag(const ::std::string& value);
  inline void set_clan_tag(const char* value);
  inline void set_clan_tag(const char* value, size_t size);
  inline ::std::string* mutable_clan_tag();
  inline ::std::string* release_clan_tag();
  inline void set_allocated_clan_tag(::std::string* clan_tag);

  // optional string facebook_name = 66;
  inline bool has_facebook_name() const;
  inline void clear_facebook_name();
  static const int kFacebookNameFieldNumber = 66;
  inline const ::std::string& facebook_name() const;
  inline void set_facebook_name(const ::std::string& value);
  inline void set_facebook_name(const char* value);
  inline void set_facebook_name(const char* value, size_t size);
  inline ::std::string* mutable_facebook_name();
  inline ::std::string* release_facebook_name();
  inline void set_allocated_facebook_name(::std::string* facebook_name);

  // optional uint64 facebook_id = 67;
  inline bool has_facebook_id() const;
  inline void clear_facebook_id();
  static const int kFacebookIdFieldNumber = 67;
  inline ::google::protobuf::uint64 facebook_id() const;
  inline void set_facebook_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPersonaState.Friend)
 private:
  inline void set_has_friendid();
  inline void clear_has_friendid();
  inline void set_has_persona_state();
  inline void clear_has_persona_state();
  inline void set_has_game_played_app_id();
  inline void clear_has_game_played_app_id();
  inline void set_has_game_server_ip();
  inline void clear_has_game_server_ip();
  inline void set_has_game_server_port();
  inline void clear_has_game_server_port();
  inline void set_has_persona_state_flags();
  inline void clear_has_persona_state_flags();
  inline void set_has_online_session_instances();
  inline void clear_has_online_session_instances();
  inline void set_has_published_instance_id();
  inline void clear_has_published_instance_id();
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_query_port();
  inline void clear_has_query_port();
  inline void set_has_steamid_source();
  inline void clear_has_steamid_source();
  inline void set_has_avatar_hash();
  inline void clear_has_avatar_hash();
  inline void set_has_last_logoff();
  inline void clear_has_last_logoff();
  inline void set_has_last_logon();
  inline void clear_has_last_logon();
  inline void set_has_clan_rank();
  inline void clear_has_clan_rank();
  inline void set_has_game_name();
  inline void clear_has_game_name();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_game_data_blob();
  inline void clear_has_game_data_blob();
  inline void set_has_clan_tag();
  inline void clear_has_clan_tag();
  inline void set_has_facebook_name();
  inline void clear_has_facebook_name();
  inline void set_has_facebook_id();
  inline void clear_has_facebook_id();

  ::google::protobuf::uint64 friendid_;
  ::google::protobuf::uint32 persona_state_;
  ::google::protobuf::uint32 game_played_app_id_;
  ::google::protobuf::uint32 game_server_ip_;
  ::google::protobuf::uint32 game_server_port_;
  ::google::protobuf::uint32 persona_state_flags_;
  ::google::protobuf::uint32 online_session_instances_;
  ::std::string* player_name_;
  ::google::protobuf::uint32 published_instance_id_;
  ::google::protobuf::uint32 query_port_;
  ::google::protobuf::uint64 steamid_source_;
  ::std::string* avatar_hash_;
  ::google::protobuf::uint32 last_logoff_;
  ::google::protobuf::uint32 last_logon_;
  ::std::string* game_name_;
  ::google::protobuf::uint64 gameid_;
  ::std::string* game_data_blob_;
  ::std::string* clan_tag_;
  ::std::string* facebook_name_;
  ::google::protobuf::uint64 facebook_id_;
  ::google::protobuf::uint32 clan_rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPersonaState_Friend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPersonaState : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPersonaState();
  virtual ~CMsgClientPersonaState();

  CMsgClientPersonaState(const CMsgClientPersonaState& from);

  inline CMsgClientPersonaState& operator=(const CMsgClientPersonaState& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPersonaState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPersonaState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPersonaState* other);

  // implements Message ----------------------------------------------

  CMsgClientPersonaState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPersonaState& from);
  void MergeFrom(const CMsgClientPersonaState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientPersonaState_Friend Friend;

  // accessors -------------------------------------------------------

  // optional uint32 status_flags = 1;
  inline bool has_status_flags() const;
  inline void clear_status_flags();
  static const int kStatusFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 status_flags() const;
  inline void set_status_flags(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientPersonaState.Friend friends = 2;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 2;
  inline const ::Sc::CMsgClientPersonaState_Friend& friends(int index) const;
  inline ::Sc::CMsgClientPersonaState_Friend* mutable_friends(int index);
  inline ::Sc::CMsgClientPersonaState_Friend* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPersonaState_Friend >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPersonaState_Friend >*
      mutable_friends();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPersonaState)
 private:
  inline void set_has_status_flags();
  inline void clear_has_status_flags();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPersonaState_Friend > friends_;
  ::google::protobuf::uint32 status_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPersonaState* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendProfileInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendProfileInfo();
  virtual ~CMsgClientFriendProfileInfo();

  CMsgClientFriendProfileInfo(const CMsgClientFriendProfileInfo& from);

  inline CMsgClientFriendProfileInfo& operator=(const CMsgClientFriendProfileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendProfileInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendProfileInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendProfileInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendProfileInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendProfileInfo& from);
  void MergeFrom(const CMsgClientFriendProfileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_friend = 1;
  inline bool has_steamid_friend() const;
  inline void clear_steamid_friend();
  static const int kSteamidFriendFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_friend() const;
  inline void set_steamid_friend(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendProfileInfo)
 private:
  inline void set_has_steamid_friend();
  inline void clear_has_steamid_friend();

  ::google::protobuf::uint64 steamid_friend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendProfileInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendProfileInfoResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendProfileInfoResponse();
  virtual ~CMsgClientFriendProfileInfoResponse();

  CMsgClientFriendProfileInfoResponse(const CMsgClientFriendProfileInfoResponse& from);

  inline CMsgClientFriendProfileInfoResponse& operator=(const CMsgClientFriendProfileInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendProfileInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendProfileInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendProfileInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendProfileInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendProfileInfoResponse& from);
  void MergeFrom(const CMsgClientFriendProfileInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 steamid_friend = 2;
  inline bool has_steamid_friend() const;
  inline void clear_steamid_friend();
  static const int kSteamidFriendFieldNumber = 2;
  inline ::google::protobuf::uint64 steamid_friend() const;
  inline void set_steamid_friend(::google::protobuf::uint64 value);

  // optional uint32 time_created = 3;
  inline bool has_time_created() const;
  inline void clear_time_created();
  static const int kTimeCreatedFieldNumber = 3;
  inline ::google::protobuf::uint32 time_created() const;
  inline void set_time_created(::google::protobuf::uint32 value);

  // optional string real_name = 4;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 4;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const char* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // optional string city_name = 5;
  inline bool has_city_name() const;
  inline void clear_city_name();
  static const int kCityNameFieldNumber = 5;
  inline const ::std::string& city_name() const;
  inline void set_city_name(const ::std::string& value);
  inline void set_city_name(const char* value);
  inline void set_city_name(const char* value, size_t size);
  inline ::std::string* mutable_city_name();
  inline ::std::string* release_city_name();
  inline void set_allocated_city_name(::std::string* city_name);

  // optional string state_name = 6;
  inline bool has_state_name() const;
  inline void clear_state_name();
  static const int kStateNameFieldNumber = 6;
  inline const ::std::string& state_name() const;
  inline void set_state_name(const ::std::string& value);
  inline void set_state_name(const char* value);
  inline void set_state_name(const char* value, size_t size);
  inline ::std::string* mutable_state_name();
  inline ::std::string* release_state_name();
  inline void set_allocated_state_name(::std::string* state_name);

  // optional string country_name = 7;
  inline bool has_country_name() const;
  inline void clear_country_name();
  static const int kCountryNameFieldNumber = 7;
  inline const ::std::string& country_name() const;
  inline void set_country_name(const ::std::string& value);
  inline void set_country_name(const char* value);
  inline void set_country_name(const char* value, size_t size);
  inline ::std::string* mutable_country_name();
  inline ::std::string* release_country_name();
  inline void set_allocated_country_name(::std::string* country_name);

  // optional string headline = 8;
  inline bool has_headline() const;
  inline void clear_headline();
  static const int kHeadlineFieldNumber = 8;
  inline const ::std::string& headline() const;
  inline void set_headline(const ::std::string& value);
  inline void set_headline(const char* value);
  inline void set_headline(const char* value, size_t size);
  inline ::std::string* mutable_headline();
  inline ::std::string* release_headline();
  inline void set_allocated_headline(::std::string* headline);

  // optional string summary = 9;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 9;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // optional uint32 recent_playtime = 10;
  inline bool has_recent_playtime() const;
  inline void clear_recent_playtime();
  static const int kRecentPlaytimeFieldNumber = 10;
  inline ::google::protobuf::uint32 recent_playtime() const;
  inline void set_recent_playtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendProfileInfoResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_steamid_friend();
  inline void clear_has_steamid_friend();
  inline void set_has_time_created();
  inline void clear_has_time_created();
  inline void set_has_real_name();
  inline void clear_has_real_name();
  inline void set_has_city_name();
  inline void clear_has_city_name();
  inline void set_has_state_name();
  inline void clear_has_state_name();
  inline void set_has_country_name();
  inline void clear_has_country_name();
  inline void set_has_headline();
  inline void clear_has_headline();
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_recent_playtime();
  inline void clear_has_recent_playtime();

  ::google::protobuf::uint64 steamid_friend_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 time_created_;
  ::std::string* real_name_;
  ::std::string* city_name_;
  ::std::string* state_name_;
  ::std::string* country_name_;
  ::std::string* headline_;
  ::std::string* summary_;
  ::google::protobuf::uint32 recent_playtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendProfileInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServerList_Server : public ::google::protobuf::MessageLite {
 public:
  CMsgClientServerList_Server();
  virtual ~CMsgClientServerList_Server();

  CMsgClientServerList_Server(const CMsgClientServerList_Server& from);

  inline CMsgClientServerList_Server& operator=(const CMsgClientServerList_Server& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientServerList_Server& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientServerList_Server* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientServerList_Server* other);

  // implements Message ----------------------------------------------

  CMsgClientServerList_Server* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientServerList_Server& from);
  void MergeFrom(const CMsgClientServerList_Server& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_type = 1;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 server_type() const;
  inline void set_server_type(::google::protobuf::uint32 value);

  // optional uint32 server_ip = 2;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 2;
  inline ::google::protobuf::uint32 server_ip() const;
  inline void set_server_ip(::google::protobuf::uint32 value);

  // optional uint32 server_port = 3;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 3;
  inline ::google::protobuf::uint32 server_port() const;
  inline void set_server_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientServerList.Server)
 private:
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_server_port();
  inline void clear_has_server_port();

  ::google::protobuf::uint32 server_type_;
  ::google::protobuf::uint32 server_ip_;
  ::google::protobuf::uint32 server_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServerList_Server* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServerList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientServerList();
  virtual ~CMsgClientServerList();

  CMsgClientServerList(const CMsgClientServerList& from);

  inline CMsgClientServerList& operator=(const CMsgClientServerList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientServerList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientServerList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientServerList* other);

  // implements Message ----------------------------------------------

  CMsgClientServerList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientServerList& from);
  void MergeFrom(const CMsgClientServerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientServerList_Server Server;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientServerList.Server servers = 1;
  inline int servers_size() const;
  inline void clear_servers();
  static const int kServersFieldNumber = 1;
  inline const ::Sc::CMsgClientServerList_Server& servers(int index) const;
  inline ::Sc::CMsgClientServerList_Server* mutable_servers(int index);
  inline ::Sc::CMsgClientServerList_Server* add_servers();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServerList_Server >&
      servers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServerList_Server >*
      mutable_servers();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientServerList)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServerList_Server > servers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServerList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestedClientStats_StatsToSend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestedClientStats_StatsToSend();
  virtual ~CMsgClientRequestedClientStats_StatsToSend();

  CMsgClientRequestedClientStats_StatsToSend(const CMsgClientRequestedClientStats_StatsToSend& from);

  inline CMsgClientRequestedClientStats_StatsToSend& operator=(const CMsgClientRequestedClientStats_StatsToSend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestedClientStats_StatsToSend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestedClientStats_StatsToSend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestedClientStats_StatsToSend* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestedClientStats_StatsToSend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestedClientStats_StatsToSend& from);
  void MergeFrom(const CMsgClientRequestedClientStats_StatsToSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_stat = 1;
  inline bool has_client_stat() const;
  inline void clear_client_stat();
  static const int kClientStatFieldNumber = 1;
  inline ::google::protobuf::uint32 client_stat() const;
  inline void set_client_stat(::google::protobuf::uint32 value);

  // optional uint32 stat_aggregate_method = 2;
  inline bool has_stat_aggregate_method() const;
  inline void clear_stat_aggregate_method();
  static const int kStatAggregateMethodFieldNumber = 2;
  inline ::google::protobuf::uint32 stat_aggregate_method() const;
  inline void set_stat_aggregate_method(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestedClientStats.StatsToSend)
 private:
  inline void set_has_client_stat();
  inline void clear_has_client_stat();
  inline void set_has_stat_aggregate_method();
  inline void clear_has_stat_aggregate_method();

  ::google::protobuf::uint32 client_stat_;
  ::google::protobuf::uint32 stat_aggregate_method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestedClientStats_StatsToSend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestedClientStats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestedClientStats();
  virtual ~CMsgClientRequestedClientStats();

  CMsgClientRequestedClientStats(const CMsgClientRequestedClientStats& from);

  inline CMsgClientRequestedClientStats& operator=(const CMsgClientRequestedClientStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestedClientStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestedClientStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestedClientStats* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestedClientStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestedClientStats& from);
  void MergeFrom(const CMsgClientRequestedClientStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientRequestedClientStats_StatsToSend StatsToSend;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientRequestedClientStats.StatsToSend stats_to_send = 1;
  inline int stats_to_send_size() const;
  inline void clear_stats_to_send();
  static const int kStatsToSendFieldNumber = 1;
  inline const ::Sc::CMsgClientRequestedClientStats_StatsToSend& stats_to_send(int index) const;
  inline ::Sc::CMsgClientRequestedClientStats_StatsToSend* mutable_stats_to_send(int index);
  inline ::Sc::CMsgClientRequestedClientStats_StatsToSend* add_stats_to_send();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRequestedClientStats_StatsToSend >&
      stats_to_send() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRequestedClientStats_StatsToSend >*
      mutable_stats_to_send();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestedClientStats)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRequestedClientStats_StatsToSend > stats_to_send_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestedClientStats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStat2_StatDetail : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStat2_StatDetail();
  virtual ~CMsgClientStat2_StatDetail();

  CMsgClientStat2_StatDetail(const CMsgClientStat2_StatDetail& from);

  inline CMsgClientStat2_StatDetail& operator=(const CMsgClientStat2_StatDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStat2_StatDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStat2_StatDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStat2_StatDetail* other);

  // implements Message ----------------------------------------------

  CMsgClientStat2_StatDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStat2_StatDetail& from);
  void MergeFrom(const CMsgClientStat2_StatDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_stat = 1;
  inline bool has_client_stat() const;
  inline void clear_client_stat();
  static const int kClientStatFieldNumber = 1;
  inline ::google::protobuf::uint32 client_stat() const;
  inline void set_client_stat(::google::protobuf::uint32 value);

  // optional int64 ll_value = 2;
  inline bool has_ll_value() const;
  inline void clear_ll_value();
  static const int kLlValueFieldNumber = 2;
  inline ::google::protobuf::int64 ll_value() const;
  inline void set_ll_value(::google::protobuf::int64 value);

  // optional uint32 time_of_day = 3;
  inline bool has_time_of_day() const;
  inline void clear_time_of_day();
  static const int kTimeOfDayFieldNumber = 3;
  inline ::google::protobuf::uint32 time_of_day() const;
  inline void set_time_of_day(::google::protobuf::uint32 value);

  // optional uint32 cell_id = 4;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 4;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional uint32 depot_id = 5;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 5;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // optional uint32 app_id = 6;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 6;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStat2.StatDetail)
 private:
  inline void set_has_client_stat();
  inline void clear_has_client_stat();
  inline void set_has_ll_value();
  inline void clear_has_ll_value();
  inline void set_has_time_of_day();
  inline void clear_has_time_of_day();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::int64 ll_value_;
  ::google::protobuf::uint32 client_stat_;
  ::google::protobuf::uint32 time_of_day_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::uint32 depot_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStat2_StatDetail* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStat2 : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStat2();
  virtual ~CMsgClientStat2();

  CMsgClientStat2(const CMsgClientStat2& from);

  inline CMsgClientStat2& operator=(const CMsgClientStat2& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStat2& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStat2* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStat2* other);

  // implements Message ----------------------------------------------

  CMsgClientStat2* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStat2& from);
  void MergeFrom(const CMsgClientStat2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientStat2_StatDetail StatDetail;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientStat2.StatDetail stat_detail = 1;
  inline int stat_detail_size() const;
  inline void clear_stat_detail();
  static const int kStatDetailFieldNumber = 1;
  inline const ::Sc::CMsgClientStat2_StatDetail& stat_detail(int index) const;
  inline ::Sc::CMsgClientStat2_StatDetail* mutable_stat_detail(int index);
  inline ::Sc::CMsgClientStat2_StatDetail* add_stat_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStat2_StatDetail >&
      stat_detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStat2_StatDetail >*
      mutable_stat_detail();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStat2)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStat2_StatDetail > stat_detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStat2* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSCreateLobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSCreateLobby();
  virtual ~CMsgClientMMSCreateLobby();

  CMsgClientMMSCreateLobby(const CMsgClientMMSCreateLobby& from);

  inline CMsgClientMMSCreateLobby& operator=(const CMsgClientMMSCreateLobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSCreateLobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSCreateLobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSCreateLobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSCreateLobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSCreateLobby& from);
  void MergeFrom(const CMsgClientMMSCreateLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 max_members = 2;
  inline bool has_max_members() const;
  inline void clear_max_members();
  static const int kMaxMembersFieldNumber = 2;
  inline ::google::protobuf::int32 max_members() const;
  inline void set_max_members(::google::protobuf::int32 value);

  // optional int32 lobby_type = 3;
  inline bool has_lobby_type() const;
  inline void clear_lobby_type();
  static const int kLobbyTypeFieldNumber = 3;
  inline ::google::protobuf::int32 lobby_type() const;
  inline void set_lobby_type(::google::protobuf::int32 value);

  // optional int32 lobby_flags = 4;
  inline bool has_lobby_flags() const;
  inline void clear_lobby_flags();
  static const int kLobbyFlagsFieldNumber = 4;
  inline ::google::protobuf::int32 lobby_flags() const;
  inline void set_lobby_flags(::google::protobuf::int32 value);

  // optional uint32 cell_id = 5;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 5;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional uint32 public_ip = 6;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 6;
  inline ::google::protobuf::uint32 public_ip() const;
  inline void set_public_ip(::google::protobuf::uint32 value);

  // optional bytes metadata = 7;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 7;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // optional string persona_name_owner = 8;
  inline bool has_persona_name_owner() const;
  inline void clear_persona_name_owner();
  static const int kPersonaNameOwnerFieldNumber = 8;
  inline const ::std::string& persona_name_owner() const;
  inline void set_persona_name_owner(const ::std::string& value);
  inline void set_persona_name_owner(const char* value);
  inline void set_persona_name_owner(const char* value, size_t size);
  inline ::std::string* mutable_persona_name_owner();
  inline ::std::string* release_persona_name_owner();
  inline void set_allocated_persona_name_owner(::std::string* persona_name_owner);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSCreateLobby)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_max_members();
  inline void clear_has_max_members();
  inline void set_has_lobby_type();
  inline void clear_has_lobby_type();
  inline void set_has_lobby_flags();
  inline void clear_has_lobby_flags();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_persona_name_owner();
  inline void clear_has_persona_name_owner();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 max_members_;
  ::google::protobuf::int32 lobby_type_;
  ::google::protobuf::int32 lobby_flags_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::uint32 public_ip_;
  ::std::string* metadata_;
  ::std::string* persona_name_owner_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSCreateLobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSCreateLobbyResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSCreateLobbyResponse();
  virtual ~CMsgClientMMSCreateLobbyResponse();

  CMsgClientMMSCreateLobbyResponse(const CMsgClientMMSCreateLobbyResponse& from);

  inline CMsgClientMMSCreateLobbyResponse& operator=(const CMsgClientMMSCreateLobbyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSCreateLobbyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSCreateLobbyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSCreateLobbyResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSCreateLobbyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSCreateLobbyResponse& from);
  void MergeFrom(const CMsgClientMMSCreateLobbyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional int32 eresult = 3 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 3;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSCreateLobbyResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSCreateLobbyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSJoinLobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSJoinLobby();
  virtual ~CMsgClientMMSJoinLobby();

  CMsgClientMMSJoinLobby(const CMsgClientMMSJoinLobby& from);

  inline CMsgClientMMSJoinLobby& operator=(const CMsgClientMMSJoinLobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSJoinLobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSJoinLobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSJoinLobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSJoinLobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSJoinLobby& from);
  void MergeFrom(const CMsgClientMMSJoinLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional string persona_name = 3;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 3;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSJoinLobby)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_persona_name();
  inline void clear_has_persona_name();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::std::string* persona_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSJoinLobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSJoinLobbyResponse_Member : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSJoinLobbyResponse_Member();
  virtual ~CMsgClientMMSJoinLobbyResponse_Member();

  CMsgClientMMSJoinLobbyResponse_Member(const CMsgClientMMSJoinLobbyResponse_Member& from);

  inline CMsgClientMMSJoinLobbyResponse_Member& operator=(const CMsgClientMMSJoinLobbyResponse_Member& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSJoinLobbyResponse_Member& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSJoinLobbyResponse_Member* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSJoinLobbyResponse_Member* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSJoinLobbyResponse_Member* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSJoinLobbyResponse_Member& from);
  void MergeFrom(const CMsgClientMMSJoinLobbyResponse_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional string persona_name = 2;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 2;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // optional bytes metadata = 3;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSJoinLobbyResponse.Member)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_persona_name();
  inline void clear_has_persona_name();
  inline void set_has_metadata();
  inline void clear_has_metadata();

  ::google::protobuf::uint64 steam_id_;
  ::std::string* persona_name_;
  ::std::string* metadata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSJoinLobbyResponse_Member* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSJoinLobbyResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSJoinLobbyResponse();
  virtual ~CMsgClientMMSJoinLobbyResponse();

  CMsgClientMMSJoinLobbyResponse(const CMsgClientMMSJoinLobbyResponse& from);

  inline CMsgClientMMSJoinLobbyResponse& operator=(const CMsgClientMMSJoinLobbyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSJoinLobbyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSJoinLobbyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSJoinLobbyResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSJoinLobbyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSJoinLobbyResponse& from);
  void MergeFrom(const CMsgClientMMSJoinLobbyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientMMSJoinLobbyResponse_Member Member;

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional int32 chat_room_enter_response = 3;
  inline bool has_chat_room_enter_response() const;
  inline void clear_chat_room_enter_response();
  static const int kChatRoomEnterResponseFieldNumber = 3;
  inline ::google::protobuf::int32 chat_room_enter_response() const;
  inline void set_chat_room_enter_response(::google::protobuf::int32 value);

  // optional int32 max_members = 4;
  inline bool has_max_members() const;
  inline void clear_max_members();
  static const int kMaxMembersFieldNumber = 4;
  inline ::google::protobuf::int32 max_members() const;
  inline void set_max_members(::google::protobuf::int32 value);

  // optional int32 lobby_type = 5;
  inline bool has_lobby_type() const;
  inline void clear_lobby_type();
  static const int kLobbyTypeFieldNumber = 5;
  inline ::google::protobuf::int32 lobby_type() const;
  inline void set_lobby_type(::google::protobuf::int32 value);

  // optional int32 lobby_flags = 6;
  inline bool has_lobby_flags() const;
  inline void clear_lobby_flags();
  static const int kLobbyFlagsFieldNumber = 6;
  inline ::google::protobuf::int32 lobby_flags() const;
  inline void set_lobby_flags(::google::protobuf::int32 value);

  // optional fixed64 steam_id_owner = 7;
  inline bool has_steam_id_owner() const;
  inline void clear_steam_id_owner();
  static const int kSteamIdOwnerFieldNumber = 7;
  inline ::google::protobuf::uint64 steam_id_owner() const;
  inline void set_steam_id_owner(::google::protobuf::uint64 value);

  // optional bytes metadata = 8;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 8;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // repeated .Sc.CMsgClientMMSJoinLobbyResponse.Member members = 9;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 9;
  inline const ::Sc::CMsgClientMMSJoinLobbyResponse_Member& members(int index) const;
  inline ::Sc::CMsgClientMMSJoinLobbyResponse_Member* mutable_members(int index);
  inline ::Sc::CMsgClientMMSJoinLobbyResponse_Member* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSJoinLobbyResponse_Member >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSJoinLobbyResponse_Member >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSJoinLobbyResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_chat_room_enter_response();
  inline void clear_has_chat_room_enter_response();
  inline void set_has_max_members();
  inline void clear_has_max_members();
  inline void set_has_lobby_type();
  inline void clear_has_lobby_type();
  inline void set_has_lobby_flags();
  inline void clear_has_lobby_flags();
  inline void set_has_steam_id_owner();
  inline void clear_has_steam_id_owner();
  inline void set_has_metadata();
  inline void clear_has_metadata();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 chat_room_enter_response_;
  ::google::protobuf::int32 max_members_;
  ::google::protobuf::int32 lobby_type_;
  ::google::protobuf::uint64 steam_id_owner_;
  ::std::string* metadata_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSJoinLobbyResponse_Member > members_;
  ::google::protobuf::int32 lobby_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSJoinLobbyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSLeaveLobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSLeaveLobby();
  virtual ~CMsgClientMMSLeaveLobby();

  CMsgClientMMSLeaveLobby(const CMsgClientMMSLeaveLobby& from);

  inline CMsgClientMMSLeaveLobby& operator=(const CMsgClientMMSLeaveLobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSLeaveLobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSLeaveLobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSLeaveLobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSLeaveLobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSLeaveLobby& from);
  void MergeFrom(const CMsgClientMMSLeaveLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSLeaveLobby)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSLeaveLobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSLeaveLobbyResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSLeaveLobbyResponse();
  virtual ~CMsgClientMMSLeaveLobbyResponse();

  CMsgClientMMSLeaveLobbyResponse(const CMsgClientMMSLeaveLobbyResponse& from);

  inline CMsgClientMMSLeaveLobbyResponse& operator=(const CMsgClientMMSLeaveLobbyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSLeaveLobbyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSLeaveLobbyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSLeaveLobbyResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSLeaveLobbyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSLeaveLobbyResponse& from);
  void MergeFrom(const CMsgClientMMSLeaveLobbyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional int32 eresult = 3 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 3;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSLeaveLobbyResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSLeaveLobbyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSGetLobbyList_Filter : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSGetLobbyList_Filter();
  virtual ~CMsgClientMMSGetLobbyList_Filter();

  CMsgClientMMSGetLobbyList_Filter(const CMsgClientMMSGetLobbyList_Filter& from);

  inline CMsgClientMMSGetLobbyList_Filter& operator=(const CMsgClientMMSGetLobbyList_Filter& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSGetLobbyList_Filter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSGetLobbyList_Filter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSGetLobbyList_Filter* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSGetLobbyList_Filter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSGetLobbyList_Filter& from);
  void MergeFrom(const CMsgClientMMSGetLobbyList_Filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional int32 comparision = 3;
  inline bool has_comparision() const;
  inline void clear_comparision();
  static const int kComparisionFieldNumber = 3;
  inline ::google::protobuf::int32 comparision() const;
  inline void set_comparision(::google::protobuf::int32 value);

  // optional int32 filter_type = 4;
  inline bool has_filter_type() const;
  inline void clear_filter_type();
  static const int kFilterTypeFieldNumber = 4;
  inline ::google::protobuf::int32 filter_type() const;
  inline void set_filter_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSGetLobbyList.Filter)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_comparision();
  inline void clear_has_comparision();
  inline void set_has_filter_type();
  inline void clear_has_filter_type();

  ::std::string* key_;
  ::std::string* value_;
  ::google::protobuf::int32 comparision_;
  ::google::protobuf::int32 filter_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSGetLobbyList_Filter* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSGetLobbyList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSGetLobbyList();
  virtual ~CMsgClientMMSGetLobbyList();

  CMsgClientMMSGetLobbyList(const CMsgClientMMSGetLobbyList& from);

  inline CMsgClientMMSGetLobbyList& operator=(const CMsgClientMMSGetLobbyList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSGetLobbyList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSGetLobbyList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSGetLobbyList* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSGetLobbyList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSGetLobbyList& from);
  void MergeFrom(const CMsgClientMMSGetLobbyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientMMSGetLobbyList_Filter Filter;

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 num_lobbies_requested = 3;
  inline bool has_num_lobbies_requested() const;
  inline void clear_num_lobbies_requested();
  static const int kNumLobbiesRequestedFieldNumber = 3;
  inline ::google::protobuf::int32 num_lobbies_requested() const;
  inline void set_num_lobbies_requested(::google::protobuf::int32 value);

  // optional uint32 cell_id = 4;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 4;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional uint32 public_ip = 5;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 5;
  inline ::google::protobuf::uint32 public_ip() const;
  inline void set_public_ip(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientMMSGetLobbyList.Filter filters = 6;
  inline int filters_size() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 6;
  inline const ::Sc::CMsgClientMMSGetLobbyList_Filter& filters(int index) const;
  inline ::Sc::CMsgClientMMSGetLobbyList_Filter* mutable_filters(int index);
  inline ::Sc::CMsgClientMMSGetLobbyList_Filter* add_filters();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyList_Filter >&
      filters() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyList_Filter >*
      mutable_filters();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSGetLobbyList)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_num_lobbies_requested();
  inline void clear_has_num_lobbies_requested();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 num_lobbies_requested_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::uint32 public_ip_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyList_Filter > filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSGetLobbyList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSGetLobbyListResponse_Lobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSGetLobbyListResponse_Lobby();
  virtual ~CMsgClientMMSGetLobbyListResponse_Lobby();

  CMsgClientMMSGetLobbyListResponse_Lobby(const CMsgClientMMSGetLobbyListResponse_Lobby& from);

  inline CMsgClientMMSGetLobbyListResponse_Lobby& operator=(const CMsgClientMMSGetLobbyListResponse_Lobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSGetLobbyListResponse_Lobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSGetLobbyListResponse_Lobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSGetLobbyListResponse_Lobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSGetLobbyListResponse_Lobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSGetLobbyListResponse_Lobby& from);
  void MergeFrom(const CMsgClientMMSGetLobbyListResponse_Lobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional int32 max_members = 2;
  inline bool has_max_members() const;
  inline void clear_max_members();
  static const int kMaxMembersFieldNumber = 2;
  inline ::google::protobuf::int32 max_members() const;
  inline void set_max_members(::google::protobuf::int32 value);

  // optional int32 lobby_type = 3;
  inline bool has_lobby_type() const;
  inline void clear_lobby_type();
  static const int kLobbyTypeFieldNumber = 3;
  inline ::google::protobuf::int32 lobby_type() const;
  inline void set_lobby_type(::google::protobuf::int32 value);

  // optional int32 lobby_flags = 4;
  inline bool has_lobby_flags() const;
  inline void clear_lobby_flags();
  static const int kLobbyFlagsFieldNumber = 4;
  inline ::google::protobuf::int32 lobby_flags() const;
  inline void set_lobby_flags(::google::protobuf::int32 value);

  // optional bytes metadata = 5;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 5;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // optional int32 num_members = 6;
  inline bool has_num_members() const;
  inline void clear_num_members();
  static const int kNumMembersFieldNumber = 6;
  inline ::google::protobuf::int32 num_members() const;
  inline void set_num_members(::google::protobuf::int32 value);

  // optional float distance = 7;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 7;
  inline float distance() const;
  inline void set_distance(float value);

  // optional int64 weight = 8;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 8;
  inline ::google::protobuf::int64 weight() const;
  inline void set_weight(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSGetLobbyListResponse.Lobby)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_max_members();
  inline void clear_has_max_members();
  inline void set_has_lobby_type();
  inline void clear_has_lobby_type();
  inline void set_has_lobby_flags();
  inline void clear_has_lobby_flags();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_num_members();
  inline void clear_has_num_members();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_weight();
  inline void clear_has_weight();

  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::int32 max_members_;
  ::google::protobuf::int32 lobby_type_;
  ::std::string* metadata_;
  ::google::protobuf::int32 lobby_flags_;
  ::google::protobuf::int32 num_members_;
  ::google::protobuf::int64 weight_;
  float distance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSGetLobbyListResponse_Lobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSGetLobbyListResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSGetLobbyListResponse();
  virtual ~CMsgClientMMSGetLobbyListResponse();

  CMsgClientMMSGetLobbyListResponse(const CMsgClientMMSGetLobbyListResponse& from);

  inline CMsgClientMMSGetLobbyListResponse& operator=(const CMsgClientMMSGetLobbyListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSGetLobbyListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSGetLobbyListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSGetLobbyListResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSGetLobbyListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSGetLobbyListResponse& from);
  void MergeFrom(const CMsgClientMMSGetLobbyListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientMMSGetLobbyListResponse_Lobby Lobby;

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 eresult = 3 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 3;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientMMSGetLobbyListResponse.Lobby lobbies = 4;
  inline int lobbies_size() const;
  inline void clear_lobbies();
  static const int kLobbiesFieldNumber = 4;
  inline const ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby& lobbies(int index) const;
  inline ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby* mutable_lobbies(int index);
  inline ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby* add_lobbies();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby >&
      lobbies() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby >*
      mutable_lobbies();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSGetLobbyListResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby > lobbies_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSGetLobbyListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSetLobbyData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSetLobbyData();
  virtual ~CMsgClientMMSSetLobbyData();

  CMsgClientMMSSetLobbyData(const CMsgClientMMSSetLobbyData& from);

  inline CMsgClientMMSSetLobbyData& operator=(const CMsgClientMMSSetLobbyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSetLobbyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSetLobbyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSetLobbyData* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSetLobbyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSetLobbyData& from);
  void MergeFrom(const CMsgClientMMSSetLobbyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_member = 3;
  inline bool has_steam_id_member() const;
  inline void clear_steam_id_member();
  static const int kSteamIdMemberFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_member() const;
  inline void set_steam_id_member(::google::protobuf::uint64 value);

  // optional int32 max_members = 4;
  inline bool has_max_members() const;
  inline void clear_max_members();
  static const int kMaxMembersFieldNumber = 4;
  inline ::google::protobuf::int32 max_members() const;
  inline void set_max_members(::google::protobuf::int32 value);

  // optional int32 lobby_type = 5;
  inline bool has_lobby_type() const;
  inline void clear_lobby_type();
  static const int kLobbyTypeFieldNumber = 5;
  inline ::google::protobuf::int32 lobby_type() const;
  inline void set_lobby_type(::google::protobuf::int32 value);

  // optional int32 lobby_flags = 6;
  inline bool has_lobby_flags() const;
  inline void clear_lobby_flags();
  static const int kLobbyFlagsFieldNumber = 6;
  inline ::google::protobuf::int32 lobby_flags() const;
  inline void set_lobby_flags(::google::protobuf::int32 value);

  // optional bytes metadata = 7;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 7;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSetLobbyData)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_member();
  inline void clear_has_steam_id_member();
  inline void set_has_max_members();
  inline void clear_has_max_members();
  inline void set_has_lobby_type();
  inline void clear_has_lobby_type();
  inline void set_has_lobby_flags();
  inline void clear_has_lobby_flags();
  inline void set_has_metadata();
  inline void clear_has_metadata();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 max_members_;
  ::google::protobuf::uint64 steam_id_member_;
  ::google::protobuf::int32 lobby_type_;
  ::google::protobuf::int32 lobby_flags_;
  ::std::string* metadata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSetLobbyData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSetLobbyDataResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSetLobbyDataResponse();
  virtual ~CMsgClientMMSSetLobbyDataResponse();

  CMsgClientMMSSetLobbyDataResponse(const CMsgClientMMSSetLobbyDataResponse& from);

  inline CMsgClientMMSSetLobbyDataResponse& operator=(const CMsgClientMMSSetLobbyDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSetLobbyDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSetLobbyDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSetLobbyDataResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSetLobbyDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSetLobbyDataResponse& from);
  void MergeFrom(const CMsgClientMMSSetLobbyDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional int32 eresult = 3 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 3;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSetLobbyDataResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSetLobbyDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSGetLobbyData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSGetLobbyData();
  virtual ~CMsgClientMMSGetLobbyData();

  CMsgClientMMSGetLobbyData(const CMsgClientMMSGetLobbyData& from);

  inline CMsgClientMMSGetLobbyData& operator=(const CMsgClientMMSGetLobbyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSGetLobbyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSGetLobbyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSGetLobbyData* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSGetLobbyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSGetLobbyData& from);
  void MergeFrom(const CMsgClientMMSGetLobbyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSGetLobbyData)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSGetLobbyData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSLobbyData_Member : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSLobbyData_Member();
  virtual ~CMsgClientMMSLobbyData_Member();

  CMsgClientMMSLobbyData_Member(const CMsgClientMMSLobbyData_Member& from);

  inline CMsgClientMMSLobbyData_Member& operator=(const CMsgClientMMSLobbyData_Member& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSLobbyData_Member& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSLobbyData_Member* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSLobbyData_Member* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSLobbyData_Member* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSLobbyData_Member& from);
  void MergeFrom(const CMsgClientMMSLobbyData_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional string persona_name = 2;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 2;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // optional bytes metadata = 3;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSLobbyData.Member)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_persona_name();
  inline void clear_has_persona_name();
  inline void set_has_metadata();
  inline void clear_has_metadata();

  ::google::protobuf::uint64 steam_id_;
  ::std::string* persona_name_;
  ::std::string* metadata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSLobbyData_Member* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSLobbyData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSLobbyData();
  virtual ~CMsgClientMMSLobbyData();

  CMsgClientMMSLobbyData(const CMsgClientMMSLobbyData& from);

  inline CMsgClientMMSLobbyData& operator=(const CMsgClientMMSLobbyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSLobbyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSLobbyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSLobbyData* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSLobbyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSLobbyData& from);
  void MergeFrom(const CMsgClientMMSLobbyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientMMSLobbyData_Member Member;

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional int32 num_members = 3;
  inline bool has_num_members() const;
  inline void clear_num_members();
  static const int kNumMembersFieldNumber = 3;
  inline ::google::protobuf::int32 num_members() const;
  inline void set_num_members(::google::protobuf::int32 value);

  // optional int32 max_members = 4;
  inline bool has_max_members() const;
  inline void clear_max_members();
  static const int kMaxMembersFieldNumber = 4;
  inline ::google::protobuf::int32 max_members() const;
  inline void set_max_members(::google::protobuf::int32 value);

  // optional int32 lobby_type = 5;
  inline bool has_lobby_type() const;
  inline void clear_lobby_type();
  static const int kLobbyTypeFieldNumber = 5;
  inline ::google::protobuf::int32 lobby_type() const;
  inline void set_lobby_type(::google::protobuf::int32 value);

  // optional int32 lobby_flags = 6;
  inline bool has_lobby_flags() const;
  inline void clear_lobby_flags();
  static const int kLobbyFlagsFieldNumber = 6;
  inline ::google::protobuf::int32 lobby_flags() const;
  inline void set_lobby_flags(::google::protobuf::int32 value);

  // optional fixed64 steam_id_owner = 7;
  inline bool has_steam_id_owner() const;
  inline void clear_steam_id_owner();
  static const int kSteamIdOwnerFieldNumber = 7;
  inline ::google::protobuf::uint64 steam_id_owner() const;
  inline void set_steam_id_owner(::google::protobuf::uint64 value);

  // optional bytes metadata = 8;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 8;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // repeated .Sc.CMsgClientMMSLobbyData.Member members = 9;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 9;
  inline const ::Sc::CMsgClientMMSLobbyData_Member& members(int index) const;
  inline ::Sc::CMsgClientMMSLobbyData_Member* mutable_members(int index);
  inline ::Sc::CMsgClientMMSLobbyData_Member* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSLobbyData_Member >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSLobbyData_Member >*
      mutable_members();

  // optional uint32 lobby_cellid = 10;
  inline bool has_lobby_cellid() const;
  inline void clear_lobby_cellid();
  static const int kLobbyCellidFieldNumber = 10;
  inline ::google::protobuf::uint32 lobby_cellid() const;
  inline void set_lobby_cellid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSLobbyData)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_num_members();
  inline void clear_has_num_members();
  inline void set_has_max_members();
  inline void clear_has_max_members();
  inline void set_has_lobby_type();
  inline void clear_has_lobby_type();
  inline void set_has_lobby_flags();
  inline void clear_has_lobby_flags();
  inline void set_has_steam_id_owner();
  inline void clear_has_steam_id_owner();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_lobby_cellid();
  inline void clear_has_lobby_cellid();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 num_members_;
  ::google::protobuf::int32 max_members_;
  ::google::protobuf::int32 lobby_type_;
  ::google::protobuf::uint64 steam_id_owner_;
  ::std::string* metadata_;
  ::google::protobuf::int32 lobby_flags_;
  ::google::protobuf::uint32 lobby_cellid_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSLobbyData_Member > members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSLobbyData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSendLobbyChatMsg : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSendLobbyChatMsg();
  virtual ~CMsgClientMMSSendLobbyChatMsg();

  CMsgClientMMSSendLobbyChatMsg(const CMsgClientMMSSendLobbyChatMsg& from);

  inline CMsgClientMMSSendLobbyChatMsg& operator=(const CMsgClientMMSSendLobbyChatMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSendLobbyChatMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSendLobbyChatMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSendLobbyChatMsg* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSendLobbyChatMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSendLobbyChatMsg& from);
  void MergeFrom(const CMsgClientMMSSendLobbyChatMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_target = 3;
  inline bool has_steam_id_target() const;
  inline void clear_steam_id_target();
  static const int kSteamIdTargetFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_target() const;
  inline void set_steam_id_target(::google::protobuf::uint64 value);

  // optional bytes lobby_message = 4;
  inline bool has_lobby_message() const;
  inline void clear_lobby_message();
  static const int kLobbyMessageFieldNumber = 4;
  inline const ::std::string& lobby_message() const;
  inline void set_lobby_message(const ::std::string& value);
  inline void set_lobby_message(const char* value);
  inline void set_lobby_message(const void* value, size_t size);
  inline ::std::string* mutable_lobby_message();
  inline ::std::string* release_lobby_message();
  inline void set_allocated_lobby_message(::std::string* lobby_message);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSendLobbyChatMsg)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_target();
  inline void clear_has_steam_id_target();
  inline void set_has_lobby_message();
  inline void clear_has_lobby_message();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_target_;
  ::std::string* lobby_message_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSendLobbyChatMsg* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSLobbyChatMsg : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSLobbyChatMsg();
  virtual ~CMsgClientMMSLobbyChatMsg();

  CMsgClientMMSLobbyChatMsg(const CMsgClientMMSLobbyChatMsg& from);

  inline CMsgClientMMSLobbyChatMsg& operator=(const CMsgClientMMSLobbyChatMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSLobbyChatMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSLobbyChatMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSLobbyChatMsg* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSLobbyChatMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSLobbyChatMsg& from);
  void MergeFrom(const CMsgClientMMSLobbyChatMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_sender = 3;
  inline bool has_steam_id_sender() const;
  inline void clear_steam_id_sender();
  static const int kSteamIdSenderFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_sender() const;
  inline void set_steam_id_sender(::google::protobuf::uint64 value);

  // optional bytes lobby_message = 4;
  inline bool has_lobby_message() const;
  inline void clear_lobby_message();
  static const int kLobbyMessageFieldNumber = 4;
  inline const ::std::string& lobby_message() const;
  inline void set_lobby_message(const ::std::string& value);
  inline void set_lobby_message(const char* value);
  inline void set_lobby_message(const void* value, size_t size);
  inline ::std::string* mutable_lobby_message();
  inline ::std::string* release_lobby_message();
  inline void set_allocated_lobby_message(::std::string* lobby_message);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSLobbyChatMsg)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_sender();
  inline void clear_has_steam_id_sender();
  inline void set_has_lobby_message();
  inline void clear_has_lobby_message();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_sender_;
  ::std::string* lobby_message_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSLobbyChatMsg* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSetLobbyOwner : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSetLobbyOwner();
  virtual ~CMsgClientMMSSetLobbyOwner();

  CMsgClientMMSSetLobbyOwner(const CMsgClientMMSSetLobbyOwner& from);

  inline CMsgClientMMSSetLobbyOwner& operator=(const CMsgClientMMSSetLobbyOwner& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSetLobbyOwner& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSetLobbyOwner* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSetLobbyOwner* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSetLobbyOwner* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSetLobbyOwner& from);
  void MergeFrom(const CMsgClientMMSSetLobbyOwner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_new_owner = 3;
  inline bool has_steam_id_new_owner() const;
  inline void clear_steam_id_new_owner();
  static const int kSteamIdNewOwnerFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_new_owner() const;
  inline void set_steam_id_new_owner(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSetLobbyOwner)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_new_owner();
  inline void clear_has_steam_id_new_owner();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_new_owner_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSetLobbyOwner* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSetLobbyOwnerResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSetLobbyOwnerResponse();
  virtual ~CMsgClientMMSSetLobbyOwnerResponse();

  CMsgClientMMSSetLobbyOwnerResponse(const CMsgClientMMSSetLobbyOwnerResponse& from);

  inline CMsgClientMMSSetLobbyOwnerResponse& operator=(const CMsgClientMMSSetLobbyOwnerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSetLobbyOwnerResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSetLobbyOwnerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSetLobbyOwnerResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSetLobbyOwnerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSetLobbyOwnerResponse& from);
  void MergeFrom(const CMsgClientMMSSetLobbyOwnerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional int32 eresult = 3 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 3;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSetLobbyOwnerResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSetLobbyOwnerResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSetLobbyLinked : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSetLobbyLinked();
  virtual ~CMsgClientMMSSetLobbyLinked();

  CMsgClientMMSSetLobbyLinked(const CMsgClientMMSSetLobbyLinked& from);

  inline CMsgClientMMSSetLobbyLinked& operator=(const CMsgClientMMSSetLobbyLinked& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSetLobbyLinked& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSetLobbyLinked* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSetLobbyLinked* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSetLobbyLinked* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSetLobbyLinked& from);
  void MergeFrom(const CMsgClientMMSSetLobbyLinked& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_lobby2 = 3;
  inline bool has_steam_id_lobby2() const;
  inline void clear_steam_id_lobby2();
  static const int kSteamIdLobby2FieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_lobby2() const;
  inline void set_steam_id_lobby2(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSetLobbyLinked)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_lobby2();
  inline void clear_has_steam_id_lobby2();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_lobby2_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSetLobbyLinked* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSSetLobbyGameServer : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSSetLobbyGameServer();
  virtual ~CMsgClientMMSSetLobbyGameServer();

  CMsgClientMMSSetLobbyGameServer(const CMsgClientMMSSetLobbyGameServer& from);

  inline CMsgClientMMSSetLobbyGameServer& operator=(const CMsgClientMMSSetLobbyGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSSetLobbyGameServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSSetLobbyGameServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSSetLobbyGameServer* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSSetLobbyGameServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSSetLobbyGameServer& from);
  void MergeFrom(const CMsgClientMMSSetLobbyGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional uint32 game_server_ip = 3;
  inline bool has_game_server_ip() const;
  inline void clear_game_server_ip();
  static const int kGameServerIpFieldNumber = 3;
  inline ::google::protobuf::uint32 game_server_ip() const;
  inline void set_game_server_ip(::google::protobuf::uint32 value);

  // optional uint32 game_server_port = 4;
  inline bool has_game_server_port() const;
  inline void clear_game_server_port();
  static const int kGameServerPortFieldNumber = 4;
  inline ::google::protobuf::uint32 game_server_port() const;
  inline void set_game_server_port(::google::protobuf::uint32 value);

  // optional fixed64 game_server_steam_id = 5;
  inline bool has_game_server_steam_id() const;
  inline void clear_game_server_steam_id();
  static const int kGameServerSteamIdFieldNumber = 5;
  inline ::google::protobuf::uint64 game_server_steam_id() const;
  inline void set_game_server_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSSetLobbyGameServer)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_game_server_ip();
  inline void clear_has_game_server_ip();
  inline void set_has_game_server_port();
  inline void clear_has_game_server_port();
  inline void set_has_game_server_steam_id();
  inline void clear_has_game_server_steam_id();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 game_server_ip_;
  ::google::protobuf::uint64 game_server_steam_id_;
  ::google::protobuf::uint32 game_server_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSSetLobbyGameServer* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSLobbyGameServerSet : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSLobbyGameServerSet();
  virtual ~CMsgClientMMSLobbyGameServerSet();

  CMsgClientMMSLobbyGameServerSet(const CMsgClientMMSLobbyGameServerSet& from);

  inline CMsgClientMMSLobbyGameServerSet& operator=(const CMsgClientMMSLobbyGameServerSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSLobbyGameServerSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSLobbyGameServerSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSLobbyGameServerSet* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSLobbyGameServerSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSLobbyGameServerSet& from);
  void MergeFrom(const CMsgClientMMSLobbyGameServerSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional uint32 game_server_ip = 3;
  inline bool has_game_server_ip() const;
  inline void clear_game_server_ip();
  static const int kGameServerIpFieldNumber = 3;
  inline ::google::protobuf::uint32 game_server_ip() const;
  inline void set_game_server_ip(::google::protobuf::uint32 value);

  // optional uint32 game_server_port = 4;
  inline bool has_game_server_port() const;
  inline void clear_game_server_port();
  static const int kGameServerPortFieldNumber = 4;
  inline ::google::protobuf::uint32 game_server_port() const;
  inline void set_game_server_port(::google::protobuf::uint32 value);

  // optional fixed64 game_server_steam_id = 5;
  inline bool has_game_server_steam_id() const;
  inline void clear_game_server_steam_id();
  static const int kGameServerSteamIdFieldNumber = 5;
  inline ::google::protobuf::uint64 game_server_steam_id() const;
  inline void set_game_server_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSLobbyGameServerSet)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_game_server_ip();
  inline void clear_has_game_server_ip();
  inline void set_has_game_server_port();
  inline void clear_has_game_server_port();
  inline void set_has_game_server_steam_id();
  inline void clear_has_game_server_steam_id();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 game_server_ip_;
  ::google::protobuf::uint64 game_server_steam_id_;
  ::google::protobuf::uint32 game_server_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSLobbyGameServerSet* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSUserJoinedLobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSUserJoinedLobby();
  virtual ~CMsgClientMMSUserJoinedLobby();

  CMsgClientMMSUserJoinedLobby(const CMsgClientMMSUserJoinedLobby& from);

  inline CMsgClientMMSUserJoinedLobby& operator=(const CMsgClientMMSUserJoinedLobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSUserJoinedLobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSUserJoinedLobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSUserJoinedLobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSUserJoinedLobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSUserJoinedLobby& from);
  void MergeFrom(const CMsgClientMMSUserJoinedLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_user = 3;
  inline bool has_steam_id_user() const;
  inline void clear_steam_id_user();
  static const int kSteamIdUserFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_user() const;
  inline void set_steam_id_user(::google::protobuf::uint64 value);

  // optional string persona_name = 4;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 4;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSUserJoinedLobby)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_user();
  inline void clear_has_steam_id_user();
  inline void set_has_persona_name();
  inline void clear_has_persona_name();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_user_;
  ::std::string* persona_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSUserJoinedLobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSUserLeftLobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSUserLeftLobby();
  virtual ~CMsgClientMMSUserLeftLobby();

  CMsgClientMMSUserLeftLobby(const CMsgClientMMSUserLeftLobby& from);

  inline CMsgClientMMSUserLeftLobby& operator=(const CMsgClientMMSUserLeftLobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSUserLeftLobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSUserLeftLobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSUserLeftLobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSUserLeftLobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSUserLeftLobby& from);
  void MergeFrom(const CMsgClientMMSUserLeftLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_user = 3;
  inline bool has_steam_id_user() const;
  inline void clear_steam_id_user();
  static const int kSteamIdUserFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_user() const;
  inline void set_steam_id_user(::google::protobuf::uint64 value);

  // optional string persona_name = 4;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 4;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSUserLeftLobby)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_user();
  inline void clear_has_steam_id_user();
  inline void set_has_persona_name();
  inline void clear_has_persona_name();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_user_;
  ::std::string* persona_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSUserLeftLobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMMSInviteToLobby : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMMSInviteToLobby();
  virtual ~CMsgClientMMSInviteToLobby();

  CMsgClientMMSInviteToLobby(const CMsgClientMMSInviteToLobby& from);

  inline CMsgClientMMSInviteToLobby& operator=(const CMsgClientMMSInviteToLobby& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMMSInviteToLobby& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMMSInviteToLobby* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMMSInviteToLobby* other);

  // implements Message ----------------------------------------------

  CMsgClientMMSInviteToLobby* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMMSInviteToLobby& from);
  void MergeFrom(const CMsgClientMMSInviteToLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 steam_id_lobby = 2;
  inline bool has_steam_id_lobby() const;
  inline void clear_steam_id_lobby();
  static const int kSteamIdLobbyFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_lobby() const;
  inline void set_steam_id_lobby(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_user_invited = 3;
  inline bool has_steam_id_user_invited() const;
  inline void clear_steam_id_user_invited();
  static const int kSteamIdUserInvitedFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_user_invited() const;
  inline void set_steam_id_user_invited(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMMSInviteToLobby)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_steam_id_lobby();
  inline void clear_has_steam_id_lobby();
  inline void set_has_steam_id_user_invited();
  inline void clear_has_steam_id_user_invited();

  ::google::protobuf::uint64 steam_id_lobby_;
  ::google::protobuf::uint64 steam_id_user_invited_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMMSInviteToLobby* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUDSInviteToGame : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUDSInviteToGame();
  virtual ~CMsgClientUDSInviteToGame();

  CMsgClientUDSInviteToGame(const CMsgClientUDSInviteToGame& from);

  inline CMsgClientUDSInviteToGame& operator=(const CMsgClientUDSInviteToGame& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUDSInviteToGame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUDSInviteToGame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUDSInviteToGame* other);

  // implements Message ----------------------------------------------

  CMsgClientUDSInviteToGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUDSInviteToGame& from);
  void MergeFrom(const CMsgClientUDSInviteToGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_dest = 1;
  inline bool has_steam_id_dest() const;
  inline void clear_steam_id_dest();
  static const int kSteamIdDestFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_dest() const;
  inline void set_steam_id_dest(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_src = 2;
  inline bool has_steam_id_src() const;
  inline void clear_steam_id_src();
  static const int kSteamIdSrcFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_src() const;
  inline void set_steam_id_src(::google::protobuf::uint64 value);

  // optional string connect_string = 3;
  inline bool has_connect_string() const;
  inline void clear_connect_string();
  static const int kConnectStringFieldNumber = 3;
  inline const ::std::string& connect_string() const;
  inline void set_connect_string(const ::std::string& value);
  inline void set_connect_string(const char* value);
  inline void set_connect_string(const char* value, size_t size);
  inline ::std::string* mutable_connect_string();
  inline ::std::string* release_connect_string();
  inline void set_allocated_connect_string(::std::string* connect_string);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUDSInviteToGame)
 private:
  inline void set_has_steam_id_dest();
  inline void clear_has_steam_id_dest();
  inline void set_has_steam_id_src();
  inline void clear_has_steam_id_src();
  inline void set_has_connect_string();
  inline void clear_has_connect_string();

  ::google::protobuf::uint64 steam_id_dest_;
  ::google::protobuf::uint64 steam_id_src_;
  ::std::string* connect_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUDSInviteToGame* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientChatInvite : public ::google::protobuf::MessageLite {
 public:
  CMsgClientChatInvite();
  virtual ~CMsgClientChatInvite();

  CMsgClientChatInvite(const CMsgClientChatInvite& from);

  inline CMsgClientChatInvite& operator=(const CMsgClientChatInvite& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientChatInvite& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientChatInvite* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientChatInvite* other);

  // implements Message ----------------------------------------------

  CMsgClientChatInvite* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientChatInvite& from);
  void MergeFrom(const CMsgClientChatInvite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_invited = 1;
  inline bool has_steam_id_invited() const;
  inline void clear_steam_id_invited();
  static const int kSteamIdInvitedFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_invited() const;
  inline void set_steam_id_invited(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_chat = 2;
  inline bool has_steam_id_chat() const;
  inline void clear_steam_id_chat();
  static const int kSteamIdChatFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_chat() const;
  inline void set_steam_id_chat(::google::protobuf::uint64 value);

  // optional fixed64 steam_id_patron = 3;
  inline bool has_steam_id_patron() const;
  inline void clear_steam_id_patron();
  static const int kSteamIdPatronFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_id_patron() const;
  inline void set_steam_id_patron(::google::protobuf::uint64 value);

  // optional int32 chatroom_type = 4;
  inline bool has_chatroom_type() const;
  inline void clear_chatroom_type();
  static const int kChatroomTypeFieldNumber = 4;
  inline ::google::protobuf::int32 chatroom_type() const;
  inline void set_chatroom_type(::google::protobuf::int32 value);

  // optional fixed64 steam_id_friend_chat = 5;
  inline bool has_steam_id_friend_chat() const;
  inline void clear_steam_id_friend_chat();
  static const int kSteamIdFriendChatFieldNumber = 5;
  inline ::google::protobuf::uint64 steam_id_friend_chat() const;
  inline void set_steam_id_friend_chat(::google::protobuf::uint64 value);

  // optional string chat_name = 6;
  inline bool has_chat_name() const;
  inline void clear_chat_name();
  static const int kChatNameFieldNumber = 6;
  inline const ::std::string& chat_name() const;
  inline void set_chat_name(const ::std::string& value);
  inline void set_chat_name(const char* value);
  inline void set_chat_name(const char* value, size_t size);
  inline ::std::string* mutable_chat_name();
  inline ::std::string* release_chat_name();
  inline void set_allocated_chat_name(::std::string* chat_name);

  // optional fixed64 game_id = 7;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 7;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientChatInvite)
 private:
  inline void set_has_steam_id_invited();
  inline void clear_has_steam_id_invited();
  inline void set_has_steam_id_chat();
  inline void clear_has_steam_id_chat();
  inline void set_has_steam_id_patron();
  inline void clear_has_steam_id_patron();
  inline void set_has_chatroom_type();
  inline void clear_has_chatroom_type();
  inline void set_has_steam_id_friend_chat();
  inline void clear_has_steam_id_friend_chat();
  inline void set_has_chat_name();
  inline void clear_has_chat_name();
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::uint64 steam_id_invited_;
  ::google::protobuf::uint64 steam_id_chat_;
  ::google::protobuf::uint64 steam_id_patron_;
  ::google::protobuf::uint64 steam_id_friend_chat_;
  ::std::string* chat_name_;
  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::int32 chatroom_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientChatInvite* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientConnectionStats_Stats_Logon : public ::google::protobuf::MessageLite {
 public:
  CMsgClientConnectionStats_Stats_Logon();
  virtual ~CMsgClientConnectionStats_Stats_Logon();

  CMsgClientConnectionStats_Stats_Logon(const CMsgClientConnectionStats_Stats_Logon& from);

  inline CMsgClientConnectionStats_Stats_Logon& operator=(const CMsgClientConnectionStats_Stats_Logon& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientConnectionStats_Stats_Logon& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientConnectionStats_Stats_Logon* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientConnectionStats_Stats_Logon* other);

  // implements Message ----------------------------------------------

  CMsgClientConnectionStats_Stats_Logon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientConnectionStats_Stats_Logon& from);
  void MergeFrom(const CMsgClientConnectionStats_Stats_Logon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 connect_attempts = 1;
  inline bool has_connect_attempts() const;
  inline void clear_connect_attempts();
  static const int kConnectAttemptsFieldNumber = 1;
  inline ::google::protobuf::int32 connect_attempts() const;
  inline void set_connect_attempts(::google::protobuf::int32 value);

  // optional int32 connect_successes = 2;
  inline bool has_connect_successes() const;
  inline void clear_connect_successes();
  static const int kConnectSuccessesFieldNumber = 2;
  inline ::google::protobuf::int32 connect_successes() const;
  inline void set_connect_successes(::google::protobuf::int32 value);

  // optional int32 connect_failures = 3;
  inline bool has_connect_failures() const;
  inline void clear_connect_failures();
  static const int kConnectFailuresFieldNumber = 3;
  inline ::google::protobuf::int32 connect_failures() const;
  inline void set_connect_failures(::google::protobuf::int32 value);

  // optional int32 connections_dropped = 4;
  inline bool has_connections_dropped() const;
  inline void clear_connections_dropped();
  static const int kConnectionsDroppedFieldNumber = 4;
  inline ::google::protobuf::int32 connections_dropped() const;
  inline void set_connections_dropped(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientConnectionStats.Stats_Logon)
 private:
  inline void set_has_connect_attempts();
  inline void clear_has_connect_attempts();
  inline void set_has_connect_successes();
  inline void clear_has_connect_successes();
  inline void set_has_connect_failures();
  inline void clear_has_connect_failures();
  inline void set_has_connections_dropped();
  inline void clear_has_connections_dropped();

  ::google::protobuf::int32 connect_attempts_;
  ::google::protobuf::int32 connect_successes_;
  ::google::protobuf::int32 connect_failures_;
  ::google::protobuf::int32 connections_dropped_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientConnectionStats_Stats_Logon* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientConnectionStats_Stats_UDP : public ::google::protobuf::MessageLite {
 public:
  CMsgClientConnectionStats_Stats_UDP();
  virtual ~CMsgClientConnectionStats_Stats_UDP();

  CMsgClientConnectionStats_Stats_UDP(const CMsgClientConnectionStats_Stats_UDP& from);

  inline CMsgClientConnectionStats_Stats_UDP& operator=(const CMsgClientConnectionStats_Stats_UDP& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientConnectionStats_Stats_UDP& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientConnectionStats_Stats_UDP* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientConnectionStats_Stats_UDP* other);

  // implements Message ----------------------------------------------

  CMsgClientConnectionStats_Stats_UDP* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientConnectionStats_Stats_UDP& from);
  void MergeFrom(const CMsgClientConnectionStats_Stats_UDP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 pkts_sent = 1;
  inline bool has_pkts_sent() const;
  inline void clear_pkts_sent();
  static const int kPktsSentFieldNumber = 1;
  inline ::google::protobuf::uint64 pkts_sent() const;
  inline void set_pkts_sent(::google::protobuf::uint64 value);

  // optional uint64 bytes_sent = 2;
  inline bool has_bytes_sent() const;
  inline void clear_bytes_sent();
  static const int kBytesSentFieldNumber = 2;
  inline ::google::protobuf::uint64 bytes_sent() const;
  inline void set_bytes_sent(::google::protobuf::uint64 value);

  // optional uint64 pkts_recv = 3;
  inline bool has_pkts_recv() const;
  inline void clear_pkts_recv();
  static const int kPktsRecvFieldNumber = 3;
  inline ::google::protobuf::uint64 pkts_recv() const;
  inline void set_pkts_recv(::google::protobuf::uint64 value);

  // optional uint64 pkts_processed = 4;
  inline bool has_pkts_processed() const;
  inline void clear_pkts_processed();
  static const int kPktsProcessedFieldNumber = 4;
  inline ::google::protobuf::uint64 pkts_processed() const;
  inline void set_pkts_processed(::google::protobuf::uint64 value);

  // optional uint64 bytes_recv = 5;
  inline bool has_bytes_recv() const;
  inline void clear_bytes_recv();
  static const int kBytesRecvFieldNumber = 5;
  inline ::google::protobuf::uint64 bytes_recv() const;
  inline void set_bytes_recv(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientConnectionStats.Stats_UDP)
 private:
  inline void set_has_pkts_sent();
  inline void clear_has_pkts_sent();
  inline void set_has_bytes_sent();
  inline void clear_has_bytes_sent();
  inline void set_has_pkts_recv();
  inline void clear_has_pkts_recv();
  inline void set_has_pkts_processed();
  inline void clear_has_pkts_processed();
  inline void set_has_bytes_recv();
  inline void clear_has_bytes_recv();

  ::google::protobuf::uint64 pkts_sent_;
  ::google::protobuf::uint64 bytes_sent_;
  ::google::protobuf::uint64 pkts_recv_;
  ::google::protobuf::uint64 pkts_processed_;
  ::google::protobuf::uint64 bytes_recv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientConnectionStats_Stats_UDP* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientConnectionStats_Stats_VConn : public ::google::protobuf::MessageLite {
 public:
  CMsgClientConnectionStats_Stats_VConn();
  virtual ~CMsgClientConnectionStats_Stats_VConn();

  CMsgClientConnectionStats_Stats_VConn(const CMsgClientConnectionStats_Stats_VConn& from);

  inline CMsgClientConnectionStats_Stats_VConn& operator=(const CMsgClientConnectionStats_Stats_VConn& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientConnectionStats_Stats_VConn& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientConnectionStats_Stats_VConn* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientConnectionStats_Stats_VConn* other);

  // implements Message ----------------------------------------------

  CMsgClientConnectionStats_Stats_VConn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientConnectionStats_Stats_VConn& from);
  void MergeFrom(const CMsgClientConnectionStats_Stats_VConn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 connections_udp = 1;
  inline bool has_connections_udp() const;
  inline void clear_connections_udp();
  static const int kConnectionsUdpFieldNumber = 1;
  inline ::google::protobuf::uint32 connections_udp() const;
  inline void set_connections_udp(::google::protobuf::uint32 value);

  // optional uint32 connections_tcp = 2;
  inline bool has_connections_tcp() const;
  inline void clear_connections_tcp();
  static const int kConnectionsTcpFieldNumber = 2;
  inline ::google::protobuf::uint32 connections_tcp() const;
  inline void set_connections_tcp(::google::protobuf::uint32 value);

  // optional .Sc.CMsgClientConnectionStats.Stats_UDP stats_udp = 3;
  inline bool has_stats_udp() const;
  inline void clear_stats_udp();
  static const int kStatsUdpFieldNumber = 3;
  inline const ::Sc::CMsgClientConnectionStats_Stats_UDP& stats_udp() const;
  inline ::Sc::CMsgClientConnectionStats_Stats_UDP* mutable_stats_udp();
  inline ::Sc::CMsgClientConnectionStats_Stats_UDP* release_stats_udp();
  inline void set_allocated_stats_udp(::Sc::CMsgClientConnectionStats_Stats_UDP* stats_udp);

  // optional uint64 pkts_abandoned = 4;
  inline bool has_pkts_abandoned() const;
  inline void clear_pkts_abandoned();
  static const int kPktsAbandonedFieldNumber = 4;
  inline ::google::protobuf::uint64 pkts_abandoned() const;
  inline void set_pkts_abandoned(::google::protobuf::uint64 value);

  // optional uint64 conn_req_received = 5;
  inline bool has_conn_req_received() const;
  inline void clear_conn_req_received();
  static const int kConnReqReceivedFieldNumber = 5;
  inline ::google::protobuf::uint64 conn_req_received() const;
  inline void set_conn_req_received(::google::protobuf::uint64 value);

  // optional uint64 pkts_resent = 6;
  inline bool has_pkts_resent() const;
  inline void clear_pkts_resent();
  static const int kPktsResentFieldNumber = 6;
  inline ::google::protobuf::uint64 pkts_resent() const;
  inline void set_pkts_resent(::google::protobuf::uint64 value);

  // optional uint64 msgs_sent = 7;
  inline bool has_msgs_sent() const;
  inline void clear_msgs_sent();
  static const int kMsgsSentFieldNumber = 7;
  inline ::google::protobuf::uint64 msgs_sent() const;
  inline void set_msgs_sent(::google::protobuf::uint64 value);

  // optional uint64 msgs_sent_failed = 8;
  inline bool has_msgs_sent_failed() const;
  inline void clear_msgs_sent_failed();
  static const int kMsgsSentFailedFieldNumber = 8;
  inline ::google::protobuf::uint64 msgs_sent_failed() const;
  inline void set_msgs_sent_failed(::google::protobuf::uint64 value);

  // optional uint64 msgs_recv = 9;
  inline bool has_msgs_recv() const;
  inline void clear_msgs_recv();
  static const int kMsgsRecvFieldNumber = 9;
  inline ::google::protobuf::uint64 msgs_recv() const;
  inline void set_msgs_recv(::google::protobuf::uint64 value);

  // optional uint64 datagrams_sent = 10;
  inline bool has_datagrams_sent() const;
  inline void clear_datagrams_sent();
  static const int kDatagramsSentFieldNumber = 10;
  inline ::google::protobuf::uint64 datagrams_sent() const;
  inline void set_datagrams_sent(::google::protobuf::uint64 value);

  // optional uint64 datagrams_recv = 11;
  inline bool has_datagrams_recv() const;
  inline void clear_datagrams_recv();
  static const int kDatagramsRecvFieldNumber = 11;
  inline ::google::protobuf::uint64 datagrams_recv() const;
  inline void set_datagrams_recv(::google::protobuf::uint64 value);

  // optional uint64 bad_pkts_recv = 12;
  inline bool has_bad_pkts_recv() const;
  inline void clear_bad_pkts_recv();
  static const int kBadPktsRecvFieldNumber = 12;
  inline ::google::protobuf::uint64 bad_pkts_recv() const;
  inline void set_bad_pkts_recv(::google::protobuf::uint64 value);

  // optional uint64 unknown_conn_pkts_recv = 13;
  inline bool has_unknown_conn_pkts_recv() const;
  inline void clear_unknown_conn_pkts_recv();
  static const int kUnknownConnPktsRecvFieldNumber = 13;
  inline ::google::protobuf::uint64 unknown_conn_pkts_recv() const;
  inline void set_unknown_conn_pkts_recv(::google::protobuf::uint64 value);

  // optional uint64 missed_pkts_recv = 14;
  inline bool has_missed_pkts_recv() const;
  inline void clear_missed_pkts_recv();
  static const int kMissedPktsRecvFieldNumber = 14;
  inline ::google::protobuf::uint64 missed_pkts_recv() const;
  inline void set_missed_pkts_recv(::google::protobuf::uint64 value);

  // optional uint64 dup_pkts_recv = 15;
  inline bool has_dup_pkts_recv() const;
  inline void clear_dup_pkts_recv();
  static const int kDupPktsRecvFieldNumber = 15;
  inline ::google::protobuf::uint64 dup_pkts_recv() const;
  inline void set_dup_pkts_recv(::google::protobuf::uint64 value);

  // optional uint64 failed_connect_challenges = 16;
  inline bool has_failed_connect_challenges() const;
  inline void clear_failed_connect_challenges();
  static const int kFailedConnectChallengesFieldNumber = 16;
  inline ::google::protobuf::uint64 failed_connect_challenges() const;
  inline void set_failed_connect_challenges(::google::protobuf::uint64 value);

  // optional uint32 micro_sec_avg_latency = 17;
  inline bool has_micro_sec_avg_latency() const;
  inline void clear_micro_sec_avg_latency();
  static const int kMicroSecAvgLatencyFieldNumber = 17;
  inline ::google::protobuf::uint32 micro_sec_avg_latency() const;
  inline void set_micro_sec_avg_latency(::google::protobuf::uint32 value);

  // optional uint32 micro_sec_min_latency = 18;
  inline bool has_micro_sec_min_latency() const;
  inline void clear_micro_sec_min_latency();
  static const int kMicroSecMinLatencyFieldNumber = 18;
  inline ::google::protobuf::uint32 micro_sec_min_latency() const;
  inline void set_micro_sec_min_latency(::google::protobuf::uint32 value);

  // optional uint32 micro_sec_max_latency = 19;
  inline bool has_micro_sec_max_latency() const;
  inline void clear_micro_sec_max_latency();
  static const int kMicroSecMaxLatencyFieldNumber = 19;
  inline ::google::protobuf::uint32 micro_sec_max_latency() const;
  inline void set_micro_sec_max_latency(::google::protobuf::uint32 value);

  // optional uint32 mem_pool_msg_in_use = 20;
  inline bool has_mem_pool_msg_in_use() const;
  inline void clear_mem_pool_msg_in_use();
  static const int kMemPoolMsgInUseFieldNumber = 20;
  inline ::google::protobuf::uint32 mem_pool_msg_in_use() const;
  inline void set_mem_pool_msg_in_use(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientConnectionStats.Stats_VConn)
 private:
  inline void set_has_connections_udp();
  inline void clear_has_connections_udp();
  inline void set_has_connections_tcp();
  inline void clear_has_connections_tcp();
  inline void set_has_stats_udp();
  inline void clear_has_stats_udp();
  inline void set_has_pkts_abandoned();
  inline void clear_has_pkts_abandoned();
  inline void set_has_conn_req_received();
  inline void clear_has_conn_req_received();
  inline void set_has_pkts_resent();
  inline void clear_has_pkts_resent();
  inline void set_has_msgs_sent();
  inline void clear_has_msgs_sent();
  inline void set_has_msgs_sent_failed();
  inline void clear_has_msgs_sent_failed();
  inline void set_has_msgs_recv();
  inline void clear_has_msgs_recv();
  inline void set_has_datagrams_sent();
  inline void clear_has_datagrams_sent();
  inline void set_has_datagrams_recv();
  inline void clear_has_datagrams_recv();
  inline void set_has_bad_pkts_recv();
  inline void clear_has_bad_pkts_recv();
  inline void set_has_unknown_conn_pkts_recv();
  inline void clear_has_unknown_conn_pkts_recv();
  inline void set_has_missed_pkts_recv();
  inline void clear_has_missed_pkts_recv();
  inline void set_has_dup_pkts_recv();
  inline void clear_has_dup_pkts_recv();
  inline void set_has_failed_connect_challenges();
  inline void clear_has_failed_connect_challenges();
  inline void set_has_micro_sec_avg_latency();
  inline void clear_has_micro_sec_avg_latency();
  inline void set_has_micro_sec_min_latency();
  inline void clear_has_micro_sec_min_latency();
  inline void set_has_micro_sec_max_latency();
  inline void clear_has_micro_sec_max_latency();
  inline void set_has_mem_pool_msg_in_use();
  inline void clear_has_mem_pool_msg_in_use();

  ::google::protobuf::uint32 connections_udp_;
  ::google::protobuf::uint32 connections_tcp_;
  ::Sc::CMsgClientConnectionStats_Stats_UDP* stats_udp_;
  ::google::protobuf::uint64 pkts_abandoned_;
  ::google::protobuf::uint64 conn_req_received_;
  ::google::protobuf::uint64 pkts_resent_;
  ::google::protobuf::uint64 msgs_sent_;
  ::google::protobuf::uint64 msgs_sent_failed_;
  ::google::protobuf::uint64 msgs_recv_;
  ::google::protobuf::uint64 datagrams_sent_;
  ::google::protobuf::uint64 datagrams_recv_;
  ::google::protobuf::uint64 bad_pkts_recv_;
  ::google::protobuf::uint64 unknown_conn_pkts_recv_;
  ::google::protobuf::uint64 missed_pkts_recv_;
  ::google::protobuf::uint64 dup_pkts_recv_;
  ::google::protobuf::uint64 failed_connect_challenges_;
  ::google::protobuf::uint32 micro_sec_avg_latency_;
  ::google::protobuf::uint32 micro_sec_min_latency_;
  ::google::protobuf::uint32 micro_sec_max_latency_;
  ::google::protobuf::uint32 mem_pool_msg_in_use_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientConnectionStats_Stats_VConn* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientConnectionStats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientConnectionStats();
  virtual ~CMsgClientConnectionStats();

  CMsgClientConnectionStats(const CMsgClientConnectionStats& from);

  inline CMsgClientConnectionStats& operator=(const CMsgClientConnectionStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientConnectionStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientConnectionStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientConnectionStats* other);

  // implements Message ----------------------------------------------

  CMsgClientConnectionStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientConnectionStats& from);
  void MergeFrom(const CMsgClientConnectionStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientConnectionStats_Stats_Logon Stats_Logon;
  typedef CMsgClientConnectionStats_Stats_UDP Stats_UDP;
  typedef CMsgClientConnectionStats_Stats_VConn Stats_VConn;

  // accessors -------------------------------------------------------

  // optional .Sc.CMsgClientConnectionStats.Stats_Logon stats_logon = 1;
  inline bool has_stats_logon() const;
  inline void clear_stats_logon();
  static const int kStatsLogonFieldNumber = 1;
  inline const ::Sc::CMsgClientConnectionStats_Stats_Logon& stats_logon() const;
  inline ::Sc::CMsgClientConnectionStats_Stats_Logon* mutable_stats_logon();
  inline ::Sc::CMsgClientConnectionStats_Stats_Logon* release_stats_logon();
  inline void set_allocated_stats_logon(::Sc::CMsgClientConnectionStats_Stats_Logon* stats_logon);

  // optional .Sc.CMsgClientConnectionStats.Stats_VConn stats_vconn = 2;
  inline bool has_stats_vconn() const;
  inline void clear_stats_vconn();
  static const int kStatsVconnFieldNumber = 2;
  inline const ::Sc::CMsgClientConnectionStats_Stats_VConn& stats_vconn() const;
  inline ::Sc::CMsgClientConnectionStats_Stats_VConn* mutable_stats_vconn();
  inline ::Sc::CMsgClientConnectionStats_Stats_VConn* release_stats_vconn();
  inline void set_allocated_stats_vconn(::Sc::CMsgClientConnectionStats_Stats_VConn* stats_vconn);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientConnectionStats)
 private:
  inline void set_has_stats_logon();
  inline void clear_has_stats_logon();
  inline void set_has_stats_vconn();
  inline void clear_has_stats_vconn();

  ::Sc::CMsgClientConnectionStats_Stats_Logon* stats_logon_;
  ::Sc::CMsgClientConnectionStats_Stats_VConn* stats_vconn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientConnectionStats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServersAvailable_Server_Types_Available : public ::google::protobuf::MessageLite {
 public:
  CMsgClientServersAvailable_Server_Types_Available();
  virtual ~CMsgClientServersAvailable_Server_Types_Available();

  CMsgClientServersAvailable_Server_Types_Available(const CMsgClientServersAvailable_Server_Types_Available& from);

  inline CMsgClientServersAvailable_Server_Types_Available& operator=(const CMsgClientServersAvailable_Server_Types_Available& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientServersAvailable_Server_Types_Available& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientServersAvailable_Server_Types_Available* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientServersAvailable_Server_Types_Available* other);

  // implements Message ----------------------------------------------

  CMsgClientServersAvailable_Server_Types_Available* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientServersAvailable_Server_Types_Available& from);
  void MergeFrom(const CMsgClientServersAvailable_Server_Types_Available& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline ::google::protobuf::uint32 server() const;
  inline void set_server(::google::protobuf::uint32 value);

  // optional bool changed = 2;
  inline bool has_changed() const;
  inline void clear_changed();
  static const int kChangedFieldNumber = 2;
  inline bool changed() const;
  inline void set_changed(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientServersAvailable.Server_Types_Available)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_changed();
  inline void clear_has_changed();

  ::google::protobuf::uint32 server_;
  bool changed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServersAvailable_Server_Types_Available* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServersAvailable : public ::google::protobuf::MessageLite {
 public:
  CMsgClientServersAvailable();
  virtual ~CMsgClientServersAvailable();

  CMsgClientServersAvailable(const CMsgClientServersAvailable& from);

  inline CMsgClientServersAvailable& operator=(const CMsgClientServersAvailable& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientServersAvailable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientServersAvailable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientServersAvailable* other);

  // implements Message ----------------------------------------------

  CMsgClientServersAvailable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientServersAvailable& from);
  void MergeFrom(const CMsgClientServersAvailable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientServersAvailable_Server_Types_Available Server_Types_Available;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientServersAvailable.Server_Types_Available server_types_available = 1;
  inline int server_types_available_size() const;
  inline void clear_server_types_available();
  static const int kServerTypesAvailableFieldNumber = 1;
  inline const ::Sc::CMsgClientServersAvailable_Server_Types_Available& server_types_available(int index) const;
  inline ::Sc::CMsgClientServersAvailable_Server_Types_Available* mutable_server_types_available(int index);
  inline ::Sc::CMsgClientServersAvailable_Server_Types_Available* add_server_types_available();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServersAvailable_Server_Types_Available >&
      server_types_available() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServersAvailable_Server_Types_Available >*
      mutable_server_types_available();

  // optional uint32 server_type_for_auth_services = 2;
  inline bool has_server_type_for_auth_services() const;
  inline void clear_server_type_for_auth_services();
  static const int kServerTypeForAuthServicesFieldNumber = 2;
  inline ::google::protobuf::uint32 server_type_for_auth_services() const;
  inline void set_server_type_for_auth_services(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientServersAvailable)
 private:
  inline void set_has_server_type_for_auth_services();
  inline void clear_has_server_type_for_auth_services();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServersAvailable_Server_Types_Available > server_types_available_;
  ::google::protobuf::uint32 server_type_for_auth_services_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServersAvailable* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetUserStats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetUserStats();
  virtual ~CMsgClientGetUserStats();

  CMsgClientGetUserStats(const CMsgClientGetUserStats& from);

  inline CMsgClientGetUserStats& operator=(const CMsgClientGetUserStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetUserStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetUserStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetUserStats* other);

  // implements Message ----------------------------------------------

  CMsgClientGetUserStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetUserStats& from);
  void MergeFrom(const CMsgClientGetUserStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 game_id = 1;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional uint32 crc_stats = 2;
  inline bool has_crc_stats() const;
  inline void clear_crc_stats();
  static const int kCrcStatsFieldNumber = 2;
  inline ::google::protobuf::uint32 crc_stats() const;
  inline void set_crc_stats(::google::protobuf::uint32 value);

  // optional int32 schema_local_version = 3;
  inline bool has_schema_local_version() const;
  inline void clear_schema_local_version();
  static const int kSchemaLocalVersionFieldNumber = 3;
  inline ::google::protobuf::int32 schema_local_version() const;
  inline void set_schema_local_version(::google::protobuf::int32 value);

  // optional fixed64 steam_id_for_user = 4;
  inline bool has_steam_id_for_user() const;
  inline void clear_steam_id_for_user();
  static const int kSteamIdForUserFieldNumber = 4;
  inline ::google::protobuf::uint64 steam_id_for_user() const;
  inline void set_steam_id_for_user(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetUserStats)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_crc_stats();
  inline void clear_has_crc_stats();
  inline void set_has_schema_local_version();
  inline void clear_has_schema_local_version();
  inline void set_has_steam_id_for_user();
  inline void clear_has_steam_id_for_user();

  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::uint32 crc_stats_;
  ::google::protobuf::int32 schema_local_version_;
  ::google::protobuf::uint64 steam_id_for_user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetUserStats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetUserStatsResponse_Stats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetUserStatsResponse_Stats();
  virtual ~CMsgClientGetUserStatsResponse_Stats();

  CMsgClientGetUserStatsResponse_Stats(const CMsgClientGetUserStatsResponse_Stats& from);

  inline CMsgClientGetUserStatsResponse_Stats& operator=(const CMsgClientGetUserStatsResponse_Stats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetUserStatsResponse_Stats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetUserStatsResponse_Stats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetUserStatsResponse_Stats* other);

  // implements Message ----------------------------------------------

  CMsgClientGetUserStatsResponse_Stats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetUserStatsResponse_Stats& from);
  void MergeFrom(const CMsgClientGetUserStatsResponse_Stats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stat_id = 1;
  inline bool has_stat_id() const;
  inline void clear_stat_id();
  static const int kStatIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stat_id() const;
  inline void set_stat_id(::google::protobuf::uint32 value);

  // optional uint32 stat_value = 2;
  inline bool has_stat_value() const;
  inline void clear_stat_value();
  static const int kStatValueFieldNumber = 2;
  inline ::google::protobuf::uint32 stat_value() const;
  inline void set_stat_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetUserStatsResponse.Stats)
 private:
  inline void set_has_stat_id();
  inline void clear_has_stat_id();
  inline void set_has_stat_value();
  inline void clear_has_stat_value();

  ::google::protobuf::uint32 stat_id_;
  ::google::protobuf::uint32 stat_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetUserStatsResponse_Stats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetUserStatsResponse_Achievement_Blocks : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetUserStatsResponse_Achievement_Blocks();
  virtual ~CMsgClientGetUserStatsResponse_Achievement_Blocks();

  CMsgClientGetUserStatsResponse_Achievement_Blocks(const CMsgClientGetUserStatsResponse_Achievement_Blocks& from);

  inline CMsgClientGetUserStatsResponse_Achievement_Blocks& operator=(const CMsgClientGetUserStatsResponse_Achievement_Blocks& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetUserStatsResponse_Achievement_Blocks& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetUserStatsResponse_Achievement_Blocks* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetUserStatsResponse_Achievement_Blocks* other);

  // implements Message ----------------------------------------------

  CMsgClientGetUserStatsResponse_Achievement_Blocks* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetUserStatsResponse_Achievement_Blocks& from);
  void MergeFrom(const CMsgClientGetUserStatsResponse_Achievement_Blocks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 achievement_id = 1;
  inline bool has_achievement_id() const;
  inline void clear_achievement_id();
  static const int kAchievementIdFieldNumber = 1;
  inline ::google::protobuf::uint32 achievement_id() const;
  inline void set_achievement_id(::google::protobuf::uint32 value);

  // repeated fixed32 unlock_time = 2;
  inline int unlock_time_size() const;
  inline void clear_unlock_time();
  static const int kUnlockTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 unlock_time(int index) const;
  inline void set_unlock_time(int index, ::google::protobuf::uint32 value);
  inline void add_unlock_time(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      unlock_time() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_unlock_time();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetUserStatsResponse.Achievement_Blocks)
 private:
  inline void set_has_achievement_id();
  inline void clear_has_achievement_id();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > unlock_time_;
  ::google::protobuf::uint32 achievement_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetUserStatsResponse_Achievement_Blocks* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetUserStatsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetUserStatsResponse();
  virtual ~CMsgClientGetUserStatsResponse();

  CMsgClientGetUserStatsResponse(const CMsgClientGetUserStatsResponse& from);

  inline CMsgClientGetUserStatsResponse& operator=(const CMsgClientGetUserStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetUserStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetUserStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetUserStatsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetUserStatsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetUserStatsResponse& from);
  void MergeFrom(const CMsgClientGetUserStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientGetUserStatsResponse_Stats Stats;
  typedef CMsgClientGetUserStatsResponse_Achievement_Blocks Achievement_Blocks;

  // accessors -------------------------------------------------------

  // optional fixed64 game_id = 1;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional int32 eresult = 2 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 crc_stats = 3;
  inline bool has_crc_stats() const;
  inline void clear_crc_stats();
  static const int kCrcStatsFieldNumber = 3;
  inline ::google::protobuf::uint32 crc_stats() const;
  inline void set_crc_stats(::google::protobuf::uint32 value);

  // optional bytes schema = 4;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 4;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const void* value, size_t size);
  inline ::std::string* mutable_schema();
  inline ::std::string* release_schema();
  inline void set_allocated_schema(::std::string* schema);

  // repeated .Sc.CMsgClientGetUserStatsResponse.Stats stats = 5;
  inline int stats_size() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 5;
  inline const ::Sc::CMsgClientGetUserStatsResponse_Stats& stats(int index) const;
  inline ::Sc::CMsgClientGetUserStatsResponse_Stats* mutable_stats(int index);
  inline ::Sc::CMsgClientGetUserStatsResponse_Stats* add_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Stats >&
      stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Stats >*
      mutable_stats();

  // repeated .Sc.CMsgClientGetUserStatsResponse.Achievement_Blocks achievement_blocks = 6;
  inline int achievement_blocks_size() const;
  inline void clear_achievement_blocks();
  static const int kAchievementBlocksFieldNumber = 6;
  inline const ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks& achievement_blocks(int index) const;
  inline ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks* mutable_achievement_blocks(int index);
  inline ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks* add_achievement_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks >&
      achievement_blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks >*
      mutable_achievement_blocks();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetUserStatsResponse)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_crc_stats();
  inline void clear_has_crc_stats();
  inline void set_has_schema();
  inline void clear_has_schema();

  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 crc_stats_;
  ::std::string* schema_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Stats > stats_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks > achievement_blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetUserStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStoreUserStatsResponse_Stats_Failed_Validation : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStoreUserStatsResponse_Stats_Failed_Validation();
  virtual ~CMsgClientStoreUserStatsResponse_Stats_Failed_Validation();

  CMsgClientStoreUserStatsResponse_Stats_Failed_Validation(const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& from);

  inline CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& operator=(const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* other);

  // implements Message ----------------------------------------------

  CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& from);
  void MergeFrom(const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stat_id = 1;
  inline bool has_stat_id() const;
  inline void clear_stat_id();
  static const int kStatIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stat_id() const;
  inline void set_stat_id(::google::protobuf::uint32 value);

  // optional uint32 reverted_stat_value = 2;
  inline bool has_reverted_stat_value() const;
  inline void clear_reverted_stat_value();
  static const int kRevertedStatValueFieldNumber = 2;
  inline ::google::protobuf::uint32 reverted_stat_value() const;
  inline void set_reverted_stat_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStoreUserStatsResponse.Stats_Failed_Validation)
 private:
  inline void set_has_stat_id();
  inline void clear_has_stat_id();
  inline void set_has_reverted_stat_value();
  inline void clear_has_reverted_stat_value();

  ::google::protobuf::uint32 stat_id_;
  ::google::protobuf::uint32 reverted_stat_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStoreUserStatsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStoreUserStatsResponse();
  virtual ~CMsgClientStoreUserStatsResponse();

  CMsgClientStoreUserStatsResponse(const CMsgClientStoreUserStatsResponse& from);

  inline CMsgClientStoreUserStatsResponse& operator=(const CMsgClientStoreUserStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStoreUserStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStoreUserStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStoreUserStatsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientStoreUserStatsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStoreUserStatsResponse& from);
  void MergeFrom(const CMsgClientStoreUserStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientStoreUserStatsResponse_Stats_Failed_Validation Stats_Failed_Validation;

  // accessors -------------------------------------------------------

  // optional fixed64 game_id = 1;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional int32 eresult = 2 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 crc_stats = 3;
  inline bool has_crc_stats() const;
  inline void clear_crc_stats();
  static const int kCrcStatsFieldNumber = 3;
  inline ::google::protobuf::uint32 crc_stats() const;
  inline void set_crc_stats(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientStoreUserStatsResponse.Stats_Failed_Validation stats_failed_validation = 4;
  inline int stats_failed_validation_size() const;
  inline void clear_stats_failed_validation();
  static const int kStatsFailedValidationFieldNumber = 4;
  inline const ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& stats_failed_validation(int index) const;
  inline ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* mutable_stats_failed_validation(int index);
  inline ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* add_stats_failed_validation();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation >&
      stats_failed_validation() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation >*
      mutable_stats_failed_validation();

  // optional bool stats_out_of_date = 5;
  inline bool has_stats_out_of_date() const;
  inline void clear_stats_out_of_date();
  static const int kStatsOutOfDateFieldNumber = 5;
  inline bool stats_out_of_date() const;
  inline void set_stats_out_of_date(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStoreUserStatsResponse)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_crc_stats();
  inline void clear_has_crc_stats();
  inline void set_has_stats_out_of_date();
  inline void clear_has_stats_out_of_date();

  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 crc_stats_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation > stats_failed_validation_;
  bool stats_out_of_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStoreUserStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStoreUserStats2_Stats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStoreUserStats2_Stats();
  virtual ~CMsgClientStoreUserStats2_Stats();

  CMsgClientStoreUserStats2_Stats(const CMsgClientStoreUserStats2_Stats& from);

  inline CMsgClientStoreUserStats2_Stats& operator=(const CMsgClientStoreUserStats2_Stats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStoreUserStats2_Stats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStoreUserStats2_Stats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStoreUserStats2_Stats* other);

  // implements Message ----------------------------------------------

  CMsgClientStoreUserStats2_Stats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStoreUserStats2_Stats& from);
  void MergeFrom(const CMsgClientStoreUserStats2_Stats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stat_id = 1;
  inline bool has_stat_id() const;
  inline void clear_stat_id();
  static const int kStatIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stat_id() const;
  inline void set_stat_id(::google::protobuf::uint32 value);

  // optional uint32 stat_value = 2;
  inline bool has_stat_value() const;
  inline void clear_stat_value();
  static const int kStatValueFieldNumber = 2;
  inline ::google::protobuf::uint32 stat_value() const;
  inline void set_stat_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStoreUserStats2.Stats)
 private:
  inline void set_has_stat_id();
  inline void clear_has_stat_id();
  inline void set_has_stat_value();
  inline void clear_has_stat_value();

  ::google::protobuf::uint32 stat_id_;
  ::google::protobuf::uint32 stat_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStoreUserStats2_Stats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStoreUserStats2 : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStoreUserStats2();
  virtual ~CMsgClientStoreUserStats2();

  CMsgClientStoreUserStats2(const CMsgClientStoreUserStats2& from);

  inline CMsgClientStoreUserStats2& operator=(const CMsgClientStoreUserStats2& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStoreUserStats2& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStoreUserStats2* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStoreUserStats2* other);

  // implements Message ----------------------------------------------

  CMsgClientStoreUserStats2* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStoreUserStats2& from);
  void MergeFrom(const CMsgClientStoreUserStats2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientStoreUserStats2_Stats Stats;

  // accessors -------------------------------------------------------

  // optional fixed64 game_id = 1;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional fixed64 settor_steam_id = 2;
  inline bool has_settor_steam_id() const;
  inline void clear_settor_steam_id();
  static const int kSettorSteamIdFieldNumber = 2;
  inline ::google::protobuf::uint64 settor_steam_id() const;
  inline void set_settor_steam_id(::google::protobuf::uint64 value);

  // optional fixed64 settee_steam_id = 3;
  inline bool has_settee_steam_id() const;
  inline void clear_settee_steam_id();
  static const int kSetteeSteamIdFieldNumber = 3;
  inline ::google::protobuf::uint64 settee_steam_id() const;
  inline void set_settee_steam_id(::google::protobuf::uint64 value);

  // optional uint32 crc_stats = 4;
  inline bool has_crc_stats() const;
  inline void clear_crc_stats();
  static const int kCrcStatsFieldNumber = 4;
  inline ::google::protobuf::uint32 crc_stats() const;
  inline void set_crc_stats(::google::protobuf::uint32 value);

  // optional bool explicit_reset = 5;
  inline bool has_explicit_reset() const;
  inline void clear_explicit_reset();
  static const int kExplicitResetFieldNumber = 5;
  inline bool explicit_reset() const;
  inline void set_explicit_reset(bool value);

  // repeated .Sc.CMsgClientStoreUserStats2.Stats stats = 6;
  inline int stats_size() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 6;
  inline const ::Sc::CMsgClientStoreUserStats2_Stats& stats(int index) const;
  inline ::Sc::CMsgClientStoreUserStats2_Stats* mutable_stats(int index);
  inline ::Sc::CMsgClientStoreUserStats2_Stats* add_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats2_Stats >&
      stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats2_Stats >*
      mutable_stats();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStoreUserStats2)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_settor_steam_id();
  inline void clear_has_settor_steam_id();
  inline void set_has_settee_steam_id();
  inline void clear_has_settee_steam_id();
  inline void set_has_crc_stats();
  inline void clear_has_crc_stats();
  inline void set_has_explicit_reset();
  inline void clear_has_explicit_reset();

  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::uint64 settor_steam_id_;
  ::google::protobuf::uint64 settee_steam_id_;
  ::google::protobuf::uint32 crc_stats_;
  bool explicit_reset_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats2_Stats > stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStoreUserStats2* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStatsUpdated_Updated_Stats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStatsUpdated_Updated_Stats();
  virtual ~CMsgClientStatsUpdated_Updated_Stats();

  CMsgClientStatsUpdated_Updated_Stats(const CMsgClientStatsUpdated_Updated_Stats& from);

  inline CMsgClientStatsUpdated_Updated_Stats& operator=(const CMsgClientStatsUpdated_Updated_Stats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStatsUpdated_Updated_Stats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStatsUpdated_Updated_Stats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStatsUpdated_Updated_Stats* other);

  // implements Message ----------------------------------------------

  CMsgClientStatsUpdated_Updated_Stats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStatsUpdated_Updated_Stats& from);
  void MergeFrom(const CMsgClientStatsUpdated_Updated_Stats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stat_id = 1;
  inline bool has_stat_id() const;
  inline void clear_stat_id();
  static const int kStatIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stat_id() const;
  inline void set_stat_id(::google::protobuf::uint32 value);

  // optional uint32 stat_value = 2;
  inline bool has_stat_value() const;
  inline void clear_stat_value();
  static const int kStatValueFieldNumber = 2;
  inline ::google::protobuf::uint32 stat_value() const;
  inline void set_stat_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStatsUpdated.Updated_Stats)
 private:
  inline void set_has_stat_id();
  inline void clear_has_stat_id();
  inline void set_has_stat_value();
  inline void clear_has_stat_value();

  ::google::protobuf::uint32 stat_id_;
  ::google::protobuf::uint32 stat_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStatsUpdated_Updated_Stats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStatsUpdated : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStatsUpdated();
  virtual ~CMsgClientStatsUpdated();

  CMsgClientStatsUpdated(const CMsgClientStatsUpdated& from);

  inline CMsgClientStatsUpdated& operator=(const CMsgClientStatsUpdated& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStatsUpdated& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStatsUpdated* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStatsUpdated* other);

  // implements Message ----------------------------------------------

  CMsgClientStatsUpdated* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStatsUpdated& from);
  void MergeFrom(const CMsgClientStatsUpdated& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientStatsUpdated_Updated_Stats Updated_Stats;

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional fixed64 game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional uint32 crc_stats = 3;
  inline bool has_crc_stats() const;
  inline void clear_crc_stats();
  static const int kCrcStatsFieldNumber = 3;
  inline ::google::protobuf::uint32 crc_stats() const;
  inline void set_crc_stats(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientStatsUpdated.Updated_Stats updated_stats = 4;
  inline int updated_stats_size() const;
  inline void clear_updated_stats();
  static const int kUpdatedStatsFieldNumber = 4;
  inline const ::Sc::CMsgClientStatsUpdated_Updated_Stats& updated_stats(int index) const;
  inline ::Sc::CMsgClientStatsUpdated_Updated_Stats* mutable_updated_stats(int index);
  inline ::Sc::CMsgClientStatsUpdated_Updated_Stats* add_updated_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStatsUpdated_Updated_Stats >&
      updated_stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStatsUpdated_Updated_Stats >*
      mutable_updated_stats();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStatsUpdated)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_crc_stats();
  inline void clear_has_crc_stats();

  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStatsUpdated_Updated_Stats > updated_stats_;
  ::google::protobuf::uint32 crc_stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStatsUpdated* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStoreUserStats_Stats_To_Store : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStoreUserStats_Stats_To_Store();
  virtual ~CMsgClientStoreUserStats_Stats_To_Store();

  CMsgClientStoreUserStats_Stats_To_Store(const CMsgClientStoreUserStats_Stats_To_Store& from);

  inline CMsgClientStoreUserStats_Stats_To_Store& operator=(const CMsgClientStoreUserStats_Stats_To_Store& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStoreUserStats_Stats_To_Store& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStoreUserStats_Stats_To_Store* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStoreUserStats_Stats_To_Store* other);

  // implements Message ----------------------------------------------

  CMsgClientStoreUserStats_Stats_To_Store* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStoreUserStats_Stats_To_Store& from);
  void MergeFrom(const CMsgClientStoreUserStats_Stats_To_Store& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stat_id = 1;
  inline bool has_stat_id() const;
  inline void clear_stat_id();
  static const int kStatIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stat_id() const;
  inline void set_stat_id(::google::protobuf::uint32 value);

  // optional uint32 stat_value = 2;
  inline bool has_stat_value() const;
  inline void clear_stat_value();
  static const int kStatValueFieldNumber = 2;
  inline ::google::protobuf::uint32 stat_value() const;
  inline void set_stat_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStoreUserStats.Stats_To_Store)
 private:
  inline void set_has_stat_id();
  inline void clear_has_stat_id();
  inline void set_has_stat_value();
  inline void clear_has_stat_value();

  ::google::protobuf::uint32 stat_id_;
  ::google::protobuf::uint32 stat_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStoreUserStats_Stats_To_Store* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientStoreUserStats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientStoreUserStats();
  virtual ~CMsgClientStoreUserStats();

  CMsgClientStoreUserStats(const CMsgClientStoreUserStats& from);

  inline CMsgClientStoreUserStats& operator=(const CMsgClientStoreUserStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientStoreUserStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientStoreUserStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientStoreUserStats* other);

  // implements Message ----------------------------------------------

  CMsgClientStoreUserStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientStoreUserStats& from);
  void MergeFrom(const CMsgClientStoreUserStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientStoreUserStats_Stats_To_Store Stats_To_Store;

  // accessors -------------------------------------------------------

  // optional fixed64 game_id = 1;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional bool explicit_reset = 2;
  inline bool has_explicit_reset() const;
  inline void clear_explicit_reset();
  static const int kExplicitResetFieldNumber = 2;
  inline bool explicit_reset() const;
  inline void set_explicit_reset(bool value);

  // repeated .Sc.CMsgClientStoreUserStats.Stats_To_Store stats_to_store = 3;
  inline int stats_to_store_size() const;
  inline void clear_stats_to_store();
  static const int kStatsToStoreFieldNumber = 3;
  inline const ::Sc::CMsgClientStoreUserStats_Stats_To_Store& stats_to_store(int index) const;
  inline ::Sc::CMsgClientStoreUserStats_Stats_To_Store* mutable_stats_to_store(int index);
  inline ::Sc::CMsgClientStoreUserStats_Stats_To_Store* add_stats_to_store();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats_Stats_To_Store >&
      stats_to_store() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats_Stats_To_Store >*
      mutable_stats_to_store();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientStoreUserStats)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_explicit_reset();
  inline void clear_has_explicit_reset();

  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats_Stats_To_Store > stats_to_store_;
  bool explicit_reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientStoreUserStats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientDetails : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientDetails();
  virtual ~CMsgClientGetClientDetails();

  CMsgClientGetClientDetails(const CMsgClientGetClientDetails& from);

  inline CMsgClientGetClientDetails& operator=(const CMsgClientGetClientDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientDetails* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientDetails& from);
  void MergeFrom(const CMsgClientGetClientDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientDetails)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientDetails* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientReportOverlayDetourFailure : public ::google::protobuf::MessageLite {
 public:
  CMsgClientReportOverlayDetourFailure();
  virtual ~CMsgClientReportOverlayDetourFailure();

  CMsgClientReportOverlayDetourFailure(const CMsgClientReportOverlayDetourFailure& from);

  inline CMsgClientReportOverlayDetourFailure& operator=(const CMsgClientReportOverlayDetourFailure& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientReportOverlayDetourFailure& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientReportOverlayDetourFailure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientReportOverlayDetourFailure* other);

  // implements Message ----------------------------------------------

  CMsgClientReportOverlayDetourFailure* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientReportOverlayDetourFailure& from);
  void MergeFrom(const CMsgClientReportOverlayDetourFailure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string failure_strings = 1;
  inline int failure_strings_size() const;
  inline void clear_failure_strings();
  static const int kFailureStringsFieldNumber = 1;
  inline const ::std::string& failure_strings(int index) const;
  inline ::std::string* mutable_failure_strings(int index);
  inline void set_failure_strings(int index, const ::std::string& value);
  inline void set_failure_strings(int index, const char* value);
  inline void set_failure_strings(int index, const char* value, size_t size);
  inline ::std::string* add_failure_strings();
  inline void add_failure_strings(const ::std::string& value);
  inline void add_failure_strings(const char* value);
  inline void add_failure_strings(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& failure_strings() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_failure_strings();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientReportOverlayDetourFailure)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> failure_strings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientReportOverlayDetourFailure* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientDetailsResponse_Game : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientDetailsResponse_Game();
  virtual ~CMsgClientGetClientDetailsResponse_Game();

  CMsgClientGetClientDetailsResponse_Game(const CMsgClientGetClientDetailsResponse_Game& from);

  inline CMsgClientGetClientDetailsResponse_Game& operator=(const CMsgClientGetClientDetailsResponse_Game& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientDetailsResponse_Game& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientDetailsResponse_Game* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientDetailsResponse_Game* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientDetailsResponse_Game* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientDetailsResponse_Game& from);
  void MergeFrom(const CMsgClientGetClientDetailsResponse_Game& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional string extra_info = 2;
  inline bool has_extra_info() const;
  inline void clear_extra_info();
  static const int kExtraInfoFieldNumber = 2;
  inline const ::std::string& extra_info() const;
  inline void set_extra_info(const ::std::string& value);
  inline void set_extra_info(const char* value);
  inline void set_extra_info(const char* value, size_t size);
  inline ::std::string* mutable_extra_info();
  inline ::std::string* release_extra_info();
  inline void set_allocated_extra_info(::std::string* extra_info);

  // optional uint32 time_running_sec = 3;
  inline bool has_time_running_sec() const;
  inline void clear_time_running_sec();
  static const int kTimeRunningSecFieldNumber = 3;
  inline ::google::protobuf::uint32 time_running_sec() const;
  inline void set_time_running_sec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientDetailsResponse.Game)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_extra_info();
  inline void clear_has_extra_info();
  inline void set_has_time_running_sec();
  inline void clear_has_time_running_sec();

  ::std::string* extra_info_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 time_running_sec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientDetailsResponse_Game* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientDetailsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientDetailsResponse();
  virtual ~CMsgClientGetClientDetailsResponse();

  CMsgClientGetClientDetailsResponse(const CMsgClientGetClientDetailsResponse& from);

  inline CMsgClientGetClientDetailsResponse& operator=(const CMsgClientGetClientDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientDetailsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientDetailsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientDetailsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientDetailsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientDetailsResponse& from);
  void MergeFrom(const CMsgClientGetClientDetailsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientGetClientDetailsResponse_Game Game;

  // accessors -------------------------------------------------------

  // optional uint32 package_version = 1;
  inline bool has_package_version() const;
  inline void clear_package_version();
  static const int kPackageVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 package_version() const;
  inline void set_package_version(::google::protobuf::uint32 value);

  // optional uint32 protocol_version = 8;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 8;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // optional string os = 2;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 2;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string machine_name = 3;
  inline bool has_machine_name() const;
  inline void clear_machine_name();
  static const int kMachineNameFieldNumber = 3;
  inline const ::std::string& machine_name() const;
  inline void set_machine_name(const ::std::string& value);
  inline void set_machine_name(const char* value);
  inline void set_machine_name(const char* value, size_t size);
  inline ::std::string* mutable_machine_name();
  inline ::std::string* release_machine_name();
  inline void set_allocated_machine_name(::std::string* machine_name);

  // optional string ip_public = 4;
  inline bool has_ip_public() const;
  inline void clear_ip_public();
  static const int kIpPublicFieldNumber = 4;
  inline const ::std::string& ip_public() const;
  inline void set_ip_public(const ::std::string& value);
  inline void set_ip_public(const char* value);
  inline void set_ip_public(const char* value, size_t size);
  inline ::std::string* mutable_ip_public();
  inline ::std::string* release_ip_public();
  inline void set_allocated_ip_public(::std::string* ip_public);

  // optional string ip_private = 5;
  inline bool has_ip_private() const;
  inline void clear_ip_private();
  static const int kIpPrivateFieldNumber = 5;
  inline const ::std::string& ip_private() const;
  inline void set_ip_private(const ::std::string& value);
  inline void set_ip_private(const char* value);
  inline void set_ip_private(const char* value, size_t size);
  inline ::std::string* mutable_ip_private();
  inline ::std::string* release_ip_private();
  inline void set_allocated_ip_private(::std::string* ip_private);

  // optional uint64 bytes_available = 7;
  inline bool has_bytes_available() const;
  inline void clear_bytes_available();
  static const int kBytesAvailableFieldNumber = 7;
  inline ::google::protobuf::uint64 bytes_available() const;
  inline void set_bytes_available(::google::protobuf::uint64 value);

  // repeated .Sc.CMsgClientGetClientDetailsResponse.Game games_running = 6;
  inline int games_running_size() const;
  inline void clear_games_running();
  static const int kGamesRunningFieldNumber = 6;
  inline const ::Sc::CMsgClientGetClientDetailsResponse_Game& games_running(int index) const;
  inline ::Sc::CMsgClientGetClientDetailsResponse_Game* mutable_games_running(int index);
  inline ::Sc::CMsgClientGetClientDetailsResponse_Game* add_games_running();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientDetailsResponse_Game >&
      games_running() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientDetailsResponse_Game >*
      mutable_games_running();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientDetailsResponse)
 private:
  inline void set_has_package_version();
  inline void clear_has_package_version();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_machine_name();
  inline void clear_has_machine_name();
  inline void set_has_ip_public();
  inline void clear_has_ip_public();
  inline void set_has_ip_private();
  inline void clear_has_ip_private();
  inline void set_has_bytes_available();
  inline void clear_has_bytes_available();

  ::google::protobuf::uint32 package_version_;
  ::google::protobuf::uint32 protocol_version_;
  ::std::string* os_;
  ::std::string* machine_name_;
  ::std::string* ip_public_;
  ::std::string* ip_private_;
  ::google::protobuf::uint64 bytes_available_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientDetailsResponse_Game > games_running_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientDetailsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientAppList : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientAppList();
  virtual ~CMsgClientGetClientAppList();

  CMsgClientGetClientAppList(const CMsgClientGetClientAppList& from);

  inline CMsgClientGetClientAppList& operator=(const CMsgClientGetClientAppList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientAppList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientAppList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientAppList* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientAppList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientAppList& from);
  void MergeFrom(const CMsgClientGetClientAppList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool media = 1;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 1;
  inline bool media() const;
  inline void set_media(bool value);

  // optional bool tools = 2;
  inline bool has_tools() const;
  inline void clear_tools();
  static const int kToolsFieldNumber = 2;
  inline bool tools() const;
  inline void set_tools(bool value);

  // optional bool games = 3;
  inline bool has_games() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 3;
  inline bool games() const;
  inline void set_games(bool value);

  // optional bool only_installed = 4;
  inline bool has_only_installed() const;
  inline void clear_only_installed();
  static const int kOnlyInstalledFieldNumber = 4;
  inline bool only_installed() const;
  inline void set_only_installed(bool value);

  // optional bool only_changing = 5;
  inline bool has_only_changing() const;
  inline void clear_only_changing();
  static const int kOnlyChangingFieldNumber = 5;
  inline bool only_changing() const;
  inline void set_only_changing(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientAppList)
 private:
  inline void set_has_media();
  inline void clear_has_media();
  inline void set_has_tools();
  inline void clear_has_tools();
  inline void set_has_games();
  inline void clear_has_games();
  inline void set_has_only_installed();
  inline void clear_has_only_installed();
  inline void set_has_only_changing();
  inline void clear_has_only_changing();

  bool media_;
  bool tools_;
  bool games_;
  bool only_installed_;
  bool only_changing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientAppList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientAppListResponse_App_DLC : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientAppListResponse_App_DLC();
  virtual ~CMsgClientGetClientAppListResponse_App_DLC();

  CMsgClientGetClientAppListResponse_App_DLC(const CMsgClientGetClientAppListResponse_App_DLC& from);

  inline CMsgClientGetClientAppListResponse_App_DLC& operator=(const CMsgClientGetClientAppListResponse_App_DLC& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientAppListResponse_App_DLC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientAppListResponse_App_DLC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientAppListResponse_App_DLC* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientAppListResponse_App_DLC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientAppListResponse_App_DLC& from);
  void MergeFrom(const CMsgClientGetClientAppListResponse_App_DLC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional bool installed = 2;
  inline bool has_installed() const;
  inline void clear_installed();
  static const int kInstalledFieldNumber = 2;
  inline bool installed() const;
  inline void set_installed(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientAppListResponse.App.DLC)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_installed();
  inline void clear_has_installed();

  ::google::protobuf::uint32 appid_;
  bool installed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientAppListResponse_App_DLC* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientAppListResponse_App : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientAppListResponse_App();
  virtual ~CMsgClientGetClientAppListResponse_App();

  CMsgClientGetClientAppListResponse_App(const CMsgClientGetClientAppListResponse_App& from);

  inline CMsgClientGetClientAppListResponse_App& operator=(const CMsgClientGetClientAppListResponse_App& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientAppListResponse_App& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientAppListResponse_App* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientAppListResponse_App* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientAppListResponse_App* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientAppListResponse_App& from);
  void MergeFrom(const CMsgClientGetClientAppListResponse_App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientGetClientAppListResponse_App_DLC DLC;

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional string category = 2;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 2;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  inline void set_allocated_category(::std::string* category);

  // optional string app_type = 10;
  inline bool has_app_type() const;
  inline void clear_app_type();
  static const int kAppTypeFieldNumber = 10;
  inline const ::std::string& app_type() const;
  inline void set_app_type(const ::std::string& value);
  inline void set_app_type(const char* value);
  inline void set_app_type(const char* value, size_t size);
  inline ::std::string* mutable_app_type();
  inline ::std::string* release_app_type();
  inline void set_allocated_app_type(::std::string* app_type);

  // optional bool favorite = 3;
  inline bool has_favorite() const;
  inline void clear_favorite();
  static const int kFavoriteFieldNumber = 3;
  inline bool favorite() const;
  inline void set_favorite(bool value);

  // optional bool installed = 4;
  inline bool has_installed() const;
  inline void clear_installed();
  static const int kInstalledFieldNumber = 4;
  inline bool installed() const;
  inline void set_installed(bool value);

  // optional bool auto_update = 5;
  inline bool has_auto_update() const;
  inline void clear_auto_update();
  static const int kAutoUpdateFieldNumber = 5;
  inline bool auto_update() const;
  inline void set_auto_update(bool value);

  // optional uint64 bytes_downloaded = 6;
  inline bool has_bytes_downloaded() const;
  inline void clear_bytes_downloaded();
  static const int kBytesDownloadedFieldNumber = 6;
  inline ::google::protobuf::uint64 bytes_downloaded() const;
  inline void set_bytes_downloaded(::google::protobuf::uint64 value);

  // optional uint64 bytes_needed = 7;
  inline bool has_bytes_needed() const;
  inline void clear_bytes_needed();
  static const int kBytesNeededFieldNumber = 7;
  inline ::google::protobuf::uint64 bytes_needed() const;
  inline void set_bytes_needed(::google::protobuf::uint64 value);

  // optional uint32 bytes_download_rate = 8;
  inline bool has_bytes_download_rate() const;
  inline void clear_bytes_download_rate();
  static const int kBytesDownloadRateFieldNumber = 8;
  inline ::google::protobuf::uint32 bytes_download_rate() const;
  inline void set_bytes_download_rate(::google::protobuf::uint32 value);

  // optional bool download_paused = 11;
  inline bool has_download_paused() const;
  inline void clear_download_paused();
  static const int kDownloadPausedFieldNumber = 11;
  inline bool download_paused() const;
  inline void set_download_paused(bool value);

  // optional uint32 num_downloading = 12;
  inline bool has_num_downloading() const;
  inline void clear_num_downloading();
  static const int kNumDownloadingFieldNumber = 12;
  inline ::google::protobuf::uint32 num_downloading() const;
  inline void set_num_downloading(::google::protobuf::uint32 value);

  // optional uint32 num_paused = 13;
  inline bool has_num_paused() const;
  inline void clear_num_paused();
  static const int kNumPausedFieldNumber = 13;
  inline ::google::protobuf::uint32 num_paused() const;
  inline void set_num_paused(::google::protobuf::uint32 value);

  // optional bool changing = 14;
  inline bool has_changing() const;
  inline void clear_changing();
  static const int kChangingFieldNumber = 14;
  inline bool changing() const;
  inline void set_changing(bool value);

  // optional bool available_on_platform = 15;
  inline bool has_available_on_platform() const;
  inline void clear_available_on_platform();
  static const int kAvailableOnPlatformFieldNumber = 15;
  inline bool available_on_platform() const;
  inline void set_available_on_platform(bool value);

  // repeated .Sc.CMsgClientGetClientAppListResponse.App.DLC dlcs = 9;
  inline int dlcs_size() const;
  inline void clear_dlcs();
  static const int kDlcsFieldNumber = 9;
  inline const ::Sc::CMsgClientGetClientAppListResponse_App_DLC& dlcs(int index) const;
  inline ::Sc::CMsgClientGetClientAppListResponse_App_DLC* mutable_dlcs(int index);
  inline ::Sc::CMsgClientGetClientAppListResponse_App_DLC* add_dlcs();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App_DLC >&
      dlcs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App_DLC >*
      mutable_dlcs();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientAppListResponse.App)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_app_type();
  inline void clear_has_app_type();
  inline void set_has_favorite();
  inline void clear_has_favorite();
  inline void set_has_installed();
  inline void clear_has_installed();
  inline void set_has_auto_update();
  inline void clear_has_auto_update();
  inline void set_has_bytes_downloaded();
  inline void clear_has_bytes_downloaded();
  inline void set_has_bytes_needed();
  inline void clear_has_bytes_needed();
  inline void set_has_bytes_download_rate();
  inline void clear_has_bytes_download_rate();
  inline void set_has_download_paused();
  inline void clear_has_download_paused();
  inline void set_has_num_downloading();
  inline void clear_has_num_downloading();
  inline void set_has_num_paused();
  inline void clear_has_num_paused();
  inline void set_has_changing();
  inline void clear_has_changing();
  inline void set_has_available_on_platform();
  inline void clear_has_available_on_platform();

  ::std::string* category_;
  ::std::string* app_type_;
  ::google::protobuf::uint32 appid_;
  bool favorite_;
  bool installed_;
  bool auto_update_;
  bool download_paused_;
  ::google::protobuf::uint64 bytes_downloaded_;
  ::google::protobuf::uint64 bytes_needed_;
  ::google::protobuf::uint32 bytes_download_rate_;
  ::google::protobuf::uint32 num_downloading_;
  ::google::protobuf::uint32 num_paused_;
  bool changing_;
  bool available_on_platform_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App_DLC > dlcs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientAppListResponse_App* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClientAppListResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClientAppListResponse();
  virtual ~CMsgClientGetClientAppListResponse();

  CMsgClientGetClientAppListResponse(const CMsgClientGetClientAppListResponse& from);

  inline CMsgClientGetClientAppListResponse& operator=(const CMsgClientGetClientAppListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClientAppListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClientAppListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClientAppListResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClientAppListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClientAppListResponse& from);
  void MergeFrom(const CMsgClientGetClientAppListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientGetClientAppListResponse_App App;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientGetClientAppListResponse.App apps = 1;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 1;
  inline const ::Sc::CMsgClientGetClientAppListResponse_App& apps(int index) const;
  inline ::Sc::CMsgClientGetClientAppListResponse_App* mutable_apps(int index);
  inline ::Sc::CMsgClientGetClientAppListResponse_App* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App >*
      mutable_apps();

  // optional uint64 bytes_available = 2;
  inline bool has_bytes_available() const;
  inline void clear_bytes_available();
  static const int kBytesAvailableFieldNumber = 2;
  inline ::google::protobuf::uint64 bytes_available() const;
  inline void set_bytes_available(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClientAppListResponse)
 private:
  inline void set_has_bytes_available();
  inline void clear_has_bytes_available();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App > apps_;
  ::google::protobuf::uint64 bytes_available_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClientAppListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientInstallClientApp : public ::google::protobuf::MessageLite {
 public:
  CMsgClientInstallClientApp();
  virtual ~CMsgClientInstallClientApp();

  CMsgClientInstallClientApp(const CMsgClientInstallClientApp& from);

  inline CMsgClientInstallClientApp& operator=(const CMsgClientInstallClientApp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientInstallClientApp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientInstallClientApp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientInstallClientApp* other);

  // implements Message ----------------------------------------------

  CMsgClientInstallClientApp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientInstallClientApp& from);
  void MergeFrom(const CMsgClientInstallClientApp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientInstallClientApp)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::uint32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientInstallClientApp* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientInstallClientAppResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientInstallClientAppResponse();
  virtual ~CMsgClientInstallClientAppResponse();

  CMsgClientInstallClientAppResponse(const CMsgClientInstallClientAppResponse& from);

  inline CMsgClientInstallClientAppResponse& operator=(const CMsgClientInstallClientAppResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientInstallClientAppResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientInstallClientAppResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientInstallClientAppResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientInstallClientAppResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientInstallClientAppResponse& from);
  void MergeFrom(const CMsgClientInstallClientAppResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientInstallClientAppResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientInstallClientAppResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUninstallClientApp : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUninstallClientApp();
  virtual ~CMsgClientUninstallClientApp();

  CMsgClientUninstallClientApp(const CMsgClientUninstallClientApp& from);

  inline CMsgClientUninstallClientApp& operator=(const CMsgClientUninstallClientApp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUninstallClientApp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUninstallClientApp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUninstallClientApp* other);

  // implements Message ----------------------------------------------

  CMsgClientUninstallClientApp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUninstallClientApp& from);
  void MergeFrom(const CMsgClientUninstallClientApp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUninstallClientApp)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::uint32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUninstallClientApp* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUninstallClientAppResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUninstallClientAppResponse();
  virtual ~CMsgClientUninstallClientAppResponse();

  CMsgClientUninstallClientAppResponse(const CMsgClientUninstallClientAppResponse& from);

  inline CMsgClientUninstallClientAppResponse& operator=(const CMsgClientUninstallClientAppResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUninstallClientAppResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUninstallClientAppResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUninstallClientAppResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUninstallClientAppResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUninstallClientAppResponse& from);
  void MergeFrom(const CMsgClientUninstallClientAppResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUninstallClientAppResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUninstallClientAppResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSetClientAppUpdateState : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSetClientAppUpdateState();
  virtual ~CMsgClientSetClientAppUpdateState();

  CMsgClientSetClientAppUpdateState(const CMsgClientSetClientAppUpdateState& from);

  inline CMsgClientSetClientAppUpdateState& operator=(const CMsgClientSetClientAppUpdateState& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSetClientAppUpdateState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSetClientAppUpdateState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSetClientAppUpdateState* other);

  // implements Message ----------------------------------------------

  CMsgClientSetClientAppUpdateState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSetClientAppUpdateState& from);
  void MergeFrom(const CMsgClientSetClientAppUpdateState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional bool update = 2;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 2;
  inline bool update() const;
  inline void set_update(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSetClientAppUpdateState)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_update();
  inline void clear_has_update();

  ::google::protobuf::uint32 appid_;
  bool update_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSetClientAppUpdateState* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSetClientAppUpdateStateResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSetClientAppUpdateStateResponse();
  virtual ~CMsgClientSetClientAppUpdateStateResponse();

  CMsgClientSetClientAppUpdateStateResponse(const CMsgClientSetClientAppUpdateStateResponse& from);

  inline CMsgClientSetClientAppUpdateStateResponse& operator=(const CMsgClientSetClientAppUpdateStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSetClientAppUpdateStateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSetClientAppUpdateStateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSetClientAppUpdateStateResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientSetClientAppUpdateStateResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSetClientAppUpdateStateResponse& from);
  void MergeFrom(const CMsgClientSetClientAppUpdateStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSetClientAppUpdateStateResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSetClientAppUpdateStateResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSUploadFileRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSUploadFileRequest();
  virtual ~CMsgClientUFSUploadFileRequest();

  CMsgClientUFSUploadFileRequest(const CMsgClientUFSUploadFileRequest& from);

  inline CMsgClientUFSUploadFileRequest& operator=(const CMsgClientUFSUploadFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSUploadFileRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSUploadFileRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSUploadFileRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSUploadFileRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSUploadFileRequest& from);
  void MergeFrom(const CMsgClientUFSUploadFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // optional uint32 raw_file_size = 3;
  inline bool has_raw_file_size() const;
  inline void clear_raw_file_size();
  static const int kRawFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 raw_file_size() const;
  inline void set_raw_file_size(::google::protobuf::uint32 value);

  // optional bytes sha_file = 4;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 4;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint64 time_stamp = 5;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::uint64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint64 value);

  // optional string file_name = 6;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 6;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional uint32 platforms_to_sync_deprecated = 7;
  inline bool has_platforms_to_sync_deprecated() const;
  inline void clear_platforms_to_sync_deprecated();
  static const int kPlatformsToSyncDeprecatedFieldNumber = 7;
  inline ::google::protobuf::uint32 platforms_to_sync_deprecated() const;
  inline void set_platforms_to_sync_deprecated(::google::protobuf::uint32 value);

  // optional uint32 platforms_to_sync = 8 [default = 4294967295];
  inline bool has_platforms_to_sync() const;
  inline void clear_platforms_to_sync();
  static const int kPlatformsToSyncFieldNumber = 8;
  inline ::google::protobuf::uint32 platforms_to_sync() const;
  inline void set_platforms_to_sync(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSUploadFileRequest)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_raw_file_size();
  inline void clear_has_raw_file_size();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_platforms_to_sync_deprecated();
  inline void clear_has_platforms_to_sync_deprecated();
  inline void set_has_platforms_to_sync();
  inline void clear_has_platforms_to_sync();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 file_size_;
  ::std::string* sha_file_;
  ::google::protobuf::uint64 time_stamp_;
  ::google::protobuf::uint32 raw_file_size_;
  ::google::protobuf::uint32 platforms_to_sync_deprecated_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 platforms_to_sync_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSUploadFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSUploadFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSUploadFileResponse();
  virtual ~CMsgClientUFSUploadFileResponse();

  CMsgClientUFSUploadFileResponse(const CMsgClientUFSUploadFileResponse& from);

  inline CMsgClientUFSUploadFileResponse& operator=(const CMsgClientUFSUploadFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSUploadFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSUploadFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSUploadFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSUploadFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSUploadFileResponse& from);
  void MergeFrom(const CMsgClientUFSUploadFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional bytes sha_file = 2;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 2;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSUploadFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();

  ::std::string* sha_file_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSUploadFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSFileChunk : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSFileChunk();
  virtual ~CMsgClientUFSFileChunk();

  CMsgClientUFSFileChunk(const CMsgClientUFSFileChunk& from);

  inline CMsgClientUFSFileChunk& operator=(const CMsgClientUFSFileChunk& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSFileChunk& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSFileChunk* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSFileChunk* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSFileChunk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSFileChunk& from);
  void MergeFrom(const CMsgClientUFSFileChunk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha_file = 1;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 1;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint32 file_start = 2;
  inline bool has_file_start() const;
  inline void clear_file_start();
  static const int kFileStartFieldNumber = 2;
  inline ::google::protobuf::uint32 file_start() const;
  inline void set_file_start(::google::protobuf::uint32 value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSFileChunk)
 private:
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_file_start();
  inline void clear_has_file_start();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* sha_file_;
  ::std::string* data_;
  ::google::protobuf::uint32 file_start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSFileChunk* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSTransferHeartbeat : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSTransferHeartbeat();
  virtual ~CMsgClientUFSTransferHeartbeat();

  CMsgClientUFSTransferHeartbeat(const CMsgClientUFSTransferHeartbeat& from);

  inline CMsgClientUFSTransferHeartbeat& operator=(const CMsgClientUFSTransferHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSTransferHeartbeat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSTransferHeartbeat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSTransferHeartbeat* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSTransferHeartbeat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSTransferHeartbeat& from);
  void MergeFrom(const CMsgClientUFSTransferHeartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSTransferHeartbeat)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSTransferHeartbeat* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSUploadFileFinished : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSUploadFileFinished();
  virtual ~CMsgClientUFSUploadFileFinished();

  CMsgClientUFSUploadFileFinished(const CMsgClientUFSUploadFileFinished& from);

  inline CMsgClientUFSUploadFileFinished& operator=(const CMsgClientUFSUploadFileFinished& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSUploadFileFinished& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSUploadFileFinished* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSUploadFileFinished* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSUploadFileFinished* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSUploadFileFinished& from);
  void MergeFrom(const CMsgClientUFSUploadFileFinished& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional bytes sha_file = 2;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 2;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSUploadFileFinished)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();

  ::std::string* sha_file_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSUploadFileFinished* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSDeleteFileRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSDeleteFileRequest();
  virtual ~CMsgClientUFSDeleteFileRequest();

  CMsgClientUFSDeleteFileRequest(const CMsgClientUFSDeleteFileRequest& from);

  inline CMsgClientUFSDeleteFileRequest& operator=(const CMsgClientUFSDeleteFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSDeleteFileRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSDeleteFileRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSDeleteFileRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSDeleteFileRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSDeleteFileRequest& from);
  void MergeFrom(const CMsgClientUFSDeleteFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional bool is_explicit_delete = 3;
  inline bool has_is_explicit_delete() const;
  inline void clear_is_explicit_delete();
  static const int kIsExplicitDeleteFieldNumber = 3;
  inline bool is_explicit_delete() const;
  inline void set_is_explicit_delete(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSDeleteFileRequest)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_is_explicit_delete();
  inline void clear_has_is_explicit_delete();

  ::std::string* file_name_;
  ::google::protobuf::uint32 app_id_;
  bool is_explicit_delete_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSDeleteFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSDeleteFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSDeleteFileResponse();
  virtual ~CMsgClientUFSDeleteFileResponse();

  CMsgClientUFSDeleteFileResponse(const CMsgClientUFSDeleteFileResponse& from);

  inline CMsgClientUFSDeleteFileResponse& operator=(const CMsgClientUFSDeleteFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSDeleteFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSDeleteFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSDeleteFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSDeleteFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSDeleteFileResponse& from);
  void MergeFrom(const CMsgClientUFSDeleteFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSDeleteFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::std::string* file_name_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSDeleteFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetFileListForApp : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetFileListForApp();
  virtual ~CMsgClientUFSGetFileListForApp();

  CMsgClientUFSGetFileListForApp(const CMsgClientUFSGetFileListForApp& from);

  inline CMsgClientUFSGetFileListForApp& operator=(const CMsgClientUFSGetFileListForApp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetFileListForApp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetFileListForApp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetFileListForApp* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetFileListForApp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetFileListForApp& from);
  void MergeFrom(const CMsgClientUFSGetFileListForApp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 apps_to_query = 1;
  inline int apps_to_query_size() const;
  inline void clear_apps_to_query();
  static const int kAppsToQueryFieldNumber = 1;
  inline ::google::protobuf::uint32 apps_to_query(int index) const;
  inline void set_apps_to_query(int index, ::google::protobuf::uint32 value);
  inline void add_apps_to_query(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      apps_to_query() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_apps_to_query();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetFileListForApp)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > apps_to_query_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetFileListForApp* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetFileListForAppResponse_File : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetFileListForAppResponse_File();
  virtual ~CMsgClientUFSGetFileListForAppResponse_File();

  CMsgClientUFSGetFileListForAppResponse_File(const CMsgClientUFSGetFileListForAppResponse_File& from);

  inline CMsgClientUFSGetFileListForAppResponse_File& operator=(const CMsgClientUFSGetFileListForAppResponse_File& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetFileListForAppResponse_File& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetFileListForAppResponse_File* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetFileListForAppResponse_File* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetFileListForAppResponse_File* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetFileListForAppResponse_File& from);
  void MergeFrom(const CMsgClientUFSGetFileListForAppResponse_File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional bytes sha_file = 3;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 3;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint64 time_stamp = 4;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 4;
  inline ::google::protobuf::uint64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint64 value);

  // optional uint32 raw_file_size = 5;
  inline bool has_raw_file_size() const;
  inline void clear_raw_file_size();
  static const int kRawFileSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 raw_file_size() const;
  inline void set_raw_file_size(::google::protobuf::uint32 value);

  // optional bool is_explicit_delete = 6;
  inline bool has_is_explicit_delete() const;
  inline void clear_is_explicit_delete();
  static const int kIsExplicitDeleteFieldNumber = 6;
  inline bool is_explicit_delete() const;
  inline void set_is_explicit_delete(bool value);

  // optional uint32 platforms_to_sync = 7;
  inline bool has_platforms_to_sync() const;
  inline void clear_platforms_to_sync();
  static const int kPlatformsToSyncFieldNumber = 7;
  inline ::google::protobuf::uint32 platforms_to_sync() const;
  inline void set_platforms_to_sync(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetFileListForAppResponse.File)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_raw_file_size();
  inline void clear_has_raw_file_size();
  inline void set_has_is_explicit_delete();
  inline void clear_has_is_explicit_delete();
  inline void set_has_platforms_to_sync();
  inline void clear_has_platforms_to_sync();

  ::std::string* file_name_;
  ::std::string* sha_file_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 raw_file_size_;
  ::google::protobuf::uint64 time_stamp_;
  bool is_explicit_delete_;
  ::google::protobuf::uint32 platforms_to_sync_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetFileListForAppResponse_File* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetFileListForAppResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetFileListForAppResponse();
  virtual ~CMsgClientUFSGetFileListForAppResponse();

  CMsgClientUFSGetFileListForAppResponse(const CMsgClientUFSGetFileListForAppResponse& from);

  inline CMsgClientUFSGetFileListForAppResponse& operator=(const CMsgClientUFSGetFileListForAppResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetFileListForAppResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetFileListForAppResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetFileListForAppResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetFileListForAppResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetFileListForAppResponse& from);
  void MergeFrom(const CMsgClientUFSGetFileListForAppResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUFSGetFileListForAppResponse_File File;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientUFSGetFileListForAppResponse.File files = 1;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 1;
  inline const ::Sc::CMsgClientUFSGetFileListForAppResponse_File& files(int index) const;
  inline ::Sc::CMsgClientUFSGetFileListForAppResponse_File* mutable_files(int index);
  inline ::Sc::CMsgClientUFSGetFileListForAppResponse_File* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUFSGetFileListForAppResponse_File >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUFSGetFileListForAppResponse_File >*
      mutable_files();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetFileListForAppResponse)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUFSGetFileListForAppResponse_File > files_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetFileListForAppResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSDownloadRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSDownloadRequest();
  virtual ~CMsgClientUFSDownloadRequest();

  CMsgClientUFSDownloadRequest(const CMsgClientUFSDownloadRequest& from);

  inline CMsgClientUFSDownloadRequest& operator=(const CMsgClientUFSDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSDownloadRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSDownloadRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSDownloadRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSDownloadRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSDownloadRequest& from);
  void MergeFrom(const CMsgClientUFSDownloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSDownloadRequest)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::std::string* file_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSDownloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSDownloadResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSDownloadResponse();
  virtual ~CMsgClientUFSDownloadResponse();

  CMsgClientUFSDownloadResponse(const CMsgClientUFSDownloadResponse& from);

  inline CMsgClientUFSDownloadResponse& operator=(const CMsgClientUFSDownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSDownloadResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSDownloadResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSDownloadResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSDownloadResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSDownloadResponse& from);
  void MergeFrom(const CMsgClientUFSDownloadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 file_size = 3;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // optional uint32 raw_file_size = 4;
  inline bool has_raw_file_size() const;
  inline void clear_raw_file_size();
  static const int kRawFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 raw_file_size() const;
  inline void set_raw_file_size(::google::protobuf::uint32 value);

  // optional bytes sha_file = 5;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 5;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint64 time_stamp = 6;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 6;
  inline ::google::protobuf::uint64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint64 value);

  // optional bool is_explicit_delete = 7;
  inline bool has_is_explicit_delete() const;
  inline void clear_is_explicit_delete();
  static const int kIsExplicitDeleteFieldNumber = 7;
  inline bool is_explicit_delete() const;
  inline void set_is_explicit_delete(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSDownloadResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_raw_file_size();
  inline void clear_has_raw_file_size();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_is_explicit_delete();
  inline void clear_has_is_explicit_delete();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 file_size_;
  ::google::protobuf::uint32 raw_file_size_;
  ::std::string* sha_file_;
  ::google::protobuf::uint64 time_stamp_;
  bool is_explicit_delete_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSDownloadResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSLoginRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSLoginRequest();
  virtual ~CMsgClientUFSLoginRequest();

  CMsgClientUFSLoginRequest(const CMsgClientUFSLoginRequest& from);

  inline CMsgClientUFSLoginRequest& operator=(const CMsgClientUFSLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSLoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSLoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSLoginRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSLoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSLoginRequest& from);
  void MergeFrom(const CMsgClientUFSLoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // optional uint64 am_session_token = 2;
  inline bool has_am_session_token() const;
  inline void clear_am_session_token();
  static const int kAmSessionTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 am_session_token() const;
  inline void set_am_session_token(::google::protobuf::uint64 value);

  // repeated uint32 apps = 3;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 3;
  inline ::google::protobuf::uint32 apps(int index) const;
  inline void set_apps(int index, ::google::protobuf::uint32 value);
  inline void add_apps(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      apps() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_apps();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSLoginRequest)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_am_session_token();
  inline void clear_has_am_session_token();

  ::google::protobuf::uint64 am_session_token_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > apps_;
  ::google::protobuf::uint32 protocol_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSLoginResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSLoginResponse();
  virtual ~CMsgClientUFSLoginResponse();

  CMsgClientUFSLoginResponse(const CMsgClientUFSLoginResponse& from);

  inline CMsgClientUFSLoginResponse& operator=(const CMsgClientUFSLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSLoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSLoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSLoginResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSLoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSLoginResponse& from);
  void MergeFrom(const CMsgClientUFSLoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSLoginResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestEncryptedAppTicket : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestEncryptedAppTicket();
  virtual ~CMsgClientRequestEncryptedAppTicket();

  CMsgClientRequestEncryptedAppTicket(const CMsgClientRequestEncryptedAppTicket& from);

  inline CMsgClientRequestEncryptedAppTicket& operator=(const CMsgClientRequestEncryptedAppTicket& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestEncryptedAppTicket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestEncryptedAppTicket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestEncryptedAppTicket* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestEncryptedAppTicket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestEncryptedAppTicket& from);
  void MergeFrom(const CMsgClientRequestEncryptedAppTicket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional bytes userdata = 2;
  inline bool has_userdata() const;
  inline void clear_userdata();
  static const int kUserdataFieldNumber = 2;
  inline const ::std::string& userdata() const;
  inline void set_userdata(const ::std::string& value);
  inline void set_userdata(const char* value);
  inline void set_userdata(const void* value, size_t size);
  inline ::std::string* mutable_userdata();
  inline ::std::string* release_userdata();
  inline void set_allocated_userdata(::std::string* userdata);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestEncryptedAppTicket)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_userdata();
  inline void clear_has_userdata();

  ::std::string* userdata_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestEncryptedAppTicket* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestEncryptedAppTicketResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestEncryptedAppTicketResponse();
  virtual ~CMsgClientRequestEncryptedAppTicketResponse();

  CMsgClientRequestEncryptedAppTicketResponse(const CMsgClientRequestEncryptedAppTicketResponse& from);

  inline CMsgClientRequestEncryptedAppTicketResponse& operator=(const CMsgClientRequestEncryptedAppTicketResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestEncryptedAppTicketResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestEncryptedAppTicketResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestEncryptedAppTicketResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestEncryptedAppTicketResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestEncryptedAppTicketResponse& from);
  void MergeFrom(const CMsgClientRequestEncryptedAppTicketResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 eresult = 2 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional .Sc.EncryptedAppTicket encrypted_app_ticket = 3;
  inline bool has_encrypted_app_ticket() const;
  inline void clear_encrypted_app_ticket();
  static const int kEncryptedAppTicketFieldNumber = 3;
  inline const ::Sc::EncryptedAppTicket& encrypted_app_ticket() const;
  inline ::Sc::EncryptedAppTicket* mutable_encrypted_app_ticket();
  inline ::Sc::EncryptedAppTicket* release_encrypted_app_ticket();
  inline void set_allocated_encrypted_app_ticket(::Sc::EncryptedAppTicket* encrypted_app_ticket);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestEncryptedAppTicketResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_encrypted_app_ticket();
  inline void clear_has_encrypted_app_ticket();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;
  ::Sc::EncryptedAppTicket* encrypted_app_ticket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestEncryptedAppTicketResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestOAuthTokenForApp : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestOAuthTokenForApp();
  virtual ~CMsgClientRequestOAuthTokenForApp();

  CMsgClientRequestOAuthTokenForApp(const CMsgClientRequestOAuthTokenForApp& from);

  inline CMsgClientRequestOAuthTokenForApp& operator=(const CMsgClientRequestOAuthTokenForApp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestOAuthTokenForApp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestOAuthTokenForApp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestOAuthTokenForApp* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestOAuthTokenForApp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestOAuthTokenForApp& from);
  void MergeFrom(const CMsgClientRequestOAuthTokenForApp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string oauth_scope = 2;
  inline bool has_oauth_scope() const;
  inline void clear_oauth_scope();
  static const int kOauthScopeFieldNumber = 2;
  inline const ::std::string& oauth_scope() const;
  inline void set_oauth_scope(const ::std::string& value);
  inline void set_oauth_scope(const char* value);
  inline void set_oauth_scope(const char* value, size_t size);
  inline ::std::string* mutable_oauth_scope();
  inline ::std::string* release_oauth_scope();
  inline void set_allocated_oauth_scope(::std::string* oauth_scope);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestOAuthTokenForApp)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_oauth_scope();
  inline void clear_has_oauth_scope();

  ::std::string* oauth_scope_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestOAuthTokenForApp* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestOAuthTokenForAppResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestOAuthTokenForAppResponse();
  virtual ~CMsgClientRequestOAuthTokenForAppResponse();

  CMsgClientRequestOAuthTokenForAppResponse(const CMsgClientRequestOAuthTokenForAppResponse& from);

  inline CMsgClientRequestOAuthTokenForAppResponse& operator=(const CMsgClientRequestOAuthTokenForAppResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestOAuthTokenForAppResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestOAuthTokenForAppResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestOAuthTokenForAppResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestOAuthTokenForAppResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestOAuthTokenForAppResponse& from);
  void MergeFrom(const CMsgClientRequestOAuthTokenForAppResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 eresult = 2 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string oauth_token = 3;
  inline bool has_oauth_token() const;
  inline void clear_oauth_token();
  static const int kOauthTokenFieldNumber = 3;
  inline const ::std::string& oauth_token() const;
  inline void set_oauth_token(const ::std::string& value);
  inline void set_oauth_token(const char* value);
  inline void set_oauth_token(const char* value, size_t size);
  inline ::std::string* mutable_oauth_token();
  inline ::std::string* release_oauth_token();
  inline void set_allocated_oauth_token(::std::string* oauth_token);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestOAuthTokenForAppResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_oauth_token();
  inline void clear_has_oauth_token();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 eresult_;
  ::std::string* oauth_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestOAuthTokenForAppResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientWalletInfoUpdate : public ::google::protobuf::MessageLite {
 public:
  CMsgClientWalletInfoUpdate();
  virtual ~CMsgClientWalletInfoUpdate();

  CMsgClientWalletInfoUpdate(const CMsgClientWalletInfoUpdate& from);

  inline CMsgClientWalletInfoUpdate& operator=(const CMsgClientWalletInfoUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientWalletInfoUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientWalletInfoUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientWalletInfoUpdate* other);

  // implements Message ----------------------------------------------

  CMsgClientWalletInfoUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientWalletInfoUpdate& from);
  void MergeFrom(const CMsgClientWalletInfoUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool has_wallet = 1;
  inline bool has_has_wallet() const;
  inline void clear_has_wallet();
  static const int kHasWalletFieldNumber = 1;
  inline bool has_wallet() const;
  inline void set_has_wallet(bool value);

  // optional int32 balance = 2;
  inline bool has_balance() const;
  inline void clear_balance();
  static const int kBalanceFieldNumber = 2;
  inline ::google::protobuf::int32 balance() const;
  inline void set_balance(::google::protobuf::int32 value);

  // optional int32 currency = 3;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  inline ::google::protobuf::int32 currency() const;
  inline void set_currency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientWalletInfoUpdate)
 private:
  inline void set_has_has_wallet();
  inline void clear_has_has_wallet();
  inline void set_has_balance();
  inline void clear_has_balance();
  inline void set_has_currency();
  inline void clear_has_currency();

  bool has_wallet_;
  ::google::protobuf::int32 balance_;
  ::google::protobuf::int32 currency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientWalletInfoUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoUpdate : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoUpdate();
  virtual ~CMsgClientAppInfoUpdate();

  CMsgClientAppInfoUpdate(const CMsgClientAppInfoUpdate& from);

  inline CMsgClientAppInfoUpdate& operator=(const CMsgClientAppInfoUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoUpdate* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoUpdate& from);
  void MergeFrom(const CMsgClientAppInfoUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_changenumber = 1;
  inline bool has_last_changenumber() const;
  inline void clear_last_changenumber();
  static const int kLastChangenumberFieldNumber = 1;
  inline ::google::protobuf::uint32 last_changenumber() const;
  inline void set_last_changenumber(::google::protobuf::uint32 value);

  // optional bool send_changelist = 2;
  inline bool has_send_changelist() const;
  inline void clear_send_changelist();
  static const int kSendChangelistFieldNumber = 2;
  inline bool send_changelist() const;
  inline void set_send_changelist(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoUpdate)
 private:
  inline void set_has_last_changenumber();
  inline void clear_has_last_changenumber();
  inline void set_has_send_changelist();
  inline void clear_has_send_changelist();

  ::google::protobuf::uint32 last_changenumber_;
  bool send_changelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoChanges : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoChanges();
  virtual ~CMsgClientAppInfoChanges();

  CMsgClientAppInfoChanges(const CMsgClientAppInfoChanges& from);

  inline CMsgClientAppInfoChanges& operator=(const CMsgClientAppInfoChanges& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoChanges& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoChanges* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoChanges* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoChanges* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoChanges& from);
  void MergeFrom(const CMsgClientAppInfoChanges& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 current_change_number = 1;
  inline bool has_current_change_number() const;
  inline void clear_current_change_number();
  static const int kCurrentChangeNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 current_change_number() const;
  inline void set_current_change_number(::google::protobuf::uint32 value);

  // optional bool force_full_update = 2;
  inline bool has_force_full_update() const;
  inline void clear_force_full_update();
  static const int kForceFullUpdateFieldNumber = 2;
  inline bool force_full_update() const;
  inline void set_force_full_update(bool value);

  // repeated uint32 appIDs = 3;
  inline int appids_size() const;
  inline void clear_appids();
  static const int kAppIDsFieldNumber = 3;
  inline ::google::protobuf::uint32 appids(int index) const;
  inline void set_appids(int index, ::google::protobuf::uint32 value);
  inline void add_appids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      appids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_appids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoChanges)
 private:
  inline void set_has_current_change_number();
  inline void clear_has_current_change_number();
  inline void set_has_force_full_update();
  inline void clear_has_force_full_update();

  ::google::protobuf::uint32 current_change_number_;
  bool force_full_update_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > appids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoChanges* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoRequest_App : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoRequest_App();
  virtual ~CMsgClientAppInfoRequest_App();

  CMsgClientAppInfoRequest_App(const CMsgClientAppInfoRequest_App& from);

  inline CMsgClientAppInfoRequest_App& operator=(const CMsgClientAppInfoRequest_App& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoRequest_App& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoRequest_App* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoRequest_App* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoRequest_App* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoRequest_App& from);
  void MergeFrom(const CMsgClientAppInfoRequest_App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 section_flags = 2;
  inline bool has_section_flags() const;
  inline void clear_section_flags();
  static const int kSectionFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 section_flags() const;
  inline void set_section_flags(::google::protobuf::uint32 value);

  // repeated uint32 section_CRC = 3;
  inline int section_crc_size() const;
  inline void clear_section_crc();
  static const int kSectionCRCFieldNumber = 3;
  inline ::google::protobuf::uint32 section_crc(int index) const;
  inline void set_section_crc(int index, ::google::protobuf::uint32 value);
  inline void add_section_crc(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      section_crc() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_section_crc();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoRequest.App)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_section_flags();
  inline void clear_has_section_flags();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 section_flags_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > section_crc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoRequest_App* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoRequest();
  virtual ~CMsgClientAppInfoRequest();

  CMsgClientAppInfoRequest(const CMsgClientAppInfoRequest& from);

  inline CMsgClientAppInfoRequest& operator=(const CMsgClientAppInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoRequest& from);
  void MergeFrom(const CMsgClientAppInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAppInfoRequest_App App;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientAppInfoRequest.App apps = 1;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 1;
  inline const ::Sc::CMsgClientAppInfoRequest_App& apps(int index) const;
  inline ::Sc::CMsgClientAppInfoRequest_App* mutable_apps(int index);
  inline ::Sc::CMsgClientAppInfoRequest_App* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoRequest_App >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoRequest_App >*
      mutable_apps();

  // optional bool supports_batches = 2 [default = false];
  inline bool has_supports_batches() const;
  inline void clear_supports_batches();
  static const int kSupportsBatchesFieldNumber = 2;
  inline bool supports_batches() const;
  inline void set_supports_batches(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoRequest)
 private:
  inline void set_has_supports_batches();
  inline void clear_has_supports_batches();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoRequest_App > apps_;
  bool supports_batches_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoResponse_App_Section : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoResponse_App_Section();
  virtual ~CMsgClientAppInfoResponse_App_Section();

  CMsgClientAppInfoResponse_App_Section(const CMsgClientAppInfoResponse_App_Section& from);

  inline CMsgClientAppInfoResponse_App_Section& operator=(const CMsgClientAppInfoResponse_App_Section& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoResponse_App_Section& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoResponse_App_Section* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoResponse_App_Section* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoResponse_App_Section* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoResponse_App_Section& from);
  void MergeFrom(const CMsgClientAppInfoResponse_App_Section& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 section_id = 1;
  inline bool has_section_id() const;
  inline void clear_section_id();
  static const int kSectionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 section_id() const;
  inline void set_section_id(::google::protobuf::uint32 value);

  // optional bytes section_kv = 2;
  inline bool has_section_kv() const;
  inline void clear_section_kv();
  static const int kSectionKvFieldNumber = 2;
  inline const ::std::string& section_kv() const;
  inline void set_section_kv(const ::std::string& value);
  inline void set_section_kv(const char* value);
  inline void set_section_kv(const void* value, size_t size);
  inline ::std::string* mutable_section_kv();
  inline ::std::string* release_section_kv();
  inline void set_allocated_section_kv(::std::string* section_kv);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoResponse.App.Section)
 private:
  inline void set_has_section_id();
  inline void clear_has_section_id();
  inline void set_has_section_kv();
  inline void clear_has_section_kv();

  ::std::string* section_kv_;
  ::google::protobuf::uint32 section_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoResponse_App_Section* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoResponse_App : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoResponse_App();
  virtual ~CMsgClientAppInfoResponse_App();

  CMsgClientAppInfoResponse_App(const CMsgClientAppInfoResponse_App& from);

  inline CMsgClientAppInfoResponse_App& operator=(const CMsgClientAppInfoResponse_App& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoResponse_App& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoResponse_App* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoResponse_App* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoResponse_App* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoResponse_App& from);
  void MergeFrom(const CMsgClientAppInfoResponse_App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAppInfoResponse_App_Section Section;

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 change_number = 2;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 change_number() const;
  inline void set_change_number(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientAppInfoResponse.App.Section sections = 3;
  inline int sections_size() const;
  inline void clear_sections();
  static const int kSectionsFieldNumber = 3;
  inline const ::Sc::CMsgClientAppInfoResponse_App_Section& sections(int index) const;
  inline ::Sc::CMsgClientAppInfoResponse_App_Section* mutable_sections(int index);
  inline ::Sc::CMsgClientAppInfoResponse_App_Section* add_sections();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App_Section >&
      sections() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App_Section >*
      mutable_sections();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoResponse.App)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_change_number();
  inline void clear_has_change_number();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 change_number_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App_Section > sections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoResponse_App* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAppInfoResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAppInfoResponse();
  virtual ~CMsgClientAppInfoResponse();

  CMsgClientAppInfoResponse(const CMsgClientAppInfoResponse& from);

  inline CMsgClientAppInfoResponse& operator=(const CMsgClientAppInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAppInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAppInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAppInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientAppInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAppInfoResponse& from);
  void MergeFrom(const CMsgClientAppInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAppInfoResponse_App App;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientAppInfoResponse.App apps = 1;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 1;
  inline const ::Sc::CMsgClientAppInfoResponse_App& apps(int index) const;
  inline ::Sc::CMsgClientAppInfoResponse_App* mutable_apps(int index);
  inline ::Sc::CMsgClientAppInfoResponse_App* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App >*
      mutable_apps();

  // repeated uint32 apps_unknown = 2;
  inline int apps_unknown_size() const;
  inline void clear_apps_unknown();
  static const int kAppsUnknownFieldNumber = 2;
  inline ::google::protobuf::uint32 apps_unknown(int index) const;
  inline void set_apps_unknown(int index, ::google::protobuf::uint32 value);
  inline void add_apps_unknown(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      apps_unknown() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_apps_unknown();

  // optional uint32 apps_pending = 3;
  inline bool has_apps_pending() const;
  inline void clear_apps_pending();
  static const int kAppsPendingFieldNumber = 3;
  inline ::google::protobuf::uint32 apps_pending() const;
  inline void set_apps_pending(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAppInfoResponse)
 private:
  inline void set_has_apps_pending();
  inline void clear_has_apps_pending();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App > apps_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > apps_unknown_;
  ::google::protobuf::uint32 apps_pending_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAppInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPackageInfoRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPackageInfoRequest();
  virtual ~CMsgClientPackageInfoRequest();

  CMsgClientPackageInfoRequest(const CMsgClientPackageInfoRequest& from);

  inline CMsgClientPackageInfoRequest& operator=(const CMsgClientPackageInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPackageInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPackageInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPackageInfoRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientPackageInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPackageInfoRequest& from);
  void MergeFrom(const CMsgClientPackageInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 package_ids = 1;
  inline int package_ids_size() const;
  inline void clear_package_ids();
  static const int kPackageIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 package_ids(int index) const;
  inline void set_package_ids(int index, ::google::protobuf::uint32 value);
  inline void add_package_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      package_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_package_ids();

  // optional bool meta_data_only = 2;
  inline bool has_meta_data_only() const;
  inline void clear_meta_data_only();
  static const int kMetaDataOnlyFieldNumber = 2;
  inline bool meta_data_only() const;
  inline void set_meta_data_only(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPackageInfoRequest)
 private:
  inline void set_has_meta_data_only();
  inline void clear_has_meta_data_only();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > package_ids_;
  bool meta_data_only_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPackageInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPackageInfoResponse_Package : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPackageInfoResponse_Package();
  virtual ~CMsgClientPackageInfoResponse_Package();

  CMsgClientPackageInfoResponse_Package(const CMsgClientPackageInfoResponse_Package& from);

  inline CMsgClientPackageInfoResponse_Package& operator=(const CMsgClientPackageInfoResponse_Package& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPackageInfoResponse_Package& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPackageInfoResponse_Package* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPackageInfoResponse_Package* other);

  // implements Message ----------------------------------------------

  CMsgClientPackageInfoResponse_Package* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPackageInfoResponse_Package& from);
  void MergeFrom(const CMsgClientPackageInfoResponse_Package& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 package_id = 1;
  inline bool has_package_id() const;
  inline void clear_package_id();
  static const int kPackageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 package_id() const;
  inline void set_package_id(::google::protobuf::uint32 value);

  // optional uint32 change_number = 2;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 change_number() const;
  inline void set_change_number(::google::protobuf::uint32 value);

  // optional bytes sha = 3;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 3;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  inline ::std::string* release_sha();
  inline void set_allocated_sha(::std::string* sha);

  // optional bytes buffer = 4;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 4;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  inline void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPackageInfoResponse.Package)
 private:
  inline void set_has_package_id();
  inline void clear_has_package_id();
  inline void set_has_change_number();
  inline void clear_has_change_number();
  inline void set_has_sha();
  inline void clear_has_sha();
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::uint32 package_id_;
  ::google::protobuf::uint32 change_number_;
  ::std::string* sha_;
  ::std::string* buffer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPackageInfoResponse_Package* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPackageInfoResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPackageInfoResponse();
  virtual ~CMsgClientPackageInfoResponse();

  CMsgClientPackageInfoResponse(const CMsgClientPackageInfoResponse& from);

  inline CMsgClientPackageInfoResponse& operator=(const CMsgClientPackageInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPackageInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPackageInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPackageInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientPackageInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPackageInfoResponse& from);
  void MergeFrom(const CMsgClientPackageInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientPackageInfoResponse_Package Package;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientPackageInfoResponse.Package packages = 1;
  inline int packages_size() const;
  inline void clear_packages();
  static const int kPackagesFieldNumber = 1;
  inline const ::Sc::CMsgClientPackageInfoResponse_Package& packages(int index) const;
  inline ::Sc::CMsgClientPackageInfoResponse_Package* mutable_packages(int index);
  inline ::Sc::CMsgClientPackageInfoResponse_Package* add_packages();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPackageInfoResponse_Package >&
      packages() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPackageInfoResponse_Package >*
      mutable_packages();

  // repeated uint32 packages_unknown = 2;
  inline int packages_unknown_size() const;
  inline void clear_packages_unknown();
  static const int kPackagesUnknownFieldNumber = 2;
  inline ::google::protobuf::uint32 packages_unknown(int index) const;
  inline void set_packages_unknown(int index, ::google::protobuf::uint32 value);
  inline void add_packages_unknown(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      packages_unknown() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_packages_unknown();

  // optional uint32 packages_pending = 3;
  inline bool has_packages_pending() const;
  inline void clear_packages_pending();
  static const int kPackagesPendingFieldNumber = 3;
  inline ::google::protobuf::uint32 packages_pending() const;
  inline void set_packages_pending(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPackageInfoResponse)
 private:
  inline void set_has_packages_pending();
  inline void clear_has_packages_pending();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPackageInfoResponse_Package > packages_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > packages_unknown_;
  ::google::protobuf::uint32 packages_pending_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPackageInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSChangesSinceRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSChangesSinceRequest();
  virtual ~CMsgPICSChangesSinceRequest();

  CMsgPICSChangesSinceRequest(const CMsgPICSChangesSinceRequest& from);

  inline CMsgPICSChangesSinceRequest& operator=(const CMsgPICSChangesSinceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSChangesSinceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSChangesSinceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSChangesSinceRequest* other);

  // implements Message ----------------------------------------------

  CMsgPICSChangesSinceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSChangesSinceRequest& from);
  void MergeFrom(const CMsgPICSChangesSinceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 since_change_number = 1;
  inline bool has_since_change_number() const;
  inline void clear_since_change_number();
  static const int kSinceChangeNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 since_change_number() const;
  inline void set_since_change_number(::google::protobuf::uint32 value);

  // optional bool send_app_info_changes = 2;
  inline bool has_send_app_info_changes() const;
  inline void clear_send_app_info_changes();
  static const int kSendAppInfoChangesFieldNumber = 2;
  inline bool send_app_info_changes() const;
  inline void set_send_app_info_changes(bool value);

  // optional bool send_package_info_changes = 3;
  inline bool has_send_package_info_changes() const;
  inline void clear_send_package_info_changes();
  static const int kSendPackageInfoChangesFieldNumber = 3;
  inline bool send_package_info_changes() const;
  inline void set_send_package_info_changes(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSChangesSinceRequest)
 private:
  inline void set_has_since_change_number();
  inline void clear_has_since_change_number();
  inline void set_has_send_app_info_changes();
  inline void clear_has_send_app_info_changes();
  inline void set_has_send_package_info_changes();
  inline void clear_has_send_package_info_changes();

  ::google::protobuf::uint32 since_change_number_;
  bool send_app_info_changes_;
  bool send_package_info_changes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSChangesSinceRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSChangesSinceResponse_PackageChange : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSChangesSinceResponse_PackageChange();
  virtual ~CMsgPICSChangesSinceResponse_PackageChange();

  CMsgPICSChangesSinceResponse_PackageChange(const CMsgPICSChangesSinceResponse_PackageChange& from);

  inline CMsgPICSChangesSinceResponse_PackageChange& operator=(const CMsgPICSChangesSinceResponse_PackageChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSChangesSinceResponse_PackageChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSChangesSinceResponse_PackageChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSChangesSinceResponse_PackageChange* other);

  // implements Message ----------------------------------------------

  CMsgPICSChangesSinceResponse_PackageChange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSChangesSinceResponse_PackageChange& from);
  void MergeFrom(const CMsgPICSChangesSinceResponse_PackageChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 packageid = 1;
  inline bool has_packageid() const;
  inline void clear_packageid();
  static const int kPackageidFieldNumber = 1;
  inline ::google::protobuf::uint32 packageid() const;
  inline void set_packageid(::google::protobuf::uint32 value);

  // optional uint32 change_number = 2;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 change_number() const;
  inline void set_change_number(::google::protobuf::uint32 value);

  // optional bool needs_token = 3;
  inline bool has_needs_token() const;
  inline void clear_needs_token();
  static const int kNeedsTokenFieldNumber = 3;
  inline bool needs_token() const;
  inline void set_needs_token(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSChangesSinceResponse.PackageChange)
 private:
  inline void set_has_packageid();
  inline void clear_has_packageid();
  inline void set_has_change_number();
  inline void clear_has_change_number();
  inline void set_has_needs_token();
  inline void clear_has_needs_token();

  ::google::protobuf::uint32 packageid_;
  ::google::protobuf::uint32 change_number_;
  bool needs_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSChangesSinceResponse_PackageChange* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSChangesSinceResponse_AppChange : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSChangesSinceResponse_AppChange();
  virtual ~CMsgPICSChangesSinceResponse_AppChange();

  CMsgPICSChangesSinceResponse_AppChange(const CMsgPICSChangesSinceResponse_AppChange& from);

  inline CMsgPICSChangesSinceResponse_AppChange& operator=(const CMsgPICSChangesSinceResponse_AppChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSChangesSinceResponse_AppChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSChangesSinceResponse_AppChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSChangesSinceResponse_AppChange* other);

  // implements Message ----------------------------------------------

  CMsgPICSChangesSinceResponse_AppChange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSChangesSinceResponse_AppChange& from);
  void MergeFrom(const CMsgPICSChangesSinceResponse_AppChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional uint32 change_number = 2;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 change_number() const;
  inline void set_change_number(::google::protobuf::uint32 value);

  // optional bool needs_token = 3;
  inline bool has_needs_token() const;
  inline void clear_needs_token();
  static const int kNeedsTokenFieldNumber = 3;
  inline bool needs_token() const;
  inline void set_needs_token(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSChangesSinceResponse.AppChange)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_change_number();
  inline void clear_has_change_number();
  inline void set_has_needs_token();
  inline void clear_has_needs_token();

  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 change_number_;
  bool needs_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSChangesSinceResponse_AppChange* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSChangesSinceResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSChangesSinceResponse();
  virtual ~CMsgPICSChangesSinceResponse();

  CMsgPICSChangesSinceResponse(const CMsgPICSChangesSinceResponse& from);

  inline CMsgPICSChangesSinceResponse& operator=(const CMsgPICSChangesSinceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSChangesSinceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSChangesSinceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSChangesSinceResponse* other);

  // implements Message ----------------------------------------------

  CMsgPICSChangesSinceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSChangesSinceResponse& from);
  void MergeFrom(const CMsgPICSChangesSinceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgPICSChangesSinceResponse_PackageChange PackageChange;
  typedef CMsgPICSChangesSinceResponse_AppChange AppChange;

  // accessors -------------------------------------------------------

  // optional uint32 current_change_number = 1;
  inline bool has_current_change_number() const;
  inline void clear_current_change_number();
  static const int kCurrentChangeNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 current_change_number() const;
  inline void set_current_change_number(::google::protobuf::uint32 value);

  // optional uint32 since_change_number = 2;
  inline bool has_since_change_number() const;
  inline void clear_since_change_number();
  static const int kSinceChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 since_change_number() const;
  inline void set_since_change_number(::google::protobuf::uint32 value);

  // optional bool force_full_update = 3;
  inline bool has_force_full_update() const;
  inline void clear_force_full_update();
  static const int kForceFullUpdateFieldNumber = 3;
  inline bool force_full_update() const;
  inline void set_force_full_update(bool value);

  // repeated .Sc.CMsgPICSChangesSinceResponse.PackageChange package_changes = 4;
  inline int package_changes_size() const;
  inline void clear_package_changes();
  static const int kPackageChangesFieldNumber = 4;
  inline const ::Sc::CMsgPICSChangesSinceResponse_PackageChange& package_changes(int index) const;
  inline ::Sc::CMsgPICSChangesSinceResponse_PackageChange* mutable_package_changes(int index);
  inline ::Sc::CMsgPICSChangesSinceResponse_PackageChange* add_package_changes();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_PackageChange >&
      package_changes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_PackageChange >*
      mutable_package_changes();

  // repeated .Sc.CMsgPICSChangesSinceResponse.AppChange app_changes = 5;
  inline int app_changes_size() const;
  inline void clear_app_changes();
  static const int kAppChangesFieldNumber = 5;
  inline const ::Sc::CMsgPICSChangesSinceResponse_AppChange& app_changes(int index) const;
  inline ::Sc::CMsgPICSChangesSinceResponse_AppChange* mutable_app_changes(int index);
  inline ::Sc::CMsgPICSChangesSinceResponse_AppChange* add_app_changes();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_AppChange >&
      app_changes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_AppChange >*
      mutable_app_changes();

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSChangesSinceResponse)
 private:
  inline void set_has_current_change_number();
  inline void clear_has_current_change_number();
  inline void set_has_since_change_number();
  inline void clear_has_since_change_number();
  inline void set_has_force_full_update();
  inline void clear_has_force_full_update();

  ::google::protobuf::uint32 current_change_number_;
  ::google::protobuf::uint32 since_change_number_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_PackageChange > package_changes_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_AppChange > app_changes_;
  bool force_full_update_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSChangesSinceResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSProductInfoRequest_AppInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSProductInfoRequest_AppInfo();
  virtual ~CMsgPICSProductInfoRequest_AppInfo();

  CMsgPICSProductInfoRequest_AppInfo(const CMsgPICSProductInfoRequest_AppInfo& from);

  inline CMsgPICSProductInfoRequest_AppInfo& operator=(const CMsgPICSProductInfoRequest_AppInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSProductInfoRequest_AppInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSProductInfoRequest_AppInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSProductInfoRequest_AppInfo* other);

  // implements Message ----------------------------------------------

  CMsgPICSProductInfoRequest_AppInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSProductInfoRequest_AppInfo& from);
  void MergeFrom(const CMsgPICSProductInfoRequest_AppInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional uint64 access_token = 2;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 access_token() const;
  inline void set_access_token(::google::protobuf::uint64 value);

  // optional bool only_public = 3;
  inline bool has_only_public() const;
  inline void clear_only_public();
  static const int kOnlyPublicFieldNumber = 3;
  inline bool only_public() const;
  inline void set_only_public(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSProductInfoRequest.AppInfo)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_only_public();
  inline void clear_has_only_public();

  ::google::protobuf::uint64 access_token_;
  ::google::protobuf::uint32 appid_;
  bool only_public_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSProductInfoRequest_AppInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSProductInfoRequest_PackageInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSProductInfoRequest_PackageInfo();
  virtual ~CMsgPICSProductInfoRequest_PackageInfo();

  CMsgPICSProductInfoRequest_PackageInfo(const CMsgPICSProductInfoRequest_PackageInfo& from);

  inline CMsgPICSProductInfoRequest_PackageInfo& operator=(const CMsgPICSProductInfoRequest_PackageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSProductInfoRequest_PackageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSProductInfoRequest_PackageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSProductInfoRequest_PackageInfo* other);

  // implements Message ----------------------------------------------

  CMsgPICSProductInfoRequest_PackageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSProductInfoRequest_PackageInfo& from);
  void MergeFrom(const CMsgPICSProductInfoRequest_PackageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 packageid = 1;
  inline bool has_packageid() const;
  inline void clear_packageid();
  static const int kPackageidFieldNumber = 1;
  inline ::google::protobuf::uint32 packageid() const;
  inline void set_packageid(::google::protobuf::uint32 value);

  // optional uint64 access_token = 2;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 access_token() const;
  inline void set_access_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSProductInfoRequest.PackageInfo)
 private:
  inline void set_has_packageid();
  inline void clear_has_packageid();
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::uint64 access_token_;
  ::google::protobuf::uint32 packageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSProductInfoRequest_PackageInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSProductInfoRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSProductInfoRequest();
  virtual ~CMsgPICSProductInfoRequest();

  CMsgPICSProductInfoRequest(const CMsgPICSProductInfoRequest& from);

  inline CMsgPICSProductInfoRequest& operator=(const CMsgPICSProductInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSProductInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSProductInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSProductInfoRequest* other);

  // implements Message ----------------------------------------------

  CMsgPICSProductInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSProductInfoRequest& from);
  void MergeFrom(const CMsgPICSProductInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgPICSProductInfoRequest_AppInfo AppInfo;
  typedef CMsgPICSProductInfoRequest_PackageInfo PackageInfo;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgPICSProductInfoRequest.PackageInfo packages = 1;
  inline int packages_size() const;
  inline void clear_packages();
  static const int kPackagesFieldNumber = 1;
  inline const ::Sc::CMsgPICSProductInfoRequest_PackageInfo& packages(int index) const;
  inline ::Sc::CMsgPICSProductInfoRequest_PackageInfo* mutable_packages(int index);
  inline ::Sc::CMsgPICSProductInfoRequest_PackageInfo* add_packages();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_PackageInfo >&
      packages() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_PackageInfo >*
      mutable_packages();

  // repeated .Sc.CMsgPICSProductInfoRequest.AppInfo apps = 2;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 2;
  inline const ::Sc::CMsgPICSProductInfoRequest_AppInfo& apps(int index) const;
  inline ::Sc::CMsgPICSProductInfoRequest_AppInfo* mutable_apps(int index);
  inline ::Sc::CMsgPICSProductInfoRequest_AppInfo* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_AppInfo >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_AppInfo >*
      mutable_apps();

  // optional bool meta_data_only = 3;
  inline bool has_meta_data_only() const;
  inline void clear_meta_data_only();
  static const int kMetaDataOnlyFieldNumber = 3;
  inline bool meta_data_only() const;
  inline void set_meta_data_only(bool value);

  // optional uint32 num_prev_failed = 4;
  inline bool has_num_prev_failed() const;
  inline void clear_num_prev_failed();
  static const int kNumPrevFailedFieldNumber = 4;
  inline ::google::protobuf::uint32 num_prev_failed() const;
  inline void set_num_prev_failed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSProductInfoRequest)
 private:
  inline void set_has_meta_data_only();
  inline void clear_has_meta_data_only();
  inline void set_has_num_prev_failed();
  inline void clear_has_num_prev_failed();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_PackageInfo > packages_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_AppInfo > apps_;
  bool meta_data_only_;
  ::google::protobuf::uint32 num_prev_failed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSProductInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSProductInfoResponse_AppInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSProductInfoResponse_AppInfo();
  virtual ~CMsgPICSProductInfoResponse_AppInfo();

  CMsgPICSProductInfoResponse_AppInfo(const CMsgPICSProductInfoResponse_AppInfo& from);

  inline CMsgPICSProductInfoResponse_AppInfo& operator=(const CMsgPICSProductInfoResponse_AppInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSProductInfoResponse_AppInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSProductInfoResponse_AppInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSProductInfoResponse_AppInfo* other);

  // implements Message ----------------------------------------------

  CMsgPICSProductInfoResponse_AppInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSProductInfoResponse_AppInfo& from);
  void MergeFrom(const CMsgPICSProductInfoResponse_AppInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional uint32 change_number = 2;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 change_number() const;
  inline void set_change_number(::google::protobuf::uint32 value);

  // optional bool missing_token = 3;
  inline bool has_missing_token() const;
  inline void clear_missing_token();
  static const int kMissingTokenFieldNumber = 3;
  inline bool missing_token() const;
  inline void set_missing_token(bool value);

  // optional bytes sha = 4;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 4;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  inline ::std::string* release_sha();
  inline void set_allocated_sha(::std::string* sha);

  // optional bytes buffer = 5;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 5;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  inline void set_allocated_buffer(::std::string* buffer);

  // optional bool only_public = 6;
  inline bool has_only_public() const;
  inline void clear_only_public();
  static const int kOnlyPublicFieldNumber = 6;
  inline bool only_public() const;
  inline void set_only_public(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSProductInfoResponse.AppInfo)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_change_number();
  inline void clear_has_change_number();
  inline void set_has_missing_token();
  inline void clear_has_missing_token();
  inline void set_has_sha();
  inline void clear_has_sha();
  inline void set_has_buffer();
  inline void clear_has_buffer();
  inline void set_has_only_public();
  inline void clear_has_only_public();

  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 change_number_;
  ::std::string* sha_;
  ::std::string* buffer_;
  bool missing_token_;
  bool only_public_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSProductInfoResponse_AppInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSProductInfoResponse_PackageInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSProductInfoResponse_PackageInfo();
  virtual ~CMsgPICSProductInfoResponse_PackageInfo();

  CMsgPICSProductInfoResponse_PackageInfo(const CMsgPICSProductInfoResponse_PackageInfo& from);

  inline CMsgPICSProductInfoResponse_PackageInfo& operator=(const CMsgPICSProductInfoResponse_PackageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSProductInfoResponse_PackageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSProductInfoResponse_PackageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSProductInfoResponse_PackageInfo* other);

  // implements Message ----------------------------------------------

  CMsgPICSProductInfoResponse_PackageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSProductInfoResponse_PackageInfo& from);
  void MergeFrom(const CMsgPICSProductInfoResponse_PackageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 packageid = 1;
  inline bool has_packageid() const;
  inline void clear_packageid();
  static const int kPackageidFieldNumber = 1;
  inline ::google::protobuf::uint32 packageid() const;
  inline void set_packageid(::google::protobuf::uint32 value);

  // optional uint32 change_number = 2;
  inline bool has_change_number() const;
  inline void clear_change_number();
  static const int kChangeNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 change_number() const;
  inline void set_change_number(::google::protobuf::uint32 value);

  // optional bool missing_token = 3;
  inline bool has_missing_token() const;
  inline void clear_missing_token();
  static const int kMissingTokenFieldNumber = 3;
  inline bool missing_token() const;
  inline void set_missing_token(bool value);

  // optional bytes sha = 4;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 4;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  inline ::std::string* release_sha();
  inline void set_allocated_sha(::std::string* sha);

  // optional bytes buffer = 5;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 5;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  inline void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSProductInfoResponse.PackageInfo)
 private:
  inline void set_has_packageid();
  inline void clear_has_packageid();
  inline void set_has_change_number();
  inline void clear_has_change_number();
  inline void set_has_missing_token();
  inline void clear_has_missing_token();
  inline void set_has_sha();
  inline void clear_has_sha();
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::uint32 packageid_;
  ::google::protobuf::uint32 change_number_;
  ::std::string* sha_;
  ::std::string* buffer_;
  bool missing_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSProductInfoResponse_PackageInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSProductInfoResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSProductInfoResponse();
  virtual ~CMsgPICSProductInfoResponse();

  CMsgPICSProductInfoResponse(const CMsgPICSProductInfoResponse& from);

  inline CMsgPICSProductInfoResponse& operator=(const CMsgPICSProductInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSProductInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSProductInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSProductInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgPICSProductInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSProductInfoResponse& from);
  void MergeFrom(const CMsgPICSProductInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgPICSProductInfoResponse_AppInfo AppInfo;
  typedef CMsgPICSProductInfoResponse_PackageInfo PackageInfo;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgPICSProductInfoResponse.AppInfo apps = 1;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 1;
  inline const ::Sc::CMsgPICSProductInfoResponse_AppInfo& apps(int index) const;
  inline ::Sc::CMsgPICSProductInfoResponse_AppInfo* mutable_apps(int index);
  inline ::Sc::CMsgPICSProductInfoResponse_AppInfo* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_AppInfo >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_AppInfo >*
      mutable_apps();

  // repeated uint32 unknown_appids = 2;
  inline int unknown_appids_size() const;
  inline void clear_unknown_appids();
  static const int kUnknownAppidsFieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_appids(int index) const;
  inline void set_unknown_appids(int index, ::google::protobuf::uint32 value);
  inline void add_unknown_appids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      unknown_appids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_unknown_appids();

  // repeated .Sc.CMsgPICSProductInfoResponse.PackageInfo packages = 3;
  inline int packages_size() const;
  inline void clear_packages();
  static const int kPackagesFieldNumber = 3;
  inline const ::Sc::CMsgPICSProductInfoResponse_PackageInfo& packages(int index) const;
  inline ::Sc::CMsgPICSProductInfoResponse_PackageInfo* mutable_packages(int index);
  inline ::Sc::CMsgPICSProductInfoResponse_PackageInfo* add_packages();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_PackageInfo >&
      packages() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_PackageInfo >*
      mutable_packages();

  // repeated uint32 unknown_packageids = 4;
  inline int unknown_packageids_size() const;
  inline void clear_unknown_packageids();
  static const int kUnknownPackageidsFieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_packageids(int index) const;
  inline void set_unknown_packageids(int index, ::google::protobuf::uint32 value);
  inline void add_unknown_packageids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      unknown_packageids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_unknown_packageids();

  // optional bool meta_data_only = 5;
  inline bool has_meta_data_only() const;
  inline void clear_meta_data_only();
  static const int kMetaDataOnlyFieldNumber = 5;
  inline bool meta_data_only() const;
  inline void set_meta_data_only(bool value);

  // optional bool response_pending = 6;
  inline bool has_response_pending() const;
  inline void clear_response_pending();
  static const int kResponsePendingFieldNumber = 6;
  inline bool response_pending() const;
  inline void set_response_pending(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSProductInfoResponse)
 private:
  inline void set_has_meta_data_only();
  inline void clear_has_meta_data_only();
  inline void set_has_response_pending();
  inline void clear_has_response_pending();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_AppInfo > apps_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > unknown_appids_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_PackageInfo > packages_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > unknown_packageids_;
  bool meta_data_only_;
  bool response_pending_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSProductInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSAccessTokenRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSAccessTokenRequest();
  virtual ~CMsgPICSAccessTokenRequest();

  CMsgPICSAccessTokenRequest(const CMsgPICSAccessTokenRequest& from);

  inline CMsgPICSAccessTokenRequest& operator=(const CMsgPICSAccessTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSAccessTokenRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSAccessTokenRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSAccessTokenRequest* other);

  // implements Message ----------------------------------------------

  CMsgPICSAccessTokenRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSAccessTokenRequest& from);
  void MergeFrom(const CMsgPICSAccessTokenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 packageids = 1;
  inline int packageids_size() const;
  inline void clear_packageids();
  static const int kPackageidsFieldNumber = 1;
  inline ::google::protobuf::uint32 packageids(int index) const;
  inline void set_packageids(int index, ::google::protobuf::uint32 value);
  inline void add_packageids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      packageids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_packageids();

  // repeated uint32 appids = 2;
  inline int appids_size() const;
  inline void clear_appids();
  static const int kAppidsFieldNumber = 2;
  inline ::google::protobuf::uint32 appids(int index) const;
  inline void set_appids(int index, ::google::protobuf::uint32 value);
  inline void add_appids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      appids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_appids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSAccessTokenRequest)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > packageids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > appids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSAccessTokenRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSAccessTokenResponse_PackageToken : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSAccessTokenResponse_PackageToken();
  virtual ~CMsgPICSAccessTokenResponse_PackageToken();

  CMsgPICSAccessTokenResponse_PackageToken(const CMsgPICSAccessTokenResponse_PackageToken& from);

  inline CMsgPICSAccessTokenResponse_PackageToken& operator=(const CMsgPICSAccessTokenResponse_PackageToken& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSAccessTokenResponse_PackageToken& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSAccessTokenResponse_PackageToken* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSAccessTokenResponse_PackageToken* other);

  // implements Message ----------------------------------------------

  CMsgPICSAccessTokenResponse_PackageToken* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSAccessTokenResponse_PackageToken& from);
  void MergeFrom(const CMsgPICSAccessTokenResponse_PackageToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 packageid = 1;
  inline bool has_packageid() const;
  inline void clear_packageid();
  static const int kPackageidFieldNumber = 1;
  inline ::google::protobuf::uint32 packageid() const;
  inline void set_packageid(::google::protobuf::uint32 value);

  // optional uint64 access_token = 2;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 access_token() const;
  inline void set_access_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSAccessTokenResponse.PackageToken)
 private:
  inline void set_has_packageid();
  inline void clear_has_packageid();
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::uint64 access_token_;
  ::google::protobuf::uint32 packageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSAccessTokenResponse_PackageToken* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSAccessTokenResponse_AppToken : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSAccessTokenResponse_AppToken();
  virtual ~CMsgPICSAccessTokenResponse_AppToken();

  CMsgPICSAccessTokenResponse_AppToken(const CMsgPICSAccessTokenResponse_AppToken& from);

  inline CMsgPICSAccessTokenResponse_AppToken& operator=(const CMsgPICSAccessTokenResponse_AppToken& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSAccessTokenResponse_AppToken& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSAccessTokenResponse_AppToken* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSAccessTokenResponse_AppToken* other);

  // implements Message ----------------------------------------------

  CMsgPICSAccessTokenResponse_AppToken* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSAccessTokenResponse_AppToken& from);
  void MergeFrom(const CMsgPICSAccessTokenResponse_AppToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional uint64 access_token = 2;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 access_token() const;
  inline void set_access_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSAccessTokenResponse.AppToken)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::uint64 access_token_;
  ::google::protobuf::uint32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSAccessTokenResponse_AppToken* default_instance_;
};
// -------------------------------------------------------------------

class CMsgPICSAccessTokenResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgPICSAccessTokenResponse();
  virtual ~CMsgPICSAccessTokenResponse();

  CMsgPICSAccessTokenResponse(const CMsgPICSAccessTokenResponse& from);

  inline CMsgPICSAccessTokenResponse& operator=(const CMsgPICSAccessTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgPICSAccessTokenResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgPICSAccessTokenResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgPICSAccessTokenResponse* other);

  // implements Message ----------------------------------------------

  CMsgPICSAccessTokenResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgPICSAccessTokenResponse& from);
  void MergeFrom(const CMsgPICSAccessTokenResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgPICSAccessTokenResponse_PackageToken PackageToken;
  typedef CMsgPICSAccessTokenResponse_AppToken AppToken;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgPICSAccessTokenResponse.PackageToken package_access_tokens = 1;
  inline int package_access_tokens_size() const;
  inline void clear_package_access_tokens();
  static const int kPackageAccessTokensFieldNumber = 1;
  inline const ::Sc::CMsgPICSAccessTokenResponse_PackageToken& package_access_tokens(int index) const;
  inline ::Sc::CMsgPICSAccessTokenResponse_PackageToken* mutable_package_access_tokens(int index);
  inline ::Sc::CMsgPICSAccessTokenResponse_PackageToken* add_package_access_tokens();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_PackageToken >&
      package_access_tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_PackageToken >*
      mutable_package_access_tokens();

  // repeated uint32 package_denied_tokens = 2;
  inline int package_denied_tokens_size() const;
  inline void clear_package_denied_tokens();
  static const int kPackageDeniedTokensFieldNumber = 2;
  inline ::google::protobuf::uint32 package_denied_tokens(int index) const;
  inline void set_package_denied_tokens(int index, ::google::protobuf::uint32 value);
  inline void add_package_denied_tokens(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      package_denied_tokens() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_package_denied_tokens();

  // repeated .Sc.CMsgPICSAccessTokenResponse.AppToken app_access_tokens = 3;
  inline int app_access_tokens_size() const;
  inline void clear_app_access_tokens();
  static const int kAppAccessTokensFieldNumber = 3;
  inline const ::Sc::CMsgPICSAccessTokenResponse_AppToken& app_access_tokens(int index) const;
  inline ::Sc::CMsgPICSAccessTokenResponse_AppToken* mutable_app_access_tokens(int index);
  inline ::Sc::CMsgPICSAccessTokenResponse_AppToken* add_app_access_tokens();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_AppToken >&
      app_access_tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_AppToken >*
      mutable_app_access_tokens();

  // repeated uint32 app_denied_tokens = 4;
  inline int app_denied_tokens_size() const;
  inline void clear_app_denied_tokens();
  static const int kAppDeniedTokensFieldNumber = 4;
  inline ::google::protobuf::uint32 app_denied_tokens(int index) const;
  inline void set_app_denied_tokens(int index, ::google::protobuf::uint32 value);
  inline void add_app_denied_tokens(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      app_denied_tokens() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_app_denied_tokens();

  // @@protoc_insertion_point(class_scope:Sc.CMsgPICSAccessTokenResponse)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_PackageToken > package_access_tokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > package_denied_tokens_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_AppToken > app_access_tokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > app_denied_tokens_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgPICSAccessTokenResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetUGCDetails : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetUGCDetails();
  virtual ~CMsgClientUFSGetUGCDetails();

  CMsgClientUFSGetUGCDetails(const CMsgClientUFSGetUGCDetails& from);

  inline CMsgClientUFSGetUGCDetails& operator=(const CMsgClientUFSGetUGCDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetUGCDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetUGCDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetUGCDetails* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetUGCDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetUGCDetails& from);
  void MergeFrom(const CMsgClientUFSGetUGCDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 hcontent = 1 [default = 18446744073709551615];
  inline bool has_hcontent() const;
  inline void clear_hcontent();
  static const int kHcontentFieldNumber = 1;
  inline ::google::protobuf::uint64 hcontent() const;
  inline void set_hcontent(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetUGCDetails)
 private:
  inline void set_has_hcontent();
  inline void clear_has_hcontent();

  ::google::protobuf::uint64 hcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetUGCDetails* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetUGCDetailsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetUGCDetailsResponse();
  virtual ~CMsgClientUFSGetUGCDetailsResponse();

  CMsgClientUFSGetUGCDetailsResponse(const CMsgClientUFSGetUGCDetailsResponse& from);

  inline CMsgClientUFSGetUGCDetailsResponse& operator=(const CMsgClientUFSGetUGCDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetUGCDetailsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetUGCDetailsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetUGCDetailsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetUGCDetailsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetUGCDetailsResponse& from);
  void MergeFrom(const CMsgClientUFSGetUGCDetailsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 app_id = 3;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 3;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string filename = 4;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 4;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional fixed64 steamid_creator = 5;
  inline bool has_steamid_creator() const;
  inline void clear_steamid_creator();
  static const int kSteamidCreatorFieldNumber = 5;
  inline ::google::protobuf::uint64 steamid_creator() const;
  inline void set_steamid_creator(::google::protobuf::uint64 value);

  // optional uint32 file_size = 6;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetUGCDetailsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_steamid_creator();
  inline void clear_has_steamid_creator();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::std::string* url_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* filename_;
  ::google::protobuf::uint64 steamid_creator_;
  ::google::protobuf::uint32 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetUGCDetailsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetSingleFileInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetSingleFileInfo();
  virtual ~CMsgClientUFSGetSingleFileInfo();

  CMsgClientUFSGetSingleFileInfo(const CMsgClientUFSGetSingleFileInfo& from);

  inline CMsgClientUFSGetSingleFileInfo& operator=(const CMsgClientUFSGetSingleFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetSingleFileInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetSingleFileInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetSingleFileInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetSingleFileInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetSingleFileInfo& from);
  void MergeFrom(const CMsgClientUFSGetSingleFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetSingleFileInfo)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::std::string* file_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetSingleFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSGetSingleFileInfoResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSGetSingleFileInfoResponse();
  virtual ~CMsgClientUFSGetSingleFileInfoResponse();

  CMsgClientUFSGetSingleFileInfoResponse(const CMsgClientUFSGetSingleFileInfoResponse& from);

  inline CMsgClientUFSGetSingleFileInfoResponse& operator=(const CMsgClientUFSGetSingleFileInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSGetSingleFileInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSGetSingleFileInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSGetSingleFileInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSGetSingleFileInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSGetSingleFileInfoResponse& from);
  void MergeFrom(const CMsgClientUFSGetSingleFileInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional bytes sha_file = 4;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 4;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint64 time_stamp = 5;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::uint64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint64 value);

  // optional uint32 raw_file_size = 6;
  inline bool has_raw_file_size() const;
  inline void clear_raw_file_size();
  static const int kRawFileSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 raw_file_size() const;
  inline void set_raw_file_size(::google::protobuf::uint32 value);

  // optional bool is_explicit_delete = 7;
  inline bool has_is_explicit_delete() const;
  inline void clear_is_explicit_delete();
  static const int kIsExplicitDeleteFieldNumber = 7;
  inline bool is_explicit_delete() const;
  inline void set_is_explicit_delete(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSGetSingleFileInfoResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_raw_file_size();
  inline void clear_has_raw_file_size();
  inline void set_has_is_explicit_delete();
  inline void clear_has_is_explicit_delete();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* file_name_;
  ::std::string* sha_file_;
  ::google::protobuf::uint64 time_stamp_;
  ::google::protobuf::uint32 raw_file_size_;
  bool is_explicit_delete_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSGetSingleFileInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSShareFile : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSShareFile();
  virtual ~CMsgClientUFSShareFile();

  CMsgClientUFSShareFile(const CMsgClientUFSShareFile& from);

  inline CMsgClientUFSShareFile& operator=(const CMsgClientUFSShareFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSShareFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSShareFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSShareFile* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSShareFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSShareFile& from);
  void MergeFrom(const CMsgClientUFSShareFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSShareFile)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::std::string* file_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSShareFile* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUFSShareFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUFSShareFileResponse();
  virtual ~CMsgClientUFSShareFileResponse();

  CMsgClientUFSShareFileResponse(const CMsgClientUFSShareFileResponse& from);

  inline CMsgClientUFSShareFileResponse& operator=(const CMsgClientUFSShareFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUFSShareFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUFSShareFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUFSShareFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUFSShareFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUFSShareFileResponse& from);
  void MergeFrom(const CMsgClientUFSShareFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 hcontent = 2 [default = 18446744073709551615];
  inline bool has_hcontent() const;
  inline void clear_hcontent();
  static const int kHcontentFieldNumber = 2;
  inline ::google::protobuf::uint64 hcontent() const;
  inline void set_hcontent(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUFSShareFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_hcontent();
  inline void clear_has_hcontent();

  ::google::protobuf::uint64 hcontent_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUFSShareFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientNewLoginKey : public ::google::protobuf::MessageLite {
 public:
  CMsgClientNewLoginKey();
  virtual ~CMsgClientNewLoginKey();

  CMsgClientNewLoginKey(const CMsgClientNewLoginKey& from);

  inline CMsgClientNewLoginKey& operator=(const CMsgClientNewLoginKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientNewLoginKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientNewLoginKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientNewLoginKey* other);

  // implements Message ----------------------------------------------

  CMsgClientNewLoginKey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientNewLoginKey& from);
  void MergeFrom(const CMsgClientNewLoginKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 unique_id = 1;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 unique_id() const;
  inline void set_unique_id(::google::protobuf::uint32 value);

  // optional string login_key = 2;
  inline bool has_login_key() const;
  inline void clear_login_key();
  static const int kLoginKeyFieldNumber = 2;
  inline const ::std::string& login_key() const;
  inline void set_login_key(const ::std::string& value);
  inline void set_login_key(const char* value);
  inline void set_login_key(const char* value, size_t size);
  inline ::std::string* mutable_login_key();
  inline ::std::string* release_login_key();
  inline void set_allocated_login_key(::std::string* login_key);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientNewLoginKey)
 private:
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_login_key();
  inline void clear_has_login_key();

  ::std::string* login_key_;
  ::google::protobuf::uint32 unique_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientNewLoginKey* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientNewLoginKeyAccepted : public ::google::protobuf::MessageLite {
 public:
  CMsgClientNewLoginKeyAccepted();
  virtual ~CMsgClientNewLoginKeyAccepted();

  CMsgClientNewLoginKeyAccepted(const CMsgClientNewLoginKeyAccepted& from);

  inline CMsgClientNewLoginKeyAccepted& operator=(const CMsgClientNewLoginKeyAccepted& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientNewLoginKeyAccepted& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientNewLoginKeyAccepted* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientNewLoginKeyAccepted* other);

  // implements Message ----------------------------------------------

  CMsgClientNewLoginKeyAccepted* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientNewLoginKeyAccepted& from);
  void MergeFrom(const CMsgClientNewLoginKeyAccepted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 unique_id = 1;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 unique_id() const;
  inline void set_unique_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientNewLoginKeyAccepted)
 private:
  inline void set_has_unique_id();
  inline void clear_has_unique_id();

  ::google::protobuf::uint32 unique_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientNewLoginKeyAccepted* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetClanOfficers : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetClanOfficers();
  virtual ~CMsgClientAMGetClanOfficers();

  CMsgClientAMGetClanOfficers(const CMsgClientAMGetClanOfficers& from);

  inline CMsgClientAMGetClanOfficers& operator=(const CMsgClientAMGetClanOfficers& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetClanOfficers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetClanOfficers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetClanOfficers* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetClanOfficers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetClanOfficers& from);
  void MergeFrom(const CMsgClientAMGetClanOfficers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_clan = 1;
  inline bool has_steamid_clan() const;
  inline void clear_steamid_clan();
  static const int kSteamidClanFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_clan() const;
  inline void set_steamid_clan(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetClanOfficers)
 private:
  inline void set_has_steamid_clan();
  inline void clear_has_steamid_clan();

  ::google::protobuf::uint64 steamid_clan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetClanOfficers* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetClanOfficersResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetClanOfficersResponse();
  virtual ~CMsgClientAMGetClanOfficersResponse();

  CMsgClientAMGetClanOfficersResponse(const CMsgClientAMGetClanOfficersResponse& from);

  inline CMsgClientAMGetClanOfficersResponse& operator=(const CMsgClientAMGetClanOfficersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetClanOfficersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetClanOfficersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetClanOfficersResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetClanOfficersResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetClanOfficersResponse& from);
  void MergeFrom(const CMsgClientAMGetClanOfficersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 steamid_clan = 2;
  inline bool has_steamid_clan() const;
  inline void clear_steamid_clan();
  static const int kSteamidClanFieldNumber = 2;
  inline ::google::protobuf::uint64 steamid_clan() const;
  inline void set_steamid_clan(::google::protobuf::uint64 value);

  // optional int32 officer_count = 3;
  inline bool has_officer_count() const;
  inline void clear_officer_count();
  static const int kOfficerCountFieldNumber = 3;
  inline ::google::protobuf::int32 officer_count() const;
  inline void set_officer_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetClanOfficersResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_steamid_clan();
  inline void clear_has_steamid_clan();
  inline void set_has_officer_count();
  inline void clear_has_officer_count();

  ::google::protobuf::uint64 steamid_clan_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 officer_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetClanOfficersResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetPersonaNameHistory_IdInstance : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetPersonaNameHistory_IdInstance();
  virtual ~CMsgClientAMGetPersonaNameHistory_IdInstance();

  CMsgClientAMGetPersonaNameHistory_IdInstance(const CMsgClientAMGetPersonaNameHistory_IdInstance& from);

  inline CMsgClientAMGetPersonaNameHistory_IdInstance& operator=(const CMsgClientAMGetPersonaNameHistory_IdInstance& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetPersonaNameHistory_IdInstance& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetPersonaNameHistory_IdInstance* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetPersonaNameHistory_IdInstance* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetPersonaNameHistory_IdInstance* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetPersonaNameHistory_IdInstance& from);
  void MergeFrom(const CMsgClientAMGetPersonaNameHistory_IdInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetPersonaNameHistory.IdInstance)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();

  ::google::protobuf::uint64 steamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetPersonaNameHistory_IdInstance* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetPersonaNameHistory : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetPersonaNameHistory();
  virtual ~CMsgClientAMGetPersonaNameHistory();

  CMsgClientAMGetPersonaNameHistory(const CMsgClientAMGetPersonaNameHistory& from);

  inline CMsgClientAMGetPersonaNameHistory& operator=(const CMsgClientAMGetPersonaNameHistory& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetPersonaNameHistory& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetPersonaNameHistory* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetPersonaNameHistory* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetPersonaNameHistory* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetPersonaNameHistory& from);
  void MergeFrom(const CMsgClientAMGetPersonaNameHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAMGetPersonaNameHistory_IdInstance IdInstance;

  // accessors -------------------------------------------------------

  // optional int32 id_count = 1;
  inline bool has_id_count() const;
  inline void clear_id_count();
  static const int kIdCountFieldNumber = 1;
  inline ::google::protobuf::int32 id_count() const;
  inline void set_id_count(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientAMGetPersonaNameHistory.IdInstance Ids = 2;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 2;
  inline const ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance& ids(int index) const;
  inline ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance* mutable_ids(int index);
  inline ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance* add_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance >&
      ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetPersonaNameHistory)
 private:
  inline void set_has_id_count();
  inline void clear_has_id_count();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance > ids_;
  ::google::protobuf::int32 id_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetPersonaNameHistory* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance();
  virtual ~CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance();

  CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& from);

  inline CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& operator=(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& from);
  void MergeFrom(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 name_since = 1;
  inline bool has_name_since() const;
  inline void clear_name_since();
  static const int kNameSinceFieldNumber = 1;
  inline ::google::protobuf::uint32 name_since() const;
  inline void set_name_since(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance)
 private:
  inline void set_has_name_since();
  inline void clear_has_name_since();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::uint32 name_since_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance();
  virtual ~CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance();

  CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& from);

  inline CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& operator=(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& from);
  void MergeFrom(const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance NameInstance;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 steamid = 2;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 2;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // repeated .Sc.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance names = 3;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 3;
  inline const ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& names(int index) const;
  inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* mutable_names(int index);
  inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* add_names();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance >&
      names() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance >*
      mutable_names();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_steamid();
  inline void clear_has_steamid();

  ::google::protobuf::uint64 steamid_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance > names_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAMGetPersonaNameHistoryResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAMGetPersonaNameHistoryResponse();
  virtual ~CMsgClientAMGetPersonaNameHistoryResponse();

  CMsgClientAMGetPersonaNameHistoryResponse(const CMsgClientAMGetPersonaNameHistoryResponse& from);

  inline CMsgClientAMGetPersonaNameHistoryResponse& operator=(const CMsgClientAMGetPersonaNameHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAMGetPersonaNameHistoryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAMGetPersonaNameHistoryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAMGetPersonaNameHistoryResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientAMGetPersonaNameHistoryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAMGetPersonaNameHistoryResponse& from);
  void MergeFrom(const CMsgClientAMGetPersonaNameHistoryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance NameTableInstance;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance responses = 2;
  inline int responses_size() const;
  inline void clear_responses();
  static const int kResponsesFieldNumber = 2;
  inline const ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& responses(int index) const;
  inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* mutable_responses(int index);
  inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* add_responses();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance >&
      responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance >*
      mutable_responses();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAMGetPersonaNameHistoryResponse)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance > responses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAMGetPersonaNameHistoryResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDeregisterWithServer : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDeregisterWithServer();
  virtual ~CMsgClientDeregisterWithServer();

  CMsgClientDeregisterWithServer(const CMsgClientDeregisterWithServer& from);

  inline CMsgClientDeregisterWithServer& operator=(const CMsgClientDeregisterWithServer& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDeregisterWithServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDeregisterWithServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDeregisterWithServer* other);

  // implements Message ----------------------------------------------

  CMsgClientDeregisterWithServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDeregisterWithServer& from);
  void MergeFrom(const CMsgClientDeregisterWithServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eservertype = 1;
  inline bool has_eservertype() const;
  inline void clear_eservertype();
  static const int kEservertypeFieldNumber = 1;
  inline ::google::protobuf::uint32 eservertype() const;
  inline void set_eservertype(::google::protobuf::uint32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDeregisterWithServer)
 private:
  inline void set_has_eservertype();
  inline void clear_has_eservertype();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 eservertype_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDeregisterWithServer* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientClanState_NameInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientClanState_NameInfo();
  virtual ~CMsgClientClanState_NameInfo();

  CMsgClientClanState_NameInfo(const CMsgClientClanState_NameInfo& from);

  inline CMsgClientClanState_NameInfo& operator=(const CMsgClientClanState_NameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientClanState_NameInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientClanState_NameInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientClanState_NameInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientClanState_NameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientClanState_NameInfo& from);
  void MergeFrom(const CMsgClientClanState_NameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string clan_name = 1;
  inline bool has_clan_name() const;
  inline void clear_clan_name();
  static const int kClanNameFieldNumber = 1;
  inline const ::std::string& clan_name() const;
  inline void set_clan_name(const ::std::string& value);
  inline void set_clan_name(const char* value);
  inline void set_clan_name(const char* value, size_t size);
  inline ::std::string* mutable_clan_name();
  inline ::std::string* release_clan_name();
  inline void set_allocated_clan_name(::std::string* clan_name);

  // optional bytes sha_avatar = 2;
  inline bool has_sha_avatar() const;
  inline void clear_sha_avatar();
  static const int kShaAvatarFieldNumber = 2;
  inline const ::std::string& sha_avatar() const;
  inline void set_sha_avatar(const ::std::string& value);
  inline void set_sha_avatar(const char* value);
  inline void set_sha_avatar(const void* value, size_t size);
  inline ::std::string* mutable_sha_avatar();
  inline ::std::string* release_sha_avatar();
  inline void set_allocated_sha_avatar(::std::string* sha_avatar);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientClanState.NameInfo)
 private:
  inline void set_has_clan_name();
  inline void clear_has_clan_name();
  inline void set_has_sha_avatar();
  inline void clear_has_sha_avatar();

  ::std::string* clan_name_;
  ::std::string* sha_avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientClanState_NameInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientClanState_UserCounts : public ::google::protobuf::MessageLite {
 public:
  CMsgClientClanState_UserCounts();
  virtual ~CMsgClientClanState_UserCounts();

  CMsgClientClanState_UserCounts(const CMsgClientClanState_UserCounts& from);

  inline CMsgClientClanState_UserCounts& operator=(const CMsgClientClanState_UserCounts& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientClanState_UserCounts& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientClanState_UserCounts* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientClanState_UserCounts* other);

  // implements Message ----------------------------------------------

  CMsgClientClanState_UserCounts* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientClanState_UserCounts& from);
  void MergeFrom(const CMsgClientClanState_UserCounts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 members = 1;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 1;
  inline ::google::protobuf::uint32 members() const;
  inline void set_members(::google::protobuf::uint32 value);

  // optional uint32 online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline ::google::protobuf::uint32 online() const;
  inline void set_online(::google::protobuf::uint32 value);

  // optional uint32 chatting = 3;
  inline bool has_chatting() const;
  inline void clear_chatting();
  static const int kChattingFieldNumber = 3;
  inline ::google::protobuf::uint32 chatting() const;
  inline void set_chatting(::google::protobuf::uint32 value);

  // optional uint32 in_game = 4;
  inline bool has_in_game() const;
  inline void clear_in_game();
  static const int kInGameFieldNumber = 4;
  inline ::google::protobuf::uint32 in_game() const;
  inline void set_in_game(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientClanState.UserCounts)
 private:
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_chatting();
  inline void clear_has_chatting();
  inline void set_has_in_game();
  inline void clear_has_in_game();

  ::google::protobuf::uint32 members_;
  ::google::protobuf::uint32 online_;
  ::google::protobuf::uint32 chatting_;
  ::google::protobuf::uint32 in_game_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientClanState_UserCounts* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientClanState_Event : public ::google::protobuf::MessageLite {
 public:
  CMsgClientClanState_Event();
  virtual ~CMsgClientClanState_Event();

  CMsgClientClanState_Event(const CMsgClientClanState_Event& from);

  inline CMsgClientClanState_Event& operator=(const CMsgClientClanState_Event& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientClanState_Event& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientClanState_Event* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientClanState_Event* other);

  // implements Message ----------------------------------------------

  CMsgClientClanState_Event* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientClanState_Event& from);
  void MergeFrom(const CMsgClientClanState_Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 event_time = 2;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 event_time() const;
  inline void set_event_time(::google::protobuf::uint32 value);

  // optional string headline = 3;
  inline bool has_headline() const;
  inline void clear_headline();
  static const int kHeadlineFieldNumber = 3;
  inline const ::std::string& headline() const;
  inline void set_headline(const ::std::string& value);
  inline void set_headline(const char* value);
  inline void set_headline(const char* value, size_t size);
  inline ::std::string* mutable_headline();
  inline ::std::string* release_headline();
  inline void set_allocated_headline(::std::string* headline);

  // optional fixed64 game_id = 4;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 4;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // optional bool just_posted = 5;
  inline bool has_just_posted() const;
  inline void clear_just_posted();
  static const int kJustPostedFieldNumber = 5;
  inline bool just_posted() const;
  inline void set_just_posted(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientClanState.Event)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_headline();
  inline void clear_has_headline();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_just_posted();
  inline void clear_has_just_posted();

  ::google::protobuf::uint64 gid_;
  ::std::string* headline_;
  ::google::protobuf::uint32 event_time_;
  bool just_posted_;
  ::google::protobuf::uint64 game_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientClanState_Event* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientClanState : public ::google::protobuf::MessageLite {
 public:
  CMsgClientClanState();
  virtual ~CMsgClientClanState();

  CMsgClientClanState(const CMsgClientClanState& from);

  inline CMsgClientClanState& operator=(const CMsgClientClanState& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientClanState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientClanState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientClanState* other);

  // implements Message ----------------------------------------------

  CMsgClientClanState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientClanState& from);
  void MergeFrom(const CMsgClientClanState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientClanState_NameInfo NameInfo;
  typedef CMsgClientClanState_UserCounts UserCounts;
  typedef CMsgClientClanState_Event Event;

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_clan = 1;
  inline bool has_steamid_clan() const;
  inline void clear_steamid_clan();
  static const int kSteamidClanFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_clan() const;
  inline void set_steamid_clan(::google::protobuf::uint64 value);

  // optional uint32 m_unStatusFlags = 2;
  inline bool has_m_unstatusflags() const;
  inline void clear_m_unstatusflags();
  static const int kMUnStatusFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 m_unstatusflags() const;
  inline void set_m_unstatusflags(::google::protobuf::uint32 value);

  // optional uint32 clan_account_flags = 3;
  inline bool has_clan_account_flags() const;
  inline void clear_clan_account_flags();
  static const int kClanAccountFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 clan_account_flags() const;
  inline void set_clan_account_flags(::google::protobuf::uint32 value);

  // optional .Sc.CMsgClientClanState.NameInfo name_info = 4;
  inline bool has_name_info() const;
  inline void clear_name_info();
  static const int kNameInfoFieldNumber = 4;
  inline const ::Sc::CMsgClientClanState_NameInfo& name_info() const;
  inline ::Sc::CMsgClientClanState_NameInfo* mutable_name_info();
  inline ::Sc::CMsgClientClanState_NameInfo* release_name_info();
  inline void set_allocated_name_info(::Sc::CMsgClientClanState_NameInfo* name_info);

  // optional .Sc.CMsgClientClanState.UserCounts user_counts = 5;
  inline bool has_user_counts() const;
  inline void clear_user_counts();
  static const int kUserCountsFieldNumber = 5;
  inline const ::Sc::CMsgClientClanState_UserCounts& user_counts() const;
  inline ::Sc::CMsgClientClanState_UserCounts* mutable_user_counts();
  inline ::Sc::CMsgClientClanState_UserCounts* release_user_counts();
  inline void set_allocated_user_counts(::Sc::CMsgClientClanState_UserCounts* user_counts);

  // repeated .Sc.CMsgClientClanState.Event events = 6;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 6;
  inline const ::Sc::CMsgClientClanState_Event& events(int index) const;
  inline ::Sc::CMsgClientClanState_Event* mutable_events(int index);
  inline ::Sc::CMsgClientClanState_Event* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >*
      mutable_events();

  // repeated .Sc.CMsgClientClanState.Event announcements = 7;
  inline int announcements_size() const;
  inline void clear_announcements();
  static const int kAnnouncementsFieldNumber = 7;
  inline const ::Sc::CMsgClientClanState_Event& announcements(int index) const;
  inline ::Sc::CMsgClientClanState_Event* mutable_announcements(int index);
  inline ::Sc::CMsgClientClanState_Event* add_announcements();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >&
      announcements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >*
      mutable_announcements();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientClanState)
 private:
  inline void set_has_steamid_clan();
  inline void clear_has_steamid_clan();
  inline void set_has_m_unstatusflags();
  inline void clear_has_m_unstatusflags();
  inline void set_has_clan_account_flags();
  inline void clear_has_clan_account_flags();
  inline void set_has_name_info();
  inline void clear_has_name_info();
  inline void set_has_user_counts();
  inline void clear_has_user_counts();

  ::google::protobuf::uint64 steamid_clan_;
  ::google::protobuf::uint32 m_unstatusflags_;
  ::google::protobuf::uint32 clan_account_flags_;
  ::Sc::CMsgClientClanState_NameInfo* name_info_;
  ::Sc::CMsgClientClanState_UserCounts* user_counts_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event > events_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event > announcements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientClanState* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendMsg : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendMsg();
  virtual ~CMsgClientFriendMsg();

  CMsgClientFriendMsg(const CMsgClientFriendMsg& from);

  inline CMsgClientFriendMsg& operator=(const CMsgClientFriendMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendMsg* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendMsg& from);
  void MergeFrom(const CMsgClientFriendMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional int32 chat_entry_type = 2;
  inline bool has_chat_entry_type() const;
  inline void clear_chat_entry_type();
  static const int kChatEntryTypeFieldNumber = 2;
  inline ::google::protobuf::int32 chat_entry_type() const;
  inline void set_chat_entry_type(::google::protobuf::int32 value);

  // optional bytes message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendMsg)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_chat_entry_type();
  inline void clear_has_chat_entry_type();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::uint64 steamid_;
  ::std::string* message_;
  ::google::protobuf::int32 chat_entry_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendMsg* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendMsgIncoming : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendMsgIncoming();
  virtual ~CMsgClientFriendMsgIncoming();

  CMsgClientFriendMsgIncoming(const CMsgClientFriendMsgIncoming& from);

  inline CMsgClientFriendMsgIncoming& operator=(const CMsgClientFriendMsgIncoming& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendMsgIncoming& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendMsgIncoming* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendMsgIncoming* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendMsgIncoming* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendMsgIncoming& from);
  void MergeFrom(const CMsgClientFriendMsgIncoming& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_from = 1;
  inline bool has_steamid_from() const;
  inline void clear_steamid_from();
  static const int kSteamidFromFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_from() const;
  inline void set_steamid_from(::google::protobuf::uint64 value);

  // optional int32 chat_entry_type = 2;
  inline bool has_chat_entry_type() const;
  inline void clear_chat_entry_type();
  static const int kChatEntryTypeFieldNumber = 2;
  inline ::google::protobuf::int32 chat_entry_type() const;
  inline void set_chat_entry_type(::google::protobuf::int32 value);

  // optional bool from_limited_account = 3;
  inline bool has_from_limited_account() const;
  inline void clear_from_limited_account();
  static const int kFromLimitedAccountFieldNumber = 3;
  inline bool from_limited_account() const;
  inline void set_from_limited_account(bool value);

  // optional bytes message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendMsgIncoming)
 private:
  inline void set_has_steamid_from();
  inline void clear_has_steamid_from();
  inline void set_has_chat_entry_type();
  inline void clear_has_chat_entry_type();
  inline void set_has_from_limited_account();
  inline void clear_has_from_limited_account();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::uint64 steamid_from_;
  ::google::protobuf::int32 chat_entry_type_;
  bool from_limited_account_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendMsgIncoming* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAddFriend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAddFriend();
  virtual ~CMsgClientAddFriend();

  CMsgClientAddFriend(const CMsgClientAddFriend& from);

  inline CMsgClientAddFriend& operator=(const CMsgClientAddFriend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAddFriend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAddFriend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAddFriend* other);

  // implements Message ----------------------------------------------

  CMsgClientAddFriend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAddFriend& from);
  void MergeFrom(const CMsgClientAddFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_to_add = 1;
  inline bool has_steamid_to_add() const;
  inline void clear_steamid_to_add();
  static const int kSteamidToAddFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_to_add() const;
  inline void set_steamid_to_add(::google::protobuf::uint64 value);

  // optional string accountname_or_email_to_add = 2;
  inline bool has_accountname_or_email_to_add() const;
  inline void clear_accountname_or_email_to_add();
  static const int kAccountnameOrEmailToAddFieldNumber = 2;
  inline const ::std::string& accountname_or_email_to_add() const;
  inline void set_accountname_or_email_to_add(const ::std::string& value);
  inline void set_accountname_or_email_to_add(const char* value);
  inline void set_accountname_or_email_to_add(const char* value, size_t size);
  inline ::std::string* mutable_accountname_or_email_to_add();
  inline ::std::string* release_accountname_or_email_to_add();
  inline void set_allocated_accountname_or_email_to_add(::std::string* accountname_or_email_to_add);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAddFriend)
 private:
  inline void set_has_steamid_to_add();
  inline void clear_has_steamid_to_add();
  inline void set_has_accountname_or_email_to_add();
  inline void clear_has_accountname_or_email_to_add();

  ::google::protobuf::uint64 steamid_to_add_;
  ::std::string* accountname_or_email_to_add_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAddFriend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAddFriendResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAddFriendResponse();
  virtual ~CMsgClientAddFriendResponse();

  CMsgClientAddFriendResponse(const CMsgClientAddFriendResponse& from);

  inline CMsgClientAddFriendResponse& operator=(const CMsgClientAddFriendResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAddFriendResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAddFriendResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAddFriendResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientAddFriendResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAddFriendResponse& from);
  void MergeFrom(const CMsgClientAddFriendResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 steam_id_added = 2;
  inline bool has_steam_id_added() const;
  inline void clear_steam_id_added();
  static const int kSteamIdAddedFieldNumber = 2;
  inline ::google::protobuf::uint64 steam_id_added() const;
  inline void set_steam_id_added(::google::protobuf::uint64 value);

  // optional string persona_name_added = 3;
  inline bool has_persona_name_added() const;
  inline void clear_persona_name_added();
  static const int kPersonaNameAddedFieldNumber = 3;
  inline const ::std::string& persona_name_added() const;
  inline void set_persona_name_added(const ::std::string& value);
  inline void set_persona_name_added(const char* value);
  inline void set_persona_name_added(const char* value, size_t size);
  inline ::std::string* mutable_persona_name_added();
  inline ::std::string* release_persona_name_added();
  inline void set_allocated_persona_name_added(::std::string* persona_name_added);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAddFriendResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_steam_id_added();
  inline void clear_has_steam_id_added();
  inline void set_has_persona_name_added();
  inline void clear_has_persona_name_added();

  ::google::protobuf::uint64 steam_id_added_;
  ::std::string* persona_name_added_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAddFriendResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRemoveFriend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRemoveFriend();
  virtual ~CMsgClientRemoveFriend();

  CMsgClientRemoveFriend(const CMsgClientRemoveFriend& from);

  inline CMsgClientRemoveFriend& operator=(const CMsgClientRemoveFriend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRemoveFriend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRemoveFriend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRemoveFriend* other);

  // implements Message ----------------------------------------------

  CMsgClientRemoveFriend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRemoveFriend& from);
  void MergeFrom(const CMsgClientRemoveFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 friendid = 1;
  inline bool has_friendid() const;
  inline void clear_friendid();
  static const int kFriendidFieldNumber = 1;
  inline ::google::protobuf::uint64 friendid() const;
  inline void set_friendid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRemoveFriend)
 private:
  inline void set_has_friendid();
  inline void clear_has_friendid();

  ::google::protobuf::uint64 friendid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRemoveFriend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientHideFriend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientHideFriend();
  virtual ~CMsgClientHideFriend();

  CMsgClientHideFriend(const CMsgClientHideFriend& from);

  inline CMsgClientHideFriend& operator=(const CMsgClientHideFriend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientHideFriend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientHideFriend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientHideFriend* other);

  // implements Message ----------------------------------------------

  CMsgClientHideFriend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientHideFriend& from);
  void MergeFrom(const CMsgClientHideFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 friendid = 1;
  inline bool has_friendid() const;
  inline void clear_friendid();
  static const int kFriendidFieldNumber = 1;
  inline ::google::protobuf::uint64 friendid() const;
  inline void set_friendid(::google::protobuf::uint64 value);

  // optional bool hide = 2;
  inline bool has_hide() const;
  inline void clear_hide();
  static const int kHideFieldNumber = 2;
  inline bool hide() const;
  inline void set_hide(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientHideFriend)
 private:
  inline void set_has_friendid();
  inline void clear_has_friendid();
  inline void set_has_hide();
  inline void clear_has_hide();

  ::google::protobuf::uint64 friendid_;
  bool hide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientHideFriend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMAddScreenshot_Tag : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMAddScreenshot_Tag();
  virtual ~CMsgClientUCMAddScreenshot_Tag();

  CMsgClientUCMAddScreenshot_Tag(const CMsgClientUCMAddScreenshot_Tag& from);

  inline CMsgClientUCMAddScreenshot_Tag& operator=(const CMsgClientUCMAddScreenshot_Tag& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMAddScreenshot_Tag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMAddScreenshot_Tag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMAddScreenshot_Tag* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMAddScreenshot_Tag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMAddScreenshot_Tag& from);
  void MergeFrom(const CMsgClientUCMAddScreenshot_Tag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tag_name = 1;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 1;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const char* value, size_t size);
  inline ::std::string* mutable_tag_name();
  inline ::std::string* release_tag_name();
  inline void set_allocated_tag_name(::std::string* tag_name);

  // optional string tag_value = 2;
  inline bool has_tag_value() const;
  inline void clear_tag_value();
  static const int kTagValueFieldNumber = 2;
  inline const ::std::string& tag_value() const;
  inline void set_tag_value(const ::std::string& value);
  inline void set_tag_value(const char* value);
  inline void set_tag_value(const char* value, size_t size);
  inline ::std::string* mutable_tag_value();
  inline ::std::string* release_tag_value();
  inline void set_allocated_tag_value(::std::string* tag_value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMAddScreenshot.Tag)
 private:
  inline void set_has_tag_name();
  inline void clear_has_tag_name();
  inline void set_has_tag_value();
  inline void clear_has_tag_value();

  ::std::string* tag_name_;
  ::std::string* tag_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMAddScreenshot_Tag* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMAddScreenshot : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMAddScreenshot();
  virtual ~CMsgClientUCMAddScreenshot();

  CMsgClientUCMAddScreenshot(const CMsgClientUCMAddScreenshot& from);

  inline CMsgClientUCMAddScreenshot& operator=(const CMsgClientUCMAddScreenshot& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMAddScreenshot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMAddScreenshot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMAddScreenshot* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMAddScreenshot* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMAddScreenshot& from);
  void MergeFrom(const CMsgClientUCMAddScreenshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUCMAddScreenshot_Tag Tag;

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string thumbname = 3;
  inline bool has_thumbname() const;
  inline void clear_thumbname();
  static const int kThumbnameFieldNumber = 3;
  inline const ::std::string& thumbname() const;
  inline void set_thumbname(const ::std::string& value);
  inline void set_thumbname(const char* value);
  inline void set_thumbname(const char* value, size_t size);
  inline ::std::string* mutable_thumbname();
  inline ::std::string* release_thumbname();
  inline void set_allocated_thumbname(::std::string* thumbname);

  // optional fixed32 rtime32_created = 4;
  inline bool has_rtime32_created() const;
  inline void clear_rtime32_created();
  static const int kRtime32CreatedFieldNumber = 4;
  inline ::google::protobuf::uint32 rtime32_created() const;
  inline void set_rtime32_created(::google::protobuf::uint32 value);

  // optional uint32 width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional uint32 permissions = 7;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 7;
  inline ::google::protobuf::uint32 permissions() const;
  inline void set_permissions(::google::protobuf::uint32 value);

  // optional string caption = 8;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 8;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional string shortcut_name = 9;
  inline bool has_shortcut_name() const;
  inline void clear_shortcut_name();
  static const int kShortcutNameFieldNumber = 9;
  inline const ::std::string& shortcut_name() const;
  inline void set_shortcut_name(const ::std::string& value);
  inline void set_shortcut_name(const char* value);
  inline void set_shortcut_name(const char* value, size_t size);
  inline ::std::string* mutable_shortcut_name();
  inline ::std::string* release_shortcut_name();
  inline void set_allocated_shortcut_name(::std::string* shortcut_name);

  // repeated .Sc.CMsgClientUCMAddScreenshot.Tag tag = 10;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 10;
  inline const ::Sc::CMsgClientUCMAddScreenshot_Tag& tag(int index) const;
  inline ::Sc::CMsgClientUCMAddScreenshot_Tag* mutable_tag(int index);
  inline ::Sc::CMsgClientUCMAddScreenshot_Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMAddScreenshot_Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMAddScreenshot_Tag >*
      mutable_tag();

  // repeated fixed64 tagged_steamid = 11;
  inline int tagged_steamid_size() const;
  inline void clear_tagged_steamid();
  static const int kTaggedSteamidFieldNumber = 11;
  inline ::google::protobuf::uint64 tagged_steamid(int index) const;
  inline void set_tagged_steamid(int index, ::google::protobuf::uint64 value);
  inline void add_tagged_steamid(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tagged_steamid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tagged_steamid();

  // optional bool spoiler_tag = 12;
  inline bool has_spoiler_tag() const;
  inline void clear_spoiler_tag();
  static const int kSpoilerTagFieldNumber = 12;
  inline bool spoiler_tag() const;
  inline void set_spoiler_tag(bool value);

  // repeated uint64 tagged_publishedfileid = 13;
  inline int tagged_publishedfileid_size() const;
  inline void clear_tagged_publishedfileid();
  static const int kTaggedPublishedfileidFieldNumber = 13;
  inline ::google::protobuf::uint64 tagged_publishedfileid(int index) const;
  inline void set_tagged_publishedfileid(int index, ::google::protobuf::uint64 value);
  inline void add_tagged_publishedfileid(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tagged_publishedfileid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tagged_publishedfileid();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMAddScreenshot)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_thumbname();
  inline void clear_has_thumbname();
  inline void set_has_rtime32_created();
  inline void clear_has_rtime32_created();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_permissions();
  inline void clear_has_permissions();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_shortcut_name();
  inline void clear_has_shortcut_name();
  inline void set_has_spoiler_tag();
  inline void clear_has_spoiler_tag();

  ::std::string* filename_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 rtime32_created_;
  ::std::string* thumbname_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::std::string* caption_;
  ::std::string* shortcut_name_;
  ::google::protobuf::uint32 permissions_;
  bool spoiler_tag_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMAddScreenshot_Tag > tag_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tagged_steamid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tagged_publishedfileid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMAddScreenshot* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMAddScreenshotResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMAddScreenshotResponse();
  virtual ~CMsgClientUCMAddScreenshotResponse();

  CMsgClientUCMAddScreenshotResponse(const CMsgClientUCMAddScreenshotResponse& from);

  inline CMsgClientUCMAddScreenshotResponse& operator=(const CMsgClientUCMAddScreenshotResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMAddScreenshotResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMAddScreenshotResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMAddScreenshotResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMAddScreenshotResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMAddScreenshotResponse& from);
  void MergeFrom(const CMsgClientUCMAddScreenshotResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 screenshotid = 2 [default = 18446744073709551615];
  inline bool has_screenshotid() const;
  inline void clear_screenshotid();
  static const int kScreenshotidFieldNumber = 2;
  inline ::google::protobuf::uint64 screenshotid() const;
  inline void set_screenshotid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMAddScreenshotResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_screenshotid();
  inline void clear_has_screenshotid();

  ::google::protobuf::uint64 screenshotid_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMAddScreenshotResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMDeleteScreenshot : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMDeleteScreenshot();
  virtual ~CMsgClientUCMDeleteScreenshot();

  CMsgClientUCMDeleteScreenshot(const CMsgClientUCMDeleteScreenshot& from);

  inline CMsgClientUCMDeleteScreenshot& operator=(const CMsgClientUCMDeleteScreenshot& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMDeleteScreenshot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMDeleteScreenshot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMDeleteScreenshot* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMDeleteScreenshot* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMDeleteScreenshot& from);
  void MergeFrom(const CMsgClientUCMDeleteScreenshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 screenshotid = 1 [default = 18446744073709551615];
  inline bool has_screenshotid() const;
  inline void clear_screenshotid();
  static const int kScreenshotidFieldNumber = 1;
  inline ::google::protobuf::uint64 screenshotid() const;
  inline void set_screenshotid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMDeleteScreenshot)
 private:
  inline void set_has_screenshotid();
  inline void clear_has_screenshotid();

  ::google::protobuf::uint64 screenshotid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMDeleteScreenshot* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMDeleteScreenshotResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMDeleteScreenshotResponse();
  virtual ~CMsgClientUCMDeleteScreenshotResponse();

  CMsgClientUCMDeleteScreenshotResponse(const CMsgClientUCMDeleteScreenshotResponse& from);

  inline CMsgClientUCMDeleteScreenshotResponse& operator=(const CMsgClientUCMDeleteScreenshotResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMDeleteScreenshotResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMDeleteScreenshotResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMDeleteScreenshotResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMDeleteScreenshotResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMDeleteScreenshotResponse& from);
  void MergeFrom(const CMsgClientUCMDeleteScreenshotResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMDeleteScreenshotResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMDeleteScreenshotResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMPublishFile : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMPublishFile();
  virtual ~CMsgClientUCMPublishFile();

  CMsgClientUCMPublishFile(const CMsgClientUCMPublishFile& from);

  inline CMsgClientUCMPublishFile& operator=(const CMsgClientUCMPublishFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMPublishFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMPublishFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMPublishFile* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMPublishFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMPublishFile& from);
  void MergeFrom(const CMsgClientUCMPublishFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string preview_file_name = 3;
  inline bool has_preview_file_name() const;
  inline void clear_preview_file_name();
  static const int kPreviewFileNameFieldNumber = 3;
  inline const ::std::string& preview_file_name() const;
  inline void set_preview_file_name(const ::std::string& value);
  inline void set_preview_file_name(const char* value);
  inline void set_preview_file_name(const char* value, size_t size);
  inline ::std::string* mutable_preview_file_name();
  inline ::std::string* release_preview_file_name();
  inline void set_allocated_preview_file_name(::std::string* preview_file_name);

  // optional uint32 consumer_app_id = 4;
  inline bool has_consumer_app_id() const;
  inline void clear_consumer_app_id();
  static const int kConsumerAppIdFieldNumber = 4;
  inline ::google::protobuf::uint32 consumer_app_id() const;
  inline void set_consumer_app_id(::google::protobuf::uint32 value);

  // optional string title = 5;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 5;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated string tags = 8;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 8;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // optional bool workshop_file = 9;
  inline bool has_workshop_file() const;
  inline void clear_workshop_file();
  static const int kWorkshopFileFieldNumber = 9;
  inline bool workshop_file() const;
  inline void set_workshop_file(bool value);

  // optional int32 visibility = 10;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 10;
  inline ::google::protobuf::int32 visibility() const;
  inline void set_visibility(::google::protobuf::int32 value);

  // optional uint32 file_type = 11;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 file_type() const;
  inline void set_file_type(::google::protobuf::uint32 value);

  // optional string url = 12;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 12;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 video_provider = 13;
  inline bool has_video_provider() const;
  inline void clear_video_provider();
  static const int kVideoProviderFieldNumber = 13;
  inline ::google::protobuf::uint32 video_provider() const;
  inline void set_video_provider(::google::protobuf::uint32 value);

  // optional string video_account_name = 14;
  inline bool has_video_account_name() const;
  inline void clear_video_account_name();
  static const int kVideoAccountNameFieldNumber = 14;
  inline const ::std::string& video_account_name() const;
  inline void set_video_account_name(const ::std::string& value);
  inline void set_video_account_name(const char* value);
  inline void set_video_account_name(const char* value, size_t size);
  inline ::std::string* mutable_video_account_name();
  inline ::std::string* release_video_account_name();
  inline void set_allocated_video_account_name(::std::string* video_account_name);

  // optional string video_identifier = 15;
  inline bool has_video_identifier() const;
  inline void clear_video_identifier();
  static const int kVideoIdentifierFieldNumber = 15;
  inline const ::std::string& video_identifier() const;
  inline void set_video_identifier(const ::std::string& value);
  inline void set_video_identifier(const char* value);
  inline void set_video_identifier(const char* value, size_t size);
  inline ::std::string* mutable_video_identifier();
  inline ::std::string* release_video_identifier();
  inline void set_allocated_video_identifier(::std::string* video_identifier);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMPublishFile)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_preview_file_name();
  inline void clear_has_preview_file_name();
  inline void set_has_consumer_app_id();
  inline void clear_has_consumer_app_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_workshop_file();
  inline void clear_has_workshop_file();
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_file_type();
  inline void clear_has_file_type();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_video_provider();
  inline void clear_has_video_provider();
  inline void set_has_video_account_name();
  inline void clear_has_video_account_name();
  inline void set_has_video_identifier();
  inline void clear_has_video_identifier();

  ::std::string* file_name_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 consumer_app_id_;
  ::std::string* preview_file_name_;
  ::std::string* title_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  bool workshop_file_;
  ::google::protobuf::int32 visibility_;
  ::std::string* url_;
  ::google::protobuf::uint32 file_type_;
  ::google::protobuf::uint32 video_provider_;
  ::std::string* video_account_name_;
  ::std::string* video_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMPublishFile* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMPublishFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMPublishFileResponse();
  virtual ~CMsgClientUCMPublishFileResponse();

  CMsgClientUCMPublishFileResponse(const CMsgClientUCMPublishFileResponse& from);

  inline CMsgClientUCMPublishFileResponse& operator=(const CMsgClientUCMPublishFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMPublishFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMPublishFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMPublishFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMPublishFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMPublishFileResponse& from);
  void MergeFrom(const CMsgClientUCMPublishFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 published_file_id = 2 [default = 18446744073709551615];
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 2;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMPublishFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMPublishFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMUpdatePublishedFile : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMUpdatePublishedFile();
  virtual ~CMsgClientUCMUpdatePublishedFile();

  CMsgClientUCMUpdatePublishedFile(const CMsgClientUCMUpdatePublishedFile& from);

  inline CMsgClientUCMUpdatePublishedFile& operator=(const CMsgClientUCMUpdatePublishedFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMUpdatePublishedFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMUpdatePublishedFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMUpdatePublishedFile* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMUpdatePublishedFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMUpdatePublishedFile& from);
  void MergeFrom(const CMsgClientUCMUpdatePublishedFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 published_file_id = 2;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 2;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string preview_file_name = 4;
  inline bool has_preview_file_name() const;
  inline void clear_preview_file_name();
  static const int kPreviewFileNameFieldNumber = 4;
  inline const ::std::string& preview_file_name() const;
  inline void set_preview_file_name(const ::std::string& value);
  inline void set_preview_file_name(const char* value);
  inline void set_preview_file_name(const char* value, size_t size);
  inline ::std::string* mutable_preview_file_name();
  inline ::std::string* release_preview_file_name();
  inline void set_allocated_preview_file_name(::std::string* preview_file_name);

  // optional string title = 5;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 5;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated string tags = 7;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 7;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // optional int32 visibility = 8;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 8;
  inline ::google::protobuf::int32 visibility() const;
  inline void set_visibility(::google::protobuf::int32 value);

  // optional bool update_file = 9;
  inline bool has_update_file() const;
  inline void clear_update_file();
  static const int kUpdateFileFieldNumber = 9;
  inline bool update_file() const;
  inline void set_update_file(bool value);

  // optional bool update_preview_file = 10;
  inline bool has_update_preview_file() const;
  inline void clear_update_preview_file();
  static const int kUpdatePreviewFileFieldNumber = 10;
  inline bool update_preview_file() const;
  inline void set_update_preview_file(bool value);

  // optional bool update_title = 11;
  inline bool has_update_title() const;
  inline void clear_update_title();
  static const int kUpdateTitleFieldNumber = 11;
  inline bool update_title() const;
  inline void set_update_title(bool value);

  // optional bool update_description = 12;
  inline bool has_update_description() const;
  inline void clear_update_description();
  static const int kUpdateDescriptionFieldNumber = 12;
  inline bool update_description() const;
  inline void set_update_description(bool value);

  // optional bool update_tags = 13;
  inline bool has_update_tags() const;
  inline void clear_update_tags();
  static const int kUpdateTagsFieldNumber = 13;
  inline bool update_tags() const;
  inline void set_update_tags(bool value);

  // optional bool update_visibility = 14;
  inline bool has_update_visibility() const;
  inline void clear_update_visibility();
  static const int kUpdateVisibilityFieldNumber = 14;
  inline bool update_visibility() const;
  inline void set_update_visibility(bool value);

  // optional string change_description = 15;
  inline bool has_change_description() const;
  inline void clear_change_description();
  static const int kChangeDescriptionFieldNumber = 15;
  inline const ::std::string& change_description() const;
  inline void set_change_description(const ::std::string& value);
  inline void set_change_description(const char* value);
  inline void set_change_description(const char* value, size_t size);
  inline ::std::string* mutable_change_description();
  inline ::std::string* release_change_description();
  inline void set_allocated_change_description(::std::string* change_description);

  // optional bool update_url = 16;
  inline bool has_update_url() const;
  inline void clear_update_url();
  static const int kUpdateUrlFieldNumber = 16;
  inline bool update_url() const;
  inline void set_update_url(bool value);

  // optional string url = 17;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 17;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMUpdatePublishedFile)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_preview_file_name();
  inline void clear_has_preview_file_name();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_update_file();
  inline void clear_has_update_file();
  inline void set_has_update_preview_file();
  inline void clear_has_update_preview_file();
  inline void set_has_update_title();
  inline void clear_has_update_title();
  inline void set_has_update_description();
  inline void clear_has_update_description();
  inline void set_has_update_tags();
  inline void clear_has_update_tags();
  inline void set_has_update_visibility();
  inline void clear_has_update_visibility();
  inline void set_has_change_description();
  inline void clear_has_change_description();
  inline void set_has_update_url();
  inline void clear_has_update_url();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::uint64 published_file_id_;
  ::std::string* file_name_;
  ::std::string* preview_file_name_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 visibility_;
  ::std::string* title_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  bool update_file_;
  bool update_preview_file_;
  bool update_title_;
  bool update_description_;
  bool update_tags_;
  bool update_visibility_;
  bool update_url_;
  ::std::string* change_description_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMUpdatePublishedFile* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMUpdatePublishedFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMUpdatePublishedFileResponse();
  virtual ~CMsgClientUCMUpdatePublishedFileResponse();

  CMsgClientUCMUpdatePublishedFileResponse(const CMsgClientUCMUpdatePublishedFileResponse& from);

  inline CMsgClientUCMUpdatePublishedFileResponse& operator=(const CMsgClientUCMUpdatePublishedFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMUpdatePublishedFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMUpdatePublishedFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMUpdatePublishedFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMUpdatePublishedFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMUpdatePublishedFileResponse& from);
  void MergeFrom(const CMsgClientUCMUpdatePublishedFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMUpdatePublishedFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMUpdatePublishedFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMGetPublishedFileDetails : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMGetPublishedFileDetails();
  virtual ~CMsgClientUCMGetPublishedFileDetails();

  CMsgClientUCMGetPublishedFileDetails(const CMsgClientUCMGetPublishedFileDetails& from);

  inline CMsgClientUCMGetPublishedFileDetails& operator=(const CMsgClientUCMGetPublishedFileDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMGetPublishedFileDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMGetPublishedFileDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMGetPublishedFileDetails* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMGetPublishedFileDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMGetPublishedFileDetails& from);
  void MergeFrom(const CMsgClientUCMGetPublishedFileDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMGetPublishedFileDetails)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMGetPublishedFileDetails* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMGetPublishedFileDetailsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMGetPublishedFileDetailsResponse();
  virtual ~CMsgClientUCMGetPublishedFileDetailsResponse();

  CMsgClientUCMGetPublishedFileDetailsResponse(const CMsgClientUCMGetPublishedFileDetailsResponse& from);

  inline CMsgClientUCMGetPublishedFileDetailsResponse& operator=(const CMsgClientUCMGetPublishedFileDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMGetPublishedFileDetailsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMGetPublishedFileDetailsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMGetPublishedFileDetailsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMGetPublishedFileDetailsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMGetPublishedFileDetailsResponse& from);
  void MergeFrom(const CMsgClientUCMGetPublishedFileDetailsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 published_file_id = 2 [default = 18446744073709551615];
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 2;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional fixed64 creator_steam_id = 3;
  inline bool has_creator_steam_id() const;
  inline void clear_creator_steam_id();
  static const int kCreatorSteamIdFieldNumber = 3;
  inline ::google::protobuf::uint64 creator_steam_id() const;
  inline void set_creator_steam_id(::google::protobuf::uint64 value);

  // optional uint32 creator_app_id = 4;
  inline bool has_creator_app_id() const;
  inline void clear_creator_app_id();
  static const int kCreatorAppIdFieldNumber = 4;
  inline ::google::protobuf::uint32 creator_app_id() const;
  inline void set_creator_app_id(::google::protobuf::uint32 value);

  // optional uint32 consumer_app_id = 5;
  inline bool has_consumer_app_id() const;
  inline void clear_consumer_app_id();
  static const int kConsumerAppIdFieldNumber = 5;
  inline ::google::protobuf::uint32 consumer_app_id() const;
  inline void set_consumer_app_id(::google::protobuf::uint32 value);

  // optional fixed64 file_hcontent = 6 [default = 18446744073709551615];
  inline bool has_file_hcontent() const;
  inline void clear_file_hcontent();
  static const int kFileHcontentFieldNumber = 6;
  inline ::google::protobuf::uint64 file_hcontent() const;
  inline void set_file_hcontent(::google::protobuf::uint64 value);

  // optional fixed64 preview_hcontent = 7 [default = 18446744073709551615];
  inline bool has_preview_hcontent() const;
  inline void clear_preview_hcontent();
  static const int kPreviewHcontentFieldNumber = 7;
  inline ::google::protobuf::uint64 preview_hcontent() const;
  inline void set_preview_hcontent(::google::protobuf::uint64 value);

  // optional string title = 8;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 8;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 9;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 9;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional fixed32 rtime32_created = 10;
  inline bool has_rtime32_created() const;
  inline void clear_rtime32_created();
  static const int kRtime32CreatedFieldNumber = 10;
  inline ::google::protobuf::uint32 rtime32_created() const;
  inline void set_rtime32_created(::google::protobuf::uint32 value);

  // optional fixed32 rtime32_updated = 11;
  inline bool has_rtime32_updated() const;
  inline void clear_rtime32_updated();
  static const int kRtime32UpdatedFieldNumber = 11;
  inline ::google::protobuf::uint32 rtime32_updated() const;
  inline void set_rtime32_updated(::google::protobuf::uint32 value);

  // optional int32 visibility = 12;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 12;
  inline ::google::protobuf::int32 visibility() const;
  inline void set_visibility(::google::protobuf::int32 value);

  // optional bool banned = 13;
  inline bool has_banned() const;
  inline void clear_banned();
  static const int kBannedFieldNumber = 13;
  inline bool banned() const;
  inline void set_banned(bool value);

  // repeated string tag = 14;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 14;
  inline const ::std::string& tag(int index) const;
  inline ::std::string* mutable_tag(int index);
  inline void set_tag(int index, const ::std::string& value);
  inline void set_tag(int index, const char* value);
  inline void set_tag(int index, const char* value, size_t size);
  inline ::std::string* add_tag();
  inline void add_tag(const ::std::string& value);
  inline void add_tag(const char* value);
  inline void add_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag();

  // optional string filename = 15;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 15;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 file_size = 16;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 16;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // optional uint32 preview_file_size = 17;
  inline bool has_preview_file_size() const;
  inline void clear_preview_file_size();
  static const int kPreviewFileSizeFieldNumber = 17;
  inline ::google::protobuf::uint32 preview_file_size() const;
  inline void set_preview_file_size(::google::protobuf::uint32 value);

  // optional string url = 18;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 18;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 file_type = 19;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 19;
  inline ::google::protobuf::uint32 file_type() const;
  inline void set_file_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMGetPublishedFileDetailsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_creator_steam_id();
  inline void clear_has_creator_steam_id();
  inline void set_has_creator_app_id();
  inline void clear_has_creator_app_id();
  inline void set_has_consumer_app_id();
  inline void clear_has_consumer_app_id();
  inline void set_has_file_hcontent();
  inline void clear_has_file_hcontent();
  inline void set_has_preview_hcontent();
  inline void clear_has_preview_hcontent();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_rtime32_created();
  inline void clear_has_rtime32_created();
  inline void set_has_rtime32_updated();
  inline void clear_has_rtime32_updated();
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_banned();
  inline void clear_has_banned();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_preview_file_size();
  inline void clear_has_preview_file_size();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_file_type();
  inline void clear_has_file_type();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 creator_app_id_;
  ::google::protobuf::uint64 creator_steam_id_;
  ::google::protobuf::uint64 file_hcontent_;
  ::google::protobuf::uint64 preview_hcontent_;
  ::google::protobuf::uint32 consumer_app_id_;
  ::google::protobuf::uint32 rtime32_created_;
  ::std::string* title_;
  ::std::string* description_;
  ::google::protobuf::uint32 rtime32_updated_;
  ::google::protobuf::int32 visibility_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_;
  bool banned_;
  ::google::protobuf::uint32 file_size_;
  ::std::string* filename_;
  ::std::string* url_;
  ::google::protobuf::uint32 preview_file_size_;
  ::google::protobuf::uint32 file_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMGetPublishedFileDetailsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMDeletePublishedFile : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMDeletePublishedFile();
  virtual ~CMsgClientUCMDeletePublishedFile();

  CMsgClientUCMDeletePublishedFile(const CMsgClientUCMDeletePublishedFile& from);

  inline CMsgClientUCMDeletePublishedFile& operator=(const CMsgClientUCMDeletePublishedFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMDeletePublishedFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMDeletePublishedFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMDeletePublishedFile* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMDeletePublishedFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMDeletePublishedFile& from);
  void MergeFrom(const CMsgClientUCMDeletePublishedFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMDeletePublishedFile)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMDeletePublishedFile* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMDeletePublishedFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMDeletePublishedFileResponse();
  virtual ~CMsgClientUCMDeletePublishedFileResponse();

  CMsgClientUCMDeletePublishedFileResponse(const CMsgClientUCMDeletePublishedFileResponse& from);

  inline CMsgClientUCMDeletePublishedFileResponse& operator=(const CMsgClientUCMDeletePublishedFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMDeletePublishedFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMDeletePublishedFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMDeletePublishedFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMDeletePublishedFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMDeletePublishedFileResponse& from);
  void MergeFrom(const CMsgClientUCMDeletePublishedFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMDeletePublishedFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMDeletePublishedFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserPublishedFiles : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserPublishedFiles();
  virtual ~CMsgClientUCMEnumerateUserPublishedFiles();

  CMsgClientUCMEnumerateUserPublishedFiles(const CMsgClientUCMEnumerateUserPublishedFiles& from);

  inline CMsgClientUCMEnumerateUserPublishedFiles& operator=(const CMsgClientUCMEnumerateUserPublishedFiles& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserPublishedFiles& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserPublishedFiles* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserPublishedFiles* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserPublishedFiles* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserPublishedFiles& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserPublishedFiles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 sort_order = 3;
  inline bool has_sort_order() const;
  inline void clear_sort_order();
  static const int kSortOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 sort_order() const;
  inline void set_sort_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserPublishedFiles)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_sort_order();
  inline void clear_has_sort_order();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 sort_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserPublishedFiles* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId();
  virtual ~CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId();

  CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId(const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& from);

  inline CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& operator=(const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserPublishedFilesResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserPublishedFilesResponse();
  virtual ~CMsgClientUCMEnumerateUserPublishedFilesResponse();

  CMsgClientUCMEnumerateUserPublishedFilesResponse(const CMsgClientUCMEnumerateUserPublishedFilesResponse& from);

  inline CMsgClientUCMEnumerateUserPublishedFilesResponse& operator=(const CMsgClientUCMEnumerateUserPublishedFilesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserPublishedFilesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserPublishedFilesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserPublishedFilesResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserPublishedFilesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserPublishedFilesResponse& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserPublishedFilesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId published_files = 2;
  inline int published_files_size() const;
  inline void clear_published_files();
  static const int kPublishedFilesFieldNumber = 2;
  inline const ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& published_files(int index) const;
  inline ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* mutable_published_files(int index);
  inline ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* add_published_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId >&
      published_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId >*
      mutable_published_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserPublishedFilesResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId > published_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserPublishedFilesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMSubscribePublishedFile : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMSubscribePublishedFile();
  virtual ~CMsgClientUCMSubscribePublishedFile();

  CMsgClientUCMSubscribePublishedFile(const CMsgClientUCMSubscribePublishedFile& from);

  inline CMsgClientUCMSubscribePublishedFile& operator=(const CMsgClientUCMSubscribePublishedFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMSubscribePublishedFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMSubscribePublishedFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMSubscribePublishedFile* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMSubscribePublishedFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMSubscribePublishedFile& from);
  void MergeFrom(const CMsgClientUCMSubscribePublishedFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 published_file_id = 2;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 2;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMSubscribePublishedFile)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMSubscribePublishedFile* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMSubscribePublishedFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMSubscribePublishedFileResponse();
  virtual ~CMsgClientUCMSubscribePublishedFileResponse();

  CMsgClientUCMSubscribePublishedFileResponse(const CMsgClientUCMSubscribePublishedFileResponse& from);

  inline CMsgClientUCMSubscribePublishedFileResponse& operator=(const CMsgClientUCMSubscribePublishedFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMSubscribePublishedFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMSubscribePublishedFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMSubscribePublishedFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMSubscribePublishedFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMSubscribePublishedFileResponse& from);
  void MergeFrom(const CMsgClientUCMSubscribePublishedFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMSubscribePublishedFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMSubscribePublishedFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserSubscribedFiles : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserSubscribedFiles();
  virtual ~CMsgClientUCMEnumerateUserSubscribedFiles();

  CMsgClientUCMEnumerateUserSubscribedFiles(const CMsgClientUCMEnumerateUserSubscribedFiles& from);

  inline CMsgClientUCMEnumerateUserSubscribedFiles& operator=(const CMsgClientUCMEnumerateUserSubscribedFiles& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserSubscribedFiles& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserSubscribedFiles* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserSubscribedFiles* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserSubscribedFiles* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserSubscribedFiles& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserSubscribedFiles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 list_type = 3 [default = 1];
  inline bool has_list_type() const;
  inline void clear_list_type();
  static const int kListTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 list_type() const;
  inline void set_list_type(::google::protobuf::uint32 value);

  // optional uint32 matching_file_type = 4 [default = 0];
  inline bool has_matching_file_type() const;
  inline void clear_matching_file_type();
  static const int kMatchingFileTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 matching_file_type() const;
  inline void set_matching_file_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserSubscribedFiles)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_list_type();
  inline void clear_has_list_type();
  inline void set_has_matching_file_type();
  inline void clear_has_matching_file_type();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 list_type_;
  ::google::protobuf::uint32 matching_file_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserSubscribedFiles* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId();
  virtual ~CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId();

  CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId(const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& from);

  inline CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& operator=(const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional fixed32 rtime32_subscribed = 2 [default = 0];
  inline bool has_rtime32_subscribed() const;
  inline void clear_rtime32_subscribed();
  static const int kRtime32SubscribedFieldNumber = 2;
  inline ::google::protobuf::uint32 rtime32_subscribed() const;
  inline void set_rtime32_subscribed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_rtime32_subscribed();
  inline void clear_has_rtime32_subscribed();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 rtime32_subscribed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserSubscribedFilesResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserSubscribedFilesResponse();
  virtual ~CMsgClientUCMEnumerateUserSubscribedFilesResponse();

  CMsgClientUCMEnumerateUserSubscribedFilesResponse(const CMsgClientUCMEnumerateUserSubscribedFilesResponse& from);

  inline CMsgClientUCMEnumerateUserSubscribedFilesResponse& operator=(const CMsgClientUCMEnumerateUserSubscribedFilesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserSubscribedFilesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserSubscribedFilesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserSubscribedFilesResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserSubscribedFilesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserSubscribedFilesResponse& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserSubscribedFilesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId subscribed_files = 2;
  inline int subscribed_files_size() const;
  inline void clear_subscribed_files();
  static const int kSubscribedFilesFieldNumber = 2;
  inline const ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& subscribed_files(int index) const;
  inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* mutable_subscribed_files(int index);
  inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* add_subscribed_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId >&
      subscribed_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId >*
      mutable_subscribed_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserSubscribedFilesResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId > subscribed_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserSubscribedFilesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates();
  virtual ~CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates();

  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates& from);

  inline CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates& operator=(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional fixed32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_start_time();
  inline void clear_has_start_time();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 start_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId();
  virtual ~CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId();

  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& from);

  inline CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& operator=(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional fixed32 rtime32_subscribed = 2 [default = 0];
  inline bool has_rtime32_subscribed() const;
  inline void clear_rtime32_subscribed();
  static const int kRtime32SubscribedFieldNumber = 2;
  inline ::google::protobuf::uint32 rtime32_subscribed() const;
  inline void set_rtime32_subscribed(::google::protobuf::uint32 value);

  // optional uint32 appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional fixed64 file_hcontent = 4;
  inline bool has_file_hcontent() const;
  inline void clear_file_hcontent();
  static const int kFileHcontentFieldNumber = 4;
  inline ::google::protobuf::uint64 file_hcontent() const;
  inline void set_file_hcontent(::google::protobuf::uint64 value);

  // optional uint32 file_size = 5;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // optional fixed32 rtime32_last_updated = 6;
  inline bool has_rtime32_last_updated() const;
  inline void clear_rtime32_last_updated();
  static const int kRtime32LastUpdatedFieldNumber = 6;
  inline ::google::protobuf::uint32 rtime32_last_updated() const;
  inline void set_rtime32_last_updated(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_rtime32_subscribed();
  inline void clear_has_rtime32_subscribed();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_file_hcontent();
  inline void clear_has_file_hcontent();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_rtime32_last_updated();
  inline void clear_has_rtime32_last_updated();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 rtime32_subscribed_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint64 file_hcontent_;
  ::google::protobuf::uint32 file_size_;
  ::google::protobuf::uint32 rtime32_last_updated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse();
  virtual ~CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse();

  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse& from);

  inline CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse& operator=(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse& from);
  void MergeFrom(const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId subscribed_files = 2;
  inline int subscribed_files_size() const;
  inline void clear_subscribed_files();
  static const int kSubscribedFilesFieldNumber = 2;
  inline const ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& subscribed_files(int index) const;
  inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* mutable_subscribed_files(int index);
  inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* add_subscribed_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId >&
      subscribed_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId >*
      mutable_subscribed_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId > subscribed_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMUnsubscribePublishedFile : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMUnsubscribePublishedFile();
  virtual ~CMsgClientUCMUnsubscribePublishedFile();

  CMsgClientUCMUnsubscribePublishedFile(const CMsgClientUCMUnsubscribePublishedFile& from);

  inline CMsgClientUCMUnsubscribePublishedFile& operator=(const CMsgClientUCMUnsubscribePublishedFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMUnsubscribePublishedFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMUnsubscribePublishedFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMUnsubscribePublishedFile* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMUnsubscribePublishedFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMUnsubscribePublishedFile& from);
  void MergeFrom(const CMsgClientUCMUnsubscribePublishedFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 published_file_id = 2;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 2;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMUnsubscribePublishedFile)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMUnsubscribePublishedFile* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMUnsubscribePublishedFileResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMUnsubscribePublishedFileResponse();
  virtual ~CMsgClientUCMUnsubscribePublishedFileResponse();

  CMsgClientUCMUnsubscribePublishedFileResponse(const CMsgClientUCMUnsubscribePublishedFileResponse& from);

  inline CMsgClientUCMUnsubscribePublishedFileResponse& operator=(const CMsgClientUCMUnsubscribePublishedFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMUnsubscribePublishedFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMUnsubscribePublishedFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMUnsubscribePublishedFileResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMUnsubscribePublishedFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMUnsubscribePublishedFileResponse& from);
  void MergeFrom(const CMsgClientUCMUnsubscribePublishedFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMUnsubscribePublishedFileResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMUnsubscribePublishedFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMPublishedFileSubscribed : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMPublishedFileSubscribed();
  virtual ~CMsgClientUCMPublishedFileSubscribed();

  CMsgClientUCMPublishedFileSubscribed(const CMsgClientUCMPublishedFileSubscribed& from);

  inline CMsgClientUCMPublishedFileSubscribed& operator=(const CMsgClientUCMPublishedFileSubscribed& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMPublishedFileSubscribed& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMPublishedFileSubscribed* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMPublishedFileSubscribed* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMPublishedFileSubscribed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMPublishedFileSubscribed& from);
  void MergeFrom(const CMsgClientUCMPublishedFileSubscribed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 file_hcontent = 3;
  inline bool has_file_hcontent() const;
  inline void clear_file_hcontent();
  static const int kFileHcontentFieldNumber = 3;
  inline ::google::protobuf::uint64 file_hcontent() const;
  inline void set_file_hcontent(::google::protobuf::uint64 value);

  // optional uint32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMPublishedFileSubscribed)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_file_hcontent();
  inline void clear_has_file_hcontent();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint64 file_hcontent_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMPublishedFileSubscribed* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMPublishedFileUnsubscribed : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMPublishedFileUnsubscribed();
  virtual ~CMsgClientUCMPublishedFileUnsubscribed();

  CMsgClientUCMPublishedFileUnsubscribed(const CMsgClientUCMPublishedFileUnsubscribed& from);

  inline CMsgClientUCMPublishedFileUnsubscribed& operator=(const CMsgClientUCMPublishedFileUnsubscribed& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMPublishedFileUnsubscribed& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMPublishedFileUnsubscribed* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMPublishedFileUnsubscribed* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMPublishedFileUnsubscribed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMPublishedFileUnsubscribed& from);
  void MergeFrom(const CMsgClientUCMPublishedFileUnsubscribed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMPublishedFileUnsubscribed)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMPublishedFileUnsubscribed* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMPublishedFileDeleted : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMPublishedFileDeleted();
  virtual ~CMsgClientUCMPublishedFileDeleted();

  CMsgClientUCMPublishedFileDeleted(const CMsgClientUCMPublishedFileDeleted& from);

  inline CMsgClientUCMPublishedFileDeleted& operator=(const CMsgClientUCMPublishedFileDeleted& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMPublishedFileDeleted& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMPublishedFileDeleted* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMPublishedFileDeleted* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMPublishedFileDeleted* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMPublishedFileDeleted& from);
  void MergeFrom(const CMsgClientUCMPublishedFileDeleted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMPublishedFileDeleted)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMPublishedFileDeleted* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMGetPublishedFilesForUser : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMGetPublishedFilesForUser();
  virtual ~CMsgClientUCMGetPublishedFilesForUser();

  CMsgClientUCMGetPublishedFilesForUser(const CMsgClientUCMGetPublishedFilesForUser& from);

  inline CMsgClientUCMGetPublishedFilesForUser& operator=(const CMsgClientUCMGetPublishedFilesForUser& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMGetPublishedFilesForUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMGetPublishedFilesForUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMGetPublishedFilesForUser* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMGetPublishedFilesForUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMGetPublishedFilesForUser& from);
  void MergeFrom(const CMsgClientUCMGetPublishedFilesForUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional fixed64 creator_steam_id = 2;
  inline bool has_creator_steam_id() const;
  inline void clear_creator_steam_id();
  static const int kCreatorSteamIdFieldNumber = 2;
  inline ::google::protobuf::uint64 creator_steam_id() const;
  inline void set_creator_steam_id(::google::protobuf::uint64 value);

  // repeated string required_tags = 3;
  inline int required_tags_size() const;
  inline void clear_required_tags();
  static const int kRequiredTagsFieldNumber = 3;
  inline const ::std::string& required_tags(int index) const;
  inline ::std::string* mutable_required_tags(int index);
  inline void set_required_tags(int index, const ::std::string& value);
  inline void set_required_tags(int index, const char* value);
  inline void set_required_tags(int index, const char* value, size_t size);
  inline ::std::string* add_required_tags();
  inline void add_required_tags(const ::std::string& value);
  inline void add_required_tags(const char* value);
  inline void add_required_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& required_tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_required_tags();

  // repeated string excluded_tags = 4;
  inline int excluded_tags_size() const;
  inline void clear_excluded_tags();
  static const int kExcludedTagsFieldNumber = 4;
  inline const ::std::string& excluded_tags(int index) const;
  inline ::std::string* mutable_excluded_tags(int index);
  inline void set_excluded_tags(int index, const ::std::string& value);
  inline void set_excluded_tags(int index, const char* value);
  inline void set_excluded_tags(int index, const char* value, size_t size);
  inline ::std::string* add_excluded_tags();
  inline void add_excluded_tags(const ::std::string& value);
  inline void add_excluded_tags(const char* value);
  inline void add_excluded_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& excluded_tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_excluded_tags();

  // optional uint32 start_index = 5;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMGetPublishedFilesForUser)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_creator_steam_id();
  inline void clear_has_creator_steam_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();

  ::google::protobuf::uint64 creator_steam_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> required_tags_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> excluded_tags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMGetPublishedFilesForUser* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId();
  virtual ~CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId();

  CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId(const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& from);

  inline CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& operator=(const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& from);
  void MergeFrom(const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMGetPublishedFilesForUserResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMGetPublishedFilesForUserResponse();
  virtual ~CMsgClientUCMGetPublishedFilesForUserResponse();

  CMsgClientUCMGetPublishedFilesForUserResponse(const CMsgClientUCMGetPublishedFilesForUserResponse& from);

  inline CMsgClientUCMGetPublishedFilesForUserResponse& operator=(const CMsgClientUCMGetPublishedFilesForUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMGetPublishedFilesForUserResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMGetPublishedFilesForUserResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMGetPublishedFilesForUserResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMGetPublishedFilesForUserResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMGetPublishedFilesForUserResponse& from);
  void MergeFrom(const CMsgClientUCMGetPublishedFilesForUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId published_files = 2;
  inline int published_files_size() const;
  inline void clear_published_files();
  static const int kPublishedFilesFieldNumber = 2;
  inline const ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& published_files(int index) const;
  inline ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* mutable_published_files(int index);
  inline ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* add_published_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId >&
      published_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId >*
      mutable_published_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMGetPublishedFilesForUserResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId > published_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMGetPublishedFilesForUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMSetUserPublishedFileAction : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMSetUserPublishedFileAction();
  virtual ~CMsgClientUCMSetUserPublishedFileAction();

  CMsgClientUCMSetUserPublishedFileAction(const CMsgClientUCMSetUserPublishedFileAction& from);

  inline CMsgClientUCMSetUserPublishedFileAction& operator=(const CMsgClientUCMSetUserPublishedFileAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMSetUserPublishedFileAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMSetUserPublishedFileAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMSetUserPublishedFileAction* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMSetUserPublishedFileAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMSetUserPublishedFileAction& from);
  void MergeFrom(const CMsgClientUCMSetUserPublishedFileAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMSetUserPublishedFileAction)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMSetUserPublishedFileAction* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMSetUserPublishedFileActionResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMSetUserPublishedFileActionResponse();
  virtual ~CMsgClientUCMSetUserPublishedFileActionResponse();

  CMsgClientUCMSetUserPublishedFileActionResponse(const CMsgClientUCMSetUserPublishedFileActionResponse& from);

  inline CMsgClientUCMSetUserPublishedFileActionResponse& operator=(const CMsgClientUCMSetUserPublishedFileActionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMSetUserPublishedFileActionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMSetUserPublishedFileActionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMSetUserPublishedFileActionResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMSetUserPublishedFileActionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMSetUserPublishedFileActionResponse& from);
  void MergeFrom(const CMsgClientUCMSetUserPublishedFileActionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMSetUserPublishedFileActionResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMSetUserPublishedFileActionResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumeratePublishedFilesByUserAction : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumeratePublishedFilesByUserAction();
  virtual ~CMsgClientUCMEnumeratePublishedFilesByUserAction();

  CMsgClientUCMEnumeratePublishedFilesByUserAction(const CMsgClientUCMEnumeratePublishedFilesByUserAction& from);

  inline CMsgClientUCMEnumeratePublishedFilesByUserAction& operator=(const CMsgClientUCMEnumeratePublishedFilesByUserAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumeratePublishedFilesByUserAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumeratePublishedFilesByUserAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumeratePublishedFilesByUserAction* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumeratePublishedFilesByUserAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumeratePublishedFilesByUserAction& from);
  void MergeFrom(const CMsgClientUCMEnumeratePublishedFilesByUserAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional int32 action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumeratePublishedFilesByUserAction)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::int32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumeratePublishedFilesByUserAction* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId();
  virtual ~CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId();

  CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& from);

  inline CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& operator=(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& from);
  void MergeFrom(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional fixed32 rtime_time_stamp = 2 [default = 0];
  inline bool has_rtime_time_stamp() const;
  inline void clear_rtime_time_stamp();
  static const int kRtimeTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 rtime_time_stamp() const;
  inline void set_rtime_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_rtime_time_stamp();
  inline void clear_has_rtime_time_stamp();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::uint32 rtime_time_stamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUCMEnumeratePublishedFilesByUserActionResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUCMEnumeratePublishedFilesByUserActionResponse();
  virtual ~CMsgClientUCMEnumeratePublishedFilesByUserActionResponse();

  CMsgClientUCMEnumeratePublishedFilesByUserActionResponse(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse& from);

  inline CMsgClientUCMEnumeratePublishedFilesByUserActionResponse& operator=(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUCMEnumeratePublishedFilesByUserActionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse& from);
  void MergeFrom(const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId published_files = 2;
  inline int published_files_size() const;
  inline void clear_published_files();
  static const int kPublishedFilesFieldNumber = 2;
  inline const ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& published_files(int index) const;
  inline ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* mutable_published_files(int index);
  inline ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* add_published_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId >&
      published_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId >*
      mutable_published_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUCMEnumeratePublishedFilesByUserActionResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId > published_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientScreenshotsChanged : public ::google::protobuf::MessageLite {
 public:
  CMsgClientScreenshotsChanged();
  virtual ~CMsgClientScreenshotsChanged();

  CMsgClientScreenshotsChanged(const CMsgClientScreenshotsChanged& from);

  inline CMsgClientScreenshotsChanged& operator=(const CMsgClientScreenshotsChanged& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientScreenshotsChanged& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientScreenshotsChanged* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientScreenshotsChanged* other);

  // implements Message ----------------------------------------------

  CMsgClientScreenshotsChanged* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientScreenshotsChanged& from);
  void MergeFrom(const CMsgClientScreenshotsChanged& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientScreenshotsChanged)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientScreenshotsChanged* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUpdateUserGameInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUpdateUserGameInfo();
  virtual ~CMsgClientUpdateUserGameInfo();

  CMsgClientUpdateUserGameInfo(const CMsgClientUpdateUserGameInfo& from);

  inline CMsgClientUpdateUserGameInfo& operator=(const CMsgClientUpdateUserGameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUpdateUserGameInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUpdateUserGameInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUpdateUserGameInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientUpdateUserGameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUpdateUserGameInfo& from);
  void MergeFrom(const CMsgClientUpdateUserGameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_idgs = 1;
  inline bool has_steamid_idgs() const;
  inline void clear_steamid_idgs();
  static const int kSteamidIdgsFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_idgs() const;
  inline void set_steamid_idgs(::google::protobuf::uint64 value);

  // optional fixed64 gameid = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 2;
  inline ::google::protobuf::uint64 gameid() const;
  inline void set_gameid(::google::protobuf::uint64 value);

  // optional uint32 game_ip = 3;
  inline bool has_game_ip() const;
  inline void clear_game_ip();
  static const int kGameIpFieldNumber = 3;
  inline ::google::protobuf::uint32 game_ip() const;
  inline void set_game_ip(::google::protobuf::uint32 value);

  // optional uint32 game_port = 4;
  inline bool has_game_port() const;
  inline void clear_game_port();
  static const int kGamePortFieldNumber = 4;
  inline ::google::protobuf::uint32 game_port() const;
  inline void set_game_port(::google::protobuf::uint32 value);

  // optional bytes token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUpdateUserGameInfo)
 private:
  inline void set_has_steamid_idgs();
  inline void clear_has_steamid_idgs();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_game_ip();
  inline void clear_has_game_ip();
  inline void set_has_game_port();
  inline void clear_has_game_port();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::uint64 steamid_idgs_;
  ::google::protobuf::uint64 gameid_;
  ::google::protobuf::uint32 game_ip_;
  ::google::protobuf::uint32 game_port_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUpdateUserGameInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRichPresenceUpload : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRichPresenceUpload();
  virtual ~CMsgClientRichPresenceUpload();

  CMsgClientRichPresenceUpload(const CMsgClientRichPresenceUpload& from);

  inline CMsgClientRichPresenceUpload& operator=(const CMsgClientRichPresenceUpload& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRichPresenceUpload& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRichPresenceUpload* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRichPresenceUpload* other);

  // implements Message ----------------------------------------------

  CMsgClientRichPresenceUpload* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRichPresenceUpload& from);
  void MergeFrom(const CMsgClientRichPresenceUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes rich_presence_kv = 1;
  inline bool has_rich_presence_kv() const;
  inline void clear_rich_presence_kv();
  static const int kRichPresenceKvFieldNumber = 1;
  inline const ::std::string& rich_presence_kv() const;
  inline void set_rich_presence_kv(const ::std::string& value);
  inline void set_rich_presence_kv(const char* value);
  inline void set_rich_presence_kv(const void* value, size_t size);
  inline ::std::string* mutable_rich_presence_kv();
  inline ::std::string* release_rich_presence_kv();
  inline void set_allocated_rich_presence_kv(::std::string* rich_presence_kv);

  // repeated fixed64 steamid_broadcast = 2;
  inline int steamid_broadcast_size() const;
  inline void clear_steamid_broadcast();
  static const int kSteamidBroadcastFieldNumber = 2;
  inline ::google::protobuf::uint64 steamid_broadcast(int index) const;
  inline void set_steamid_broadcast(int index, ::google::protobuf::uint64 value);
  inline void add_steamid_broadcast(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      steamid_broadcast() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_steamid_broadcast();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRichPresenceUpload)
 private:
  inline void set_has_rich_presence_kv();
  inline void clear_has_rich_presence_kv();

  ::std::string* rich_presence_kv_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > steamid_broadcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRichPresenceUpload* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRichPresenceRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRichPresenceRequest();
  virtual ~CMsgClientRichPresenceRequest();

  CMsgClientRichPresenceRequest(const CMsgClientRichPresenceRequest& from);

  inline CMsgClientRichPresenceRequest& operator=(const CMsgClientRichPresenceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRichPresenceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRichPresenceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRichPresenceRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientRichPresenceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRichPresenceRequest& from);
  void MergeFrom(const CMsgClientRichPresenceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 steamid_request = 1;
  inline int steamid_request_size() const;
  inline void clear_steamid_request();
  static const int kSteamidRequestFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_request(int index) const;
  inline void set_steamid_request(int index, ::google::protobuf::uint64 value);
  inline void add_steamid_request(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      steamid_request() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_steamid_request();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRichPresenceRequest)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > steamid_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRichPresenceRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRichPresenceInfo_RichPresence : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRichPresenceInfo_RichPresence();
  virtual ~CMsgClientRichPresenceInfo_RichPresence();

  CMsgClientRichPresenceInfo_RichPresence(const CMsgClientRichPresenceInfo_RichPresence& from);

  inline CMsgClientRichPresenceInfo_RichPresence& operator=(const CMsgClientRichPresenceInfo_RichPresence& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRichPresenceInfo_RichPresence& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRichPresenceInfo_RichPresence* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRichPresenceInfo_RichPresence* other);

  // implements Message ----------------------------------------------

  CMsgClientRichPresenceInfo_RichPresence* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRichPresenceInfo_RichPresence& from);
  void MergeFrom(const CMsgClientRichPresenceInfo_RichPresence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid_user = 1;
  inline bool has_steamid_user() const;
  inline void clear_steamid_user();
  static const int kSteamidUserFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_user() const;
  inline void set_steamid_user(::google::protobuf::uint64 value);

  // optional bytes rich_presence_kv = 2;
  inline bool has_rich_presence_kv() const;
  inline void clear_rich_presence_kv();
  static const int kRichPresenceKvFieldNumber = 2;
  inline const ::std::string& rich_presence_kv() const;
  inline void set_rich_presence_kv(const ::std::string& value);
  inline void set_rich_presence_kv(const char* value);
  inline void set_rich_presence_kv(const void* value, size_t size);
  inline ::std::string* mutable_rich_presence_kv();
  inline ::std::string* release_rich_presence_kv();
  inline void set_allocated_rich_presence_kv(::std::string* rich_presence_kv);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRichPresenceInfo.RichPresence)
 private:
  inline void set_has_steamid_user();
  inline void clear_has_steamid_user();
  inline void set_has_rich_presence_kv();
  inline void clear_has_rich_presence_kv();

  ::google::protobuf::uint64 steamid_user_;
  ::std::string* rich_presence_kv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRichPresenceInfo_RichPresence* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRichPresenceInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRichPresenceInfo();
  virtual ~CMsgClientRichPresenceInfo();

  CMsgClientRichPresenceInfo(const CMsgClientRichPresenceInfo& from);

  inline CMsgClientRichPresenceInfo& operator=(const CMsgClientRichPresenceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRichPresenceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRichPresenceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRichPresenceInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientRichPresenceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRichPresenceInfo& from);
  void MergeFrom(const CMsgClientRichPresenceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientRichPresenceInfo_RichPresence RichPresence;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientRichPresenceInfo.RichPresence rich_presence = 1;
  inline int rich_presence_size() const;
  inline void clear_rich_presence();
  static const int kRichPresenceFieldNumber = 1;
  inline const ::Sc::CMsgClientRichPresenceInfo_RichPresence& rich_presence(int index) const;
  inline ::Sc::CMsgClientRichPresenceInfo_RichPresence* mutable_rich_presence(int index);
  inline ::Sc::CMsgClientRichPresenceInfo_RichPresence* add_rich_presence();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRichPresenceInfo_RichPresence >&
      rich_presence() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRichPresenceInfo_RichPresence >*
      mutable_rich_presence();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRichPresenceInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRichPresenceInfo_RichPresence > rich_presence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRichPresenceInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientCheckFileSignature : public ::google::protobuf::MessageLite {
 public:
  CMsgClientCheckFileSignature();
  virtual ~CMsgClientCheckFileSignature();

  CMsgClientCheckFileSignature(const CMsgClientCheckFileSignature& from);

  inline CMsgClientCheckFileSignature& operator=(const CMsgClientCheckFileSignature& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientCheckFileSignature& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientCheckFileSignature* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientCheckFileSignature* other);

  // implements Message ----------------------------------------------

  CMsgClientCheckFileSignature* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientCheckFileSignature& from);
  void MergeFrom(const CMsgClientCheckFileSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientCheckFileSignature)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientCheckFileSignature* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientCheckFileSignatureResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientCheckFileSignatureResponse();
  virtual ~CMsgClientCheckFileSignatureResponse();

  CMsgClientCheckFileSignatureResponse(const CMsgClientCheckFileSignatureResponse& from);

  inline CMsgClientCheckFileSignatureResponse& operator=(const CMsgClientCheckFileSignatureResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientCheckFileSignatureResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientCheckFileSignatureResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientCheckFileSignatureResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientCheckFileSignatureResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientCheckFileSignatureResponse& from);
  void MergeFrom(const CMsgClientCheckFileSignatureResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);

  // optional uint32 eresult = 3;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 3;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional string filename = 4;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 4;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 esignatureresult = 5;
  inline bool has_esignatureresult() const;
  inline void clear_esignatureresult();
  static const int kEsignatureresultFieldNumber = 5;
  inline ::google::protobuf::uint32 esignatureresult() const;
  inline void set_esignatureresult(::google::protobuf::uint32 value);

  // optional bytes sha_file = 6;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 6;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional bytes signatureheader = 7;
  inline bool has_signatureheader() const;
  inline void clear_signatureheader();
  static const int kSignatureheaderFieldNumber = 7;
  inline const ::std::string& signatureheader() const;
  inline void set_signatureheader(const ::std::string& value);
  inline void set_signatureheader(const char* value);
  inline void set_signatureheader(const void* value, size_t size);
  inline ::std::string* mutable_signatureheader();
  inline ::std::string* release_signatureheader();
  inline void set_allocated_signatureheader(::std::string* signatureheader);

  // optional uint32 filesize = 8;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 8;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional uint32 getlasterror = 9;
  inline bool has_getlasterror() const;
  inline void clear_getlasterror();
  static const int kGetlasterrorFieldNumber = 9;
  inline ::google::protobuf::uint32 getlasterror() const;
  inline void set_getlasterror(::google::protobuf::uint32 value);

  // optional uint32 evalvesignaturecheckdetail = 10;
  inline bool has_evalvesignaturecheckdetail() const;
  inline void clear_evalvesignaturecheckdetail();
  static const int kEvalvesignaturecheckdetailFieldNumber = 10;
  inline ::google::protobuf::uint32 evalvesignaturecheckdetail() const;
  inline void set_evalvesignaturecheckdetail(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientCheckFileSignatureResponse)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_esignatureresult();
  inline void clear_has_esignatureresult();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_signatureheader();
  inline void clear_has_signatureheader();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_getlasterror();
  inline void clear_has_getlasterror();
  inline void set_has_evalvesignaturecheckdetail();
  inline void clear_has_evalvesignaturecheckdetail();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 pid_;
  ::std::string* filename_;
  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 esignatureresult_;
  ::std::string* sha_file_;
  ::std::string* signatureheader_;
  ::google::protobuf::uint32 filesize_;
  ::google::protobuf::uint32 getlasterror_;
  ::google::protobuf::uint32 evalvesignaturecheckdetail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientCheckFileSignatureResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientReadMachineAuth : public ::google::protobuf::MessageLite {
 public:
  CMsgClientReadMachineAuth();
  virtual ~CMsgClientReadMachineAuth();

  CMsgClientReadMachineAuth(const CMsgClientReadMachineAuth& from);

  inline CMsgClientReadMachineAuth& operator=(const CMsgClientReadMachineAuth& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientReadMachineAuth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientReadMachineAuth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientReadMachineAuth* other);

  // implements Message ----------------------------------------------

  CMsgClientReadMachineAuth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientReadMachineAuth& from);
  void MergeFrom(const CMsgClientReadMachineAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional uint32 cubtoread = 3;
  inline bool has_cubtoread() const;
  inline void clear_cubtoread();
  static const int kCubtoreadFieldNumber = 3;
  inline ::google::protobuf::uint32 cubtoread() const;
  inline void set_cubtoread(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientReadMachineAuth)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_cubtoread();
  inline void clear_has_cubtoread();

  ::std::string* filename_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 cubtoread_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientReadMachineAuth* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientReadMachineAuthResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientReadMachineAuthResponse();
  virtual ~CMsgClientReadMachineAuthResponse();

  CMsgClientReadMachineAuthResponse(const CMsgClientReadMachineAuthResponse& from);

  inline CMsgClientReadMachineAuthResponse& operator=(const CMsgClientReadMachineAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientReadMachineAuthResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientReadMachineAuthResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientReadMachineAuthResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientReadMachineAuthResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientReadMachineAuthResponse& from);
  void MergeFrom(const CMsgClientReadMachineAuthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 eresult = 2;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 filesize = 3;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 3;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional bytes sha_file = 4;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 4;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint32 getlasterror = 5;
  inline bool has_getlasterror() const;
  inline void clear_getlasterror();
  static const int kGetlasterrorFieldNumber = 5;
  inline ::google::protobuf::uint32 getlasterror() const;
  inline void set_getlasterror(::google::protobuf::uint32 value);

  // optional uint32 offset = 6;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 6;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional uint32 cubread = 7;
  inline bool has_cubread() const;
  inline void clear_cubread();
  static const int kCubreadFieldNumber = 7;
  inline ::google::protobuf::uint32 cubread() const;
  inline void set_cubread(::google::protobuf::uint32 value);

  // optional bytes bytes_read = 8;
  inline bool has_bytes_read() const;
  inline void clear_bytes_read();
  static const int kBytesReadFieldNumber = 8;
  inline const ::std::string& bytes_read() const;
  inline void set_bytes_read(const ::std::string& value);
  inline void set_bytes_read(const char* value);
  inline void set_bytes_read(const void* value, size_t size);
  inline ::std::string* mutable_bytes_read();
  inline ::std::string* release_bytes_read();
  inline void set_allocated_bytes_read(::std::string* bytes_read);

  // optional string filename_sentry = 9;
  inline bool has_filename_sentry() const;
  inline void clear_filename_sentry();
  static const int kFilenameSentryFieldNumber = 9;
  inline const ::std::string& filename_sentry() const;
  inline void set_filename_sentry(const ::std::string& value);
  inline void set_filename_sentry(const char* value);
  inline void set_filename_sentry(const char* value, size_t size);
  inline ::std::string* mutable_filename_sentry();
  inline ::std::string* release_filename_sentry();
  inline void set_allocated_filename_sentry(::std::string* filename_sentry);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientReadMachineAuthResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_getlasterror();
  inline void clear_has_getlasterror();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_cubread();
  inline void clear_has_cubread();
  inline void set_has_bytes_read();
  inline void clear_has_bytes_read();
  inline void set_has_filename_sentry();
  inline void clear_has_filename_sentry();

  ::std::string* filename_;
  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 filesize_;
  ::std::string* sha_file_;
  ::google::protobuf::uint32 getlasterror_;
  ::google::protobuf::uint32 offset_;
  ::std::string* bytes_read_;
  ::std::string* filename_sentry_;
  ::google::protobuf::uint32 cubread_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientReadMachineAuthResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUpdateMachineAuth : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUpdateMachineAuth();
  virtual ~CMsgClientUpdateMachineAuth();

  CMsgClientUpdateMachineAuth(const CMsgClientUpdateMachineAuth& from);

  inline CMsgClientUpdateMachineAuth& operator=(const CMsgClientUpdateMachineAuth& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUpdateMachineAuth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUpdateMachineAuth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUpdateMachineAuth* other);

  // implements Message ----------------------------------------------

  CMsgClientUpdateMachineAuth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUpdateMachineAuth& from);
  void MergeFrom(const CMsgClientUpdateMachineAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional uint32 cubtowrite = 3;
  inline bool has_cubtowrite() const;
  inline void clear_cubtowrite();
  static const int kCubtowriteFieldNumber = 3;
  inline ::google::protobuf::uint32 cubtowrite() const;
  inline void set_cubtowrite(::google::protobuf::uint32 value);

  // optional bytes bytes = 4;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 4;
  inline const ::std::string& bytes() const;
  inline void set_bytes(const ::std::string& value);
  inline void set_bytes(const char* value);
  inline void set_bytes(const void* value, size_t size);
  inline ::std::string* mutable_bytes();
  inline ::std::string* release_bytes();
  inline void set_allocated_bytes(::std::string* bytes);

  // optional uint32 otp_type = 5;
  inline bool has_otp_type() const;
  inline void clear_otp_type();
  static const int kOtpTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 otp_type() const;
  inline void set_otp_type(::google::protobuf::uint32 value);

  // optional string otp_identifier = 6;
  inline bool has_otp_identifier() const;
  inline void clear_otp_identifier();
  static const int kOtpIdentifierFieldNumber = 6;
  inline const ::std::string& otp_identifier() const;
  inline void set_otp_identifier(const ::std::string& value);
  inline void set_otp_identifier(const char* value);
  inline void set_otp_identifier(const char* value, size_t size);
  inline ::std::string* mutable_otp_identifier();
  inline ::std::string* release_otp_identifier();
  inline void set_allocated_otp_identifier(::std::string* otp_identifier);

  // optional bytes otp_sharedsecret = 7;
  inline bool has_otp_sharedsecret() const;
  inline void clear_otp_sharedsecret();
  static const int kOtpSharedsecretFieldNumber = 7;
  inline const ::std::string& otp_sharedsecret() const;
  inline void set_otp_sharedsecret(const ::std::string& value);
  inline void set_otp_sharedsecret(const char* value);
  inline void set_otp_sharedsecret(const void* value, size_t size);
  inline ::std::string* mutable_otp_sharedsecret();
  inline ::std::string* release_otp_sharedsecret();
  inline void set_allocated_otp_sharedsecret(::std::string* otp_sharedsecret);

  // optional uint32 otp_timedrift = 8;
  inline bool has_otp_timedrift() const;
  inline void clear_otp_timedrift();
  static const int kOtpTimedriftFieldNumber = 8;
  inline ::google::protobuf::uint32 otp_timedrift() const;
  inline void set_otp_timedrift(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUpdateMachineAuth)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_cubtowrite();
  inline void clear_has_cubtowrite();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  inline void set_has_otp_type();
  inline void clear_has_otp_type();
  inline void set_has_otp_identifier();
  inline void clear_has_otp_identifier();
  inline void set_has_otp_sharedsecret();
  inline void clear_has_otp_sharedsecret();
  inline void set_has_otp_timedrift();
  inline void clear_has_otp_timedrift();

  ::std::string* filename_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 cubtowrite_;
  ::std::string* bytes_;
  ::std::string* otp_identifier_;
  ::google::protobuf::uint32 otp_type_;
  ::google::protobuf::uint32 otp_timedrift_;
  ::std::string* otp_sharedsecret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUpdateMachineAuth* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUpdateMachineAuthResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUpdateMachineAuthResponse();
  virtual ~CMsgClientUpdateMachineAuthResponse();

  CMsgClientUpdateMachineAuthResponse(const CMsgClientUpdateMachineAuthResponse& from);

  inline CMsgClientUpdateMachineAuthResponse& operator=(const CMsgClientUpdateMachineAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUpdateMachineAuthResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUpdateMachineAuthResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUpdateMachineAuthResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUpdateMachineAuthResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUpdateMachineAuthResponse& from);
  void MergeFrom(const CMsgClientUpdateMachineAuthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 eresult = 2;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 filesize = 3;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 3;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional bytes sha_file = 4;
  inline bool has_sha_file() const;
  inline void clear_sha_file();
  static const int kShaFileFieldNumber = 4;
  inline const ::std::string& sha_file() const;
  inline void set_sha_file(const ::std::string& value);
  inline void set_sha_file(const char* value);
  inline void set_sha_file(const void* value, size_t size);
  inline ::std::string* mutable_sha_file();
  inline ::std::string* release_sha_file();
  inline void set_allocated_sha_file(::std::string* sha_file);

  // optional uint32 getlasterror = 5;
  inline bool has_getlasterror() const;
  inline void clear_getlasterror();
  static const int kGetlasterrorFieldNumber = 5;
  inline ::google::protobuf::uint32 getlasterror() const;
  inline void set_getlasterror(::google::protobuf::uint32 value);

  // optional uint32 offset = 6;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 6;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional uint32 cubwrote = 7;
  inline bool has_cubwrote() const;
  inline void clear_cubwrote();
  static const int kCubwroteFieldNumber = 7;
  inline ::google::protobuf::uint32 cubwrote() const;
  inline void set_cubwrote(::google::protobuf::uint32 value);

  // optional int32 otp_type = 8;
  inline bool has_otp_type() const;
  inline void clear_otp_type();
  static const int kOtpTypeFieldNumber = 8;
  inline ::google::protobuf::int32 otp_type() const;
  inline void set_otp_type(::google::protobuf::int32 value);

  // optional uint32 otp_value = 9;
  inline bool has_otp_value() const;
  inline void clear_otp_value();
  static const int kOtpValueFieldNumber = 9;
  inline ::google::protobuf::uint32 otp_value() const;
  inline void set_otp_value(::google::protobuf::uint32 value);

  // optional string otp_identifier = 10;
  inline bool has_otp_identifier() const;
  inline void clear_otp_identifier();
  static const int kOtpIdentifierFieldNumber = 10;
  inline const ::std::string& otp_identifier() const;
  inline void set_otp_identifier(const ::std::string& value);
  inline void set_otp_identifier(const char* value);
  inline void set_otp_identifier(const char* value, size_t size);
  inline ::std::string* mutable_otp_identifier();
  inline ::std::string* release_otp_identifier();
  inline void set_allocated_otp_identifier(::std::string* otp_identifier);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUpdateMachineAuthResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_sha_file();
  inline void clear_has_sha_file();
  inline void set_has_getlasterror();
  inline void clear_has_getlasterror();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_cubwrote();
  inline void clear_has_cubwrote();
  inline void set_has_otp_type();
  inline void clear_has_otp_type();
  inline void set_has_otp_value();
  inline void clear_has_otp_value();
  inline void set_has_otp_identifier();
  inline void clear_has_otp_identifier();

  ::std::string* filename_;
  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 filesize_;
  ::std::string* sha_file_;
  ::google::protobuf::uint32 getlasterror_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 cubwrote_;
  ::google::protobuf::int32 otp_type_;
  ::std::string* otp_identifier_;
  ::google::protobuf::uint32 otp_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUpdateMachineAuthResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestMachineAuth : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestMachineAuth();
  virtual ~CMsgClientRequestMachineAuth();

  CMsgClientRequestMachineAuth(const CMsgClientRequestMachineAuth& from);

  inline CMsgClientRequestMachineAuth& operator=(const CMsgClientRequestMachineAuth& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestMachineAuth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestMachineAuth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestMachineAuth* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestMachineAuth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestMachineAuth& from);
  void MergeFrom(const CMsgClientRequestMachineAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional uint32 eresult_sentryfile = 2;
  inline bool has_eresult_sentryfile() const;
  inline void clear_eresult_sentryfile();
  static const int kEresultSentryfileFieldNumber = 2;
  inline ::google::protobuf::uint32 eresult_sentryfile() const;
  inline void set_eresult_sentryfile(::google::protobuf::uint32 value);

  // optional uint32 filesize = 3;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 3;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // optional bytes sha_sentryfile = 4;
  inline bool has_sha_sentryfile() const;
  inline void clear_sha_sentryfile();
  static const int kShaSentryfileFieldNumber = 4;
  inline const ::std::string& sha_sentryfile() const;
  inline void set_sha_sentryfile(const ::std::string& value);
  inline void set_sha_sentryfile(const char* value);
  inline void set_sha_sentryfile(const void* value, size_t size);
  inline ::std::string* mutable_sha_sentryfile();
  inline ::std::string* release_sha_sentryfile();
  inline void set_allocated_sha_sentryfile(::std::string* sha_sentryfile);

  // optional int32 lock_account_action = 6;
  inline bool has_lock_account_action() const;
  inline void clear_lock_account_action();
  static const int kLockAccountActionFieldNumber = 6;
  inline ::google::protobuf::int32 lock_account_action() const;
  inline void set_lock_account_action(::google::protobuf::int32 value);

  // optional uint32 otp_type = 7;
  inline bool has_otp_type() const;
  inline void clear_otp_type();
  static const int kOtpTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 otp_type() const;
  inline void set_otp_type(::google::protobuf::uint32 value);

  // optional string otp_identifier = 8;
  inline bool has_otp_identifier() const;
  inline void clear_otp_identifier();
  static const int kOtpIdentifierFieldNumber = 8;
  inline const ::std::string& otp_identifier() const;
  inline void set_otp_identifier(const ::std::string& value);
  inline void set_otp_identifier(const char* value);
  inline void set_otp_identifier(const char* value, size_t size);
  inline ::std::string* mutable_otp_identifier();
  inline ::std::string* release_otp_identifier();
  inline void set_allocated_otp_identifier(::std::string* otp_identifier);

  // optional bytes otp_sharedsecret = 9;
  inline bool has_otp_sharedsecret() const;
  inline void clear_otp_sharedsecret();
  static const int kOtpSharedsecretFieldNumber = 9;
  inline const ::std::string& otp_sharedsecret() const;
  inline void set_otp_sharedsecret(const ::std::string& value);
  inline void set_otp_sharedsecret(const char* value);
  inline void set_otp_sharedsecret(const void* value, size_t size);
  inline ::std::string* mutable_otp_sharedsecret();
  inline ::std::string* release_otp_sharedsecret();
  inline void set_allocated_otp_sharedsecret(::std::string* otp_sharedsecret);

  // optional uint32 otp_value = 10;
  inline bool has_otp_value() const;
  inline void clear_otp_value();
  static const int kOtpValueFieldNumber = 10;
  inline ::google::protobuf::uint32 otp_value() const;
  inline void set_otp_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestMachineAuth)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_eresult_sentryfile();
  inline void clear_has_eresult_sentryfile();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_sha_sentryfile();
  inline void clear_has_sha_sentryfile();
  inline void set_has_lock_account_action();
  inline void clear_has_lock_account_action();
  inline void set_has_otp_type();
  inline void clear_has_otp_type();
  inline void set_has_otp_identifier();
  inline void clear_has_otp_identifier();
  inline void set_has_otp_sharedsecret();
  inline void clear_has_otp_sharedsecret();
  inline void set_has_otp_value();
  inline void clear_has_otp_value();

  ::std::string* filename_;
  ::google::protobuf::uint32 eresult_sentryfile_;
  ::google::protobuf::uint32 filesize_;
  ::std::string* sha_sentryfile_;
  ::google::protobuf::int32 lock_account_action_;
  ::google::protobuf::uint32 otp_type_;
  ::std::string* otp_identifier_;
  ::std::string* otp_sharedsecret_;
  ::google::protobuf::uint32 otp_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestMachineAuth* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestMachineAuthResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestMachineAuthResponse();
  virtual ~CMsgClientRequestMachineAuthResponse();

  CMsgClientRequestMachineAuthResponse(const CMsgClientRequestMachineAuthResponse& from);

  inline CMsgClientRequestMachineAuthResponse& operator=(const CMsgClientRequestMachineAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestMachineAuthResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestMachineAuthResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestMachineAuthResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestMachineAuthResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestMachineAuthResponse& from);
  void MergeFrom(const CMsgClientRequestMachineAuthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestMachineAuthResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestMachineAuthResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientChangeSteamGuardOptions : public ::google::protobuf::MessageLite {
 public:
  CMsgClientChangeSteamGuardOptions();
  virtual ~CMsgClientChangeSteamGuardOptions();

  CMsgClientChangeSteamGuardOptions(const CMsgClientChangeSteamGuardOptions& from);

  inline CMsgClientChangeSteamGuardOptions& operator=(const CMsgClientChangeSteamGuardOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientChangeSteamGuardOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientChangeSteamGuardOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientChangeSteamGuardOptions* other);

  // implements Message ----------------------------------------------

  CMsgClientChangeSteamGuardOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientChangeSteamGuardOptions& from);
  void MergeFrom(const CMsgClientChangeSteamGuardOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 steamguard_provider = 1;
  inline bool has_steamguard_provider() const;
  inline void clear_steamguard_provider();
  static const int kSteamguardProviderFieldNumber = 1;
  inline ::google::protobuf::uint32 steamguard_provider() const;
  inline void set_steamguard_provider(::google::protobuf::uint32 value);

  // optional uint32 steamguard_require_code_default = 2;
  inline bool has_steamguard_require_code_default() const;
  inline void clear_steamguard_require_code_default();
  static const int kSteamguardRequireCodeDefaultFieldNumber = 2;
  inline ::google::protobuf::uint32 steamguard_require_code_default() const;
  inline void set_steamguard_require_code_default(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientChangeSteamGuardOptions)
 private:
  inline void set_has_steamguard_provider();
  inline void clear_has_steamguard_provider();
  inline void set_has_steamguard_require_code_default();
  inline void clear_has_steamguard_require_code_default();

  ::google::protobuf::uint32 steamguard_provider_;
  ::google::protobuf::uint32 steamguard_require_code_default_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientChangeSteamGuardOptions* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientChangeSteamGuardOptionsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientChangeSteamGuardOptionsResponse();
  virtual ~CMsgClientChangeSteamGuardOptionsResponse();

  CMsgClientChangeSteamGuardOptionsResponse(const CMsgClientChangeSteamGuardOptionsResponse& from);

  inline CMsgClientChangeSteamGuardOptionsResponse& operator=(const CMsgClientChangeSteamGuardOptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientChangeSteamGuardOptionsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientChangeSteamGuardOptionsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientChangeSteamGuardOptionsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientChangeSteamGuardOptionsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientChangeSteamGuardOptionsResponse& from);
  void MergeFrom(const CMsgClientChangeSteamGuardOptionsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientChangeSteamGuardOptionsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientChangeSteamGuardOptionsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientCreateFriendsGroup : public ::google::protobuf::MessageLite {
 public:
  CMsgClientCreateFriendsGroup();
  virtual ~CMsgClientCreateFriendsGroup();

  CMsgClientCreateFriendsGroup(const CMsgClientCreateFriendsGroup& from);

  inline CMsgClientCreateFriendsGroup& operator=(const CMsgClientCreateFriendsGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientCreateFriendsGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientCreateFriendsGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientCreateFriendsGroup* other);

  // implements Message ----------------------------------------------

  CMsgClientCreateFriendsGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientCreateFriendsGroup& from);
  void MergeFrom(const CMsgClientCreateFriendsGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional string groupname = 2;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupnameFieldNumber = 2;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientCreateFriendsGroup)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_groupname();
  inline void clear_has_groupname();

  ::google::protobuf::uint64 steamid_;
  ::std::string* groupname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientCreateFriendsGroup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientCreateFriendsGroupResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientCreateFriendsGroupResponse();
  virtual ~CMsgClientCreateFriendsGroupResponse();

  CMsgClientCreateFriendsGroupResponse(const CMsgClientCreateFriendsGroupResponse& from);

  inline CMsgClientCreateFriendsGroupResponse& operator=(const CMsgClientCreateFriendsGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientCreateFriendsGroupResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientCreateFriendsGroupResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientCreateFriendsGroupResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientCreateFriendsGroupResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientCreateFriendsGroupResponse& from);
  void MergeFrom(const CMsgClientCreateFriendsGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional int32 groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientCreateFriendsGroupResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientCreateFriendsGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDeleteFriendsGroup : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDeleteFriendsGroup();
  virtual ~CMsgClientDeleteFriendsGroup();

  CMsgClientDeleteFriendsGroup(const CMsgClientDeleteFriendsGroup& from);

  inline CMsgClientDeleteFriendsGroup& operator=(const CMsgClientDeleteFriendsGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDeleteFriendsGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDeleteFriendsGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDeleteFriendsGroup* other);

  // implements Message ----------------------------------------------

  CMsgClientDeleteFriendsGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDeleteFriendsGroup& from);
  void MergeFrom(const CMsgClientDeleteFriendsGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional int32 groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDeleteFriendsGroup)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint64 steamid_;
  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDeleteFriendsGroup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDeleteFriendsGroupResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDeleteFriendsGroupResponse();
  virtual ~CMsgClientDeleteFriendsGroupResponse();

  CMsgClientDeleteFriendsGroupResponse(const CMsgClientDeleteFriendsGroupResponse& from);

  inline CMsgClientDeleteFriendsGroupResponse& operator=(const CMsgClientDeleteFriendsGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDeleteFriendsGroupResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDeleteFriendsGroupResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDeleteFriendsGroupResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientDeleteFriendsGroupResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDeleteFriendsGroupResponse& from);
  void MergeFrom(const CMsgClientDeleteFriendsGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDeleteFriendsGroupResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDeleteFriendsGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRenameFriendsGroup : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRenameFriendsGroup();
  virtual ~CMsgClientRenameFriendsGroup();

  CMsgClientRenameFriendsGroup(const CMsgClientRenameFriendsGroup& from);

  inline CMsgClientRenameFriendsGroup& operator=(const CMsgClientRenameFriendsGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRenameFriendsGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRenameFriendsGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRenameFriendsGroup* other);

  // implements Message ----------------------------------------------

  CMsgClientRenameFriendsGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRenameFriendsGroup& from);
  void MergeFrom(const CMsgClientRenameFriendsGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // optional string groupname = 2;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupnameFieldNumber = 2;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRenameFriendsGroup)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_groupname();
  inline void clear_has_groupname();

  ::std::string* groupname_;
  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRenameFriendsGroup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRenameFriendsGroupResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRenameFriendsGroupResponse();
  virtual ~CMsgClientRenameFriendsGroupResponse();

  CMsgClientRenameFriendsGroupResponse(const CMsgClientRenameFriendsGroupResponse& from);

  inline CMsgClientRenameFriendsGroupResponse& operator=(const CMsgClientRenameFriendsGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRenameFriendsGroupResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRenameFriendsGroupResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRenameFriendsGroupResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRenameFriendsGroupResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRenameFriendsGroupResponse& from);
  void MergeFrom(const CMsgClientRenameFriendsGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRenameFriendsGroupResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRenameFriendsGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAddFriendToGroup : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAddFriendToGroup();
  virtual ~CMsgClientAddFriendToGroup();

  CMsgClientAddFriendToGroup(const CMsgClientAddFriendToGroup& from);

  inline CMsgClientAddFriendToGroup& operator=(const CMsgClientAddFriendToGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAddFriendToGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAddFriendToGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAddFriendToGroup* other);

  // implements Message ----------------------------------------------

  CMsgClientAddFriendToGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAddFriendToGroup& from);
  void MergeFrom(const CMsgClientAddFriendToGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // optional fixed64 steamiduser = 2;
  inline bool has_steamiduser() const;
  inline void clear_steamiduser();
  static const int kSteamiduserFieldNumber = 2;
  inline ::google::protobuf::uint64 steamiduser() const;
  inline void set_steamiduser(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAddFriendToGroup)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_steamiduser();
  inline void clear_has_steamiduser();

  ::google::protobuf::uint64 steamiduser_;
  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAddFriendToGroup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAddFriendToGroupResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientAddFriendToGroupResponse();
  virtual ~CMsgClientAddFriendToGroupResponse();

  CMsgClientAddFriendToGroupResponse(const CMsgClientAddFriendToGroupResponse& from);

  inline CMsgClientAddFriendToGroupResponse& operator=(const CMsgClientAddFriendToGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientAddFriendToGroupResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientAddFriendToGroupResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientAddFriendToGroupResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientAddFriendToGroupResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientAddFriendToGroupResponse& from);
  void MergeFrom(const CMsgClientAddFriendToGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientAddFriendToGroupResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAddFriendToGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRemoveFriendFromGroup : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRemoveFriendFromGroup();
  virtual ~CMsgClientRemoveFriendFromGroup();

  CMsgClientRemoveFriendFromGroup(const CMsgClientRemoveFriendFromGroup& from);

  inline CMsgClientRemoveFriendFromGroup& operator=(const CMsgClientRemoveFriendFromGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRemoveFriendFromGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRemoveFriendFromGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRemoveFriendFromGroup* other);

  // implements Message ----------------------------------------------

  CMsgClientRemoveFriendFromGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRemoveFriendFromGroup& from);
  void MergeFrom(const CMsgClientRemoveFriendFromGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // optional fixed64 steamiduser = 2;
  inline bool has_steamiduser() const;
  inline void clear_steamiduser();
  static const int kSteamiduserFieldNumber = 2;
  inline ::google::protobuf::uint64 steamiduser() const;
  inline void set_steamiduser(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRemoveFriendFromGroup)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_steamiduser();
  inline void clear_has_steamiduser();

  ::google::protobuf::uint64 steamiduser_;
  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRemoveFriendFromGroup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRemoveFriendFromGroupResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRemoveFriendFromGroupResponse();
  virtual ~CMsgClientRemoveFriendFromGroupResponse();

  CMsgClientRemoveFriendFromGroupResponse(const CMsgClientRemoveFriendFromGroupResponse& from);

  inline CMsgClientRemoveFriendFromGroupResponse& operator=(const CMsgClientRemoveFriendFromGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRemoveFriendFromGroupResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRemoveFriendFromGroupResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRemoveFriendFromGroupResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRemoveFriendFromGroupResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRemoveFriendFromGroupResponse& from);
  void MergeFrom(const CMsgClientRemoveFriendFromGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRemoveFriendFromGroupResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRemoveFriendFromGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRegisterKey : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRegisterKey();
  virtual ~CMsgClientRegisterKey();

  CMsgClientRegisterKey(const CMsgClientRegisterKey& from);

  inline CMsgClientRegisterKey& operator=(const CMsgClientRegisterKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRegisterKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRegisterKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRegisterKey* other);

  // implements Message ----------------------------------------------

  CMsgClientRegisterKey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRegisterKey& from);
  void MergeFrom(const CMsgClientRegisterKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRegisterKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRegisterKey* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPurchaseResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPurchaseResponse();
  virtual ~CMsgClientPurchaseResponse();

  CMsgClientPurchaseResponse(const CMsgClientPurchaseResponse& from);

  inline CMsgClientPurchaseResponse& operator=(const CMsgClientPurchaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPurchaseResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPurchaseResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPurchaseResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientPurchaseResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPurchaseResponse& from);
  void MergeFrom(const CMsgClientPurchaseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 purchase_result_details = 2;
  inline bool has_purchase_result_details() const;
  inline void clear_purchase_result_details();
  static const int kPurchaseResultDetailsFieldNumber = 2;
  inline ::google::protobuf::int32 purchase_result_details() const;
  inline void set_purchase_result_details(::google::protobuf::int32 value);

  // optional bytes purchase_receipt_info = 3;
  inline bool has_purchase_receipt_info() const;
  inline void clear_purchase_receipt_info();
  static const int kPurchaseReceiptInfoFieldNumber = 3;
  inline const ::std::string& purchase_receipt_info() const;
  inline void set_purchase_receipt_info(const ::std::string& value);
  inline void set_purchase_receipt_info(const char* value);
  inline void set_purchase_receipt_info(const void* value, size_t size);
  inline ::std::string* mutable_purchase_receipt_info();
  inline ::std::string* release_purchase_receipt_info();
  inline void set_allocated_purchase_receipt_info(::std::string* purchase_receipt_info);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPurchaseResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_purchase_result_details();
  inline void clear_has_purchase_result_details();
  inline void set_has_purchase_receipt_info();
  inline void clear_has_purchase_receipt_info();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 purchase_result_details_;
  ::std::string* purchase_receipt_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPurchaseResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientActivateOEMLicense : public ::google::protobuf::MessageLite {
 public:
  CMsgClientActivateOEMLicense();
  virtual ~CMsgClientActivateOEMLicense();

  CMsgClientActivateOEMLicense(const CMsgClientActivateOEMLicense& from);

  inline CMsgClientActivateOEMLicense& operator=(const CMsgClientActivateOEMLicense& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientActivateOEMLicense& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientActivateOEMLicense* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientActivateOEMLicense* other);

  // implements Message ----------------------------------------------

  CMsgClientActivateOEMLicense* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientActivateOEMLicense& from);
  void MergeFrom(const CMsgClientActivateOEMLicense& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bios_manufacturer = 1;
  inline bool has_bios_manufacturer() const;
  inline void clear_bios_manufacturer();
  static const int kBiosManufacturerFieldNumber = 1;
  inline const ::std::string& bios_manufacturer() const;
  inline void set_bios_manufacturer(const ::std::string& value);
  inline void set_bios_manufacturer(const char* value);
  inline void set_bios_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_bios_manufacturer();
  inline ::std::string* release_bios_manufacturer();
  inline void set_allocated_bios_manufacturer(::std::string* bios_manufacturer);

  // optional string bios_serialnumber = 2;
  inline bool has_bios_serialnumber() const;
  inline void clear_bios_serialnumber();
  static const int kBiosSerialnumberFieldNumber = 2;
  inline const ::std::string& bios_serialnumber() const;
  inline void set_bios_serialnumber(const ::std::string& value);
  inline void set_bios_serialnumber(const char* value);
  inline void set_bios_serialnumber(const char* value, size_t size);
  inline ::std::string* mutable_bios_serialnumber();
  inline ::std::string* release_bios_serialnumber();
  inline void set_allocated_bios_serialnumber(::std::string* bios_serialnumber);

  // optional bytes license_file = 3;
  inline bool has_license_file() const;
  inline void clear_license_file();
  static const int kLicenseFileFieldNumber = 3;
  inline const ::std::string& license_file() const;
  inline void set_license_file(const ::std::string& value);
  inline void set_license_file(const char* value);
  inline void set_license_file(const void* value, size_t size);
  inline ::std::string* mutable_license_file();
  inline ::std::string* release_license_file();
  inline void set_allocated_license_file(::std::string* license_file);

  // optional string mainboard_manufacturer = 4;
  inline bool has_mainboard_manufacturer() const;
  inline void clear_mainboard_manufacturer();
  static const int kMainboardManufacturerFieldNumber = 4;
  inline const ::std::string& mainboard_manufacturer() const;
  inline void set_mainboard_manufacturer(const ::std::string& value);
  inline void set_mainboard_manufacturer(const char* value);
  inline void set_mainboard_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_mainboard_manufacturer();
  inline ::std::string* release_mainboard_manufacturer();
  inline void set_allocated_mainboard_manufacturer(::std::string* mainboard_manufacturer);

  // optional string mainboard_product = 5;
  inline bool has_mainboard_product() const;
  inline void clear_mainboard_product();
  static const int kMainboardProductFieldNumber = 5;
  inline const ::std::string& mainboard_product() const;
  inline void set_mainboard_product(const ::std::string& value);
  inline void set_mainboard_product(const char* value);
  inline void set_mainboard_product(const char* value, size_t size);
  inline ::std::string* mutable_mainboard_product();
  inline ::std::string* release_mainboard_product();
  inline void set_allocated_mainboard_product(::std::string* mainboard_product);

  // optional string mainboard_serialnumber = 6;
  inline bool has_mainboard_serialnumber() const;
  inline void clear_mainboard_serialnumber();
  static const int kMainboardSerialnumberFieldNumber = 6;
  inline const ::std::string& mainboard_serialnumber() const;
  inline void set_mainboard_serialnumber(const ::std::string& value);
  inline void set_mainboard_serialnumber(const char* value);
  inline void set_mainboard_serialnumber(const char* value, size_t size);
  inline ::std::string* mutable_mainboard_serialnumber();
  inline ::std::string* release_mainboard_serialnumber();
  inline void set_allocated_mainboard_serialnumber(::std::string* mainboard_serialnumber);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientActivateOEMLicense)
 private:
  inline void set_has_bios_manufacturer();
  inline void clear_has_bios_manufacturer();
  inline void set_has_bios_serialnumber();
  inline void clear_has_bios_serialnumber();
  inline void set_has_license_file();
  inline void clear_has_license_file();
  inline void set_has_mainboard_manufacturer();
  inline void clear_has_mainboard_manufacturer();
  inline void set_has_mainboard_product();
  inline void clear_has_mainboard_product();
  inline void set_has_mainboard_serialnumber();
  inline void clear_has_mainboard_serialnumber();

  ::std::string* bios_manufacturer_;
  ::std::string* bios_serialnumber_;
  ::std::string* license_file_;
  ::std::string* mainboard_manufacturer_;
  ::std::string* mainboard_product_;
  ::std::string* mainboard_serialnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientActivateOEMLicense* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientPurchaseWithMachineID : public ::google::protobuf::MessageLite {
 public:
  CMsgClientPurchaseWithMachineID();
  virtual ~CMsgClientPurchaseWithMachineID();

  CMsgClientPurchaseWithMachineID(const CMsgClientPurchaseWithMachineID& from);

  inline CMsgClientPurchaseWithMachineID& operator=(const CMsgClientPurchaseWithMachineID& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientPurchaseWithMachineID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientPurchaseWithMachineID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientPurchaseWithMachineID* other);

  // implements Message ----------------------------------------------

  CMsgClientPurchaseWithMachineID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientPurchaseWithMachineID& from);
  void MergeFrom(const CMsgClientPurchaseWithMachineID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 package_id = 1;
  inline bool has_package_id() const;
  inline void clear_package_id();
  static const int kPackageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 package_id() const;
  inline void set_package_id(::google::protobuf::uint32 value);

  // optional bytes machine_info = 2;
  inline bool has_machine_info() const;
  inline void clear_machine_info();
  static const int kMachineInfoFieldNumber = 2;
  inline const ::std::string& machine_info() const;
  inline void set_machine_info(const ::std::string& value);
  inline void set_machine_info(const char* value);
  inline void set_machine_info(const void* value, size_t size);
  inline ::std::string* mutable_machine_info();
  inline ::std::string* release_machine_info();
  inline void set_allocated_machine_info(::std::string* machine_info);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientPurchaseWithMachineID)
 private:
  inline void set_has_package_id();
  inline void clear_has_package_id();
  inline void set_has_machine_info();
  inline void clear_has_machine_info();

  ::std::string* machine_info_;
  ::google::protobuf::uint32 package_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientPurchaseWithMachineID* default_instance_;
};
// -------------------------------------------------------------------

class CMsgTrading_InitiateTradeRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgTrading_InitiateTradeRequest();
  virtual ~CMsgTrading_InitiateTradeRequest();

  CMsgTrading_InitiateTradeRequest(const CMsgTrading_InitiateTradeRequest& from);

  inline CMsgTrading_InitiateTradeRequest& operator=(const CMsgTrading_InitiateTradeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgTrading_InitiateTradeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgTrading_InitiateTradeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgTrading_InitiateTradeRequest* other);

  // implements Message ----------------------------------------------

  CMsgTrading_InitiateTradeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgTrading_InitiateTradeRequest& from);
  void MergeFrom(const CMsgTrading_InitiateTradeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trade_request_id = 1;
  inline bool has_trade_request_id() const;
  inline void clear_trade_request_id();
  static const int kTradeRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 trade_request_id() const;
  inline void set_trade_request_id(::google::protobuf::uint32 value);

  // optional uint64 other_steamid = 2;
  inline bool has_other_steamid() const;
  inline void clear_other_steamid();
  static const int kOtherSteamidFieldNumber = 2;
  inline ::google::protobuf::uint64 other_steamid() const;
  inline void set_other_steamid(::google::protobuf::uint64 value);

  // optional string other_name = 3;
  inline bool has_other_name() const;
  inline void clear_other_name();
  static const int kOtherNameFieldNumber = 3;
  inline const ::std::string& other_name() const;
  inline void set_other_name(const ::std::string& value);
  inline void set_other_name(const char* value);
  inline void set_other_name(const char* value, size_t size);
  inline ::std::string* mutable_other_name();
  inline ::std::string* release_other_name();
  inline void set_allocated_other_name(::std::string* other_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgTrading_InitiateTradeRequest)
 private:
  inline void set_has_trade_request_id();
  inline void clear_has_trade_request_id();
  inline void set_has_other_steamid();
  inline void clear_has_other_steamid();
  inline void set_has_other_name();
  inline void clear_has_other_name();

  ::google::protobuf::uint64 other_steamid_;
  ::std::string* other_name_;
  ::google::protobuf::uint32 trade_request_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgTrading_InitiateTradeRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgTrading_InitiateTradeResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgTrading_InitiateTradeResponse();
  virtual ~CMsgTrading_InitiateTradeResponse();

  CMsgTrading_InitiateTradeResponse(const CMsgTrading_InitiateTradeResponse& from);

  inline CMsgTrading_InitiateTradeResponse& operator=(const CMsgTrading_InitiateTradeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgTrading_InitiateTradeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgTrading_InitiateTradeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgTrading_InitiateTradeResponse* other);

  // implements Message ----------------------------------------------

  CMsgTrading_InitiateTradeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgTrading_InitiateTradeResponse& from);
  void MergeFrom(const CMsgTrading_InitiateTradeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 response = 1;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 1;
  inline ::google::protobuf::uint32 response() const;
  inline void set_response(::google::protobuf::uint32 value);

  // optional uint32 trade_request_id = 2;
  inline bool has_trade_request_id() const;
  inline void clear_trade_request_id();
  static const int kTradeRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint32 trade_request_id() const;
  inline void set_trade_request_id(::google::protobuf::uint32 value);

  // optional uint64 other_steamid = 3;
  inline bool has_other_steamid() const;
  inline void clear_other_steamid();
  static const int kOtherSteamidFieldNumber = 3;
  inline ::google::protobuf::uint64 other_steamid() const;
  inline void set_other_steamid(::google::protobuf::uint64 value);

  // optional uint32 steamguard_required_days = 4;
  inline bool has_steamguard_required_days() const;
  inline void clear_steamguard_required_days();
  static const int kSteamguardRequiredDaysFieldNumber = 4;
  inline ::google::protobuf::uint32 steamguard_required_days() const;
  inline void set_steamguard_required_days(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgTrading_InitiateTradeResponse)
 private:
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_trade_request_id();
  inline void clear_has_trade_request_id();
  inline void set_has_other_steamid();
  inline void clear_has_other_steamid();
  inline void set_has_steamguard_required_days();
  inline void clear_has_steamguard_required_days();

  ::google::protobuf::uint32 response_;
  ::google::protobuf::uint32 trade_request_id_;
  ::google::protobuf::uint64 other_steamid_;
  ::google::protobuf::uint32 steamguard_required_days_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgTrading_InitiateTradeResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgTrading_CancelTradeRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgTrading_CancelTradeRequest();
  virtual ~CMsgTrading_CancelTradeRequest();

  CMsgTrading_CancelTradeRequest(const CMsgTrading_CancelTradeRequest& from);

  inline CMsgTrading_CancelTradeRequest& operator=(const CMsgTrading_CancelTradeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgTrading_CancelTradeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgTrading_CancelTradeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgTrading_CancelTradeRequest* other);

  // implements Message ----------------------------------------------

  CMsgTrading_CancelTradeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgTrading_CancelTradeRequest& from);
  void MergeFrom(const CMsgTrading_CancelTradeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 other_steamid = 1;
  inline bool has_other_steamid() const;
  inline void clear_other_steamid();
  static const int kOtherSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 other_steamid() const;
  inline void set_other_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgTrading_CancelTradeRequest)
 private:
  inline void set_has_other_steamid();
  inline void clear_has_other_steamid();

  ::google::protobuf::uint64 other_steamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgTrading_CancelTradeRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgTrading_StartSession : public ::google::protobuf::MessageLite {
 public:
  CMsgTrading_StartSession();
  virtual ~CMsgTrading_StartSession();

  CMsgTrading_StartSession(const CMsgTrading_StartSession& from);

  inline CMsgTrading_StartSession& operator=(const CMsgTrading_StartSession& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgTrading_StartSession& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgTrading_StartSession* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgTrading_StartSession* other);

  // implements Message ----------------------------------------------

  CMsgTrading_StartSession* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgTrading_StartSession& from);
  void MergeFrom(const CMsgTrading_StartSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 other_steamid = 1;
  inline bool has_other_steamid() const;
  inline void clear_other_steamid();
  static const int kOtherSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 other_steamid() const;
  inline void set_other_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgTrading_StartSession)
 private:
  inline void set_has_other_steamid();
  inline void clear_has_other_steamid();

  ::google::protobuf::uint64 other_steamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgTrading_StartSession* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSInitDepotBuildRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSInitDepotBuildRequest();
  virtual ~CMsgClientMDSInitDepotBuildRequest();

  CMsgClientMDSInitDepotBuildRequest(const CMsgClientMDSInitDepotBuildRequest& from);

  inline CMsgClientMDSInitDepotBuildRequest& operator=(const CMsgClientMDSInitDepotBuildRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSInitDepotBuildRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSInitDepotBuildRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSInitDepotBuildRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSInitDepotBuildRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSInitDepotBuildRequest& from);
  void MergeFrom(const CMsgClientMDSInitDepotBuildRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 depot_id = 1;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // optional bytes encrypted_aes_key = 2;
  inline bool has_encrypted_aes_key() const;
  inline void clear_encrypted_aes_key();
  static const int kEncryptedAesKeyFieldNumber = 2;
  inline const ::std::string& encrypted_aes_key() const;
  inline void set_encrypted_aes_key(const ::std::string& value);
  inline void set_encrypted_aes_key(const char* value);
  inline void set_encrypted_aes_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_aes_key();
  inline ::std::string* release_encrypted_aes_key();
  inline void set_allocated_encrypted_aes_key(::std::string* encrypted_aes_key);

  // optional uint32 build_id = 4;
  inline bool has_build_id() const;
  inline void clear_build_id();
  static const int kBuildIdFieldNumber = 4;
  inline ::google::protobuf::uint32 build_id() const;
  inline void set_build_id(::google::protobuf::uint32 value);

  // optional bool for_local_cs = 5;
  inline bool has_for_local_cs() const;
  inline void clear_for_local_cs();
  static const int kForLocalCsFieldNumber = 5;
  inline bool for_local_cs() const;
  inline void set_for_local_cs(bool value);

  // optional bool no_baseline = 6;
  inline bool has_no_baseline() const;
  inline void clear_no_baseline();
  static const int kNoBaselineFieldNumber = 6;
  inline bool no_baseline() const;
  inline void set_no_baseline(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSInitDepotBuildRequest)
 private:
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_encrypted_aes_key();
  inline void clear_has_encrypted_aes_key();
  inline void set_has_build_id();
  inline void clear_has_build_id();
  inline void set_has_for_local_cs();
  inline void clear_has_for_local_cs();
  inline void set_has_no_baseline();
  inline void clear_has_no_baseline();

  ::std::string* encrypted_aes_key_;
  ::google::protobuf::uint32 depot_id_;
  ::google::protobuf::uint32 build_id_;
  bool for_local_cs_;
  bool no_baseline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSInitDepotBuildRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSInitDepotBuildResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSInitDepotBuildResponse();
  virtual ~CMsgClientMDSInitDepotBuildResponse();

  CMsgClientMDSInitDepotBuildResponse(const CMsgClientMDSInitDepotBuildResponse& from);

  inline CMsgClientMDSInitDepotBuildResponse& operator=(const CMsgClientMDSInitDepotBuildResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSInitDepotBuildResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSInitDepotBuildResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSInitDepotBuildResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSInitDepotBuildResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSInitDepotBuildResponse& from);
  void MergeFrom(const CMsgClientMDSInitDepotBuildResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 default_chunk_size = 2;
  inline bool has_default_chunk_size() const;
  inline void clear_default_chunk_size();
  static const int kDefaultChunkSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 default_chunk_size() const;
  inline void set_default_chunk_size(::google::protobuf::uint32 value);

  // optional fixed64 base_manifest = 3;
  inline bool has_base_manifest() const;
  inline void clear_base_manifest();
  static const int kBaseManifestFieldNumber = 3;
  inline ::google::protobuf::uint64 base_manifest() const;
  inline void set_base_manifest(::google::protobuf::uint64 value);

  // optional bytes encrypted_depot_key = 4;
  inline bool has_encrypted_depot_key() const;
  inline void clear_encrypted_depot_key();
  static const int kEncryptedDepotKeyFieldNumber = 4;
  inline const ::std::string& encrypted_depot_key() const;
  inline void set_encrypted_depot_key(const ::std::string& value);
  inline void set_encrypted_depot_key(const char* value);
  inline void set_encrypted_depot_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_depot_key();
  inline ::std::string* release_encrypted_depot_key();
  inline void set_allocated_encrypted_depot_key(::std::string* encrypted_depot_key);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSInitDepotBuildResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_default_chunk_size();
  inline void clear_has_default_chunk_size();
  inline void set_has_base_manifest();
  inline void clear_has_base_manifest();
  inline void set_has_encrypted_depot_key();
  inline void clear_has_encrypted_depot_key();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 default_chunk_size_;
  ::google::protobuf::uint64 base_manifest_;
  ::std::string* encrypted_depot_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSInitDepotBuildResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSLoginRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSLoginRequest();
  virtual ~CMsgClientMDSLoginRequest();

  CMsgClientMDSLoginRequest(const CMsgClientMDSLoginRequest& from);

  inline CMsgClientMDSLoginRequest& operator=(const CMsgClientMDSLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSLoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSLoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSLoginRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSLoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSLoginRequest& from);
  void MergeFrom(const CMsgClientMDSLoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes encrypted_session_key = 1;
  inline bool has_encrypted_session_key() const;
  inline void clear_encrypted_session_key();
  static const int kEncryptedSessionKeyFieldNumber = 1;
  inline const ::std::string& encrypted_session_key() const;
  inline void set_encrypted_session_key(const ::std::string& value);
  inline void set_encrypted_session_key(const char* value);
  inline void set_encrypted_session_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_session_key();
  inline ::std::string* release_encrypted_session_key();
  inline void set_allocated_encrypted_session_key(::std::string* encrypted_session_key);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSLoginRequest)
 private:
  inline void set_has_encrypted_session_key();
  inline void clear_has_encrypted_session_key();

  ::std::string* encrypted_session_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSLoginResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSLoginResponse();
  virtual ~CMsgClientMDSLoginResponse();

  CMsgClientMDSLoginResponse(const CMsgClientMDSLoginResponse& from);

  inline CMsgClientMDSLoginResponse& operator=(const CMsgClientMDSLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSLoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSLoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSLoginResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSLoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSLoginResponse& from);
  void MergeFrom(const CMsgClientMDSLoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSLoginResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadDepotChunks_ChunkUploadData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadDepotChunks_ChunkUploadData();
  virtual ~CMsgClientMDSUploadDepotChunks_ChunkUploadData();

  CMsgClientMDSUploadDepotChunks_ChunkUploadData(const CMsgClientMDSUploadDepotChunks_ChunkUploadData& from);

  inline CMsgClientMDSUploadDepotChunks_ChunkUploadData& operator=(const CMsgClientMDSUploadDepotChunks_ChunkUploadData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadDepotChunks_ChunkUploadData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadDepotChunks_ChunkUploadData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadDepotChunks_ChunkUploadData* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadDepotChunks_ChunkUploadData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadDepotChunks_ChunkUploadData& from);
  void MergeFrom(const CMsgClientMDSUploadDepotChunks_ChunkUploadData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha = 1;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 1;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  inline ::std::string* release_sha();
  inline void set_allocated_sha(::std::string* sha);

  // optional uint32 rolling_crc = 2;
  inline bool has_rolling_crc() const;
  inline void clear_rolling_crc();
  static const int kRollingCrcFieldNumber = 2;
  inline ::google::protobuf::uint32 rolling_crc() const;
  inline void set_rolling_crc(::google::protobuf::uint32 value);

  // optional uint32 original_chunk_size = 3;
  inline bool has_original_chunk_size() const;
  inline void clear_original_chunk_size();
  static const int kOriginalChunkSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 original_chunk_size() const;
  inline void set_original_chunk_size(::google::protobuf::uint32 value);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional uint32 compressed_chunk_size = 5;
  inline bool has_compressed_chunk_size() const;
  inline void clear_compressed_chunk_size();
  static const int kCompressedChunkSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 compressed_chunk_size() const;
  inline void set_compressed_chunk_size(::google::protobuf::uint32 value);

  // optional uint32 compressed_crc = 6;
  inline bool has_compressed_crc() const;
  inline void clear_compressed_crc();
  static const int kCompressedCrcFieldNumber = 6;
  inline ::google::protobuf::uint32 compressed_crc() const;
  inline void set_compressed_crc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadDepotChunks.ChunkUploadData)
 private:
  inline void set_has_sha();
  inline void clear_has_sha();
  inline void set_has_rolling_crc();
  inline void clear_has_rolling_crc();
  inline void set_has_original_chunk_size();
  inline void clear_has_original_chunk_size();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_compressed_chunk_size();
  inline void clear_has_compressed_chunk_size();
  inline void set_has_compressed_crc();
  inline void clear_has_compressed_crc();

  ::std::string* sha_;
  ::google::protobuf::uint32 rolling_crc_;
  ::google::protobuf::uint32 original_chunk_size_;
  ::std::string* data_;
  ::google::protobuf::uint32 compressed_chunk_size_;
  ::google::protobuf::uint32 compressed_crc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadDepotChunks_ChunkUploadData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadDepotChunks : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadDepotChunks();
  virtual ~CMsgClientMDSUploadDepotChunks();

  CMsgClientMDSUploadDepotChunks(const CMsgClientMDSUploadDepotChunks& from);

  inline CMsgClientMDSUploadDepotChunks& operator=(const CMsgClientMDSUploadDepotChunks& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadDepotChunks& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadDepotChunks* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadDepotChunks* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadDepotChunks* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadDepotChunks& from);
  void MergeFrom(const CMsgClientMDSUploadDepotChunks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientMDSUploadDepotChunks_ChunkUploadData ChunkUploadData;

  // accessors -------------------------------------------------------

  // optional uint32 depot_id = 1;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientMDSUploadDepotChunks.ChunkUploadData chunks = 2;
  inline int chunks_size() const;
  inline void clear_chunks();
  static const int kChunksFieldNumber = 2;
  inline const ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData& chunks(int index) const;
  inline ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData* mutable_chunks(int index);
  inline ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData* add_chunks();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData >&
      chunks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData >*
      mutable_chunks();

  // optional bool only_meta_data = 3;
  inline bool has_only_meta_data() const;
  inline void clear_only_meta_data();
  static const int kOnlyMetaDataFieldNumber = 3;
  inline bool only_meta_data() const;
  inline void set_only_meta_data(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadDepotChunks)
 private:
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_only_meta_data();
  inline void clear_has_only_meta_data();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData > chunks_;
  ::google::protobuf::uint32 depot_id_;
  bool only_meta_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadDepotChunks* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadDepotChunksResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadDepotChunksResponse();
  virtual ~CMsgClientMDSUploadDepotChunksResponse();

  CMsgClientMDSUploadDepotChunksResponse(const CMsgClientMDSUploadDepotChunksResponse& from);

  inline CMsgClientMDSUploadDepotChunksResponse& operator=(const CMsgClientMDSUploadDepotChunksResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadDepotChunksResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadDepotChunksResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadDepotChunksResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadDepotChunksResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadDepotChunksResponse& from);
  void MergeFrom(const CMsgClientMDSUploadDepotChunksResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadDepotChunksResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadDepotChunksResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadRateTest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadRateTest();
  virtual ~CMsgClientMDSUploadRateTest();

  CMsgClientMDSUploadRateTest(const CMsgClientMDSUploadRateTest& from);

  inline CMsgClientMDSUploadRateTest& operator=(const CMsgClientMDSUploadRateTest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadRateTest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadRateTest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadRateTest* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadRateTest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadRateTest& from);
  void MergeFrom(const CMsgClientMDSUploadRateTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // optional bytes test_data = 2;
  inline bool has_test_data() const;
  inline void clear_test_data();
  static const int kTestDataFieldNumber = 2;
  inline const ::std::string& test_data() const;
  inline void set_test_data(const ::std::string& value);
  inline void set_test_data(const char* value);
  inline void set_test_data(const void* value, size_t size);
  inline ::std::string* mutable_test_data();
  inline ::std::string* release_test_data();
  inline void set_allocated_test_data(::std::string* test_data);

  // optional uint32 test_data_size = 3;
  inline bool has_test_data_size() const;
  inline void clear_test_data_size();
  static const int kTestDataSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 test_data_size() const;
  inline void set_test_data_size(::google::protobuf::uint32 value);

  // optional uint32 test_data_crc = 4;
  inline bool has_test_data_crc() const;
  inline void clear_test_data_crc();
  static const int kTestDataCrcFieldNumber = 4;
  inline ::google::protobuf::uint32 test_data_crc() const;
  inline void set_test_data_crc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadRateTest)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_test_data();
  inline void clear_has_test_data();
  inline void set_has_test_data_size();
  inline void clear_has_test_data_size();
  inline void set_has_test_data_crc();
  inline void clear_has_test_data_crc();

  ::std::string* test_data_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 test_data_size_;
  ::google::protobuf::uint32 test_data_crc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadRateTest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadRateTestResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadRateTestResponse();
  virtual ~CMsgClientMDSUploadRateTestResponse();

  CMsgClientMDSUploadRateTestResponse(const CMsgClientMDSUploadRateTestResponse& from);

  inline CMsgClientMDSUploadRateTestResponse& operator=(const CMsgClientMDSUploadRateTestResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadRateTestResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadRateTestResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadRateTestResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadRateTestResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadRateTestResponse& from);
  void MergeFrom(const CMsgClientMDSUploadRateTestResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadRateTestResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 serial_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadRateTestResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSTransmitManifestDataChunk : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSTransmitManifestDataChunk();
  virtual ~CMsgClientMDSTransmitManifestDataChunk();

  CMsgClientMDSTransmitManifestDataChunk(const CMsgClientMDSTransmitManifestDataChunk& from);

  inline CMsgClientMDSTransmitManifestDataChunk& operator=(const CMsgClientMDSTransmitManifestDataChunk& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSTransmitManifestDataChunk& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSTransmitManifestDataChunk* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSTransmitManifestDataChunk* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSTransmitManifestDataChunk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSTransmitManifestDataChunk& from);
  void MergeFrom(const CMsgClientMDSTransmitManifestDataChunk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSTransmitManifestDataChunk)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* data_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSTransmitManifestDataChunk* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadManifestRequest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadManifestRequest();
  virtual ~CMsgClientMDSUploadManifestRequest();

  CMsgClientMDSUploadManifestRequest(const CMsgClientMDSUploadManifestRequest& from);

  inline CMsgClientMDSUploadManifestRequest& operator=(const CMsgClientMDSUploadManifestRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadManifestRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadManifestRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadManifestRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadManifestRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadManifestRequest& from);
  void MergeFrom(const CMsgClientMDSUploadManifestRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 depot_id = 1;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // optional uint32 manifest_size_compressed = 2;
  inline bool has_manifest_size_compressed() const;
  inline void clear_manifest_size_compressed();
  static const int kManifestSizeCompressedFieldNumber = 2;
  inline ::google::protobuf::uint32 manifest_size_compressed() const;
  inline void set_manifest_size_compressed(::google::protobuf::uint32 value);

  // optional bool make_public = 4;
  inline bool has_make_public() const;
  inline void clear_make_public();
  static const int kMakePublicFieldNumber = 4;
  inline bool make_public() const;
  inline void set_make_public(bool value);

  // optional uint32 build_id = 6;
  inline bool has_build_id() const;
  inline void clear_build_id();
  static const int kBuildIdFieldNumber = 6;
  inline ::google::protobuf::uint32 build_id() const;
  inline void set_build_id(::google::protobuf::uint32 value);

  // optional uint32 manifest_version = 7;
  inline bool has_manifest_version() const;
  inline void clear_manifest_version();
  static const int kManifestVersionFieldNumber = 7;
  inline ::google::protobuf::uint32 manifest_version() const;
  inline void set_manifest_version(::google::protobuf::uint32 value);

  // optional bool local_cs_build = 9;
  inline bool has_local_cs_build() const;
  inline void clear_local_cs_build();
  static const int kLocalCsBuildFieldNumber = 9;
  inline bool local_cs_build() const;
  inline void set_local_cs_build(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadManifestRequest)
 private:
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_manifest_size_compressed();
  inline void clear_has_manifest_size_compressed();
  inline void set_has_make_public();
  inline void clear_has_make_public();
  inline void set_has_build_id();
  inline void clear_has_build_id();
  inline void set_has_manifest_version();
  inline void clear_has_manifest_version();
  inline void set_has_local_cs_build();
  inline void clear_has_local_cs_build();

  ::google::protobuf::uint32 depot_id_;
  ::google::protobuf::uint32 manifest_size_compressed_;
  ::google::protobuf::uint32 build_id_;
  bool make_public_;
  bool local_cs_build_;
  ::google::protobuf::uint32 manifest_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadManifestRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSUploadManifestResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSUploadManifestResponse();
  virtual ~CMsgClientMDSUploadManifestResponse();

  CMsgClientMDSUploadManifestResponse(const CMsgClientMDSUploadManifestResponse& from);

  inline CMsgClientMDSUploadManifestResponse& operator=(const CMsgClientMDSUploadManifestResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSUploadManifestResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSUploadManifestResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSUploadManifestResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSUploadManifestResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSUploadManifestResponse& from);
  void MergeFrom(const CMsgClientMDSUploadManifestResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed64 new_manifest = 2;
  inline bool has_new_manifest() const;
  inline void clear_new_manifest();
  static const int kNewManifestFieldNumber = 2;
  inline ::google::protobuf::uint64 new_manifest() const;
  inline void set_new_manifest(::google::protobuf::uint64 value);

  // optional uint32 unique_chunks = 3;
  inline bool has_unique_chunks() const;
  inline void clear_unique_chunks();
  static const int kUniqueChunksFieldNumber = 3;
  inline ::google::protobuf::uint32 unique_chunks() const;
  inline void set_unique_chunks(::google::protobuf::uint32 value);

  // optional uint32 missing_chunks = 4;
  inline bool has_missing_chunks() const;
  inline void clear_missing_chunks();
  static const int kMissingChunksFieldNumber = 4;
  inline ::google::protobuf::uint32 missing_chunks() const;
  inline void set_missing_chunks(::google::protobuf::uint32 value);

  // optional uint32 bitstring_size_uncompressed = 5;
  inline bool has_bitstring_size_uncompressed() const;
  inline void clear_bitstring_size_uncompressed();
  static const int kBitstringSizeUncompressedFieldNumber = 5;
  inline ::google::protobuf::uint32 bitstring_size_uncompressed() const;
  inline void set_bitstring_size_uncompressed(::google::protobuf::uint32 value);

  // optional bytes bitstring = 6;
  inline bool has_bitstring() const;
  inline void clear_bitstring();
  static const int kBitstringFieldNumber = 6;
  inline const ::std::string& bitstring() const;
  inline void set_bitstring(const ::std::string& value);
  inline void set_bitstring(const char* value);
  inline void set_bitstring(const void* value, size_t size);
  inline ::std::string* mutable_bitstring();
  inline ::std::string* release_bitstring();
  inline void set_allocated_bitstring(::std::string* bitstring);

  // optional bool is_prev_manifest = 7;
  inline bool has_is_prev_manifest() const;
  inline void clear_is_prev_manifest();
  static const int kIsPrevManifestFieldNumber = 7;
  inline bool is_prev_manifest() const;
  inline void set_is_prev_manifest(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSUploadManifestResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_new_manifest();
  inline void clear_has_new_manifest();
  inline void set_has_unique_chunks();
  inline void clear_has_unique_chunks();
  inline void set_has_missing_chunks();
  inline void clear_has_missing_chunks();
  inline void set_has_bitstring_size_uncompressed();
  inline void clear_has_bitstring_size_uncompressed();
  inline void set_has_bitstring();
  inline void clear_has_bitstring();
  inline void set_has_is_prev_manifest();
  inline void clear_has_is_prev_manifest();

  ::google::protobuf::uint64 new_manifest_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 unique_chunks_;
  ::google::protobuf::uint32 missing_chunks_;
  ::google::protobuf::uint32 bitstring_size_uncompressed_;
  ::std::string* bitstring_;
  bool is_prev_manifest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSUploadManifestResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSGetDepotManifest : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSGetDepotManifest();
  virtual ~CMsgClientMDSGetDepotManifest();

  CMsgClientMDSGetDepotManifest(const CMsgClientMDSGetDepotManifest& from);

  inline CMsgClientMDSGetDepotManifest& operator=(const CMsgClientMDSGetDepotManifest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSGetDepotManifest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSGetDepotManifest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSGetDepotManifest* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSGetDepotManifest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSGetDepotManifest& from);
  void MergeFrom(const CMsgClientMDSGetDepotManifest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 depot_id = 1;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // optional fixed64 manifest_id = 2;
  inline bool has_manifest_id() const;
  inline void clear_manifest_id();
  static const int kManifestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 manifest_id() const;
  inline void set_manifest_id(::google::protobuf::uint64 value);

  // optional uint32 manifest_version = 3;
  inline bool has_manifest_version() const;
  inline void clear_manifest_version();
  static const int kManifestVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 manifest_version() const;
  inline void set_manifest_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSGetDepotManifest)
 private:
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_manifest_id();
  inline void clear_has_manifest_id();
  inline void set_has_manifest_version();
  inline void clear_has_manifest_version();

  ::google::protobuf::uint64 manifest_id_;
  ::google::protobuf::uint32 depot_id_;
  ::google::protobuf::uint32 manifest_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSGetDepotManifest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSGetDepotManifestResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSGetDepotManifestResponse();
  virtual ~CMsgClientMDSGetDepotManifestResponse();

  CMsgClientMDSGetDepotManifestResponse(const CMsgClientMDSGetDepotManifestResponse& from);

  inline CMsgClientMDSGetDepotManifestResponse& operator=(const CMsgClientMDSGetDepotManifestResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSGetDepotManifestResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSGetDepotManifestResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSGetDepotManifestResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSGetDepotManifestResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSGetDepotManifestResponse& from);
  void MergeFrom(const CMsgClientMDSGetDepotManifestResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 manifest_size_compressed = 3;
  inline bool has_manifest_size_compressed() const;
  inline void clear_manifest_size_compressed();
  static const int kManifestSizeCompressedFieldNumber = 3;
  inline ::google::protobuf::uint32 manifest_size_compressed() const;
  inline void set_manifest_size_compressed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSGetDepotManifestResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_manifest_size_compressed();
  inline void clear_has_manifest_size_compressed();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 manifest_size_compressed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSGetDepotManifestResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSGetDepotManifestChunk : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSGetDepotManifestChunk();
  virtual ~CMsgClientMDSGetDepotManifestChunk();

  CMsgClientMDSGetDepotManifestChunk(const CMsgClientMDSGetDepotManifestChunk& from);

  inline CMsgClientMDSGetDepotManifestChunk& operator=(const CMsgClientMDSGetDepotManifestChunk& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSGetDepotManifestChunk& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSGetDepotManifestChunk* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSGetDepotManifestChunk* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSGetDepotManifestChunk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSGetDepotManifestChunk& from);
  void MergeFrom(const CMsgClientMDSGetDepotManifestChunk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSGetDepotManifestChunk)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* data_;
  ::google::protobuf::uint32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSGetDepotManifestChunk* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSRegisterAppBuild : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSRegisterAppBuild();
  virtual ~CMsgClientMDSRegisterAppBuild();

  CMsgClientMDSRegisterAppBuild(const CMsgClientMDSRegisterAppBuild& from);

  inline CMsgClientMDSRegisterAppBuild& operator=(const CMsgClientMDSRegisterAppBuild& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSRegisterAppBuild& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSRegisterAppBuild* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSRegisterAppBuild* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSRegisterAppBuild* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSRegisterAppBuild& from);
  void MergeFrom(const CMsgClientMDSRegisterAppBuild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int32 app_id() const;
  inline void set_app_id(::google::protobuf::int32 value);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional bool for_local_cs = 5;
  inline bool has_for_local_cs() const;
  inline void clear_for_local_cs();
  static const int kForLocalCsFieldNumber = 5;
  inline bool for_local_cs() const;
  inline void set_for_local_cs(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSRegisterAppBuild)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_for_local_cs();
  inline void clear_has_for_local_cs();

  ::std::string* description_;
  ::google::protobuf::int32 app_id_;
  bool for_local_cs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSRegisterAppBuild* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSRegisterAppBuildResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSRegisterAppBuildResponse();
  virtual ~CMsgClientMDSRegisterAppBuildResponse();

  CMsgClientMDSRegisterAppBuildResponse(const CMsgClientMDSRegisterAppBuildResponse& from);

  inline CMsgClientMDSRegisterAppBuildResponse& operator=(const CMsgClientMDSRegisterAppBuildResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSRegisterAppBuildResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSRegisterAppBuildResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSRegisterAppBuildResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSRegisterAppBuildResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSRegisterAppBuildResponse& from);
  void MergeFrom(const CMsgClientMDSRegisterAppBuildResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 build_id = 2;
  inline bool has_build_id() const;
  inline void clear_build_id();
  static const int kBuildIdFieldNumber = 2;
  inline ::google::protobuf::uint32 build_id() const;
  inline void set_build_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSRegisterAppBuildResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_build_id();
  inline void clear_has_build_id();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 build_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSRegisterAppBuildResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgMDSSetAppBuildLive : public ::google::protobuf::MessageLite {
 public:
  CMsgMDSSetAppBuildLive();
  virtual ~CMsgMDSSetAppBuildLive();

  CMsgMDSSetAppBuildLive(const CMsgMDSSetAppBuildLive& from);

  inline CMsgMDSSetAppBuildLive& operator=(const CMsgMDSSetAppBuildLive& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgMDSSetAppBuildLive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgMDSSetAppBuildLive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgMDSSetAppBuildLive* other);

  // implements Message ----------------------------------------------

  CMsgMDSSetAppBuildLive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgMDSSetAppBuildLive& from);
  void MergeFrom(const CMsgMDSSetAppBuildLive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 build_id = 1;
  inline bool has_build_id() const;
  inline void clear_build_id();
  static const int kBuildIdFieldNumber = 1;
  inline ::google::protobuf::uint32 build_id() const;
  inline void set_build_id(::google::protobuf::uint32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string beta_key = 3;
  inline bool has_beta_key() const;
  inline void clear_beta_key();
  static const int kBetaKeyFieldNumber = 3;
  inline const ::std::string& beta_key() const;
  inline void set_beta_key(const ::std::string& value);
  inline void set_beta_key(const char* value);
  inline void set_beta_key(const char* value, size_t size);
  inline ::std::string* mutable_beta_key();
  inline ::std::string* release_beta_key();
  inline void set_allocated_beta_key(::std::string* beta_key);

  // optional string beta_password = 5;
  inline bool has_beta_password() const;
  inline void clear_beta_password();
  static const int kBetaPasswordFieldNumber = 5;
  inline const ::std::string& beta_password() const;
  inline void set_beta_password(const ::std::string& value);
  inline void set_beta_password(const char* value);
  inline void set_beta_password(const char* value, size_t size);
  inline ::std::string* mutable_beta_password();
  inline ::std::string* release_beta_password();
  inline void set_allocated_beta_password(::std::string* beta_password);

  // optional bool only_finish = 6;
  inline bool has_only_finish() const;
  inline void clear_only_finish();
  static const int kOnlyFinishFieldNumber = 6;
  inline bool only_finish() const;
  inline void set_only_finish(bool value);

  // optional uint32 num_skip_depots = 7;
  inline bool has_num_skip_depots() const;
  inline void clear_num_skip_depots();
  static const int kNumSkipDepotsFieldNumber = 7;
  inline ::google::protobuf::uint32 num_skip_depots() const;
  inline void set_num_skip_depots(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgMDSSetAppBuildLive)
 private:
  inline void set_has_build_id();
  inline void clear_has_build_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_beta_key();
  inline void clear_has_beta_key();
  inline void set_has_beta_password();
  inline void clear_has_beta_password();
  inline void set_has_only_finish();
  inline void clear_has_only_finish();
  inline void set_has_num_skip_depots();
  inline void clear_has_num_skip_depots();

  ::google::protobuf::uint32 build_id_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* beta_key_;
  ::std::string* beta_password_;
  bool only_finish_;
  ::google::protobuf::uint32 num_skip_depots_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgMDSSetAppBuildLive* default_instance_;
};
// -------------------------------------------------------------------

class CMsgMDSSetAppBuildLiveResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgMDSSetAppBuildLiveResponse();
  virtual ~CMsgMDSSetAppBuildLiveResponse();

  CMsgMDSSetAppBuildLiveResponse(const CMsgMDSSetAppBuildLiveResponse& from);

  inline CMsgMDSSetAppBuildLiveResponse& operator=(const CMsgMDSSetAppBuildLiveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgMDSSetAppBuildLiveResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgMDSSetAppBuildLiveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgMDSSetAppBuildLiveResponse* other);

  // implements Message ----------------------------------------------

  CMsgMDSSetAppBuildLiveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgMDSSetAppBuildLiveResponse& from);
  void MergeFrom(const CMsgMDSSetAppBuildLiveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string error_string = 2;
  inline bool has_error_string() const;
  inline void clear_error_string();
  static const int kErrorStringFieldNumber = 2;
  inline const ::std::string& error_string() const;
  inline void set_error_string(const ::std::string& value);
  inline void set_error_string(const char* value);
  inline void set_error_string(const char* value, size_t size);
  inline ::std::string* mutable_error_string();
  inline ::std::string* release_error_string();
  inline void set_allocated_error_string(::std::string* error_string);

  // @@protoc_insertion_point(class_scope:Sc.CMsgMDSSetAppBuildLiveResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_error_string();
  inline void clear_has_error_string();

  ::std::string* error_string_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgMDSSetAppBuildLiveResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSSignInstallScript : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSSignInstallScript();
  virtual ~CMsgClientMDSSignInstallScript();

  CMsgClientMDSSignInstallScript(const CMsgClientMDSSignInstallScript& from);

  inline CMsgClientMDSSignInstallScript& operator=(const CMsgClientMDSSignInstallScript& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSSignInstallScript& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSSignInstallScript* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSSignInstallScript* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSSignInstallScript* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSSignInstallScript& from);
  void MergeFrom(const CMsgClientMDSSignInstallScript& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 depot_id = 1;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 1;
  inline ::google::protobuf::int32 depot_id() const;
  inline void set_depot_id(::google::protobuf::int32 value);

  // optional string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSSignInstallScript)
 private:
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* data_;
  ::google::protobuf::int32 depot_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSSignInstallScript* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientMDSSignInstallScriptResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientMDSSignInstallScriptResponse();
  virtual ~CMsgClientMDSSignInstallScriptResponse();

  CMsgClientMDSSignInstallScriptResponse(const CMsgClientMDSSignInstallScriptResponse& from);

  inline CMsgClientMDSSignInstallScriptResponse& operator=(const CMsgClientMDSSignInstallScriptResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientMDSSignInstallScriptResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientMDSSignInstallScriptResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientMDSSignInstallScriptResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientMDSSignInstallScriptResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientMDSSignInstallScriptResponse& from);
  void MergeFrom(const CMsgClientMDSSignInstallScriptResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string error_string = 2;
  inline bool has_error_string() const;
  inline void clear_error_string();
  static const int kErrorStringFieldNumber = 2;
  inline const ::std::string& error_string() const;
  inline void set_error_string(const ::std::string& value);
  inline void set_error_string(const char* value);
  inline void set_error_string(const char* value, size_t size);
  inline ::std::string* mutable_error_string();
  inline ::std::string* release_error_string();
  inline void set_allocated_error_string(::std::string* error_string);

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientMDSSignInstallScriptResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_error_string();
  inline void clear_has_error_string();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* error_string_;
  ::std::string* data_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientMDSSignInstallScriptResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientEmailChange : public ::google::protobuf::MessageLite {
 public:
  CMsgClientEmailChange();
  virtual ~CMsgClientEmailChange();

  CMsgClientEmailChange(const CMsgClientEmailChange& from);

  inline CMsgClientEmailChange& operator=(const CMsgClientEmailChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientEmailChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientEmailChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientEmailChange* other);

  // implements Message ----------------------------------------------

  CMsgClientEmailChange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientEmailChange& from);
  void MergeFrom(const CMsgClientEmailChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 1;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 1;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional bool final = 4;
  inline bool has_final() const;
  inline void clear_final();
  static const int kFinalFieldNumber = 4;
  inline bool final() const;
  inline void set_final(bool value);

  // optional bool newmethod = 5;
  inline bool has_newmethod() const;
  inline void clear_newmethod();
  static const int kNewmethodFieldNumber = 5;
  inline bool newmethod() const;
  inline void set_newmethod(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientEmailChange)
 private:
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_final();
  inline void clear_has_final();
  inline void set_has_newmethod();
  inline void clear_has_newmethod();

  ::std::string* password_;
  ::std::string* email_;
  ::std::string* code_;
  bool final_;
  bool newmethod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientEmailChange* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientEmailChangeResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientEmailChangeResponse();
  virtual ~CMsgClientEmailChangeResponse();

  CMsgClientEmailChangeResponse(const CMsgClientEmailChangeResponse& from);

  inline CMsgClientEmailChangeResponse& operator=(const CMsgClientEmailChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientEmailChangeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientEmailChangeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientEmailChangeResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientEmailChangeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientEmailChangeResponse& from);
  void MergeFrom(const CMsgClientEmailChangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientEmailChangeResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientEmailChangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetCDNAuthToken : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetCDNAuthToken();
  virtual ~CMsgClientGetCDNAuthToken();

  CMsgClientGetCDNAuthToken(const CMsgClientGetCDNAuthToken& from);

  inline CMsgClientGetCDNAuthToken& operator=(const CMsgClientGetCDNAuthToken& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetCDNAuthToken& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetCDNAuthToken* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetCDNAuthToken* other);

  // implements Message ----------------------------------------------

  CMsgClientGetCDNAuthToken* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetCDNAuthToken& from);
  void MergeFrom(const CMsgClientGetCDNAuthToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string host_name = 2;
  inline bool has_host_name() const;
  inline void clear_host_name();
  static const int kHostNameFieldNumber = 2;
  inline const ::std::string& host_name() const;
  inline void set_host_name(const ::std::string& value);
  inline void set_host_name(const char* value);
  inline void set_host_name(const char* value, size_t size);
  inline ::std::string* mutable_host_name();
  inline ::std::string* release_host_name();
  inline void set_allocated_host_name(::std::string* host_name);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetCDNAuthToken)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_host_name();
  inline void clear_has_host_name();

  ::std::string* host_name_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetCDNAuthToken* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetDepotDecryptionKey : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetDepotDecryptionKey();
  virtual ~CMsgClientGetDepotDecryptionKey();

  CMsgClientGetDepotDecryptionKey(const CMsgClientGetDepotDecryptionKey& from);

  inline CMsgClientGetDepotDecryptionKey& operator=(const CMsgClientGetDepotDecryptionKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetDepotDecryptionKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetDepotDecryptionKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetDepotDecryptionKey* other);

  // implements Message ----------------------------------------------

  CMsgClientGetDepotDecryptionKey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetDepotDecryptionKey& from);
  void MergeFrom(const CMsgClientGetDepotDecryptionKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 depot_id = 1;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetDepotDecryptionKey)
 private:
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 depot_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetDepotDecryptionKey* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetDepotDecryptionKeyResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetDepotDecryptionKeyResponse();
  virtual ~CMsgClientGetDepotDecryptionKeyResponse();

  CMsgClientGetDepotDecryptionKeyResponse(const CMsgClientGetDepotDecryptionKeyResponse& from);

  inline CMsgClientGetDepotDecryptionKeyResponse& operator=(const CMsgClientGetDepotDecryptionKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetDepotDecryptionKeyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetDepotDecryptionKeyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetDepotDecryptionKeyResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetDepotDecryptionKeyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetDepotDecryptionKeyResponse& from);
  void MergeFrom(const CMsgClientGetDepotDecryptionKeyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 depot_id = 2;
  inline bool has_depot_id() const;
  inline void clear_depot_id();
  static const int kDepotIdFieldNumber = 2;
  inline ::google::protobuf::uint32 depot_id() const;
  inline void set_depot_id(::google::protobuf::uint32 value);

  // optional bytes depot_encryption_key = 3;
  inline bool has_depot_encryption_key() const;
  inline void clear_depot_encryption_key();
  static const int kDepotEncryptionKeyFieldNumber = 3;
  inline const ::std::string& depot_encryption_key() const;
  inline void set_depot_encryption_key(const ::std::string& value);
  inline void set_depot_encryption_key(const char* value);
  inline void set_depot_encryption_key(const void* value, size_t size);
  inline ::std::string* mutable_depot_encryption_key();
  inline ::std::string* release_depot_encryption_key();
  inline void set_allocated_depot_encryption_key(::std::string* depot_encryption_key);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetDepotDecryptionKeyResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_depot_id();
  inline void clear_has_depot_id();
  inline void set_has_depot_encryption_key();
  inline void clear_has_depot_encryption_key();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 depot_id_;
  ::std::string* depot_encryption_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetDepotDecryptionKeyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetAppBetaPasswords : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetAppBetaPasswords();
  virtual ~CMsgClientGetAppBetaPasswords();

  CMsgClientGetAppBetaPasswords(const CMsgClientGetAppBetaPasswords& from);

  inline CMsgClientGetAppBetaPasswords& operator=(const CMsgClientGetAppBetaPasswords& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetAppBetaPasswords& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetAppBetaPasswords* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetAppBetaPasswords* other);

  // implements Message ----------------------------------------------

  CMsgClientGetAppBetaPasswords* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetAppBetaPasswords& from);
  void MergeFrom(const CMsgClientGetAppBetaPasswords& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetAppBetaPasswords)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetAppBetaPasswords* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetAppBetaPasswordsResponse_BetaPassword : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetAppBetaPasswordsResponse_BetaPassword();
  virtual ~CMsgClientGetAppBetaPasswordsResponse_BetaPassword();

  CMsgClientGetAppBetaPasswordsResponse_BetaPassword(const CMsgClientGetAppBetaPasswordsResponse_BetaPassword& from);

  inline CMsgClientGetAppBetaPasswordsResponse_BetaPassword& operator=(const CMsgClientGetAppBetaPasswordsResponse_BetaPassword& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetAppBetaPasswordsResponse_BetaPassword& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetAppBetaPasswordsResponse_BetaPassword* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetAppBetaPasswordsResponse_BetaPassword* other);

  // implements Message ----------------------------------------------

  CMsgClientGetAppBetaPasswordsResponse_BetaPassword* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetAppBetaPasswordsResponse_BetaPassword& from);
  void MergeFrom(const CMsgClientGetAppBetaPasswordsResponse_BetaPassword& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string betaname = 1;
  inline bool has_betaname() const;
  inline void clear_betaname();
  static const int kBetanameFieldNumber = 1;
  inline const ::std::string& betaname() const;
  inline void set_betaname(const ::std::string& value);
  inline void set_betaname(const char* value);
  inline void set_betaname(const char* value, size_t size);
  inline ::std::string* mutable_betaname();
  inline ::std::string* release_betaname();
  inline void set_allocated_betaname(::std::string* betaname);

  // optional string betapassword = 2;
  inline bool has_betapassword() const;
  inline void clear_betapassword();
  static const int kBetapasswordFieldNumber = 2;
  inline const ::std::string& betapassword() const;
  inline void set_betapassword(const ::std::string& value);
  inline void set_betapassword(const char* value);
  inline void set_betapassword(const char* value, size_t size);
  inline ::std::string* mutable_betapassword();
  inline ::std::string* release_betapassword();
  inline void set_allocated_betapassword(::std::string* betapassword);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetAppBetaPasswordsResponse.BetaPassword)
 private:
  inline void set_has_betaname();
  inline void clear_has_betaname();
  inline void set_has_betapassword();
  inline void clear_has_betapassword();

  ::std::string* betaname_;
  ::std::string* betapassword_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetAppBetaPasswordsResponse_BetaPassword* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetAppBetaPasswordsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetAppBetaPasswordsResponse();
  virtual ~CMsgClientGetAppBetaPasswordsResponse();

  CMsgClientGetAppBetaPasswordsResponse(const CMsgClientGetAppBetaPasswordsResponse& from);

  inline CMsgClientGetAppBetaPasswordsResponse& operator=(const CMsgClientGetAppBetaPasswordsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetAppBetaPasswordsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetAppBetaPasswordsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetAppBetaPasswordsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetAppBetaPasswordsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetAppBetaPasswordsResponse& from);
  void MergeFrom(const CMsgClientGetAppBetaPasswordsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientGetAppBetaPasswordsResponse_BetaPassword BetaPassword;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientGetAppBetaPasswordsResponse.BetaPassword betapasswords = 3;
  inline int betapasswords_size() const;
  inline void clear_betapasswords();
  static const int kBetapasswordsFieldNumber = 3;
  inline const ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword& betapasswords(int index) const;
  inline ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword* mutable_betapasswords(int index);
  inline ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword* add_betapasswords();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword >&
      betapasswords() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword >*
      mutable_betapasswords();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetAppBetaPasswordsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword > betapasswords_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetAppBetaPasswordsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUpdateAppJobReport : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUpdateAppJobReport();
  virtual ~CMsgClientUpdateAppJobReport();

  CMsgClientUpdateAppJobReport(const CMsgClientUpdateAppJobReport& from);

  inline CMsgClientUpdateAppJobReport& operator=(const CMsgClientUpdateAppJobReport& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUpdateAppJobReport& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUpdateAppJobReport* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUpdateAppJobReport* other);

  // implements Message ----------------------------------------------

  CMsgClientUpdateAppJobReport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUpdateAppJobReport& from);
  void MergeFrom(const CMsgClientUpdateAppJobReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // repeated uint32 depot_ids = 2;
  inline int depot_ids_size() const;
  inline void clear_depot_ids();
  static const int kDepotIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 depot_ids(int index) const;
  inline void set_depot_ids(int index, ::google::protobuf::uint32 value);
  inline void add_depot_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      depot_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_depot_ids();

  // optional uint32 app_state = 3;
  inline bool has_app_state() const;
  inline void clear_app_state();
  static const int kAppStateFieldNumber = 3;
  inline ::google::protobuf::uint32 app_state() const;
  inline void set_app_state(::google::protobuf::uint32 value);

  // optional uint32 job_app_error = 4;
  inline bool has_job_app_error() const;
  inline void clear_job_app_error();
  static const int kJobAppErrorFieldNumber = 4;
  inline ::google::protobuf::uint32 job_app_error() const;
  inline void set_job_app_error(::google::protobuf::uint32 value);

  // optional string error_details = 5;
  inline bool has_error_details() const;
  inline void clear_error_details();
  static const int kErrorDetailsFieldNumber = 5;
  inline const ::std::string& error_details() const;
  inline void set_error_details(const ::std::string& value);
  inline void set_error_details(const char* value);
  inline void set_error_details(const char* value, size_t size);
  inline ::std::string* mutable_error_details();
  inline ::std::string* release_error_details();
  inline void set_allocated_error_details(::std::string* error_details);

  // optional uint32 job_duration = 6;
  inline bool has_job_duration() const;
  inline void clear_job_duration();
  static const int kJobDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 job_duration() const;
  inline void set_job_duration(::google::protobuf::uint32 value);

  // optional uint32 files_validation_failed = 7;
  inline bool has_files_validation_failed() const;
  inline void clear_files_validation_failed();
  static const int kFilesValidationFailedFieldNumber = 7;
  inline ::google::protobuf::uint32 files_validation_failed() const;
  inline void set_files_validation_failed(::google::protobuf::uint32 value);

  // optional uint64 bytes_downloaded = 8;
  inline bool has_bytes_downloaded() const;
  inline void clear_bytes_downloaded();
  static const int kBytesDownloadedFieldNumber = 8;
  inline ::google::protobuf::uint64 bytes_downloaded() const;
  inline void set_bytes_downloaded(::google::protobuf::uint64 value);

  // optional uint64 bytes_staged = 9;
  inline bool has_bytes_staged() const;
  inline void clear_bytes_staged();
  static const int kBytesStagedFieldNumber = 9;
  inline ::google::protobuf::uint64 bytes_staged() const;
  inline void set_bytes_staged(::google::protobuf::uint64 value);

  // optional uint64 bytes_comitted = 10;
  inline bool has_bytes_comitted() const;
  inline void clear_bytes_comitted();
  static const int kBytesComittedFieldNumber = 10;
  inline ::google::protobuf::uint64 bytes_comitted() const;
  inline void set_bytes_comitted(::google::protobuf::uint64 value);

  // optional uint32 start_app_state = 11;
  inline bool has_start_app_state() const;
  inline void clear_start_app_state();
  static const int kStartAppStateFieldNumber = 11;
  inline ::google::protobuf::uint32 start_app_state() const;
  inline void set_start_app_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUpdateAppJobReport)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_app_state();
  inline void clear_has_app_state();
  inline void set_has_job_app_error();
  inline void clear_has_job_app_error();
  inline void set_has_error_details();
  inline void clear_has_error_details();
  inline void set_has_job_duration();
  inline void clear_has_job_duration();
  inline void set_has_files_validation_failed();
  inline void clear_has_files_validation_failed();
  inline void set_has_bytes_downloaded();
  inline void clear_has_bytes_downloaded();
  inline void set_has_bytes_staged();
  inline void clear_has_bytes_staged();
  inline void set_has_bytes_comitted();
  inline void clear_has_bytes_comitted();
  inline void set_has_start_app_state();
  inline void clear_has_start_app_state();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > depot_ids_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 app_state_;
  ::std::string* error_details_;
  ::google::protobuf::uint32 job_app_error_;
  ::google::protobuf::uint32 job_duration_;
  ::google::protobuf::uint64 bytes_downloaded_;
  ::google::protobuf::uint64 bytes_staged_;
  ::google::protobuf::uint32 files_validation_failed_;
  ::google::protobuf::uint32 start_app_state_;
  ::google::protobuf::uint64 bytes_comitted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUpdateAppJobReport* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetCDNAuthTokenResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetCDNAuthTokenResponse();
  virtual ~CMsgClientGetCDNAuthTokenResponse();

  CMsgClientGetCDNAuthTokenResponse(const CMsgClientGetCDNAuthTokenResponse& from);

  inline CMsgClientGetCDNAuthTokenResponse& operator=(const CMsgClientGetCDNAuthTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetCDNAuthTokenResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetCDNAuthTokenResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetCDNAuthTokenResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetCDNAuthTokenResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetCDNAuthTokenResponse& from);
  void MergeFrom(const CMsgClientGetCDNAuthTokenResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 expiration_time = 3;
  inline bool has_expiration_time() const;
  inline void clear_expiration_time();
  static const int kExpirationTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 expiration_time() const;
  inline void set_expiration_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetCDNAuthTokenResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_expiration_time();
  inline void clear_has_expiration_time();

  ::std::string* token_;
  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 expiration_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetCDNAuthTokenResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDownloadRateStatistics_StatsInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgDownloadRateStatistics_StatsInfo();
  virtual ~CMsgDownloadRateStatistics_StatsInfo();

  CMsgDownloadRateStatistics_StatsInfo(const CMsgDownloadRateStatistics_StatsInfo& from);

  inline CMsgDownloadRateStatistics_StatsInfo& operator=(const CMsgDownloadRateStatistics_StatsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDownloadRateStatistics_StatsInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDownloadRateStatistics_StatsInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDownloadRateStatistics_StatsInfo* other);

  // implements Message ----------------------------------------------

  CMsgDownloadRateStatistics_StatsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDownloadRateStatistics_StatsInfo& from);
  void MergeFrom(const CMsgDownloadRateStatistics_StatsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 source_type = 1;
  inline bool has_source_type() const;
  inline void clear_source_type();
  static const int kSourceTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 source_type() const;
  inline void set_source_type(::google::protobuf::uint32 value);

  // optional uint32 source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);

  // optional uint32 seconds = 3;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // optional uint64 bytes = 4;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 bytes() const;
  inline void set_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgDownloadRateStatistics.StatsInfo)
 private:
  inline void set_has_source_type();
  inline void clear_has_source_type();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_bytes();
  inline void clear_has_bytes();

  ::google::protobuf::uint32 source_type_;
  ::google::protobuf::uint32 source_id_;
  ::google::protobuf::uint64 bytes_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDownloadRateStatistics_StatsInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDownloadRateStatistics : public ::google::protobuf::MessageLite {
 public:
  CMsgDownloadRateStatistics();
  virtual ~CMsgDownloadRateStatistics();

  CMsgDownloadRateStatistics(const CMsgDownloadRateStatistics& from);

  inline CMsgDownloadRateStatistics& operator=(const CMsgDownloadRateStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDownloadRateStatistics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDownloadRateStatistics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDownloadRateStatistics* other);

  // implements Message ----------------------------------------------

  CMsgDownloadRateStatistics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDownloadRateStatistics& from);
  void MergeFrom(const CMsgDownloadRateStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgDownloadRateStatistics_StatsInfo StatsInfo;

  // accessors -------------------------------------------------------

  // optional uint32 cell_id = 1;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 1;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgDownloadRateStatistics.StatsInfo stats = 2;
  inline int stats_size() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 2;
  inline const ::Sc::CMsgDownloadRateStatistics_StatsInfo& stats(int index) const;
  inline ::Sc::CMsgDownloadRateStatistics_StatsInfo* mutable_stats(int index);
  inline ::Sc::CMsgDownloadRateStatistics_StatsInfo* add_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgDownloadRateStatistics_StatsInfo >&
      stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgDownloadRateStatistics_StatsInfo >*
      mutable_stats();

  // @@protoc_insertion_point(class_scope:Sc.CMsgDownloadRateStatistics)
 private:
  inline void set_has_cell_id();
  inline void clear_has_cell_id();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgDownloadRateStatistics_StatsInfo > stats_;
  ::google::protobuf::uint32 cell_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDownloadRateStatistics* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestAccountData : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestAccountData();
  virtual ~CMsgClientRequestAccountData();

  CMsgClientRequestAccountData(const CMsgClientRequestAccountData& from);

  inline CMsgClientRequestAccountData& operator=(const CMsgClientRequestAccountData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestAccountData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestAccountData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestAccountData* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestAccountData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestAccountData& from);
  void MergeFrom(const CMsgClientRequestAccountData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account_or_email = 1;
  inline bool has_account_or_email() const;
  inline void clear_account_or_email();
  static const int kAccountOrEmailFieldNumber = 1;
  inline const ::std::string& account_or_email() const;
  inline void set_account_or_email(const ::std::string& value);
  inline void set_account_or_email(const char* value);
  inline void set_account_or_email(const char* value, size_t size);
  inline ::std::string* mutable_account_or_email();
  inline ::std::string* release_account_or_email();
  inline void set_allocated_account_or_email(::std::string* account_or_email);

  // optional uint32 action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestAccountData)
 private:
  inline void set_has_account_or_email();
  inline void clear_has_account_or_email();
  inline void set_has_action();
  inline void clear_has_action();

  ::std::string* account_or_email_;
  ::google::protobuf::uint32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestAccountData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestAccountDataResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestAccountDataResponse();
  virtual ~CMsgClientRequestAccountDataResponse();

  CMsgClientRequestAccountDataResponse(const CMsgClientRequestAccountDataResponse& from);

  inline CMsgClientRequestAccountDataResponse& operator=(const CMsgClientRequestAccountDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestAccountDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestAccountDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestAccountDataResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestAccountDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestAccountDataResponse& from);
  void MergeFrom(const CMsgClientRequestAccountDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // optional uint32 eresult = 2;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional string account_name = 3;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 3;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const char* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // optional uint32 ct_matches = 4;
  inline bool has_ct_matches() const;
  inline void clear_ct_matches();
  static const int kCtMatchesFieldNumber = 4;
  inline ::google::protobuf::uint32 ct_matches() const;
  inline void set_ct_matches(::google::protobuf::uint32 value);

  // optional string account_name_suggestion1 = 5;
  inline bool has_account_name_suggestion1() const;
  inline void clear_account_name_suggestion1();
  static const int kAccountNameSuggestion1FieldNumber = 5;
  inline const ::std::string& account_name_suggestion1() const;
  inline void set_account_name_suggestion1(const ::std::string& value);
  inline void set_account_name_suggestion1(const char* value);
  inline void set_account_name_suggestion1(const char* value, size_t size);
  inline ::std::string* mutable_account_name_suggestion1();
  inline ::std::string* release_account_name_suggestion1();
  inline void set_allocated_account_name_suggestion1(::std::string* account_name_suggestion1);

  // optional string account_name_suggestion2 = 6;
  inline bool has_account_name_suggestion2() const;
  inline void clear_account_name_suggestion2();
  static const int kAccountNameSuggestion2FieldNumber = 6;
  inline const ::std::string& account_name_suggestion2() const;
  inline void set_account_name_suggestion2(const ::std::string& value);
  inline void set_account_name_suggestion2(const char* value);
  inline void set_account_name_suggestion2(const char* value, size_t size);
  inline ::std::string* mutable_account_name_suggestion2();
  inline ::std::string* release_account_name_suggestion2();
  inline void set_allocated_account_name_suggestion2(::std::string* account_name_suggestion2);

  // optional string account_name_suggestion3 = 7;
  inline bool has_account_name_suggestion3() const;
  inline void clear_account_name_suggestion3();
  static const int kAccountNameSuggestion3FieldNumber = 7;
  inline const ::std::string& account_name_suggestion3() const;
  inline void set_account_name_suggestion3(const ::std::string& value);
  inline void set_account_name_suggestion3(const char* value);
  inline void set_account_name_suggestion3(const char* value, size_t size);
  inline ::std::string* mutable_account_name_suggestion3();
  inline ::std::string* release_account_name_suggestion3();
  inline void set_allocated_account_name_suggestion3(::std::string* account_name_suggestion3);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestAccountDataResponse)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_ct_matches();
  inline void clear_has_ct_matches();
  inline void set_has_account_name_suggestion1();
  inline void clear_has_account_name_suggestion1();
  inline void set_has_account_name_suggestion2();
  inline void clear_has_account_name_suggestion2();
  inline void set_has_account_name_suggestion3();
  inline void clear_has_account_name_suggestion3();

  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint32 eresult_;
  ::std::string* account_name_;
  ::std::string* account_name_suggestion1_;
  ::std::string* account_name_suggestion2_;
  ::std::string* account_name_suggestion3_;
  ::google::protobuf::uint32 ct_matches_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestAccountDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUGSGetGlobalStats : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUGSGetGlobalStats();
  virtual ~CMsgClientUGSGetGlobalStats();

  CMsgClientUGSGetGlobalStats(const CMsgClientUGSGetGlobalStats& from);

  inline CMsgClientUGSGetGlobalStats& operator=(const CMsgClientUGSGetGlobalStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUGSGetGlobalStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUGSGetGlobalStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUGSGetGlobalStats* other);

  // implements Message ----------------------------------------------

  CMsgClientUGSGetGlobalStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUGSGetGlobalStats& from);
  void MergeFrom(const CMsgClientUGSGetGlobalStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint64 gameid() const;
  inline void set_gameid(::google::protobuf::uint64 value);

  // optional uint32 history_days_requested = 2;
  inline bool has_history_days_requested() const;
  inline void clear_history_days_requested();
  static const int kHistoryDaysRequestedFieldNumber = 2;
  inline ::google::protobuf::uint32 history_days_requested() const;
  inline void set_history_days_requested(::google::protobuf::uint32 value);

  // optional fixed32 time_last_requested = 3;
  inline bool has_time_last_requested() const;
  inline void clear_time_last_requested();
  static const int kTimeLastRequestedFieldNumber = 3;
  inline ::google::protobuf::uint32 time_last_requested() const;
  inline void set_time_last_requested(::google::protobuf::uint32 value);

  // optional uint32 first_day_cached = 4;
  inline bool has_first_day_cached() const;
  inline void clear_first_day_cached();
  static const int kFirstDayCachedFieldNumber = 4;
  inline ::google::protobuf::uint32 first_day_cached() const;
  inline void set_first_day_cached(::google::protobuf::uint32 value);

  // optional uint32 days_cached = 5;
  inline bool has_days_cached() const;
  inline void clear_days_cached();
  static const int kDaysCachedFieldNumber = 5;
  inline ::google::protobuf::uint32 days_cached() const;
  inline void set_days_cached(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUGSGetGlobalStats)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_history_days_requested();
  inline void clear_has_history_days_requested();
  inline void set_has_time_last_requested();
  inline void clear_has_time_last_requested();
  inline void set_has_first_day_cached();
  inline void clear_has_first_day_cached();
  inline void set_has_days_cached();
  inline void clear_has_days_cached();

  ::google::protobuf::uint64 gameid_;
  ::google::protobuf::uint32 history_days_requested_;
  ::google::protobuf::uint32 time_last_requested_;
  ::google::protobuf::uint32 first_day_cached_;
  ::google::protobuf::uint32 days_cached_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUGSGetGlobalStats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUGSGetGlobalStatsResponse_Day_Stat : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUGSGetGlobalStatsResponse_Day_Stat();
  virtual ~CMsgClientUGSGetGlobalStatsResponse_Day_Stat();

  CMsgClientUGSGetGlobalStatsResponse_Day_Stat(const CMsgClientUGSGetGlobalStatsResponse_Day_Stat& from);

  inline CMsgClientUGSGetGlobalStatsResponse_Day_Stat& operator=(const CMsgClientUGSGetGlobalStatsResponse_Day_Stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUGSGetGlobalStatsResponse_Day_Stat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUGSGetGlobalStatsResponse_Day_Stat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUGSGetGlobalStatsResponse_Day_Stat* other);

  // implements Message ----------------------------------------------

  CMsgClientUGSGetGlobalStatsResponse_Day_Stat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUGSGetGlobalStatsResponse_Day_Stat& from);
  void MergeFrom(const CMsgClientUGSGetGlobalStatsResponse_Day_Stat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 stat_id = 1;
  inline bool has_stat_id() const;
  inline void clear_stat_id();
  static const int kStatIdFieldNumber = 1;
  inline ::google::protobuf::int32 stat_id() const;
  inline void set_stat_id(::google::protobuf::int32 value);

  // optional int64 data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int64 data() const;
  inline void set_data(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUGSGetGlobalStatsResponse.Day.Stat)
 private:
  inline void set_has_stat_id();
  inline void clear_has_stat_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::int64 data_;
  ::google::protobuf::int32 stat_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUGSGetGlobalStatsResponse_Day_Stat* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUGSGetGlobalStatsResponse_Day : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUGSGetGlobalStatsResponse_Day();
  virtual ~CMsgClientUGSGetGlobalStatsResponse_Day();

  CMsgClientUGSGetGlobalStatsResponse_Day(const CMsgClientUGSGetGlobalStatsResponse_Day& from);

  inline CMsgClientUGSGetGlobalStatsResponse_Day& operator=(const CMsgClientUGSGetGlobalStatsResponse_Day& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUGSGetGlobalStatsResponse_Day& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUGSGetGlobalStatsResponse_Day* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUGSGetGlobalStatsResponse_Day* other);

  // implements Message ----------------------------------------------

  CMsgClientUGSGetGlobalStatsResponse_Day* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUGSGetGlobalStatsResponse_Day& from);
  void MergeFrom(const CMsgClientUGSGetGlobalStatsResponse_Day& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUGSGetGlobalStatsResponse_Day_Stat Stat;

  // accessors -------------------------------------------------------

  // optional uint32 day_id = 1;
  inline bool has_day_id() const;
  inline void clear_day_id();
  static const int kDayIdFieldNumber = 1;
  inline ::google::protobuf::uint32 day_id() const;
  inline void set_day_id(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientUGSGetGlobalStatsResponse.Day.Stat stats = 2;
  inline int stats_size() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 2;
  inline const ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat& stats(int index) const;
  inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat* mutable_stats(int index);
  inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat* add_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat >&
      stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat >*
      mutable_stats();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUGSGetGlobalStatsResponse.Day)
 private:
  inline void set_has_day_id();
  inline void clear_has_day_id();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat > stats_;
  ::google::protobuf::uint32 day_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUGSGetGlobalStatsResponse_Day* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUGSGetGlobalStatsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUGSGetGlobalStatsResponse();
  virtual ~CMsgClientUGSGetGlobalStatsResponse();

  CMsgClientUGSGetGlobalStatsResponse(const CMsgClientUGSGetGlobalStatsResponse& from);

  inline CMsgClientUGSGetGlobalStatsResponse& operator=(const CMsgClientUGSGetGlobalStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUGSGetGlobalStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUGSGetGlobalStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUGSGetGlobalStatsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientUGSGetGlobalStatsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUGSGetGlobalStatsResponse& from);
  void MergeFrom(const CMsgClientUGSGetGlobalStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientUGSGetGlobalStatsResponse_Day Day;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional fixed32 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional int32 day_current = 3;
  inline bool has_day_current() const;
  inline void clear_day_current();
  static const int kDayCurrentFieldNumber = 3;
  inline ::google::protobuf::int32 day_current() const;
  inline void set_day_current(::google::protobuf::int32 value);

  // repeated .Sc.CMsgClientUGSGetGlobalStatsResponse.Day days = 4;
  inline int days_size() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 4;
  inline const ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day& days(int index) const;
  inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day* mutable_days(int index);
  inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day* add_days();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day >&
      days() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day >*
      mutable_days();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUGSGetGlobalStatsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_day_current();
  inline void clear_has_day_current();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day > days_;
  ::google::protobuf::int32 day_current_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUGSGetGlobalStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGameServerData_Player : public ::google::protobuf::MessageLite {
 public:
  CMsgGameServerData_Player();
  virtual ~CMsgGameServerData_Player();

  CMsgGameServerData_Player(const CMsgGameServerData_Player& from);

  inline CMsgGameServerData_Player& operator=(const CMsgGameServerData_Player& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGameServerData_Player& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGameServerData_Player* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGameServerData_Player* other);

  // implements Message ----------------------------------------------

  CMsgGameServerData_Player* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGameServerData_Player& from);
  void MergeFrom(const CMsgGameServerData_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGameServerData.Player)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();

  ::google::protobuf::uint64 steam_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGameServerData_Player* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGameServerData : public ::google::protobuf::MessageLite {
 public:
  CMsgGameServerData();
  virtual ~CMsgGameServerData();

  CMsgGameServerData(const CMsgGameServerData& from);

  inline CMsgGameServerData& operator=(const CMsgGameServerData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGameServerData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGameServerData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGameServerData* other);

  // implements Message ----------------------------------------------

  CMsgGameServerData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGameServerData& from);
  void MergeFrom(const CMsgGameServerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgGameServerData_Player Player;

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_gs = 1;
  inline bool has_steam_id_gs() const;
  inline void clear_steam_id_gs();
  static const int kSteamIdGsFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_gs() const;
  inline void set_steam_id_gs(::google::protobuf::uint64 value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 query_port = 3;
  inline bool has_query_port() const;
  inline void clear_query_port();
  static const int kQueryPortFieldNumber = 3;
  inline ::google::protobuf::uint32 query_port() const;
  inline void set_query_port(::google::protobuf::uint32 value);

  // optional uint32 game_port = 4;
  inline bool has_game_port() const;
  inline void clear_game_port();
  static const int kGamePortFieldNumber = 4;
  inline ::google::protobuf::uint32 game_port() const;
  inline void set_game_port(::google::protobuf::uint32 value);

  // optional uint32 sourcetv_port = 5;
  inline bool has_sourcetv_port() const;
  inline void clear_sourcetv_port();
  static const int kSourcetvPortFieldNumber = 5;
  inline ::google::protobuf::uint32 sourcetv_port() const;
  inline void set_sourcetv_port(::google::protobuf::uint32 value);

  // optional string name = 22;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 22;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 app_id = 6;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 6;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string gamedir = 7;
  inline bool has_gamedir() const;
  inline void clear_gamedir();
  static const int kGamedirFieldNumber = 7;
  inline const ::std::string& gamedir() const;
  inline void set_gamedir(const ::std::string& value);
  inline void set_gamedir(const char* value);
  inline void set_gamedir(const char* value, size_t size);
  inline ::std::string* mutable_gamedir();
  inline ::std::string* release_gamedir();
  inline void set_allocated_gamedir(::std::string* gamedir);

  // optional string version = 8;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 8;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string product = 9;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 9;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // optional string region = 10;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 10;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  inline void set_allocated_region(::std::string* region);

  // repeated .Sc.CMsgGameServerData.Player players = 11;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 11;
  inline const ::Sc::CMsgGameServerData_Player& players(int index) const;
  inline ::Sc::CMsgGameServerData_Player* mutable_players(int index);
  inline ::Sc::CMsgGameServerData_Player* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerData_Player >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerData_Player >*
      mutable_players();

  // optional uint32 max_players = 12;
  inline bool has_max_players() const;
  inline void clear_max_players();
  static const int kMaxPlayersFieldNumber = 12;
  inline ::google::protobuf::uint32 max_players() const;
  inline void set_max_players(::google::protobuf::uint32 value);

  // optional uint32 bot_count = 13;
  inline bool has_bot_count() const;
  inline void clear_bot_count();
  static const int kBotCountFieldNumber = 13;
  inline ::google::protobuf::uint32 bot_count() const;
  inline void set_bot_count(::google::protobuf::uint32 value);

  // optional bool password = 14;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 14;
  inline bool password() const;
  inline void set_password(bool value);

  // optional bool secure = 15;
  inline bool has_secure() const;
  inline void clear_secure();
  static const int kSecureFieldNumber = 15;
  inline bool secure() const;
  inline void set_secure(bool value);

  // optional bool dedicated = 16;
  inline bool has_dedicated() const;
  inline void clear_dedicated();
  static const int kDedicatedFieldNumber = 16;
  inline bool dedicated() const;
  inline void set_dedicated(bool value);

  // optional string os = 17;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 17;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string game_data = 18;
  inline bool has_game_data() const;
  inline void clear_game_data();
  static const int kGameDataFieldNumber = 18;
  inline const ::std::string& game_data() const;
  inline void set_game_data(const ::std::string& value);
  inline void set_game_data(const char* value);
  inline void set_game_data(const char* value, size_t size);
  inline ::std::string* mutable_game_data();
  inline ::std::string* release_game_data();
  inline void set_allocated_game_data(::std::string* game_data);

  // optional uint32 game_data_version = 19;
  inline bool has_game_data_version() const;
  inline void clear_game_data_version();
  static const int kGameDataVersionFieldNumber = 19;
  inline ::google::protobuf::uint32 game_data_version() const;
  inline void set_game_data_version(::google::protobuf::uint32 value);

  // optional string game_type = 20;
  inline bool has_game_type() const;
  inline void clear_game_type();
  static const int kGameTypeFieldNumber = 20;
  inline const ::std::string& game_type() const;
  inline void set_game_type(const ::std::string& value);
  inline void set_game_type(const char* value);
  inline void set_game_type(const char* value, size_t size);
  inline ::std::string* mutable_game_type();
  inline ::std::string* release_game_type();
  inline void set_allocated_game_type(::std::string* game_type);

  // optional string map = 21;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 21;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGameServerData)
 private:
  inline void set_has_steam_id_gs();
  inline void clear_has_steam_id_gs();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_query_port();
  inline void clear_has_query_port();
  inline void set_has_game_port();
  inline void clear_has_game_port();
  inline void set_has_sourcetv_port();
  inline void clear_has_sourcetv_port();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_gamedir();
  inline void clear_has_gamedir();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_max_players();
  inline void clear_has_max_players();
  inline void set_has_bot_count();
  inline void clear_has_bot_count();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_secure();
  inline void clear_has_secure();
  inline void set_has_dedicated();
  inline void clear_has_dedicated();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_game_data();
  inline void clear_has_game_data();
  inline void set_has_game_data_version();
  inline void clear_has_game_data_version();
  inline void set_has_game_type();
  inline void clear_has_game_type();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::uint64 steam_id_gs_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 query_port_;
  ::google::protobuf::uint32 game_port_;
  ::google::protobuf::uint32 sourcetv_port_;
  ::std::string* name_;
  ::std::string* gamedir_;
  ::std::string* version_;
  ::std::string* product_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 max_players_;
  ::std::string* region_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerData_Player > players_;
  ::google::protobuf::uint32 bot_count_;
  bool password_;
  bool secure_;
  bool dedicated_;
  ::std::string* os_;
  ::std::string* game_data_;
  ::std::string* game_type_;
  ::std::string* map_;
  ::google::protobuf::uint32 game_data_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGameServerData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGameServerRemove : public ::google::protobuf::MessageLite {
 public:
  CMsgGameServerRemove();
  virtual ~CMsgGameServerRemove();

  CMsgGameServerRemove(const CMsgGameServerRemove& from);

  inline CMsgGameServerRemove& operator=(const CMsgGameServerRemove& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGameServerRemove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGameServerRemove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGameServerRemove* other);

  // implements Message ----------------------------------------------

  CMsgGameServerRemove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGameServerRemove& from);
  void MergeFrom(const CMsgGameServerRemove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 query_port = 3;
  inline bool has_query_port() const;
  inline void clear_query_port();
  static const int kQueryPortFieldNumber = 3;
  inline ::google::protobuf::uint32 query_port() const;
  inline void set_query_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGameServerRemove)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_query_port();
  inline void clear_has_query_port();

  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 query_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGameServerRemove* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGMSServerQuery : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGMSServerQuery();
  virtual ~CMsgClientGMSServerQuery();

  CMsgClientGMSServerQuery(const CMsgClientGMSServerQuery& from);

  inline CMsgClientGMSServerQuery& operator=(const CMsgClientGMSServerQuery& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGMSServerQuery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGMSServerQuery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGMSServerQuery* other);

  // implements Message ----------------------------------------------

  CMsgClientGMSServerQuery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGMSServerQuery& from);
  void MergeFrom(const CMsgClientGMSServerQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 geo_location_ip = 2;
  inline bool has_geo_location_ip() const;
  inline void clear_geo_location_ip();
  static const int kGeoLocationIpFieldNumber = 2;
  inline ::google::protobuf::uint32 geo_location_ip() const;
  inline void set_geo_location_ip(::google::protobuf::uint32 value);

  // optional uint32 region_code = 3;
  inline bool has_region_code() const;
  inline void clear_region_code();
  static const int kRegionCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 region_code() const;
  inline void set_region_code(::google::protobuf::uint32 value);

  // optional string filter_text = 4;
  inline bool has_filter_text() const;
  inline void clear_filter_text();
  static const int kFilterTextFieldNumber = 4;
  inline const ::std::string& filter_text() const;
  inline void set_filter_text(const ::std::string& value);
  inline void set_filter_text(const char* value);
  inline void set_filter_text(const char* value, size_t size);
  inline ::std::string* mutable_filter_text();
  inline ::std::string* release_filter_text();
  inline void set_allocated_filter_text(::std::string* filter_text);

  // optional uint32 max_servers = 5;
  inline bool has_max_servers() const;
  inline void clear_max_servers();
  static const int kMaxServersFieldNumber = 5;
  inline ::google::protobuf::uint32 max_servers() const;
  inline void set_max_servers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGMSServerQuery)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_geo_location_ip();
  inline void clear_has_geo_location_ip();
  inline void set_has_region_code();
  inline void clear_has_region_code();
  inline void set_has_filter_text();
  inline void clear_has_filter_text();
  inline void set_has_max_servers();
  inline void clear_has_max_servers();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 geo_location_ip_;
  ::std::string* filter_text_;
  ::google::protobuf::uint32 region_code_;
  ::google::protobuf::uint32 max_servers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGMSServerQuery* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGMSClientServerQueryResponse_Server : public ::google::protobuf::MessageLite {
 public:
  CMsgGMSClientServerQueryResponse_Server();
  virtual ~CMsgGMSClientServerQueryResponse_Server();

  CMsgGMSClientServerQueryResponse_Server(const CMsgGMSClientServerQueryResponse_Server& from);

  inline CMsgGMSClientServerQueryResponse_Server& operator=(const CMsgGMSClientServerQueryResponse_Server& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGMSClientServerQueryResponse_Server& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGMSClientServerQueryResponse_Server* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGMSClientServerQueryResponse_Server* other);

  // implements Message ----------------------------------------------

  CMsgGMSClientServerQueryResponse_Server* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGMSClientServerQueryResponse_Server& from);
  void MergeFrom(const CMsgGMSClientServerQueryResponse_Server& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_ip = 1;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 1;
  inline ::google::protobuf::uint32 server_ip() const;
  inline void set_server_ip(::google::protobuf::uint32 value);

  // optional uint32 server_port = 2;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 server_port() const;
  inline void set_server_port(::google::protobuf::uint32 value);

  // optional uint32 auth_players = 3;
  inline bool has_auth_players() const;
  inline void clear_auth_players();
  static const int kAuthPlayersFieldNumber = 3;
  inline ::google::protobuf::uint32 auth_players() const;
  inline void set_auth_players(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGMSClientServerQueryResponse.Server)
 private:
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_auth_players();
  inline void clear_has_auth_players();

  ::google::protobuf::uint32 server_ip_;
  ::google::protobuf::uint32 server_port_;
  ::google::protobuf::uint32 auth_players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGMSClientServerQueryResponse_Server* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGMSClientServerQueryResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgGMSClientServerQueryResponse();
  virtual ~CMsgGMSClientServerQueryResponse();

  CMsgGMSClientServerQueryResponse(const CMsgGMSClientServerQueryResponse& from);

  inline CMsgGMSClientServerQueryResponse& operator=(const CMsgGMSClientServerQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGMSClientServerQueryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGMSClientServerQueryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGMSClientServerQueryResponse* other);

  // implements Message ----------------------------------------------

  CMsgGMSClientServerQueryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGMSClientServerQueryResponse& from);
  void MergeFrom(const CMsgGMSClientServerQueryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgGMSClientServerQueryResponse_Server Server;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgGMSClientServerQueryResponse.Server servers = 1;
  inline int servers_size() const;
  inline void clear_servers();
  static const int kServersFieldNumber = 1;
  inline const ::Sc::CMsgGMSClientServerQueryResponse_Server& servers(int index) const;
  inline ::Sc::CMsgGMSClientServerQueryResponse_Server* mutable_servers(int index);
  inline ::Sc::CMsgGMSClientServerQueryResponse_Server* add_servers();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGMSClientServerQueryResponse_Server >&
      servers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGMSClientServerQueryResponse_Server >*
      mutable_servers();

  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGMSClientServerQueryResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGMSClientServerQueryResponse_Server > servers_;
  ::std::string* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGMSClientServerQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGameServerOutOfDate : public ::google::protobuf::MessageLite {
 public:
  CMsgGameServerOutOfDate();
  virtual ~CMsgGameServerOutOfDate();

  CMsgGameServerOutOfDate(const CMsgGameServerOutOfDate& from);

  inline CMsgGameServerOutOfDate& operator=(const CMsgGameServerOutOfDate& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGameServerOutOfDate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGameServerOutOfDate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGameServerOutOfDate* other);

  // implements Message ----------------------------------------------

  CMsgGameServerOutOfDate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGameServerOutOfDate& from);
  void MergeFrom(const CMsgGameServerOutOfDate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_gs = 1;
  inline bool has_steam_id_gs() const;
  inline void clear_steam_id_gs();
  static const int kSteamIdGsFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_gs() const;
  inline void set_steam_id_gs(::google::protobuf::uint64 value);

  // optional bool reject = 2;
  inline bool has_reject() const;
  inline void clear_reject();
  static const int kRejectFieldNumber = 2;
  inline bool reject() const;
  inline void set_reject(bool value);

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGameServerOutOfDate)
 private:
  inline void set_has_steam_id_gs();
  inline void clear_has_steam_id_gs();
  inline void set_has_reject();
  inline void clear_has_reject();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::uint64 steam_id_gs_;
  ::std::string* message_;
  bool reject_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGameServerOutOfDate* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRedeemGuestPass : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRedeemGuestPass();
  virtual ~CMsgClientRedeemGuestPass();

  CMsgClientRedeemGuestPass(const CMsgClientRedeemGuestPass& from);

  inline CMsgClientRedeemGuestPass& operator=(const CMsgClientRedeemGuestPass& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRedeemGuestPass& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRedeemGuestPass* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRedeemGuestPass* other);

  // implements Message ----------------------------------------------

  CMsgClientRedeemGuestPass* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRedeemGuestPass& from);
  void MergeFrom(const CMsgClientRedeemGuestPass& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 guest_pass_id = 1;
  inline bool has_guest_pass_id() const;
  inline void clear_guest_pass_id();
  static const int kGuestPassIdFieldNumber = 1;
  inline ::google::protobuf::uint64 guest_pass_id() const;
  inline void set_guest_pass_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRedeemGuestPass)
 private:
  inline void set_has_guest_pass_id();
  inline void clear_has_guest_pass_id();

  ::google::protobuf::uint64 guest_pass_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRedeemGuestPass* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRedeemGuestPassResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRedeemGuestPassResponse();
  virtual ~CMsgClientRedeemGuestPassResponse();

  CMsgClientRedeemGuestPassResponse(const CMsgClientRedeemGuestPassResponse& from);

  inline CMsgClientRedeemGuestPassResponse& operator=(const CMsgClientRedeemGuestPassResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRedeemGuestPassResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRedeemGuestPassResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRedeemGuestPassResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRedeemGuestPassResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRedeemGuestPassResponse& from);
  void MergeFrom(const CMsgClientRedeemGuestPassResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 package_id = 2;
  inline bool has_package_id() const;
  inline void clear_package_id();
  static const int kPackageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 package_id() const;
  inline void set_package_id(::google::protobuf::uint32 value);

  // optional uint32 must_own_appid = 3;
  inline bool has_must_own_appid() const;
  inline void clear_must_own_appid();
  static const int kMustOwnAppidFieldNumber = 3;
  inline ::google::protobuf::uint32 must_own_appid() const;
  inline void set_must_own_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRedeemGuestPassResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_package_id();
  inline void clear_has_package_id();
  inline void set_has_must_own_appid();
  inline void clear_has_must_own_appid();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 package_id_;
  ::google::protobuf::uint32 must_own_appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRedeemGuestPassResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClanActivityCounts : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClanActivityCounts();
  virtual ~CMsgClientGetClanActivityCounts();

  CMsgClientGetClanActivityCounts(const CMsgClientGetClanActivityCounts& from);

  inline CMsgClientGetClanActivityCounts& operator=(const CMsgClientGetClanActivityCounts& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClanActivityCounts& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClanActivityCounts* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClanActivityCounts* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClanActivityCounts* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClanActivityCounts& from);
  void MergeFrom(const CMsgClientGetClanActivityCounts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 steamid_clans = 1;
  inline int steamid_clans_size() const;
  inline void clear_steamid_clans();
  static const int kSteamidClansFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid_clans(int index) const;
  inline void set_steamid_clans(int index, ::google::protobuf::uint64 value);
  inline void add_steamid_clans(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      steamid_clans() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_steamid_clans();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClanActivityCounts)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > steamid_clans_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClanActivityCounts* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientGetClanActivityCountsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientGetClanActivityCountsResponse();
  virtual ~CMsgClientGetClanActivityCountsResponse();

  CMsgClientGetClanActivityCountsResponse(const CMsgClientGetClanActivityCountsResponse& from);

  inline CMsgClientGetClanActivityCountsResponse& operator=(const CMsgClientGetClanActivityCountsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientGetClanActivityCountsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientGetClanActivityCountsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientGetClanActivityCountsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientGetClanActivityCountsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientGetClanActivityCountsResponse& from);
  void MergeFrom(const CMsgClientGetClanActivityCountsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientGetClanActivityCountsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientGetClanActivityCountsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientOGSReportString : public ::google::protobuf::MessageLite {
 public:
  CMsgClientOGSReportString();
  virtual ~CMsgClientOGSReportString();

  CMsgClientOGSReportString(const CMsgClientOGSReportString& from);

  inline CMsgClientOGSReportString& operator=(const CMsgClientOGSReportString& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientOGSReportString& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientOGSReportString* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientOGSReportString* other);

  // implements Message ----------------------------------------------

  CMsgClientOGSReportString* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientOGSReportString& from);
  void MergeFrom(const CMsgClientOGSReportString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool accumulated = 1;
  inline bool has_accumulated() const;
  inline void clear_accumulated();
  static const int kAccumulatedFieldNumber = 1;
  inline bool accumulated() const;
  inline void set_accumulated(bool value);

  // optional uint64 sessionid = 2;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 2;
  inline ::google::protobuf::uint64 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint64 value);

  // optional int32 severity = 3;
  inline bool has_severity() const;
  inline void clear_severity();
  static const int kSeverityFieldNumber = 3;
  inline ::google::protobuf::int32 severity() const;
  inline void set_severity(::google::protobuf::int32 value);

  // optional string formatter = 4;
  inline bool has_formatter() const;
  inline void clear_formatter();
  static const int kFormatterFieldNumber = 4;
  inline const ::std::string& formatter() const;
  inline void set_formatter(const ::std::string& value);
  inline void set_formatter(const char* value);
  inline void set_formatter(const char* value, size_t size);
  inline ::std::string* mutable_formatter();
  inline ::std::string* release_formatter();
  inline void set_allocated_formatter(::std::string* formatter);

  // optional bytes varargs = 5;
  inline bool has_varargs() const;
  inline void clear_varargs();
  static const int kVarargsFieldNumber = 5;
  inline const ::std::string& varargs() const;
  inline void set_varargs(const ::std::string& value);
  inline void set_varargs(const char* value);
  inline void set_varargs(const void* value, size_t size);
  inline ::std::string* mutable_varargs();
  inline ::std::string* release_varargs();
  inline void set_allocated_varargs(::std::string* varargs);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientOGSReportString)
 private:
  inline void set_has_accumulated();
  inline void clear_has_accumulated();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_severity();
  inline void clear_has_severity();
  inline void set_has_formatter();
  inline void clear_has_formatter();
  inline void set_has_varargs();
  inline void clear_has_varargs();

  ::google::protobuf::uint64 sessionid_;
  bool accumulated_;
  ::google::protobuf::int32 severity_;
  ::std::string* formatter_;
  ::std::string* varargs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientOGSReportString* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientOGSReportBug : public ::google::protobuf::MessageLite {
 public:
  CMsgClientOGSReportBug();
  virtual ~CMsgClientOGSReportBug();

  CMsgClientOGSReportBug(const CMsgClientOGSReportBug& from);

  inline CMsgClientOGSReportBug& operator=(const CMsgClientOGSReportBug& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientOGSReportBug& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientOGSReportBug* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientOGSReportBug* other);

  // implements Message ----------------------------------------------

  CMsgClientOGSReportBug* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientOGSReportBug& from);
  void MergeFrom(const CMsgClientOGSReportBug& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 sessionid = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  inline ::google::protobuf::uint64 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint64 value);

  // optional string bugtext = 2;
  inline bool has_bugtext() const;
  inline void clear_bugtext();
  static const int kBugtextFieldNumber = 2;
  inline const ::std::string& bugtext() const;
  inline void set_bugtext(const ::std::string& value);
  inline void set_bugtext(const char* value);
  inline void set_bugtext(const char* value, size_t size);
  inline ::std::string* mutable_bugtext();
  inline ::std::string* release_bugtext();
  inline void set_allocated_bugtext(::std::string* bugtext);

  // optional bytes screenshot = 3;
  inline bool has_screenshot() const;
  inline void clear_screenshot();
  static const int kScreenshotFieldNumber = 3;
  inline const ::std::string& screenshot() const;
  inline void set_screenshot(const ::std::string& value);
  inline void set_screenshot(const char* value);
  inline void set_screenshot(const void* value, size_t size);
  inline ::std::string* mutable_screenshot();
  inline ::std::string* release_screenshot();
  inline void set_allocated_screenshot(::std::string* screenshot);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientOGSReportBug)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_bugtext();
  inline void clear_has_bugtext();
  inline void set_has_screenshot();
  inline void clear_has_screenshot();

  ::google::protobuf::uint64 sessionid_;
  ::std::string* bugtext_;
  ::std::string* screenshot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientOGSReportBug* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSAssociateWithClan : public ::google::protobuf::MessageLite {
 public:
  CMsgGSAssociateWithClan();
  virtual ~CMsgGSAssociateWithClan();

  CMsgGSAssociateWithClan(const CMsgGSAssociateWithClan& from);

  inline CMsgGSAssociateWithClan& operator=(const CMsgGSAssociateWithClan& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSAssociateWithClan& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSAssociateWithClan* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSAssociateWithClan* other);

  // implements Message ----------------------------------------------

  CMsgGSAssociateWithClan* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSAssociateWithClan& from);
  void MergeFrom(const CMsgGSAssociateWithClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_clan = 1;
  inline bool has_steam_id_clan() const;
  inline void clear_steam_id_clan();
  static const int kSteamIdClanFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_clan() const;
  inline void set_steam_id_clan(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSAssociateWithClan)
 private:
  inline void set_has_steam_id_clan();
  inline void clear_has_steam_id_clan();

  ::google::protobuf::uint64 steam_id_clan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSAssociateWithClan* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSAssociateWithClanResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgGSAssociateWithClanResponse();
  virtual ~CMsgGSAssociateWithClanResponse();

  CMsgGSAssociateWithClanResponse(const CMsgGSAssociateWithClanResponse& from);

  inline CMsgGSAssociateWithClanResponse& operator=(const CMsgGSAssociateWithClanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSAssociateWithClanResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSAssociateWithClanResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSAssociateWithClanResponse* other);

  // implements Message ----------------------------------------------

  CMsgGSAssociateWithClanResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSAssociateWithClanResponse& from);
  void MergeFrom(const CMsgGSAssociateWithClanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_clan = 1;
  inline bool has_steam_id_clan() const;
  inline void clear_steam_id_clan();
  static const int kSteamIdClanFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_clan() const;
  inline void set_steam_id_clan(::google::protobuf::uint64 value);

  // optional uint32 eresult = 2 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSAssociateWithClanResponse)
 private:
  inline void set_has_steam_id_clan();
  inline void clear_has_steam_id_clan();
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::uint64 steam_id_clan_;
  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSAssociateWithClanResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSComputeNewPlayerCompatibility : public ::google::protobuf::MessageLite {
 public:
  CMsgGSComputeNewPlayerCompatibility();
  virtual ~CMsgGSComputeNewPlayerCompatibility();

  CMsgGSComputeNewPlayerCompatibility(const CMsgGSComputeNewPlayerCompatibility& from);

  inline CMsgGSComputeNewPlayerCompatibility& operator=(const CMsgGSComputeNewPlayerCompatibility& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSComputeNewPlayerCompatibility& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSComputeNewPlayerCompatibility* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSComputeNewPlayerCompatibility* other);

  // implements Message ----------------------------------------------

  CMsgGSComputeNewPlayerCompatibility* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSComputeNewPlayerCompatibility& from);
  void MergeFrom(const CMsgGSComputeNewPlayerCompatibility& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_candidate = 1;
  inline bool has_steam_id_candidate() const;
  inline void clear_steam_id_candidate();
  static const int kSteamIdCandidateFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_candidate() const;
  inline void set_steam_id_candidate(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSComputeNewPlayerCompatibility)
 private:
  inline void set_has_steam_id_candidate();
  inline void clear_has_steam_id_candidate();

  ::google::protobuf::uint64 steam_id_candidate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSComputeNewPlayerCompatibility* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGSComputeNewPlayerCompatibilityResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgGSComputeNewPlayerCompatibilityResponse();
  virtual ~CMsgGSComputeNewPlayerCompatibilityResponse();

  CMsgGSComputeNewPlayerCompatibilityResponse(const CMsgGSComputeNewPlayerCompatibilityResponse& from);

  inline CMsgGSComputeNewPlayerCompatibilityResponse& operator=(const CMsgGSComputeNewPlayerCompatibilityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGSComputeNewPlayerCompatibilityResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGSComputeNewPlayerCompatibilityResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGSComputeNewPlayerCompatibilityResponse* other);

  // implements Message ----------------------------------------------

  CMsgGSComputeNewPlayerCompatibilityResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGSComputeNewPlayerCompatibilityResponse& from);
  void MergeFrom(const CMsgGSComputeNewPlayerCompatibilityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id_candidate = 1;
  inline bool has_steam_id_candidate() const;
  inline void clear_steam_id_candidate();
  static const int kSteamIdCandidateFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id_candidate() const;
  inline void set_steam_id_candidate(::google::protobuf::uint64 value);

  // optional uint32 eresult = 2 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 2;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional bool is_clan_member = 3;
  inline bool has_is_clan_member() const;
  inline void clear_is_clan_member();
  static const int kIsClanMemberFieldNumber = 3;
  inline bool is_clan_member() const;
  inline void set_is_clan_member(bool value);

  // optional int32 ct_dont_like_you = 4;
  inline bool has_ct_dont_like_you() const;
  inline void clear_ct_dont_like_you();
  static const int kCtDontLikeYouFieldNumber = 4;
  inline ::google::protobuf::int32 ct_dont_like_you() const;
  inline void set_ct_dont_like_you(::google::protobuf::int32 value);

  // optional int32 ct_you_dont_like = 5;
  inline bool has_ct_you_dont_like() const;
  inline void clear_ct_you_dont_like();
  static const int kCtYouDontLikeFieldNumber = 5;
  inline ::google::protobuf::int32 ct_you_dont_like() const;
  inline void set_ct_you_dont_like(::google::protobuf::int32 value);

  // optional int32 ct_clanmembers_dont_like_you = 6;
  inline bool has_ct_clanmembers_dont_like_you() const;
  inline void clear_ct_clanmembers_dont_like_you();
  static const int kCtClanmembersDontLikeYouFieldNumber = 6;
  inline ::google::protobuf::int32 ct_clanmembers_dont_like_you() const;
  inline void set_ct_clanmembers_dont_like_you(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGSComputeNewPlayerCompatibilityResponse)
 private:
  inline void set_has_steam_id_candidate();
  inline void clear_has_steam_id_candidate();
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_is_clan_member();
  inline void clear_has_is_clan_member();
  inline void set_has_ct_dont_like_you();
  inline void clear_has_ct_dont_like_you();
  inline void set_has_ct_you_dont_like();
  inline void clear_has_ct_you_dont_like();
  inline void set_has_ct_clanmembers_dont_like_you();
  inline void clear_has_ct_clanmembers_dont_like_you();

  ::google::protobuf::uint64 steam_id_candidate_;
  ::google::protobuf::uint32 eresult_;
  bool is_clan_member_;
  ::google::protobuf::int32 ct_dont_like_you_;
  ::google::protobuf::int32 ct_you_dont_like_;
  ::google::protobuf::int32 ct_clanmembers_dont_like_you_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGSComputeNewPlayerCompatibilityResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSentLogs : public ::google::protobuf::MessageLite {
 public:
  CMsgClientSentLogs();
  virtual ~CMsgClientSentLogs();

  CMsgClientSentLogs(const CMsgClientSentLogs& from);

  inline CMsgClientSentLogs& operator=(const CMsgClientSentLogs& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientSentLogs& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientSentLogs* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientSentLogs* other);

  // implements Message ----------------------------------------------

  CMsgClientSentLogs* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientSentLogs& from);
  void MergeFrom(const CMsgClientSentLogs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientSentLogs)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSentLogs* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGCClient : public ::google::protobuf::MessageLite {
 public:
  CMsgGCClient();
  virtual ~CMsgGCClient();

  CMsgGCClient(const CMsgGCClient& from);

  inline CMsgGCClient& operator=(const CMsgGCClient& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGCClient& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGCClient* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGCClient* other);

  // implements Message ----------------------------------------------

  CMsgGCClient* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGCClient& from);
  void MergeFrom(const CMsgGCClient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional uint32 msgtype = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 2;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional fixed64 steamid = 4;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 4;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional string gcname = 5;
  inline bool has_gcname() const;
  inline void clear_gcname();
  static const int kGcnameFieldNumber = 5;
  inline const ::std::string& gcname() const;
  inline void set_gcname(const ::std::string& value);
  inline void set_gcname(const char* value);
  inline void set_gcname(const char* value, size_t size);
  inline ::std::string* mutable_gcname();
  inline ::std::string* release_gcname();
  inline void set_allocated_gcname(::std::string* gcname);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGCClient)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_gcname();
  inline void clear_has_gcname();

  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 msgtype_;
  ::std::string* payload_;
  ::google::protobuf::uint64 steamid_;
  ::std::string* gcname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGCClient* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestFreeLicense : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestFreeLicense();
  virtual ~CMsgClientRequestFreeLicense();

  CMsgClientRequestFreeLicense(const CMsgClientRequestFreeLicense& from);

  inline CMsgClientRequestFreeLicense& operator=(const CMsgClientRequestFreeLicense& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestFreeLicense& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestFreeLicense* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestFreeLicense* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestFreeLicense* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestFreeLicense& from);
  void MergeFrom(const CMsgClientRequestFreeLicense& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestFreeLicense)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestFreeLicense* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestFreeLicenseResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestFreeLicenseResponse();
  virtual ~CMsgClientRequestFreeLicenseResponse();

  CMsgClientRequestFreeLicenseResponse(const CMsgClientRequestFreeLicenseResponse& from);

  inline CMsgClientRequestFreeLicenseResponse& operator=(const CMsgClientRequestFreeLicenseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestFreeLicenseResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestFreeLicenseResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestFreeLicenseResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestFreeLicenseResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestFreeLicenseResponse& from);
  void MergeFrom(const CMsgClientRequestFreeLicenseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 package_id = 2;
  inline bool has_package_id() const;
  inline void clear_package_id();
  static const int kPackageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 package_id() const;
  inline void set_package_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestFreeLicenseResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_package_id();
  inline void clear_has_package_id();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 package_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestFreeLicenseResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDRMDownloadRequestWithCrashData : public ::google::protobuf::MessageLite {
 public:
  CMsgDRMDownloadRequestWithCrashData();
  virtual ~CMsgDRMDownloadRequestWithCrashData();

  CMsgDRMDownloadRequestWithCrashData(const CMsgDRMDownloadRequestWithCrashData& from);

  inline CMsgDRMDownloadRequestWithCrashData& operator=(const CMsgDRMDownloadRequestWithCrashData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDRMDownloadRequestWithCrashData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDRMDownloadRequestWithCrashData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDRMDownloadRequestWithCrashData* other);

  // implements Message ----------------------------------------------

  CMsgDRMDownloadRequestWithCrashData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDRMDownloadRequestWithCrashData& from);
  void MergeFrom(const CMsgDRMDownloadRequestWithCrashData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 download_flags = 1;
  inline bool has_download_flags() const;
  inline void clear_download_flags();
  static const int kDownloadFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 download_flags() const;
  inline void set_download_flags(::google::protobuf::uint32 value);

  // optional uint32 download_types_known = 2;
  inline bool has_download_types_known() const;
  inline void clear_download_types_known();
  static const int kDownloadTypesKnownFieldNumber = 2;
  inline ::google::protobuf::uint32 download_types_known() const;
  inline void set_download_types_known(::google::protobuf::uint32 value);

  // optional bytes guid_drm = 3;
  inline bool has_guid_drm() const;
  inline void clear_guid_drm();
  static const int kGuidDrmFieldNumber = 3;
  inline const ::std::string& guid_drm() const;
  inline void set_guid_drm(const ::std::string& value);
  inline void set_guid_drm(const char* value);
  inline void set_guid_drm(const void* value, size_t size);
  inline ::std::string* mutable_guid_drm();
  inline ::std::string* release_guid_drm();
  inline void set_allocated_guid_drm(::std::string* guid_drm);

  // optional bytes guid_split = 4;
  inline bool has_guid_split() const;
  inline void clear_guid_split();
  static const int kGuidSplitFieldNumber = 4;
  inline const ::std::string& guid_split() const;
  inline void set_guid_split(const ::std::string& value);
  inline void set_guid_split(const char* value);
  inline void set_guid_split(const void* value, size_t size);
  inline ::std::string* mutable_guid_split();
  inline ::std::string* release_guid_split();
  inline void set_allocated_guid_split(::std::string* guid_split);

  // optional bytes guid_merge = 5;
  inline bool has_guid_merge() const;
  inline void clear_guid_merge();
  static const int kGuidMergeFieldNumber = 5;
  inline const ::std::string& guid_merge() const;
  inline void set_guid_merge(const ::std::string& value);
  inline void set_guid_merge(const char* value);
  inline void set_guid_merge(const void* value, size_t size);
  inline ::std::string* mutable_guid_merge();
  inline ::std::string* release_guid_merge();
  inline void set_allocated_guid_merge(::std::string* guid_merge);

  // optional string module_name = 6;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 6;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  inline void set_allocated_module_name(::std::string* module_name);

  // optional string module_path = 7;
  inline bool has_module_path() const;
  inline void clear_module_path();
  static const int kModulePathFieldNumber = 7;
  inline const ::std::string& module_path() const;
  inline void set_module_path(const ::std::string& value);
  inline void set_module_path(const char* value);
  inline void set_module_path(const char* value, size_t size);
  inline ::std::string* mutable_module_path();
  inline ::std::string* release_module_path();
  inline void set_allocated_module_path(::std::string* module_path);

  // optional bytes crash_data = 8;
  inline bool has_crash_data() const;
  inline void clear_crash_data();
  static const int kCrashDataFieldNumber = 8;
  inline const ::std::string& crash_data() const;
  inline void set_crash_data(const ::std::string& value);
  inline void set_crash_data(const char* value);
  inline void set_crash_data(const void* value, size_t size);
  inline ::std::string* mutable_crash_data();
  inline ::std::string* release_crash_data();
  inline void set_allocated_crash_data(::std::string* crash_data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgDRMDownloadRequestWithCrashData)
 private:
  inline void set_has_download_flags();
  inline void clear_has_download_flags();
  inline void set_has_download_types_known();
  inline void clear_has_download_types_known();
  inline void set_has_guid_drm();
  inline void clear_has_guid_drm();
  inline void set_has_guid_split();
  inline void clear_has_guid_split();
  inline void set_has_guid_merge();
  inline void clear_has_guid_merge();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_module_path();
  inline void clear_has_module_path();
  inline void set_has_crash_data();
  inline void clear_has_crash_data();

  ::google::protobuf::uint32 download_flags_;
  ::google::protobuf::uint32 download_types_known_;
  ::std::string* guid_drm_;
  ::std::string* guid_split_;
  ::std::string* guid_merge_;
  ::std::string* module_name_;
  ::std::string* module_path_;
  ::std::string* crash_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDRMDownloadRequestWithCrashData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDRMDownloadResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgDRMDownloadResponse();
  virtual ~CMsgDRMDownloadResponse();

  CMsgDRMDownloadResponse(const CMsgDRMDownloadResponse& from);

  inline CMsgDRMDownloadResponse& operator=(const CMsgDRMDownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDRMDownloadResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDRMDownloadResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDRMDownloadResponse* other);

  // implements Message ----------------------------------------------

  CMsgDRMDownloadResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDRMDownloadResponse& from);
  void MergeFrom(const CMsgDRMDownloadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 blob_download_type = 3;
  inline bool has_blob_download_type() const;
  inline void clear_blob_download_type();
  static const int kBlobDownloadTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 blob_download_type() const;
  inline void set_blob_download_type(::google::protobuf::uint32 value);

  // optional bytes merge_guid = 4;
  inline bool has_merge_guid() const;
  inline void clear_merge_guid();
  static const int kMergeGuidFieldNumber = 4;
  inline const ::std::string& merge_guid() const;
  inline void set_merge_guid(const ::std::string& value);
  inline void set_merge_guid(const char* value);
  inline void set_merge_guid(const void* value, size_t size);
  inline ::std::string* mutable_merge_guid();
  inline ::std::string* release_merge_guid();
  inline void set_allocated_merge_guid(::std::string* merge_guid);

  // optional uint32 download_file_dfs_ip = 5;
  inline bool has_download_file_dfs_ip() const;
  inline void clear_download_file_dfs_ip();
  static const int kDownloadFileDfsIpFieldNumber = 5;
  inline ::google::protobuf::uint32 download_file_dfs_ip() const;
  inline void set_download_file_dfs_ip(::google::protobuf::uint32 value);

  // optional uint32 download_file_dfs_port = 6;
  inline bool has_download_file_dfs_port() const;
  inline void clear_download_file_dfs_port();
  static const int kDownloadFileDfsPortFieldNumber = 6;
  inline ::google::protobuf::uint32 download_file_dfs_port() const;
  inline void set_download_file_dfs_port(::google::protobuf::uint32 value);

  // optional string download_file_url = 7;
  inline bool has_download_file_url() const;
  inline void clear_download_file_url();
  static const int kDownloadFileUrlFieldNumber = 7;
  inline const ::std::string& download_file_url() const;
  inline void set_download_file_url(const ::std::string& value);
  inline void set_download_file_url(const char* value);
  inline void set_download_file_url(const char* value, size_t size);
  inline ::std::string* mutable_download_file_url();
  inline ::std::string* release_download_file_url();
  inline void set_allocated_download_file_url(::std::string* download_file_url);

  // optional string module_path = 8;
  inline bool has_module_path() const;
  inline void clear_module_path();
  static const int kModulePathFieldNumber = 8;
  inline const ::std::string& module_path() const;
  inline void set_module_path(const ::std::string& value);
  inline void set_module_path(const char* value);
  inline void set_module_path(const char* value, size_t size);
  inline ::std::string* mutable_module_path();
  inline ::std::string* release_module_path();
  inline void set_allocated_module_path(::std::string* module_path);

  // @@protoc_insertion_point(class_scope:Sc.CMsgDRMDownloadResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_blob_download_type();
  inline void clear_has_blob_download_type();
  inline void set_has_merge_guid();
  inline void clear_has_merge_guid();
  inline void set_has_download_file_dfs_ip();
  inline void clear_has_download_file_dfs_ip();
  inline void set_has_download_file_dfs_port();
  inline void clear_has_download_file_dfs_port();
  inline void set_has_download_file_url();
  inline void clear_has_download_file_url();
  inline void set_has_module_path();
  inline void clear_has_module_path();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* merge_guid_;
  ::google::protobuf::uint32 blob_download_type_;
  ::google::protobuf::uint32 download_file_dfs_ip_;
  ::std::string* download_file_url_;
  ::std::string* module_path_;
  ::google::protobuf::uint32 download_file_dfs_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDRMDownloadResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDRMFinalResult : public ::google::protobuf::MessageLite {
 public:
  CMsgDRMFinalResult();
  virtual ~CMsgDRMFinalResult();

  CMsgDRMFinalResult(const CMsgDRMFinalResult& from);

  inline CMsgDRMFinalResult& operator=(const CMsgDRMFinalResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDRMFinalResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDRMFinalResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDRMFinalResult* other);

  // implements Message ----------------------------------------------

  CMsgDRMFinalResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDRMFinalResult& from);
  void MergeFrom(const CMsgDRMFinalResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eResult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEResultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 blob_download_type = 3;
  inline bool has_blob_download_type() const;
  inline void clear_blob_download_type();
  static const int kBlobDownloadTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 blob_download_type() const;
  inline void set_blob_download_type(::google::protobuf::uint32 value);

  // optional uint32 error_detail = 4;
  inline bool has_error_detail() const;
  inline void clear_error_detail();
  static const int kErrorDetailFieldNumber = 4;
  inline ::google::protobuf::uint32 error_detail() const;
  inline void set_error_detail(::google::protobuf::uint32 value);

  // optional bytes merge_guid = 5;
  inline bool has_merge_guid() const;
  inline void clear_merge_guid();
  static const int kMergeGuidFieldNumber = 5;
  inline const ::std::string& merge_guid() const;
  inline void set_merge_guid(const ::std::string& value);
  inline void set_merge_guid(const char* value);
  inline void set_merge_guid(const void* value, size_t size);
  inline ::std::string* mutable_merge_guid();
  inline ::std::string* release_merge_guid();
  inline void set_allocated_merge_guid(::std::string* merge_guid);

  // optional uint32 download_file_dfs_ip = 6;
  inline bool has_download_file_dfs_ip() const;
  inline void clear_download_file_dfs_ip();
  static const int kDownloadFileDfsIpFieldNumber = 6;
  inline ::google::protobuf::uint32 download_file_dfs_ip() const;
  inline void set_download_file_dfs_ip(::google::protobuf::uint32 value);

  // optional uint32 download_file_dfs_port = 7;
  inline bool has_download_file_dfs_port() const;
  inline void clear_download_file_dfs_port();
  static const int kDownloadFileDfsPortFieldNumber = 7;
  inline ::google::protobuf::uint32 download_file_dfs_port() const;
  inline void set_download_file_dfs_port(::google::protobuf::uint32 value);

  // optional string download_file_url = 8;
  inline bool has_download_file_url() const;
  inline void clear_download_file_url();
  static const int kDownloadFileUrlFieldNumber = 8;
  inline const ::std::string& download_file_url() const;
  inline void set_download_file_url(const ::std::string& value);
  inline void set_download_file_url(const char* value);
  inline void set_download_file_url(const char* value, size_t size);
  inline ::std::string* mutable_download_file_url();
  inline ::std::string* release_download_file_url();
  inline void set_allocated_download_file_url(::std::string* download_file_url);

  // @@protoc_insertion_point(class_scope:Sc.CMsgDRMFinalResult)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_blob_download_type();
  inline void clear_has_blob_download_type();
  inline void set_has_error_detail();
  inline void clear_has_error_detail();
  inline void set_has_merge_guid();
  inline void clear_has_merge_guid();
  inline void set_has_download_file_dfs_ip();
  inline void clear_has_download_file_dfs_ip();
  inline void set_has_download_file_dfs_port();
  inline void clear_has_download_file_dfs_port();
  inline void set_has_download_file_url();
  inline void clear_has_download_file_url();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 blob_download_type_;
  ::google::protobuf::uint32 error_detail_;
  ::std::string* merge_guid_;
  ::google::protobuf::uint32 download_file_dfs_ip_;
  ::google::protobuf::uint32 download_file_dfs_port_;
  ::std::string* download_file_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDRMFinalResult* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDPCheckSpecialSurvey : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDPCheckSpecialSurvey();
  virtual ~CMsgClientDPCheckSpecialSurvey();

  CMsgClientDPCheckSpecialSurvey(const CMsgClientDPCheckSpecialSurvey& from);

  inline CMsgClientDPCheckSpecialSurvey& operator=(const CMsgClientDPCheckSpecialSurvey& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDPCheckSpecialSurvey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDPCheckSpecialSurvey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDPCheckSpecialSurvey* other);

  // implements Message ----------------------------------------------

  CMsgClientDPCheckSpecialSurvey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDPCheckSpecialSurvey& from);
  void MergeFrom(const CMsgClientDPCheckSpecialSurvey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 survey_id = 1;
  inline bool has_survey_id() const;
  inline void clear_survey_id();
  static const int kSurveyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 survey_id() const;
  inline void set_survey_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDPCheckSpecialSurvey)
 private:
  inline void set_has_survey_id();
  inline void clear_has_survey_id();

  ::google::protobuf::uint32 survey_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDPCheckSpecialSurvey* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDPCheckSpecialSurveyResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDPCheckSpecialSurveyResponse();
  virtual ~CMsgClientDPCheckSpecialSurveyResponse();

  CMsgClientDPCheckSpecialSurveyResponse(const CMsgClientDPCheckSpecialSurveyResponse& from);

  inline CMsgClientDPCheckSpecialSurveyResponse& operator=(const CMsgClientDPCheckSpecialSurveyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDPCheckSpecialSurveyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDPCheckSpecialSurveyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDPCheckSpecialSurveyResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientDPCheckSpecialSurveyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDPCheckSpecialSurveyResponse& from);
  void MergeFrom(const CMsgClientDPCheckSpecialSurveyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eResult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEResultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string custom_url = 4;
  inline bool has_custom_url() const;
  inline void clear_custom_url();
  static const int kCustomUrlFieldNumber = 4;
  inline const ::std::string& custom_url() const;
  inline void set_custom_url(const ::std::string& value);
  inline void set_custom_url(const char* value);
  inline void set_custom_url(const char* value, size_t size);
  inline ::std::string* mutable_custom_url();
  inline ::std::string* release_custom_url();
  inline void set_allocated_custom_url(::std::string* custom_url);

  // optional bool include_software = 5;
  inline bool has_include_software() const;
  inline void clear_include_software();
  static const int kIncludeSoftwareFieldNumber = 5;
  inline bool include_software() const;
  inline void set_include_software(bool value);

  // optional bytes token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDPCheckSpecialSurveyResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_custom_url();
  inline void clear_has_custom_url();
  inline void set_has_include_software();
  inline void clear_has_include_software();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::uint32 eresult_;
  ::google::protobuf::uint32 state_;
  ::std::string* name_;
  ::std::string* custom_url_;
  ::std::string* token_;
  bool include_software_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDPCheckSpecialSurveyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDPSendSpecialSurveyResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDPSendSpecialSurveyResponse();
  virtual ~CMsgClientDPSendSpecialSurveyResponse();

  CMsgClientDPSendSpecialSurveyResponse(const CMsgClientDPSendSpecialSurveyResponse& from);

  inline CMsgClientDPSendSpecialSurveyResponse& operator=(const CMsgClientDPSendSpecialSurveyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDPSendSpecialSurveyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDPSendSpecialSurveyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDPSendSpecialSurveyResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientDPSendSpecialSurveyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDPSendSpecialSurveyResponse& from);
  void MergeFrom(const CMsgClientDPSendSpecialSurveyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 survey_id = 1;
  inline bool has_survey_id() const;
  inline void clear_survey_id();
  static const int kSurveyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 survey_id() const;
  inline void set_survey_id(::google::protobuf::uint32 value);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDPSendSpecialSurveyResponse)
 private:
  inline void set_has_survey_id();
  inline void clear_has_survey_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* data_;
  ::google::protobuf::uint32 survey_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDPSendSpecialSurveyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientDPSendSpecialSurveyResponseReply : public ::google::protobuf::MessageLite {
 public:
  CMsgClientDPSendSpecialSurveyResponseReply();
  virtual ~CMsgClientDPSendSpecialSurveyResponseReply();

  CMsgClientDPSendSpecialSurveyResponseReply(const CMsgClientDPSendSpecialSurveyResponseReply& from);

  inline CMsgClientDPSendSpecialSurveyResponseReply& operator=(const CMsgClientDPSendSpecialSurveyResponseReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientDPSendSpecialSurveyResponseReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientDPSendSpecialSurveyResponseReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientDPSendSpecialSurveyResponseReply* other);

  // implements Message ----------------------------------------------

  CMsgClientDPSendSpecialSurveyResponseReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientDPSendSpecialSurveyResponseReply& from);
  void MergeFrom(const CMsgClientDPSendSpecialSurveyResponseReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eResult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEResultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientDPSendSpecialSurveyResponseReply)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string* token_;
  ::google::protobuf::uint32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientDPSendSpecialSurveyResponseReply* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestForgottenPasswordEmail : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestForgottenPasswordEmail();
  virtual ~CMsgClientRequestForgottenPasswordEmail();

  CMsgClientRequestForgottenPasswordEmail(const CMsgClientRequestForgottenPasswordEmail& from);

  inline CMsgClientRequestForgottenPasswordEmail& operator=(const CMsgClientRequestForgottenPasswordEmail& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestForgottenPasswordEmail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestForgottenPasswordEmail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestForgottenPasswordEmail* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestForgottenPasswordEmail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestForgottenPasswordEmail& from);
  void MergeFrom(const CMsgClientRequestForgottenPasswordEmail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account_name = 1;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 1;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const char* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // optional string password_tried = 2;
  inline bool has_password_tried() const;
  inline void clear_password_tried();
  static const int kPasswordTriedFieldNumber = 2;
  inline const ::std::string& password_tried() const;
  inline void set_password_tried(const ::std::string& value);
  inline void set_password_tried(const char* value);
  inline void set_password_tried(const char* value, size_t size);
  inline ::std::string* mutable_password_tried();
  inline ::std::string* release_password_tried();
  inline void set_allocated_password_tried(::std::string* password_tried);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestForgottenPasswordEmail)
 private:
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_password_tried();
  inline void clear_has_password_tried();

  ::std::string* account_name_;
  ::std::string* password_tried_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestForgottenPasswordEmail* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestForgottenPasswordEmailResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestForgottenPasswordEmailResponse();
  virtual ~CMsgClientRequestForgottenPasswordEmailResponse();

  CMsgClientRequestForgottenPasswordEmailResponse(const CMsgClientRequestForgottenPasswordEmailResponse& from);

  inline CMsgClientRequestForgottenPasswordEmailResponse& operator=(const CMsgClientRequestForgottenPasswordEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestForgottenPasswordEmailResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestForgottenPasswordEmailResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestForgottenPasswordEmailResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestForgottenPasswordEmailResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestForgottenPasswordEmailResponse& from);
  void MergeFrom(const CMsgClientRequestForgottenPasswordEmailResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eResult = 1;
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEResultFieldNumber = 1;
  inline ::google::protobuf::uint32 eresult() const;
  inline void set_eresult(::google::protobuf::uint32 value);

  // optional bool use_secret_question = 2;
  inline bool has_use_secret_question() const;
  inline void clear_use_secret_question();
  static const int kUseSecretQuestionFieldNumber = 2;
  inline bool use_secret_question() const;
  inline void set_use_secret_question(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestForgottenPasswordEmailResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_use_secret_question();
  inline void clear_has_use_secret_question();

  ::google::protobuf::uint32 eresult_;
  bool use_secret_question_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestForgottenPasswordEmailResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientItemAnnouncements : public ::google::protobuf::MessageLite {
 public:
  CMsgClientItemAnnouncements();
  virtual ~CMsgClientItemAnnouncements();

  CMsgClientItemAnnouncements(const CMsgClientItemAnnouncements& from);

  inline CMsgClientItemAnnouncements& operator=(const CMsgClientItemAnnouncements& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientItemAnnouncements& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientItemAnnouncements* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientItemAnnouncements* other);

  // implements Message ----------------------------------------------

  CMsgClientItemAnnouncements* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientItemAnnouncements& from);
  void MergeFrom(const CMsgClientItemAnnouncements& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count_new_items = 1;
  inline bool has_count_new_items() const;
  inline void clear_count_new_items();
  static const int kCountNewItemsFieldNumber = 1;
  inline ::google::protobuf::uint32 count_new_items() const;
  inline void set_count_new_items(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientItemAnnouncements)
 private:
  inline void set_has_count_new_items();
  inline void clear_has_count_new_items();

  ::google::protobuf::uint32 count_new_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientItemAnnouncements* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestItemAnnouncements : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestItemAnnouncements();
  virtual ~CMsgClientRequestItemAnnouncements();

  CMsgClientRequestItemAnnouncements(const CMsgClientRequestItemAnnouncements& from);

  inline CMsgClientRequestItemAnnouncements& operator=(const CMsgClientRequestItemAnnouncements& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestItemAnnouncements& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestItemAnnouncements* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestItemAnnouncements* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestItemAnnouncements* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestItemAnnouncements& from);
  void MergeFrom(const CMsgClientRequestItemAnnouncements& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestItemAnnouncements)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestItemAnnouncements* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientCommentNotifications : public ::google::protobuf::MessageLite {
 public:
  CMsgClientCommentNotifications();
  virtual ~CMsgClientCommentNotifications();

  CMsgClientCommentNotifications(const CMsgClientCommentNotifications& from);

  inline CMsgClientCommentNotifications& operator=(const CMsgClientCommentNotifications& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientCommentNotifications& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientCommentNotifications* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientCommentNotifications* other);

  // implements Message ----------------------------------------------

  CMsgClientCommentNotifications* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientCommentNotifications& from);
  void MergeFrom(const CMsgClientCommentNotifications& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count_new_comments = 1;
  inline bool has_count_new_comments() const;
  inline void clear_count_new_comments();
  static const int kCountNewCommentsFieldNumber = 1;
  inline ::google::protobuf::uint32 count_new_comments() const;
  inline void set_count_new_comments(::google::protobuf::uint32 value);

  // optional uint32 count_new_comments_owner = 2;
  inline bool has_count_new_comments_owner() const;
  inline void clear_count_new_comments_owner();
  static const int kCountNewCommentsOwnerFieldNumber = 2;
  inline ::google::protobuf::uint32 count_new_comments_owner() const;
  inline void set_count_new_comments_owner(::google::protobuf::uint32 value);

  // optional uint32 count_new_comments_subscriptions = 3;
  inline bool has_count_new_comments_subscriptions() const;
  inline void clear_count_new_comments_subscriptions();
  static const int kCountNewCommentsSubscriptionsFieldNumber = 3;
  inline ::google::protobuf::uint32 count_new_comments_subscriptions() const;
  inline void set_count_new_comments_subscriptions(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientCommentNotifications)
 private:
  inline void set_has_count_new_comments();
  inline void clear_has_count_new_comments();
  inline void set_has_count_new_comments_owner();
  inline void clear_has_count_new_comments_owner();
  inline void set_has_count_new_comments_subscriptions();
  inline void clear_has_count_new_comments_subscriptions();

  ::google::protobuf::uint32 count_new_comments_;
  ::google::protobuf::uint32 count_new_comments_owner_;
  ::google::protobuf::uint32 count_new_comments_subscriptions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientCommentNotifications* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestCommentNotifications : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestCommentNotifications();
  virtual ~CMsgClientRequestCommentNotifications();

  CMsgClientRequestCommentNotifications(const CMsgClientRequestCommentNotifications& from);

  inline CMsgClientRequestCommentNotifications& operator=(const CMsgClientRequestCommentNotifications& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestCommentNotifications& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestCommentNotifications* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestCommentNotifications* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestCommentNotifications* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestCommentNotifications& from);
  void MergeFrom(const CMsgClientRequestCommentNotifications& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestCommentNotifications)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestCommentNotifications* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientOfflineMessageNotification : public ::google::protobuf::MessageLite {
 public:
  CMsgClientOfflineMessageNotification();
  virtual ~CMsgClientOfflineMessageNotification();

  CMsgClientOfflineMessageNotification(const CMsgClientOfflineMessageNotification& from);

  inline CMsgClientOfflineMessageNotification& operator=(const CMsgClientOfflineMessageNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientOfflineMessageNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientOfflineMessageNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientOfflineMessageNotification* other);

  // implements Message ----------------------------------------------

  CMsgClientOfflineMessageNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientOfflineMessageNotification& from);
  void MergeFrom(const CMsgClientOfflineMessageNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 offline_messages = 1;
  inline bool has_offline_messages() const;
  inline void clear_offline_messages();
  static const int kOfflineMessagesFieldNumber = 1;
  inline ::google::protobuf::uint32 offline_messages() const;
  inline void set_offline_messages(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientOfflineMessageNotification)
 private:
  inline void set_has_offline_messages();
  inline void clear_has_offline_messages();

  ::google::protobuf::uint32 offline_messages_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientOfflineMessageNotification* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestOfflineMessageCount : public ::google::protobuf::MessageLite {
 public:
  CMsgClientRequestOfflineMessageCount();
  virtual ~CMsgClientRequestOfflineMessageCount();

  CMsgClientRequestOfflineMessageCount(const CMsgClientRequestOfflineMessageCount& from);

  inline CMsgClientRequestOfflineMessageCount& operator=(const CMsgClientRequestOfflineMessageCount& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientRequestOfflineMessageCount& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientRequestOfflineMessageCount* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientRequestOfflineMessageCount* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestOfflineMessageCount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientRequestOfflineMessageCount& from);
  void MergeFrom(const CMsgClientRequestOfflineMessageCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientRequestOfflineMessageCount)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestOfflineMessageCount* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendMessageHistory : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendMessageHistory();
  virtual ~CMsgClientFSGetFriendMessageHistory();

  CMsgClientFSGetFriendMessageHistory(const CMsgClientFSGetFriendMessageHistory& from);

  inline CMsgClientFSGetFriendMessageHistory& operator=(const CMsgClientFSGetFriendMessageHistory& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendMessageHistory& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendMessageHistory* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendMessageHistory* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendMessageHistory* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendMessageHistory& from);
  void MergeFrom(const CMsgClientFSGetFriendMessageHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendMessageHistory)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();

  ::google::protobuf::uint64 steamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendMessageHistory* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage();
  virtual ~CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage();

  CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage(const CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& from);

  inline CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& operator=(const CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& from);
  void MergeFrom(const CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bool unread = 4;
  inline bool has_unread() const;
  inline void clear_unread();
  static const int kUnreadFieldNumber = 4;
  inline bool unread() const;
  inline void set_unread(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendMessageHistoryResponse.FriendMessage)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_unread();
  inline void clear_has_unread();

  ::google::protobuf::uint32 accountid_;
  ::google::protobuf::uint32 timestamp_;
  ::std::string* message_;
  bool unread_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendMessageHistoryResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendMessageHistoryResponse();
  virtual ~CMsgClientFSGetFriendMessageHistoryResponse();

  CMsgClientFSGetFriendMessageHistoryResponse(const CMsgClientFSGetFriendMessageHistoryResponse& from);

  inline CMsgClientFSGetFriendMessageHistoryResponse& operator=(const CMsgClientFSGetFriendMessageHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendMessageHistoryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendMessageHistoryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendMessageHistoryResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendMessageHistoryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendMessageHistoryResponse& from);
  void MergeFrom(const CMsgClientFSGetFriendMessageHistoryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage FriendMessage;

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // optional uint32 success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline ::google::protobuf::uint32 success() const;
  inline void set_success(::google::protobuf::uint32 value);

  // repeated .Sc.CMsgClientFSGetFriendMessageHistoryResponse.FriendMessage messages = 3;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 3;
  inline const ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& messages(int index) const;
  inline ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* mutable_messages(int index);
  inline ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendMessageHistoryResponse)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::uint64 steamid_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage > messages_;
  ::google::protobuf::uint32 success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendMessageHistoryResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendMessageHistoryForOfflineMessages : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendMessageHistoryForOfflineMessages();
  virtual ~CMsgClientFSGetFriendMessageHistoryForOfflineMessages();

  CMsgClientFSGetFriendMessageHistoryForOfflineMessages(const CMsgClientFSGetFriendMessageHistoryForOfflineMessages& from);

  inline CMsgClientFSGetFriendMessageHistoryForOfflineMessages& operator=(const CMsgClientFSGetFriendMessageHistoryForOfflineMessages& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendMessageHistoryForOfflineMessages& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendMessageHistoryForOfflineMessages* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendMessageHistoryForOfflineMessages* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendMessageHistoryForOfflineMessages* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendMessageHistoryForOfflineMessages& from);
  void MergeFrom(const CMsgClientFSGetFriendMessageHistoryForOfflineMessages& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendMessageHistoryForOfflineMessages)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendMessageHistoryForOfflineMessages* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendsSteamLevels : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendsSteamLevels();
  virtual ~CMsgClientFSGetFriendsSteamLevels();

  CMsgClientFSGetFriendsSteamLevels(const CMsgClientFSGetFriendsSteamLevels& from);

  inline CMsgClientFSGetFriendsSteamLevels& operator=(const CMsgClientFSGetFriendsSteamLevels& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendsSteamLevels& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendsSteamLevels* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendsSteamLevels* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendsSteamLevels* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendsSteamLevels& from);
  void MergeFrom(const CMsgClientFSGetFriendsSteamLevels& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 accountids = 1;
  inline int accountids_size() const;
  inline void clear_accountids();
  static const int kAccountidsFieldNumber = 1;
  inline ::google::protobuf::uint32 accountids(int index) const;
  inline void set_accountids(int index, ::google::protobuf::uint32 value);
  inline void add_accountids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      accountids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_accountids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendsSteamLevels)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > accountids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendsSteamLevels* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendsSteamLevelsResponse_Friend : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendsSteamLevelsResponse_Friend();
  virtual ~CMsgClientFSGetFriendsSteamLevelsResponse_Friend();

  CMsgClientFSGetFriendsSteamLevelsResponse_Friend(const CMsgClientFSGetFriendsSteamLevelsResponse_Friend& from);

  inline CMsgClientFSGetFriendsSteamLevelsResponse_Friend& operator=(const CMsgClientFSGetFriendsSteamLevelsResponse_Friend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendsSteamLevelsResponse_Friend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendsSteamLevelsResponse_Friend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendsSteamLevelsResponse_Friend* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendsSteamLevelsResponse_Friend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendsSteamLevelsResponse_Friend& from);
  void MergeFrom(const CMsgClientFSGetFriendsSteamLevelsResponse_Friend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendsSteamLevelsResponse.Friend)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::uint32 accountid_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendsSteamLevelsResponse_Friend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFSGetFriendsSteamLevelsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFSGetFriendsSteamLevelsResponse();
  virtual ~CMsgClientFSGetFriendsSteamLevelsResponse();

  CMsgClientFSGetFriendsSteamLevelsResponse(const CMsgClientFSGetFriendsSteamLevelsResponse& from);

  inline CMsgClientFSGetFriendsSteamLevelsResponse& operator=(const CMsgClientFSGetFriendsSteamLevelsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFSGetFriendsSteamLevelsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFSGetFriendsSteamLevelsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFSGetFriendsSteamLevelsResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientFSGetFriendsSteamLevelsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFSGetFriendsSteamLevelsResponse& from);
  void MergeFrom(const CMsgClientFSGetFriendsSteamLevelsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientFSGetFriendsSteamLevelsResponse_Friend Friend;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgClientFSGetFriendsSteamLevelsResponse.Friend friends = 1;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 1;
  inline const ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend& friends(int index) const;
  inline ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend* mutable_friends(int index);
  inline ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend >*
      mutable_friends();

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFSGetFriendsSteamLevelsResponse)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend > friends_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFSGetFriendsSteamLevelsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientEmailAddrInfo : public ::google::protobuf::MessageLite {
 public:
  CMsgClientEmailAddrInfo();
  virtual ~CMsgClientEmailAddrInfo();

  CMsgClientEmailAddrInfo(const CMsgClientEmailAddrInfo& from);

  inline CMsgClientEmailAddrInfo& operator=(const CMsgClientEmailAddrInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientEmailAddrInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientEmailAddrInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientEmailAddrInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientEmailAddrInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientEmailAddrInfo& from);
  void MergeFrom(const CMsgClientEmailAddrInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email_address = 1;
  inline bool has_email_address() const;
  inline void clear_email_address();
  static const int kEmailAddressFieldNumber = 1;
  inline const ::std::string& email_address() const;
  inline void set_email_address(const ::std::string& value);
  inline void set_email_address(const char* value);
  inline void set_email_address(const char* value, size_t size);
  inline ::std::string* mutable_email_address();
  inline ::std::string* release_email_address();
  inline void set_allocated_email_address(::std::string* email_address);

  // optional bool email_is_validated = 2;
  inline bool has_email_is_validated() const;
  inline void clear_email_is_validated();
  static const int kEmailIsValidatedFieldNumber = 2;
  inline bool email_is_validated() const;
  inline void set_email_is_validated(bool value);

  // optional bool email_validation_changed = 3;
  inline bool has_email_validation_changed() const;
  inline void clear_email_validation_changed();
  static const int kEmailValidationChangedFieldNumber = 3;
  inline bool email_validation_changed() const;
  inline void set_email_validation_changed(bool value);

  // optional bool credential_change_requires_code = 4;
  inline bool has_credential_change_requires_code() const;
  inline void clear_credential_change_requires_code();
  static const int kCredentialChangeRequiresCodeFieldNumber = 4;
  inline bool credential_change_requires_code() const;
  inline void set_credential_change_requires_code(bool value);

  // optional bool password_or_secretqa_change_requires_code = 5;
  inline bool has_password_or_secretqa_change_requires_code() const;
  inline void clear_password_or_secretqa_change_requires_code();
  static const int kPasswordOrSecretqaChangeRequiresCodeFieldNumber = 5;
  inline bool password_or_secretqa_change_requires_code() const;
  inline void set_password_or_secretqa_change_requires_code(bool value);

  // optional bool remind_user_about_email = 6;
  inline bool has_remind_user_about_email() const;
  inline void clear_remind_user_about_email();
  static const int kRemindUserAboutEmailFieldNumber = 6;
  inline bool remind_user_about_email() const;
  inline void set_remind_user_about_email(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientEmailAddrInfo)
 private:
  inline void set_has_email_address();
  inline void clear_has_email_address();
  inline void set_has_email_is_validated();
  inline void clear_has_email_is_validated();
  inline void set_has_email_validation_changed();
  inline void clear_has_email_validation_changed();
  inline void set_has_credential_change_requires_code();
  inline void clear_has_credential_change_requires_code();
  inline void set_has_password_or_secretqa_change_requires_code();
  inline void clear_has_password_or_secretqa_change_requires_code();
  inline void set_has_remind_user_about_email();
  inline void clear_has_remind_user_about_email();

  ::std::string* email_address_;
  bool email_is_validated_;
  bool email_validation_changed_;
  bool credential_change_requires_code_;
  bool password_or_secretqa_change_requires_code_;
  bool remind_user_about_email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientEmailAddrInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREEnumeratePublishedFiles : public ::google::protobuf::MessageLite {
 public:
  CMsgCREEnumeratePublishedFiles();
  virtual ~CMsgCREEnumeratePublishedFiles();

  CMsgCREEnumeratePublishedFiles(const CMsgCREEnumeratePublishedFiles& from);

  inline CMsgCREEnumeratePublishedFiles& operator=(const CMsgCREEnumeratePublishedFiles& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREEnumeratePublishedFiles& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREEnumeratePublishedFiles* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREEnumeratePublishedFiles* other);

  // implements Message ----------------------------------------------

  CMsgCREEnumeratePublishedFiles* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREEnumeratePublishedFiles& from);
  void MergeFrom(const CMsgCREEnumeratePublishedFiles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional int32 query_type = 2;
  inline bool has_query_type() const;
  inline void clear_query_type();
  static const int kQueryTypeFieldNumber = 2;
  inline ::google::protobuf::int32 query_type() const;
  inline void set_query_type(::google::protobuf::int32 value);

  // optional uint32 start_index = 3;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 days = 4;
  inline bool has_days() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 4;
  inline ::google::protobuf::uint32 days() const;
  inline void set_days(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated string tags = 6;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 6;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated string user_tags = 7;
  inline int user_tags_size() const;
  inline void clear_user_tags();
  static const int kUserTagsFieldNumber = 7;
  inline const ::std::string& user_tags(int index) const;
  inline ::std::string* mutable_user_tags(int index);
  inline void set_user_tags(int index, const ::std::string& value);
  inline void set_user_tags(int index, const char* value);
  inline void set_user_tags(int index, const char* value, size_t size);
  inline ::std::string* add_user_tags();
  inline void add_user_tags(const ::std::string& value);
  inline void add_user_tags(const char* value);
  inline void add_user_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_tags();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREEnumeratePublishedFiles)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_query_type();
  inline void clear_has_query_type();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_days();
  inline void clear_has_days();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::int32 query_type_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 days_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_tags_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREEnumeratePublishedFiles* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREEnumeratePublishedFilesResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgCREEnumeratePublishedFilesResponse_PublishedFileId();
  virtual ~CMsgCREEnumeratePublishedFilesResponse_PublishedFileId();

  CMsgCREEnumeratePublishedFilesResponse_PublishedFileId(const CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& from);

  inline CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& operator=(const CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& from);
  void MergeFrom(const CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional int32 votes_for = 2;
  inline bool has_votes_for() const;
  inline void clear_votes_for();
  static const int kVotesForFieldNumber = 2;
  inline ::google::protobuf::int32 votes_for() const;
  inline void set_votes_for(::google::protobuf::int32 value);

  // optional int32 votes_against = 3;
  inline bool has_votes_against() const;
  inline void clear_votes_against();
  static const int kVotesAgainstFieldNumber = 3;
  inline ::google::protobuf::int32 votes_against() const;
  inline void set_votes_against(::google::protobuf::int32 value);

  // optional int32 reports = 4;
  inline bool has_reports() const;
  inline void clear_reports();
  static const int kReportsFieldNumber = 4;
  inline ::google::protobuf::int32 reports() const;
  inline void set_reports(::google::protobuf::int32 value);

  // optional float score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREEnumeratePublishedFilesResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_votes_for();
  inline void clear_has_votes_for();
  inline void set_has_votes_against();
  inline void clear_has_votes_against();
  inline void set_has_reports();
  inline void clear_has_reports();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 votes_for_;
  ::google::protobuf::int32 votes_against_;
  ::google::protobuf::int32 reports_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREEnumeratePublishedFilesResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgCREEnumeratePublishedFilesResponse();
  virtual ~CMsgCREEnumeratePublishedFilesResponse();

  CMsgCREEnumeratePublishedFilesResponse(const CMsgCREEnumeratePublishedFilesResponse& from);

  inline CMsgCREEnumeratePublishedFilesResponse& operator=(const CMsgCREEnumeratePublishedFilesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREEnumeratePublishedFilesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREEnumeratePublishedFilesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREEnumeratePublishedFilesResponse* other);

  // implements Message ----------------------------------------------

  CMsgCREEnumeratePublishedFilesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREEnumeratePublishedFilesResponse& from);
  void MergeFrom(const CMsgCREEnumeratePublishedFilesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCREEnumeratePublishedFilesResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgCREEnumeratePublishedFilesResponse.PublishedFileId published_files = 2;
  inline int published_files_size() const;
  inline void clear_published_files();
  static const int kPublishedFilesFieldNumber = 2;
  inline const ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& published_files(int index) const;
  inline ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* mutable_published_files(int index);
  inline ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* add_published_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId >&
      published_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId >*
      mutable_published_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREEnumeratePublishedFilesResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId > published_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREEnumeratePublishedFilesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCRERankByVote : public ::google::protobuf::MessageLite {
 public:
  CMsgCRERankByVote();
  virtual ~CMsgCRERankByVote();

  CMsgCRERankByVote(const CMsgCRERankByVote& from);

  inline CMsgCRERankByVote& operator=(const CMsgCRERankByVote& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCRERankByVote& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCRERankByVote* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCRERankByVote* other);

  // implements Message ----------------------------------------------

  CMsgCRERankByVote* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCRERankByVote& from);
  void MergeFrom(const CMsgCRERankByVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated string tags = 4;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 4;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated string user_tags = 5;
  inline int user_tags_size() const;
  inline void clear_user_tags();
  static const int kUserTagsFieldNumber = 5;
  inline const ::std::string& user_tags(int index) const;
  inline ::std::string* mutable_user_tags(int index);
  inline void set_user_tags(int index, const ::std::string& value);
  inline void set_user_tags(int index, const char* value);
  inline void set_user_tags(int index, const char* value, size_t size);
  inline ::std::string* add_user_tags();
  inline void add_user_tags(const ::std::string& value);
  inline void add_user_tags(const char* value);
  inline void add_user_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_tags();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCRERankByVote)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_tags_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCRERankByVote* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCRERankByVoteResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgCRERankByVoteResponse_PublishedFileId();
  virtual ~CMsgCRERankByVoteResponse_PublishedFileId();

  CMsgCRERankByVoteResponse_PublishedFileId(const CMsgCRERankByVoteResponse_PublishedFileId& from);

  inline CMsgCRERankByVoteResponse_PublishedFileId& operator=(const CMsgCRERankByVoteResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCRERankByVoteResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCRERankByVoteResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCRERankByVoteResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgCRERankByVoteResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCRERankByVoteResponse_PublishedFileId& from);
  void MergeFrom(const CMsgCRERankByVoteResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional int32 votes_for = 2;
  inline bool has_votes_for() const;
  inline void clear_votes_for();
  static const int kVotesForFieldNumber = 2;
  inline ::google::protobuf::int32 votes_for() const;
  inline void set_votes_for(::google::protobuf::int32 value);

  // optional int32 votes_against = 3;
  inline bool has_votes_against() const;
  inline void clear_votes_against();
  static const int kVotesAgainstFieldNumber = 3;
  inline ::google::protobuf::int32 votes_against() const;
  inline void set_votes_against(::google::protobuf::int32 value);

  // optional int32 reports = 4;
  inline bool has_reports() const;
  inline void clear_reports();
  static const int kReportsFieldNumber = 4;
  inline ::google::protobuf::int32 reports() const;
  inline void set_reports(::google::protobuf::int32 value);

  // optional float score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCRERankByVoteResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_votes_for();
  inline void clear_has_votes_for();
  inline void set_has_votes_against();
  inline void clear_has_votes_against();
  inline void set_has_reports();
  inline void clear_has_reports();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 votes_for_;
  ::google::protobuf::int32 votes_against_;
  ::google::protobuf::int32 reports_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCRERankByVoteResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCRERankByVoteResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgCRERankByVoteResponse();
  virtual ~CMsgCRERankByVoteResponse();

  CMsgCRERankByVoteResponse(const CMsgCRERankByVoteResponse& from);

  inline CMsgCRERankByVoteResponse& operator=(const CMsgCRERankByVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCRERankByVoteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCRERankByVoteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCRERankByVoteResponse* other);

  // implements Message ----------------------------------------------

  CMsgCRERankByVoteResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCRERankByVoteResponse& from);
  void MergeFrom(const CMsgCRERankByVoteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCRERankByVoteResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgCRERankByVoteResponse.PublishedFileId published_files = 2;
  inline int published_files_size() const;
  inline void clear_published_files();
  static const int kPublishedFilesFieldNumber = 2;
  inline const ::Sc::CMsgCRERankByVoteResponse_PublishedFileId& published_files(int index) const;
  inline ::Sc::CMsgCRERankByVoteResponse_PublishedFileId* mutable_published_files(int index);
  inline ::Sc::CMsgCRERankByVoteResponse_PublishedFileId* add_published_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByVoteResponse_PublishedFileId >&
      published_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByVoteResponse_PublishedFileId >*
      mutable_published_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCRERankByVoteResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByVoteResponse_PublishedFileId > published_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCRERankByVoteResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCRERankByTrend : public ::google::protobuf::MessageLite {
 public:
  CMsgCRERankByTrend();
  virtual ~CMsgCRERankByTrend();

  CMsgCRERankByTrend(const CMsgCRERankByTrend& from);

  inline CMsgCRERankByTrend& operator=(const CMsgCRERankByTrend& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCRERankByTrend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCRERankByTrend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCRERankByTrend* other);

  // implements Message ----------------------------------------------

  CMsgCRERankByTrend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCRERankByTrend& from);
  void MergeFrom(const CMsgCRERankByTrend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 days = 3;
  inline bool has_days() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 3;
  inline ::google::protobuf::uint32 days() const;
  inline void set_days(::google::protobuf::uint32 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated string tags = 5;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 5;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated string user_tags = 6;
  inline int user_tags_size() const;
  inline void clear_user_tags();
  static const int kUserTagsFieldNumber = 6;
  inline const ::std::string& user_tags(int index) const;
  inline ::std::string* mutable_user_tags(int index);
  inline void set_user_tags(int index, const ::std::string& value);
  inline void set_user_tags(int index, const char* value);
  inline void set_user_tags(int index, const char* value, size_t size);
  inline ::std::string* add_user_tags();
  inline void add_user_tags(const ::std::string& value);
  inline void add_user_tags(const char* value);
  inline void add_user_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_tags();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCRERankByTrend)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_days();
  inline void clear_has_days();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 days_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_tags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCRERankByTrend* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCRERankByTrendResponse_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgCRERankByTrendResponse_PublishedFileId();
  virtual ~CMsgCRERankByTrendResponse_PublishedFileId();

  CMsgCRERankByTrendResponse_PublishedFileId(const CMsgCRERankByTrendResponse_PublishedFileId& from);

  inline CMsgCRERankByTrendResponse_PublishedFileId& operator=(const CMsgCRERankByTrendResponse_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCRERankByTrendResponse_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCRERankByTrendResponse_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCRERankByTrendResponse_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgCRERankByTrendResponse_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCRERankByTrendResponse_PublishedFileId& from);
  void MergeFrom(const CMsgCRERankByTrendResponse_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional int32 votes_for = 2;
  inline bool has_votes_for() const;
  inline void clear_votes_for();
  static const int kVotesForFieldNumber = 2;
  inline ::google::protobuf::int32 votes_for() const;
  inline void set_votes_for(::google::protobuf::int32 value);

  // optional int32 votes_against = 3;
  inline bool has_votes_against() const;
  inline void clear_votes_against();
  static const int kVotesAgainstFieldNumber = 3;
  inline ::google::protobuf::int32 votes_against() const;
  inline void set_votes_against(::google::protobuf::int32 value);

  // optional int32 reports = 4;
  inline bool has_reports() const;
  inline void clear_reports();
  static const int kReportsFieldNumber = 4;
  inline ::google::protobuf::int32 reports() const;
  inline void set_reports(::google::protobuf::int32 value);

  // optional float score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCRERankByTrendResponse.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_votes_for();
  inline void clear_has_votes_for();
  inline void set_has_votes_against();
  inline void clear_has_votes_against();
  inline void set_has_reports();
  inline void clear_has_reports();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 votes_for_;
  ::google::protobuf::int32 votes_against_;
  ::google::protobuf::int32 reports_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCRERankByTrendResponse_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCRERankByTrendResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgCRERankByTrendResponse();
  virtual ~CMsgCRERankByTrendResponse();

  CMsgCRERankByTrendResponse(const CMsgCRERankByTrendResponse& from);

  inline CMsgCRERankByTrendResponse& operator=(const CMsgCRERankByTrendResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCRERankByTrendResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCRERankByTrendResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCRERankByTrendResponse* other);

  // implements Message ----------------------------------------------

  CMsgCRERankByTrendResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCRERankByTrendResponse& from);
  void MergeFrom(const CMsgCRERankByTrendResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCRERankByTrendResponse_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgCRERankByTrendResponse.PublishedFileId published_files = 2;
  inline int published_files_size() const;
  inline void clear_published_files();
  static const int kPublishedFilesFieldNumber = 2;
  inline const ::Sc::CMsgCRERankByTrendResponse_PublishedFileId& published_files(int index) const;
  inline ::Sc::CMsgCRERankByTrendResponse_PublishedFileId* mutable_published_files(int index);
  inline ::Sc::CMsgCRERankByTrendResponse_PublishedFileId* add_published_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByTrendResponse_PublishedFileId >&
      published_files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByTrendResponse_PublishedFileId >*
      mutable_published_files();

  // optional uint32 total_results = 3;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 3;
  inline ::google::protobuf::uint32 total_results() const;
  inline void set_total_results(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCRERankByTrendResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByTrendResponse_PublishedFileId > published_files_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::uint32 total_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCRERankByTrendResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREItemVoteSummary_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgCREItemVoteSummary_PublishedFileId();
  virtual ~CMsgCREItemVoteSummary_PublishedFileId();

  CMsgCREItemVoteSummary_PublishedFileId(const CMsgCREItemVoteSummary_PublishedFileId& from);

  inline CMsgCREItemVoteSummary_PublishedFileId& operator=(const CMsgCREItemVoteSummary_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREItemVoteSummary_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREItemVoteSummary_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREItemVoteSummary_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgCREItemVoteSummary_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREItemVoteSummary_PublishedFileId& from);
  void MergeFrom(const CMsgCREItemVoteSummary_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREItemVoteSummary.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREItemVoteSummary_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREItemVoteSummary : public ::google::protobuf::MessageLite {
 public:
  CMsgCREItemVoteSummary();
  virtual ~CMsgCREItemVoteSummary();

  CMsgCREItemVoteSummary(const CMsgCREItemVoteSummary& from);

  inline CMsgCREItemVoteSummary& operator=(const CMsgCREItemVoteSummary& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREItemVoteSummary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREItemVoteSummary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREItemVoteSummary* other);

  // implements Message ----------------------------------------------

  CMsgCREItemVoteSummary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREItemVoteSummary& from);
  void MergeFrom(const CMsgCREItemVoteSummary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCREItemVoteSummary_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgCREItemVoteSummary.PublishedFileId published_file_ids = 1;
  inline int published_file_ids_size() const;
  inline void clear_published_file_ids();
  static const int kPublishedFileIdsFieldNumber = 1;
  inline const ::Sc::CMsgCREItemVoteSummary_PublishedFileId& published_file_ids(int index) const;
  inline ::Sc::CMsgCREItemVoteSummary_PublishedFileId* mutable_published_file_ids(int index);
  inline ::Sc::CMsgCREItemVoteSummary_PublishedFileId* add_published_file_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummary_PublishedFileId >&
      published_file_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummary_PublishedFileId >*
      mutable_published_file_ids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREItemVoteSummary)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummary_PublishedFileId > published_file_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREItemVoteSummary* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREItemVoteSummaryResponse_ItemVoteSummary : public ::google::protobuf::MessageLite {
 public:
  CMsgCREItemVoteSummaryResponse_ItemVoteSummary();
  virtual ~CMsgCREItemVoteSummaryResponse_ItemVoteSummary();

  CMsgCREItemVoteSummaryResponse_ItemVoteSummary(const CMsgCREItemVoteSummaryResponse_ItemVoteSummary& from);

  inline CMsgCREItemVoteSummaryResponse_ItemVoteSummary& operator=(const CMsgCREItemVoteSummaryResponse_ItemVoteSummary& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREItemVoteSummaryResponse_ItemVoteSummary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREItemVoteSummaryResponse_ItemVoteSummary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREItemVoteSummaryResponse_ItemVoteSummary* other);

  // implements Message ----------------------------------------------

  CMsgCREItemVoteSummaryResponse_ItemVoteSummary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREItemVoteSummaryResponse_ItemVoteSummary& from);
  void MergeFrom(const CMsgCREItemVoteSummaryResponse_ItemVoteSummary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional int32 votes_for = 2;
  inline bool has_votes_for() const;
  inline void clear_votes_for();
  static const int kVotesForFieldNumber = 2;
  inline ::google::protobuf::int32 votes_for() const;
  inline void set_votes_for(::google::protobuf::int32 value);

  // optional int32 votes_against = 3;
  inline bool has_votes_against() const;
  inline void clear_votes_against();
  static const int kVotesAgainstFieldNumber = 3;
  inline ::google::protobuf::int32 votes_against() const;
  inline void set_votes_against(::google::protobuf::int32 value);

  // optional int32 reports = 4;
  inline bool has_reports() const;
  inline void clear_reports();
  static const int kReportsFieldNumber = 4;
  inline ::google::protobuf::int32 reports() const;
  inline void set_reports(::google::protobuf::int32 value);

  // optional float score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREItemVoteSummaryResponse.ItemVoteSummary)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_votes_for();
  inline void clear_has_votes_for();
  inline void set_has_votes_against();
  inline void clear_has_votes_against();
  inline void set_has_reports();
  inline void clear_has_reports();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 votes_for_;
  ::google::protobuf::int32 votes_against_;
  ::google::protobuf::int32 reports_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREItemVoteSummaryResponse_ItemVoteSummary* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREItemVoteSummaryResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgCREItemVoteSummaryResponse();
  virtual ~CMsgCREItemVoteSummaryResponse();

  CMsgCREItemVoteSummaryResponse(const CMsgCREItemVoteSummaryResponse& from);

  inline CMsgCREItemVoteSummaryResponse& operator=(const CMsgCREItemVoteSummaryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREItemVoteSummaryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREItemVoteSummaryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREItemVoteSummaryResponse* other);

  // implements Message ----------------------------------------------

  CMsgCREItemVoteSummaryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREItemVoteSummaryResponse& from);
  void MergeFrom(const CMsgCREItemVoteSummaryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCREItemVoteSummaryResponse_ItemVoteSummary ItemVoteSummary;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgCREItemVoteSummaryResponse.ItemVoteSummary item_vote_summaries = 2;
  inline int item_vote_summaries_size() const;
  inline void clear_item_vote_summaries();
  static const int kItemVoteSummariesFieldNumber = 2;
  inline const ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary& item_vote_summaries(int index) const;
  inline ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary* mutable_item_vote_summaries(int index);
  inline ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary* add_item_vote_summaries();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary >&
      item_vote_summaries() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary >*
      mutable_item_vote_summaries();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREItemVoteSummaryResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary > item_vote_summaries_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREItemVoteSummaryResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREUpdateUserPublishedItemVote : public ::google::protobuf::MessageLite {
 public:
  CMsgCREUpdateUserPublishedItemVote();
  virtual ~CMsgCREUpdateUserPublishedItemVote();

  CMsgCREUpdateUserPublishedItemVote(const CMsgCREUpdateUserPublishedItemVote& from);

  inline CMsgCREUpdateUserPublishedItemVote& operator=(const CMsgCREUpdateUserPublishedItemVote& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREUpdateUserPublishedItemVote& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREUpdateUserPublishedItemVote* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREUpdateUserPublishedItemVote* other);

  // implements Message ----------------------------------------------

  CMsgCREUpdateUserPublishedItemVote* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREUpdateUserPublishedItemVote& from);
  void MergeFrom(const CMsgCREUpdateUserPublishedItemVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional bool vote_up = 2;
  inline bool has_vote_up() const;
  inline void clear_vote_up();
  static const int kVoteUpFieldNumber = 2;
  inline bool vote_up() const;
  inline void set_vote_up(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREUpdateUserPublishedItemVote)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_vote_up();
  inline void clear_has_vote_up();

  ::google::protobuf::uint64 published_file_id_;
  bool vote_up_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREUpdateUserPublishedItemVote* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREUpdateUserPublishedItemVoteResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgCREUpdateUserPublishedItemVoteResponse();
  virtual ~CMsgCREUpdateUserPublishedItemVoteResponse();

  CMsgCREUpdateUserPublishedItemVoteResponse(const CMsgCREUpdateUserPublishedItemVoteResponse& from);

  inline CMsgCREUpdateUserPublishedItemVoteResponse& operator=(const CMsgCREUpdateUserPublishedItemVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREUpdateUserPublishedItemVoteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREUpdateUserPublishedItemVoteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREUpdateUserPublishedItemVoteResponse* other);

  // implements Message ----------------------------------------------

  CMsgCREUpdateUserPublishedItemVoteResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREUpdateUserPublishedItemVoteResponse& from);
  void MergeFrom(const CMsgCREUpdateUserPublishedItemVoteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREUpdateUserPublishedItemVoteResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREUpdateUserPublishedItemVoteResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId : public ::google::protobuf::MessageLite {
 public:
  CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId();
  virtual ~CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId();

  CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId(const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& from);

  inline CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& operator=(const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* other);

  // implements Message ----------------------------------------------

  CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& from);
  void MergeFrom(const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();

  ::google::protobuf::uint64 published_file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREGetUserPublishedItemVoteDetails : public ::google::protobuf::MessageLite {
 public:
  CMsgCREGetUserPublishedItemVoteDetails();
  virtual ~CMsgCREGetUserPublishedItemVoteDetails();

  CMsgCREGetUserPublishedItemVoteDetails(const CMsgCREGetUserPublishedItemVoteDetails& from);

  inline CMsgCREGetUserPublishedItemVoteDetails& operator=(const CMsgCREGetUserPublishedItemVoteDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREGetUserPublishedItemVoteDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREGetUserPublishedItemVoteDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREGetUserPublishedItemVoteDetails* other);

  // implements Message ----------------------------------------------

  CMsgCREGetUserPublishedItemVoteDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREGetUserPublishedItemVoteDetails& from);
  void MergeFrom(const CMsgCREGetUserPublishedItemVoteDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId PublishedFileId;

  // accessors -------------------------------------------------------

  // repeated .Sc.CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId published_file_ids = 1;
  inline int published_file_ids_size() const;
  inline void clear_published_file_ids();
  static const int kPublishedFileIdsFieldNumber = 1;
  inline const ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& published_file_ids(int index) const;
  inline ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* mutable_published_file_ids(int index);
  inline ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* add_published_file_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId >&
      published_file_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId >*
      mutable_published_file_ids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREGetUserPublishedItemVoteDetails)
 private:

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId > published_file_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREGetUserPublishedItemVoteDetails* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail : public ::google::protobuf::MessageLite {
 public:
  CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail();
  virtual ~CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail();

  CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail(const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& from);

  inline CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& operator=(const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* other);

  // implements Message ----------------------------------------------

  CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& from);
  void MergeFrom(const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 published_file_id = 1;
  inline bool has_published_file_id() const;
  inline void clear_published_file_id();
  static const int kPublishedFileIdFieldNumber = 1;
  inline ::google::protobuf::uint64 published_file_id() const;
  inline void set_published_file_id(::google::protobuf::uint64 value);

  // optional int32 vote = 2 [default = 0];
  inline bool has_vote() const;
  inline void clear_vote();
  static const int kVoteFieldNumber = 2;
  inline ::google::protobuf::int32 vote() const;
  inline void set_vote(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail)
 private:
  inline void set_has_published_file_id();
  inline void clear_has_published_file_id();
  inline void set_has_vote();
  inline void clear_has_vote();

  ::google::protobuf::uint64 published_file_id_;
  ::google::protobuf::int32 vote_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* default_instance_;
};
// -------------------------------------------------------------------

class CMsgCREGetUserPublishedItemVoteDetailsResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgCREGetUserPublishedItemVoteDetailsResponse();
  virtual ~CMsgCREGetUserPublishedItemVoteDetailsResponse();

  CMsgCREGetUserPublishedItemVoteDetailsResponse(const CMsgCREGetUserPublishedItemVoteDetailsResponse& from);

  inline CMsgCREGetUserPublishedItemVoteDetailsResponse& operator=(const CMsgCREGetUserPublishedItemVoteDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgCREGetUserPublishedItemVoteDetailsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgCREGetUserPublishedItemVoteDetailsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgCREGetUserPublishedItemVoteDetailsResponse* other);

  // implements Message ----------------------------------------------

  CMsgCREGetUserPublishedItemVoteDetailsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgCREGetUserPublishedItemVoteDetailsResponse& from);
  void MergeFrom(const CMsgCREGetUserPublishedItemVoteDetailsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail UserItemVoteDetail;

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // repeated .Sc.CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail user_item_vote_details = 2;
  inline int user_item_vote_details_size() const;
  inline void clear_user_item_vote_details();
  static const int kUserItemVoteDetailsFieldNumber = 2;
  inline const ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& user_item_vote_details(int index) const;
  inline ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* mutable_user_item_vote_details(int index);
  inline ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* add_user_item_vote_details();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail >&
      user_item_vote_details() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail >*
      mutable_user_item_vote_details();

  // @@protoc_insertion_point(class_scope:Sc.CMsgCREGetUserPublishedItemVoteDetailsResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail > user_item_vote_details_;
  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgCREGetUserPublishedItemVoteDetailsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGameServerPingSample_Sample : public ::google::protobuf::MessageLite {
 public:
  CMsgGameServerPingSample_Sample();
  virtual ~CMsgGameServerPingSample_Sample();

  CMsgGameServerPingSample_Sample(const CMsgGameServerPingSample_Sample& from);

  inline CMsgGameServerPingSample_Sample& operator=(const CMsgGameServerPingSample_Sample& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGameServerPingSample_Sample& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGameServerPingSample_Sample* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGameServerPingSample_Sample* other);

  // implements Message ----------------------------------------------

  CMsgGameServerPingSample_Sample* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGameServerPingSample_Sample& from);
  void MergeFrom(const CMsgGameServerPingSample_Sample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // optional uint32 avg_ping_ms = 2;
  inline bool has_avg_ping_ms() const;
  inline void clear_avg_ping_ms();
  static const int kAvgPingMsFieldNumber = 2;
  inline ::google::protobuf::uint32 avg_ping_ms() const;
  inline void set_avg_ping_ms(::google::protobuf::uint32 value);

  // optional uint32 stddev_ping_ms_x10 = 3;
  inline bool has_stddev_ping_ms_x10() const;
  inline void clear_stddev_ping_ms_x10();
  static const int kStddevPingMsX10FieldNumber = 3;
  inline ::google::protobuf::uint32 stddev_ping_ms_x10() const;
  inline void set_stddev_ping_ms_x10(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgGameServerPingSample.Sample)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_avg_ping_ms();
  inline void clear_has_avg_ping_ms();
  inline void set_has_stddev_ping_ms_x10();
  inline void clear_has_stddev_ping_ms_x10();

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 avg_ping_ms_;
  ::google::protobuf::uint32 stddev_ping_ms_x10_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGameServerPingSample_Sample* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGameServerPingSample : public ::google::protobuf::MessageLite {
 public:
  CMsgGameServerPingSample();
  virtual ~CMsgGameServerPingSample();

  CMsgGameServerPingSample(const CMsgGameServerPingSample& from);

  inline CMsgGameServerPingSample& operator=(const CMsgGameServerPingSample& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgGameServerPingSample& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgGameServerPingSample* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgGameServerPingSample* other);

  // implements Message ----------------------------------------------

  CMsgGameServerPingSample* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgGameServerPingSample& from);
  void MergeFrom(const CMsgGameServerPingSample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CMsgGameServerPingSample_Sample Sample;

  // accessors -------------------------------------------------------

  // optional fixed32 my_ip = 1;
  inline bool has_my_ip() const;
  inline void clear_my_ip();
  static const int kMyIpFieldNumber = 1;
  inline ::google::protobuf::uint32 my_ip() const;
  inline void set_my_ip(::google::protobuf::uint32 value);

  // optional int32 gs_app_id = 2;
  inline bool has_gs_app_id() const;
  inline void clear_gs_app_id();
  static const int kGsAppIdFieldNumber = 2;
  inline ::google::protobuf::int32 gs_app_id() const;
  inline void set_gs_app_id(::google::protobuf::int32 value);

  // repeated .Sc.CMsgGameServerPingSample.Sample gs_samples = 3;
  inline int gs_samples_size() const;
  inline void clear_gs_samples();
  static const int kGsSamplesFieldNumber = 3;
  inline const ::Sc::CMsgGameServerPingSample_Sample& gs_samples(int index) const;
  inline ::Sc::CMsgGameServerPingSample_Sample* mutable_gs_samples(int index);
  inline ::Sc::CMsgGameServerPingSample_Sample* add_gs_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerPingSample_Sample >&
      gs_samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerPingSample_Sample >*
      mutable_gs_samples();

  // @@protoc_insertion_point(class_scope:Sc.CMsgGameServerPingSample)
 private:
  inline void set_has_my_ip();
  inline void clear_has_my_ip();
  inline void set_has_gs_app_id();
  inline void clear_has_gs_app_id();

  ::google::protobuf::uint32 my_ip_;
  ::google::protobuf::int32 gs_app_id_;
  ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerPingSample_Sample > gs_samples_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgGameServerPingSample* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFSGetFollowerCount : public ::google::protobuf::MessageLite {
 public:
  CMsgFSGetFollowerCount();
  virtual ~CMsgFSGetFollowerCount();

  CMsgFSGetFollowerCount(const CMsgFSGetFollowerCount& from);

  inline CMsgFSGetFollowerCount& operator=(const CMsgFSGetFollowerCount& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgFSGetFollowerCount& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgFSGetFollowerCount* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgFSGetFollowerCount* other);

  // implements Message ----------------------------------------------

  CMsgFSGetFollowerCount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgFSGetFollowerCount& from);
  void MergeFrom(const CMsgFSGetFollowerCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgFSGetFollowerCount)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();

  ::google::protobuf::uint64 steam_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgFSGetFollowerCount* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFSGetFollowerCountResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgFSGetFollowerCountResponse();
  virtual ~CMsgFSGetFollowerCountResponse();

  CMsgFSGetFollowerCountResponse(const CMsgFSGetFollowerCountResponse& from);

  inline CMsgFSGetFollowerCountResponse& operator=(const CMsgFSGetFollowerCountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgFSGetFollowerCountResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgFSGetFollowerCountResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgFSGetFollowerCountResponse* other);

  // implements Message ----------------------------------------------

  CMsgFSGetFollowerCountResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgFSGetFollowerCountResponse& from);
  void MergeFrom(const CMsgFSGetFollowerCountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 count = 2 [default = 0];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgFSGetFollowerCountResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgFSGetFollowerCountResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFSGetIsFollowing : public ::google::protobuf::MessageLite {
 public:
  CMsgFSGetIsFollowing();
  virtual ~CMsgFSGetIsFollowing();

  CMsgFSGetIsFollowing(const CMsgFSGetIsFollowing& from);

  inline CMsgFSGetIsFollowing& operator=(const CMsgFSGetIsFollowing& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgFSGetIsFollowing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgFSGetIsFollowing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgFSGetIsFollowing* other);

  // implements Message ----------------------------------------------

  CMsgFSGetIsFollowing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgFSGetIsFollowing& from);
  void MergeFrom(const CMsgFSGetIsFollowing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgFSGetIsFollowing)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();

  ::google::protobuf::uint64 steam_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgFSGetIsFollowing* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFSGetIsFollowingResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgFSGetIsFollowingResponse();
  virtual ~CMsgFSGetIsFollowingResponse();

  CMsgFSGetIsFollowingResponse(const CMsgFSGetIsFollowingResponse& from);

  inline CMsgFSGetIsFollowingResponse& operator=(const CMsgFSGetIsFollowingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgFSGetIsFollowingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgFSGetIsFollowingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgFSGetIsFollowingResponse* other);

  // implements Message ----------------------------------------------

  CMsgFSGetIsFollowingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgFSGetIsFollowingResponse& from);
  void MergeFrom(const CMsgFSGetIsFollowingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional bool is_following = 2 [default = false];
  inline bool has_is_following() const;
  inline void clear_is_following();
  static const int kIsFollowingFieldNumber = 2;
  inline bool is_following() const;
  inline void set_is_following(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgFSGetIsFollowingResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_is_following();
  inline void clear_has_is_following();

  ::google::protobuf::int32 eresult_;
  bool is_following_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgFSGetIsFollowingResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFSEnumerateFollowingList : public ::google::protobuf::MessageLite {
 public:
  CMsgFSEnumerateFollowingList();
  virtual ~CMsgFSEnumerateFollowingList();

  CMsgFSEnumerateFollowingList(const CMsgFSEnumerateFollowingList& from);

  inline CMsgFSEnumerateFollowingList& operator=(const CMsgFSEnumerateFollowingList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgFSEnumerateFollowingList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgFSEnumerateFollowingList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgFSEnumerateFollowingList* other);

  // implements Message ----------------------------------------------

  CMsgFSEnumerateFollowingList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgFSEnumerateFollowingList& from);
  void MergeFrom(const CMsgFSEnumerateFollowingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start_index = 1;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgFSEnumerateFollowingList)
 private:
  inline void set_has_start_index();
  inline void clear_has_start_index();

  ::google::protobuf::uint32 start_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgFSEnumerateFollowingList* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFSEnumerateFollowingListResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgFSEnumerateFollowingListResponse();
  virtual ~CMsgFSEnumerateFollowingListResponse();

  CMsgFSEnumerateFollowingListResponse(const CMsgFSEnumerateFollowingListResponse& from);

  inline CMsgFSEnumerateFollowingListResponse& operator=(const CMsgFSEnumerateFollowingListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgFSEnumerateFollowingListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgFSEnumerateFollowingListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgFSEnumerateFollowingListResponse* other);

  // implements Message ----------------------------------------------

  CMsgFSEnumerateFollowingListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgFSEnumerateFollowingListResponse& from);
  void MergeFrom(const CMsgFSEnumerateFollowingListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 total_results = 2;
  inline bool has_total_results() const;
  inline void clear_total_results();
  static const int kTotalResultsFieldNumber = 2;
  inline ::google::protobuf::int32 total_results() const;
  inline void set_total_results(::google::protobuf::int32 value);

  // repeated fixed64 steam_ids = 3;
  inline int steam_ids_size() const;
  inline void clear_steam_ids();
  static const int kSteamIdsFieldNumber = 3;
  inline ::google::protobuf::uint64 steam_ids(int index) const;
  inline void set_steam_ids(int index, ::google::protobuf::uint64 value);
  inline void add_steam_ids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      steam_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_steam_ids();

  // @@protoc_insertion_point(class_scope:Sc.CMsgFSEnumerateFollowingListResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_total_results();
  inline void clear_has_total_results();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 total_results_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > steam_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgFSEnumerateFollowingListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDPGetNumberOfCurrentPlayers : public ::google::protobuf::MessageLite {
 public:
  CMsgDPGetNumberOfCurrentPlayers();
  virtual ~CMsgDPGetNumberOfCurrentPlayers();

  CMsgDPGetNumberOfCurrentPlayers(const CMsgDPGetNumberOfCurrentPlayers& from);

  inline CMsgDPGetNumberOfCurrentPlayers& operator=(const CMsgDPGetNumberOfCurrentPlayers& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDPGetNumberOfCurrentPlayers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDPGetNumberOfCurrentPlayers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDPGetNumberOfCurrentPlayers* other);

  // implements Message ----------------------------------------------

  CMsgDPGetNumberOfCurrentPlayers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDPGetNumberOfCurrentPlayers& from);
  void MergeFrom(const CMsgDPGetNumberOfCurrentPlayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgDPGetNumberOfCurrentPlayers)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::uint32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDPGetNumberOfCurrentPlayers* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDPGetNumberOfCurrentPlayersResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgDPGetNumberOfCurrentPlayersResponse();
  virtual ~CMsgDPGetNumberOfCurrentPlayersResponse();

  CMsgDPGetNumberOfCurrentPlayersResponse(const CMsgDPGetNumberOfCurrentPlayersResponse& from);

  inline CMsgDPGetNumberOfCurrentPlayersResponse& operator=(const CMsgDPGetNumberOfCurrentPlayersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgDPGetNumberOfCurrentPlayersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgDPGetNumberOfCurrentPlayersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgDPGetNumberOfCurrentPlayersResponse* other);

  // implements Message ----------------------------------------------

  CMsgDPGetNumberOfCurrentPlayersResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgDPGetNumberOfCurrentPlayersResponse& from);
  void MergeFrom(const CMsgDPGetNumberOfCurrentPlayersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 player_count = 2;
  inline bool has_player_count() const;
  inline void clear_player_count();
  static const int kPlayerCountFieldNumber = 2;
  inline ::google::protobuf::int32 player_count() const;
  inline void set_player_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgDPGetNumberOfCurrentPlayersResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_player_count();
  inline void clear_has_player_count();

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 player_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgDPGetNumberOfCurrentPlayersResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientFriendUserStatusPublished : public ::google::protobuf::MessageLite {
 public:
  CMsgClientFriendUserStatusPublished();
  virtual ~CMsgClientFriendUserStatusPublished();

  CMsgClientFriendUserStatusPublished(const CMsgClientFriendUserStatusPublished& from);

  inline CMsgClientFriendUserStatusPublished& operator=(const CMsgClientFriendUserStatusPublished& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientFriendUserStatusPublished& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientFriendUserStatusPublished* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientFriendUserStatusPublished* other);

  // implements Message ----------------------------------------------

  CMsgClientFriendUserStatusPublished* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientFriendUserStatusPublished& from);
  void MergeFrom(const CMsgClientFriendUserStatusPublished& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 friend_steamid = 1;
  inline bool has_friend_steamid() const;
  inline void clear_friend_steamid();
  static const int kFriendSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 friend_steamid() const;
  inline void set_friend_steamid(::google::protobuf::uint64 value);

  // optional uint32 appid = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 2;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional string status_text = 3;
  inline bool has_status_text() const;
  inline void clear_status_text();
  static const int kStatusTextFieldNumber = 3;
  inline const ::std::string& status_text() const;
  inline void set_status_text(const ::std::string& value);
  inline void set_status_text(const char* value);
  inline void set_status_text(const char* value, size_t size);
  inline ::std::string* mutable_status_text();
  inline ::std::string* release_status_text();
  inline void set_allocated_status_text(::std::string* status_text);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientFriendUserStatusPublished)
 private:
  inline void set_has_friend_steamid();
  inline void clear_has_friend_steamid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_status_text();
  inline void clear_has_status_text();

  ::google::protobuf::uint64 friend_steamid_;
  ::std::string* status_text_;
  ::google::protobuf::uint32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientFriendUserStatusPublished* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServiceMethod : public ::google::protobuf::MessageLite {
 public:
  CMsgClientServiceMethod();
  virtual ~CMsgClientServiceMethod();

  CMsgClientServiceMethod(const CMsgClientServiceMethod& from);

  inline CMsgClientServiceMethod& operator=(const CMsgClientServiceMethod& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientServiceMethod& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientServiceMethod* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientServiceMethod* other);

  // implements Message ----------------------------------------------

  CMsgClientServiceMethod* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientServiceMethod& from);
  void MergeFrom(const CMsgClientServiceMethod& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string method_name = 1;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 1;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  inline ::std::string* release_method_name();
  inline void set_allocated_method_name(::std::string* method_name);

  // optional string serialized_method = 2;
  inline bool has_serialized_method() const;
  inline void clear_serialized_method();
  static const int kSerializedMethodFieldNumber = 2;
  inline const ::std::string& serialized_method() const;
  inline void set_serialized_method(const ::std::string& value);
  inline void set_serialized_method(const char* value);
  inline void set_serialized_method(const char* value, size_t size);
  inline ::std::string* mutable_serialized_method();
  inline ::std::string* release_serialized_method();
  inline void set_allocated_serialized_method(::std::string* serialized_method);

  // optional bool is_notification = 3;
  inline bool has_is_notification() const;
  inline void clear_is_notification();
  static const int kIsNotificationFieldNumber = 3;
  inline bool is_notification() const;
  inline void set_is_notification(bool value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientServiceMethod)
 private:
  inline void set_has_method_name();
  inline void clear_has_method_name();
  inline void set_has_serialized_method();
  inline void clear_has_serialized_method();
  inline void set_has_is_notification();
  inline void clear_has_is_notification();

  ::std::string* method_name_;
  ::std::string* serialized_method_;
  bool is_notification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServiceMethod* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServiceMethodResponse : public ::google::protobuf::MessageLite {
 public:
  CMsgClientServiceMethodResponse();
  virtual ~CMsgClientServiceMethodResponse();

  CMsgClientServiceMethodResponse(const CMsgClientServiceMethodResponse& from);

  inline CMsgClientServiceMethodResponse& operator=(const CMsgClientServiceMethodResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientServiceMethodResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientServiceMethodResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientServiceMethodResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientServiceMethodResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientServiceMethodResponse& from);
  void MergeFrom(const CMsgClientServiceMethodResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string method_name = 1;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 1;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  inline ::std::string* release_method_name();
  inline void set_allocated_method_name(::std::string* method_name);

  // optional string serialized_method_response = 2;
  inline bool has_serialized_method_response() const;
  inline void clear_serialized_method_response();
  static const int kSerializedMethodResponseFieldNumber = 2;
  inline const ::std::string& serialized_method_response() const;
  inline void set_serialized_method_response(const ::std::string& value);
  inline void set_serialized_method_response(const char* value);
  inline void set_serialized_method_response(const char* value, size_t size);
  inline ::std::string* mutable_serialized_method_response();
  inline ::std::string* release_serialized_method_response();
  inline void set_allocated_serialized_method_response(::std::string* serialized_method_response);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientServiceMethodResponse)
 private:
  inline void set_has_method_name();
  inline void clear_has_method_name();
  inline void set_has_serialized_method_response();
  inline void clear_has_serialized_method_response();

  ::std::string* method_name_;
  ::std::string* serialized_method_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServiceMethodResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientUIMode : public ::google::protobuf::MessageLite {
 public:
  CMsgClientUIMode();
  virtual ~CMsgClientUIMode();

  CMsgClientUIMode(const CMsgClientUIMode& from);

  inline CMsgClientUIMode& operator=(const CMsgClientUIMode& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMsgClientUIMode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgClientUIMode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgClientUIMode* other);

  // implements Message ----------------------------------------------

  CMsgClientUIMode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgClientUIMode& from);
  void MergeFrom(const CMsgClientUIMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 uimode = 1;
  inline bool has_uimode() const;
  inline void clear_uimode();
  static const int kUimodeFieldNumber = 1;
  inline ::google::protobuf::uint32 uimode() const;
  inline void set_uimode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sc.CMsgClientUIMode)
 private:
  inline void set_has_uimode();
  inline void clear_has_uimode();

  ::google::protobuf::uint32 uimode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_steammessages_5fclientserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_steammessages_5fclientserver_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientUIMode* default_instance_;
};
// ===================================================================


// ===================================================================

// CMsgClientHeartBeat

// -------------------------------------------------------------------

// CMsgClientSubscribeToPersonaFeed_PersonaFeed

// optional fixed64 steamID = 1;
inline bool CMsgClientSubscribeToPersonaFeed_PersonaFeed::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientSubscribeToPersonaFeed_PersonaFeed::steamid() const {
  return steamid_;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional bool subscribe = 2;
inline bool CMsgClientSubscribeToPersonaFeed_PersonaFeed::has_subscribe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::set_has_subscribe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::clear_subscribe() {
  subscribe_ = false;
  clear_has_subscribe();
}
inline bool CMsgClientSubscribeToPersonaFeed_PersonaFeed::subscribe() const {
  return subscribe_;
}
inline void CMsgClientSubscribeToPersonaFeed_PersonaFeed::set_subscribe(bool value) {
  set_has_subscribe();
  subscribe_ = value;
}

// -------------------------------------------------------------------

// CMsgClientSubscribeToPersonaFeed

// repeated .Sc.CMsgClientSubscribeToPersonaFeed.PersonaFeed persona_feeds = 1;
inline int CMsgClientSubscribeToPersonaFeed::persona_feeds_size() const {
  return persona_feeds_.size();
}
inline void CMsgClientSubscribeToPersonaFeed::clear_persona_feeds() {
  persona_feeds_.Clear();
}
inline const ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed& CMsgClientSubscribeToPersonaFeed::persona_feeds(int index) const {
  return persona_feeds_.Get(index);
}
inline ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed* CMsgClientSubscribeToPersonaFeed::mutable_persona_feeds(int index) {
  return persona_feeds_.Mutable(index);
}
inline ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed* CMsgClientSubscribeToPersonaFeed::add_persona_feeds() {
  return persona_feeds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed >&
CMsgClientSubscribeToPersonaFeed::persona_feeds() const {
  return persona_feeds_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientSubscribeToPersonaFeed_PersonaFeed >*
CMsgClientSubscribeToPersonaFeed::mutable_persona_feeds() {
  return &persona_feeds_;
}

// -------------------------------------------------------------------

// CMsgClientUDSP2PSessionStarted

// optional fixed64 steamid_remote = 1;
inline bool CMsgClientUDSP2PSessionStarted::has_steamid_remote() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUDSP2PSessionStarted::set_has_steamid_remote() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUDSP2PSessionStarted::clear_has_steamid_remote() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUDSP2PSessionStarted::clear_steamid_remote() {
  steamid_remote_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_remote();
}
inline ::google::protobuf::uint64 CMsgClientUDSP2PSessionStarted::steamid_remote() const {
  return steamid_remote_;
}
inline void CMsgClientUDSP2PSessionStarted::set_steamid_remote(::google::protobuf::uint64 value) {
  set_has_steamid_remote();
  steamid_remote_ = value;
}

// optional int32 appid = 2;
inline bool CMsgClientUDSP2PSessionStarted::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUDSP2PSessionStarted::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUDSP2PSessionStarted::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUDSP2PSessionStarted::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionStarted::appid() const {
  return appid_;
}
inline void CMsgClientUDSP2PSessionStarted::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUDSP2PSessionEnded

// optional fixed64 steamid_remote = 1;
inline bool CMsgClientUDSP2PSessionEnded::has_steamid_remote() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_steamid_remote() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_steamid_remote() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_steamid_remote() {
  steamid_remote_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_remote();
}
inline ::google::protobuf::uint64 CMsgClientUDSP2PSessionEnded::steamid_remote() const {
  return steamid_remote_;
}
inline void CMsgClientUDSP2PSessionEnded::set_steamid_remote(::google::protobuf::uint64 value) {
  set_has_steamid_remote();
  steamid_remote_ = value;
}

// optional int32 appid = 2;
inline bool CMsgClientUDSP2PSessionEnded::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::appid() const {
  return appid_;
}
inline void CMsgClientUDSP2PSessionEnded::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 session_length_sec = 3;
inline bool CMsgClientUDSP2PSessionEnded::has_session_length_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_session_length_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_session_length_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_session_length_sec() {
  session_length_sec_ = 0;
  clear_has_session_length_sec();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::session_length_sec() const {
  return session_length_sec_;
}
inline void CMsgClientUDSP2PSessionEnded::set_session_length_sec(::google::protobuf::int32 value) {
  set_has_session_length_sec();
  session_length_sec_ = value;
}

// optional int32 session_error = 4;
inline bool CMsgClientUDSP2PSessionEnded::has_session_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_session_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_session_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_session_error() {
  session_error_ = 0;
  clear_has_session_error();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::session_error() const {
  return session_error_;
}
inline void CMsgClientUDSP2PSessionEnded::set_session_error(::google::protobuf::int32 value) {
  set_has_session_error();
  session_error_ = value;
}

// optional int32 nattype = 5;
inline bool CMsgClientUDSP2PSessionEnded::has_nattype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_nattype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_nattype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_nattype() {
  nattype_ = 0;
  clear_has_nattype();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::nattype() const {
  return nattype_;
}
inline void CMsgClientUDSP2PSessionEnded::set_nattype(::google::protobuf::int32 value) {
  set_has_nattype();
  nattype_ = value;
}

// optional int32 bytes_recv = 6;
inline bool CMsgClientUDSP2PSessionEnded::has_bytes_recv() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_bytes_recv() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_bytes_recv() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_bytes_recv() {
  bytes_recv_ = 0;
  clear_has_bytes_recv();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::bytes_recv() const {
  return bytes_recv_;
}
inline void CMsgClientUDSP2PSessionEnded::set_bytes_recv(::google::protobuf::int32 value) {
  set_has_bytes_recv();
  bytes_recv_ = value;
}

// optional int32 bytes_sent = 7;
inline bool CMsgClientUDSP2PSessionEnded::has_bytes_sent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_bytes_sent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_bytes_sent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_bytes_sent() {
  bytes_sent_ = 0;
  clear_has_bytes_sent();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::bytes_sent() const {
  return bytes_sent_;
}
inline void CMsgClientUDSP2PSessionEnded::set_bytes_sent(::google::protobuf::int32 value) {
  set_has_bytes_sent();
  bytes_sent_ = value;
}

// optional int32 bytes_sent_relay = 8;
inline bool CMsgClientUDSP2PSessionEnded::has_bytes_sent_relay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_bytes_sent_relay() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_bytes_sent_relay() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_bytes_sent_relay() {
  bytes_sent_relay_ = 0;
  clear_has_bytes_sent_relay();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::bytes_sent_relay() const {
  return bytes_sent_relay_;
}
inline void CMsgClientUDSP2PSessionEnded::set_bytes_sent_relay(::google::protobuf::int32 value) {
  set_has_bytes_sent_relay();
  bytes_sent_relay_ = value;
}

// optional int32 bytes_recv_relay = 9;
inline bool CMsgClientUDSP2PSessionEnded::has_bytes_recv_relay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_bytes_recv_relay() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_bytes_recv_relay() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_bytes_recv_relay() {
  bytes_recv_relay_ = 0;
  clear_has_bytes_recv_relay();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::bytes_recv_relay() const {
  return bytes_recv_relay_;
}
inline void CMsgClientUDSP2PSessionEnded::set_bytes_recv_relay(::google::protobuf::int32 value) {
  set_has_bytes_recv_relay();
  bytes_recv_relay_ = value;
}

// optional int32 time_to_connect_ms = 10;
inline bool CMsgClientUDSP2PSessionEnded::has_time_to_connect_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientUDSP2PSessionEnded::set_has_time_to_connect_ms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_has_time_to_connect_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientUDSP2PSessionEnded::clear_time_to_connect_ms() {
  time_to_connect_ms_ = 0;
  clear_has_time_to_connect_ms();
}
inline ::google::protobuf::int32 CMsgClientUDSP2PSessionEnded::time_to_connect_ms() const {
  return time_to_connect_ms_;
}
inline void CMsgClientUDSP2PSessionEnded::set_time_to_connect_ms(::google::protobuf::int32 value) {
  set_has_time_to_connect_ms();
  time_to_connect_ms_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRegisterAuthTicketWithCM

// optional uint32 protocol_version = 1;
inline bool CMsgClientRegisterAuthTicketWithCM::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRegisterAuthTicketWithCM::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRegisterAuthTicketWithCM::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRegisterAuthTicketWithCM::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 CMsgClientRegisterAuthTicketWithCM::protocol_version() const {
  return protocol_version_;
}
inline void CMsgClientRegisterAuthTicketWithCM::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// optional bytes ticket = 3;
inline bool CMsgClientRegisterAuthTicketWithCM::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRegisterAuthTicketWithCM::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRegisterAuthTicketWithCM::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRegisterAuthTicketWithCM::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& CMsgClientRegisterAuthTicketWithCM::ticket() const {
  return *ticket_;
}
inline void CMsgClientRegisterAuthTicketWithCM::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void CMsgClientRegisterAuthTicketWithCM::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void CMsgClientRegisterAuthTicketWithCM::set_ticket(const void* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRegisterAuthTicketWithCM::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* CMsgClientRegisterAuthTicketWithCM::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRegisterAuthTicketWithCM::set_allocated_ticket(::std::string* ticket) {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_;
  }
  if (ticket) {
    set_has_ticket();
    ticket_ = ticket;
  } else {
    clear_has_ticket();
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientTicketAuthComplete

// optional fixed64 steam_id = 1;
inline bool CMsgClientTicketAuthComplete::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientTicketAuthComplete::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientTicketAuthComplete::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientTicketAuthComplete::steam_id() const {
  return steam_id_;
}
inline void CMsgClientTicketAuthComplete::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional fixed64 game_id = 2;
inline bool CMsgClientTicketAuthComplete::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientTicketAuthComplete::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientTicketAuthComplete::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientTicketAuthComplete::game_id() const {
  return game_id_;
}
inline void CMsgClientTicketAuthComplete::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional uint32 estate = 3;
inline bool CMsgClientTicketAuthComplete::has_estate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_estate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientTicketAuthComplete::clear_has_estate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientTicketAuthComplete::clear_estate() {
  estate_ = 0u;
  clear_has_estate();
}
inline ::google::protobuf::uint32 CMsgClientTicketAuthComplete::estate() const {
  return estate_;
}
inline void CMsgClientTicketAuthComplete::set_estate(::google::protobuf::uint32 value) {
  set_has_estate();
  estate_ = value;
}

// optional uint32 eauth_session_response = 4;
inline bool CMsgClientTicketAuthComplete::has_eauth_session_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_eauth_session_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientTicketAuthComplete::clear_has_eauth_session_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientTicketAuthComplete::clear_eauth_session_response() {
  eauth_session_response_ = 0u;
  clear_has_eauth_session_response();
}
inline ::google::protobuf::uint32 CMsgClientTicketAuthComplete::eauth_session_response() const {
  return eauth_session_response_;
}
inline void CMsgClientTicketAuthComplete::set_eauth_session_response(::google::protobuf::uint32 value) {
  set_has_eauth_session_response();
  eauth_session_response_ = value;
}

// optional bytes DEPRECATED_ticket = 5;
inline bool CMsgClientTicketAuthComplete::has_deprecated_ticket() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_deprecated_ticket() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientTicketAuthComplete::clear_has_deprecated_ticket() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientTicketAuthComplete::clear_deprecated_ticket() {
  if (deprecated_ticket_ != &::google::protobuf::internal::kEmptyString) {
    deprecated_ticket_->clear();
  }
  clear_has_deprecated_ticket();
}
inline const ::std::string& CMsgClientTicketAuthComplete::deprecated_ticket() const {
  return *deprecated_ticket_;
}
inline void CMsgClientTicketAuthComplete::set_deprecated_ticket(const ::std::string& value) {
  set_has_deprecated_ticket();
  if (deprecated_ticket_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_ticket_ = new ::std::string;
  }
  deprecated_ticket_->assign(value);
}
inline void CMsgClientTicketAuthComplete::set_deprecated_ticket(const char* value) {
  set_has_deprecated_ticket();
  if (deprecated_ticket_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_ticket_ = new ::std::string;
  }
  deprecated_ticket_->assign(value);
}
inline void CMsgClientTicketAuthComplete::set_deprecated_ticket(const void* value, size_t size) {
  set_has_deprecated_ticket();
  if (deprecated_ticket_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_ticket_ = new ::std::string;
  }
  deprecated_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientTicketAuthComplete::mutable_deprecated_ticket() {
  set_has_deprecated_ticket();
  if (deprecated_ticket_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_ticket_ = new ::std::string;
  }
  return deprecated_ticket_;
}
inline ::std::string* CMsgClientTicketAuthComplete::release_deprecated_ticket() {
  clear_has_deprecated_ticket();
  if (deprecated_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deprecated_ticket_;
    deprecated_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientTicketAuthComplete::set_allocated_deprecated_ticket(::std::string* deprecated_ticket) {
  if (deprecated_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete deprecated_ticket_;
  }
  if (deprecated_ticket) {
    set_has_deprecated_ticket();
    deprecated_ticket_ = deprecated_ticket;
  } else {
    clear_has_deprecated_ticket();
    deprecated_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ticket_crc = 6;
inline bool CMsgClientTicketAuthComplete::has_ticket_crc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_ticket_crc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientTicketAuthComplete::clear_has_ticket_crc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientTicketAuthComplete::clear_ticket_crc() {
  ticket_crc_ = 0u;
  clear_has_ticket_crc();
}
inline ::google::protobuf::uint32 CMsgClientTicketAuthComplete::ticket_crc() const {
  return ticket_crc_;
}
inline void CMsgClientTicketAuthComplete::set_ticket_crc(::google::protobuf::uint32 value) {
  set_has_ticket_crc();
  ticket_crc_ = value;
}

// optional uint32 ticket_sequence = 7;
inline bool CMsgClientTicketAuthComplete::has_ticket_sequence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientTicketAuthComplete::set_has_ticket_sequence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientTicketAuthComplete::clear_has_ticket_sequence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientTicketAuthComplete::clear_ticket_sequence() {
  ticket_sequence_ = 0u;
  clear_has_ticket_sequence();
}
inline ::google::protobuf::uint32 CMsgClientTicketAuthComplete::ticket_sequence() const {
  return ticket_sequence_;
}
inline void CMsgClientTicketAuthComplete::set_ticket_sequence(::google::protobuf::uint32 value) {
  set_has_ticket_sequence();
  ticket_sequence_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLogon

// optional uint32 protocol_version = 1;
inline bool CMsgClientLogon::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLogon::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLogon::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLogon::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 CMsgClientLogon::protocol_version() const {
  return protocol_version_;
}
inline void CMsgClientLogon::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// optional uint32 obfustucated_private_ip = 2;
inline bool CMsgClientLogon::has_obfustucated_private_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLogon::set_has_obfustucated_private_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLogon::clear_has_obfustucated_private_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLogon::clear_obfustucated_private_ip() {
  obfustucated_private_ip_ = 0u;
  clear_has_obfustucated_private_ip();
}
inline ::google::protobuf::uint32 CMsgClientLogon::obfustucated_private_ip() const {
  return obfustucated_private_ip_;
}
inline void CMsgClientLogon::set_obfustucated_private_ip(::google::protobuf::uint32 value) {
  set_has_obfustucated_private_ip();
  obfustucated_private_ip_ = value;
}

// optional uint32 cell_id = 3;
inline bool CMsgClientLogon::has_cell_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLogon::set_has_cell_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLogon::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLogon::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientLogon::cell_id() const {
  return cell_id_;
}
inline void CMsgClientLogon::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional uint32 last_session_id = 4;
inline bool CMsgClientLogon::has_last_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLogon::set_has_last_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLogon::clear_has_last_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLogon::clear_last_session_id() {
  last_session_id_ = 0u;
  clear_has_last_session_id();
}
inline ::google::protobuf::uint32 CMsgClientLogon::last_session_id() const {
  return last_session_id_;
}
inline void CMsgClientLogon::set_last_session_id(::google::protobuf::uint32 value) {
  set_has_last_session_id();
  last_session_id_ = value;
}

// optional uint32 client_package_version = 5;
inline bool CMsgClientLogon::has_client_package_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLogon::set_has_client_package_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLogon::clear_has_client_package_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLogon::clear_client_package_version() {
  client_package_version_ = 0u;
  clear_has_client_package_version();
}
inline ::google::protobuf::uint32 CMsgClientLogon::client_package_version() const {
  return client_package_version_;
}
inline void CMsgClientLogon::set_client_package_version(::google::protobuf::uint32 value) {
  set_has_client_package_version();
  client_package_version_ = value;
}

// optional string client_language = 6;
inline bool CMsgClientLogon::has_client_language() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientLogon::set_has_client_language() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientLogon::clear_has_client_language() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientLogon::clear_client_language() {
  if (client_language_ != &::google::protobuf::internal::kEmptyString) {
    client_language_->clear();
  }
  clear_has_client_language();
}
inline const ::std::string& CMsgClientLogon::client_language() const {
  return *client_language_;
}
inline void CMsgClientLogon::set_client_language(const ::std::string& value) {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  client_language_->assign(value);
}
inline void CMsgClientLogon::set_client_language(const char* value) {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  client_language_->assign(value);
}
inline void CMsgClientLogon::set_client_language(const char* value, size_t size) {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  client_language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_client_language() {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  return client_language_;
}
inline ::std::string* CMsgClientLogon::release_client_language() {
  clear_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_language_;
    client_language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_client_language(::std::string* client_language) {
  if (client_language_ != &::google::protobuf::internal::kEmptyString) {
    delete client_language_;
  }
  if (client_language) {
    set_has_client_language();
    client_language_ = client_language;
  } else {
    clear_has_client_language();
    client_language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 client_os_type = 7;
inline bool CMsgClientLogon::has_client_os_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientLogon::set_has_client_os_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientLogon::clear_has_client_os_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientLogon::clear_client_os_type() {
  client_os_type_ = 0u;
  clear_has_client_os_type();
}
inline ::google::protobuf::uint32 CMsgClientLogon::client_os_type() const {
  return client_os_type_;
}
inline void CMsgClientLogon::set_client_os_type(::google::protobuf::uint32 value) {
  set_has_client_os_type();
  client_os_type_ = value;
}

// optional bool should_remember_password = 8 [default = false];
inline bool CMsgClientLogon::has_should_remember_password() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientLogon::set_has_should_remember_password() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientLogon::clear_has_should_remember_password() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientLogon::clear_should_remember_password() {
  should_remember_password_ = false;
  clear_has_should_remember_password();
}
inline bool CMsgClientLogon::should_remember_password() const {
  return should_remember_password_;
}
inline void CMsgClientLogon::set_should_remember_password(bool value) {
  set_has_should_remember_password();
  should_remember_password_ = value;
}

// optional string wine_version = 9;
inline bool CMsgClientLogon::has_wine_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientLogon::set_has_wine_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientLogon::clear_has_wine_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientLogon::clear_wine_version() {
  if (wine_version_ != &::google::protobuf::internal::kEmptyString) {
    wine_version_->clear();
  }
  clear_has_wine_version();
}
inline const ::std::string& CMsgClientLogon::wine_version() const {
  return *wine_version_;
}
inline void CMsgClientLogon::set_wine_version(const ::std::string& value) {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  wine_version_->assign(value);
}
inline void CMsgClientLogon::set_wine_version(const char* value) {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  wine_version_->assign(value);
}
inline void CMsgClientLogon::set_wine_version(const char* value, size_t size) {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  wine_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_wine_version() {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  return wine_version_;
}
inline ::std::string* CMsgClientLogon::release_wine_version() {
  clear_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wine_version_;
    wine_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_wine_version(::std::string* wine_version) {
  if (wine_version_ != &::google::protobuf::internal::kEmptyString) {
    delete wine_version_;
  }
  if (wine_version) {
    set_has_wine_version();
    wine_version_ = wine_version;
  } else {
    clear_has_wine_version();
    wine_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ping_ms_from_cell_search = 10;
inline bool CMsgClientLogon::has_ping_ms_from_cell_search() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientLogon::set_has_ping_ms_from_cell_search() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientLogon::clear_has_ping_ms_from_cell_search() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientLogon::clear_ping_ms_from_cell_search() {
  ping_ms_from_cell_search_ = 0u;
  clear_has_ping_ms_from_cell_search();
}
inline ::google::protobuf::uint32 CMsgClientLogon::ping_ms_from_cell_search() const {
  return ping_ms_from_cell_search_;
}
inline void CMsgClientLogon::set_ping_ms_from_cell_search(::google::protobuf::uint32 value) {
  set_has_ping_ms_from_cell_search();
  ping_ms_from_cell_search_ = value;
}

// optional uint32 public_ip = 20;
inline bool CMsgClientLogon::has_public_ip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientLogon::set_has_public_ip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientLogon::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientLogon::clear_public_ip() {
  public_ip_ = 0u;
  clear_has_public_ip();
}
inline ::google::protobuf::uint32 CMsgClientLogon::public_ip() const {
  return public_ip_;
}
inline void CMsgClientLogon::set_public_ip(::google::protobuf::uint32 value) {
  set_has_public_ip();
  public_ip_ = value;
}

// optional uint32 qos_level = 21;
inline bool CMsgClientLogon::has_qos_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientLogon::set_has_qos_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientLogon::clear_has_qos_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientLogon::clear_qos_level() {
  qos_level_ = 0u;
  clear_has_qos_level();
}
inline ::google::protobuf::uint32 CMsgClientLogon::qos_level() const {
  return qos_level_;
}
inline void CMsgClientLogon::set_qos_level(::google::protobuf::uint32 value) {
  set_has_qos_level();
  qos_level_ = value;
}

// optional fixed64 client_supplied_steam_id = 22;
inline bool CMsgClientLogon::has_client_supplied_steam_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientLogon::set_has_client_supplied_steam_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientLogon::clear_has_client_supplied_steam_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientLogon::clear_client_supplied_steam_id() {
  client_supplied_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_client_supplied_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientLogon::client_supplied_steam_id() const {
  return client_supplied_steam_id_;
}
inline void CMsgClientLogon::set_client_supplied_steam_id(::google::protobuf::uint64 value) {
  set_has_client_supplied_steam_id();
  client_supplied_steam_id_ = value;
}

// optional bytes machine_id = 30;
inline bool CMsgClientLogon::has_machine_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientLogon::set_has_machine_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientLogon::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientLogon::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& CMsgClientLogon::machine_id() const {
  return *machine_id_;
}
inline void CMsgClientLogon::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void CMsgClientLogon::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void CMsgClientLogon::set_machine_id(const void* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* CMsgClientLogon::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes steam2_auth_ticket = 41;
inline bool CMsgClientLogon::has_steam2_auth_ticket() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientLogon::set_has_steam2_auth_ticket() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientLogon::clear_has_steam2_auth_ticket() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientLogon::clear_steam2_auth_ticket() {
  if (steam2_auth_ticket_ != &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_->clear();
  }
  clear_has_steam2_auth_ticket();
}
inline const ::std::string& CMsgClientLogon::steam2_auth_ticket() const {
  return *steam2_auth_ticket_;
}
inline void CMsgClientLogon::set_steam2_auth_ticket(const ::std::string& value) {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  steam2_auth_ticket_->assign(value);
}
inline void CMsgClientLogon::set_steam2_auth_ticket(const char* value) {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  steam2_auth_ticket_->assign(value);
}
inline void CMsgClientLogon::set_steam2_auth_ticket(const void* value, size_t size) {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  steam2_auth_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_steam2_auth_ticket() {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  return steam2_auth_ticket_;
}
inline ::std::string* CMsgClientLogon::release_steam2_auth_ticket() {
  clear_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = steam2_auth_ticket_;
    steam2_auth_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_steam2_auth_ticket(::std::string* steam2_auth_ticket) {
  if (steam2_auth_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete steam2_auth_ticket_;
  }
  if (steam2_auth_ticket) {
    set_has_steam2_auth_ticket();
    steam2_auth_ticket_ = steam2_auth_ticket;
  } else {
    clear_has_steam2_auth_ticket();
    steam2_auth_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email_address = 42;
inline bool CMsgClientLogon::has_email_address() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientLogon::set_has_email_address() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientLogon::clear_has_email_address() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientLogon::clear_email_address() {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    email_address_->clear();
  }
  clear_has_email_address();
}
inline const ::std::string& CMsgClientLogon::email_address() const {
  return *email_address_;
}
inline void CMsgClientLogon::set_email_address(const ::std::string& value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void CMsgClientLogon::set_email_address(const char* value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void CMsgClientLogon::set_email_address(const char* value, size_t size) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_email_address() {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  return email_address_;
}
inline ::std::string* CMsgClientLogon::release_email_address() {
  clear_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_address_;
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_email_address(::std::string* email_address) {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    delete email_address_;
  }
  if (email_address) {
    set_has_email_address();
    email_address_ = email_address;
  } else {
    clear_has_email_address();
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 rtime32_account_creation = 43;
inline bool CMsgClientLogon::has_rtime32_account_creation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientLogon::set_has_rtime32_account_creation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientLogon::clear_has_rtime32_account_creation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientLogon::clear_rtime32_account_creation() {
  rtime32_account_creation_ = 0u;
  clear_has_rtime32_account_creation();
}
inline ::google::protobuf::uint32 CMsgClientLogon::rtime32_account_creation() const {
  return rtime32_account_creation_;
}
inline void CMsgClientLogon::set_rtime32_account_creation(::google::protobuf::uint32 value) {
  set_has_rtime32_account_creation();
  rtime32_account_creation_ = value;
}

// optional string account_name = 50;
inline bool CMsgClientLogon::has_account_name() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgClientLogon::set_has_account_name() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgClientLogon::clear_has_account_name() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgClientLogon::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& CMsgClientLogon::account_name() const {
  return *account_name_;
}
inline void CMsgClientLogon::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientLogon::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientLogon::set_account_name(const char* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  return account_name_;
}
inline ::std::string* CMsgClientLogon::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 51;
inline bool CMsgClientLogon::has_password() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgClientLogon::set_has_password() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgClientLogon::clear_has_password() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgClientLogon::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgClientLogon::password() const {
  return *password_;
}
inline void CMsgClientLogon::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CMsgClientLogon::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CMsgClientLogon::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CMsgClientLogon::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string login_key = 60;
inline bool CMsgClientLogon::has_login_key() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgClientLogon::set_has_login_key() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CMsgClientLogon::clear_has_login_key() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CMsgClientLogon::clear_login_key() {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    login_key_->clear();
  }
  clear_has_login_key();
}
inline const ::std::string& CMsgClientLogon::login_key() const {
  return *login_key_;
}
inline void CMsgClientLogon::set_login_key(const ::std::string& value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientLogon::set_login_key(const char* value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientLogon::set_login_key(const char* value, size_t size) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_login_key() {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  return login_key_;
}
inline ::std::string* CMsgClientLogon::release_login_key() {
  clear_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_key_;
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_login_key(::std::string* login_key) {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    delete login_key_;
  }
  if (login_key) {
    set_has_login_key();
    login_key_ = login_key;
  } else {
    clear_has_login_key();
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sony_psn_ticket = 90;
inline bool CMsgClientLogon::has_sony_psn_ticket() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgClientLogon::set_has_sony_psn_ticket() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CMsgClientLogon::clear_has_sony_psn_ticket() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CMsgClientLogon::clear_sony_psn_ticket() {
  if (sony_psn_ticket_ != &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_->clear();
  }
  clear_has_sony_psn_ticket();
}
inline const ::std::string& CMsgClientLogon::sony_psn_ticket() const {
  return *sony_psn_ticket_;
}
inline void CMsgClientLogon::set_sony_psn_ticket(const ::std::string& value) {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  sony_psn_ticket_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_ticket(const char* value) {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  sony_psn_ticket_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_ticket(const void* value, size_t size) {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  sony_psn_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sony_psn_ticket() {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  return sony_psn_ticket_;
}
inline ::std::string* CMsgClientLogon::release_sony_psn_ticket() {
  clear_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sony_psn_ticket_;
    sony_psn_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sony_psn_ticket(::std::string* sony_psn_ticket) {
  if (sony_psn_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete sony_psn_ticket_;
  }
  if (sony_psn_ticket) {
    set_has_sony_psn_ticket();
    sony_psn_ticket_ = sony_psn_ticket;
  } else {
    clear_has_sony_psn_ticket();
    sony_psn_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sony_psn_service_id = 91;
inline bool CMsgClientLogon::has_sony_psn_service_id() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgClientLogon::set_has_sony_psn_service_id() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CMsgClientLogon::clear_has_sony_psn_service_id() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CMsgClientLogon::clear_sony_psn_service_id() {
  if (sony_psn_service_id_ != &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_->clear();
  }
  clear_has_sony_psn_service_id();
}
inline const ::std::string& CMsgClientLogon::sony_psn_service_id() const {
  return *sony_psn_service_id_;
}
inline void CMsgClientLogon::set_sony_psn_service_id(const ::std::string& value) {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  sony_psn_service_id_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_service_id(const char* value) {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  sony_psn_service_id_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_service_id(const char* value, size_t size) {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  sony_psn_service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sony_psn_service_id() {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  return sony_psn_service_id_;
}
inline ::std::string* CMsgClientLogon::release_sony_psn_service_id() {
  clear_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sony_psn_service_id_;
    sony_psn_service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sony_psn_service_id(::std::string* sony_psn_service_id) {
  if (sony_psn_service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sony_psn_service_id_;
  }
  if (sony_psn_service_id) {
    set_has_sony_psn_service_id();
    sony_psn_service_id_ = sony_psn_service_id;
  } else {
    clear_has_sony_psn_service_id();
    sony_psn_service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool create_new_psn_linked_account_if_needed = 92 [default = false];
inline bool CMsgClientLogon::has_create_new_psn_linked_account_if_needed() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CMsgClientLogon::set_has_create_new_psn_linked_account_if_needed() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CMsgClientLogon::clear_has_create_new_psn_linked_account_if_needed() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CMsgClientLogon::clear_create_new_psn_linked_account_if_needed() {
  create_new_psn_linked_account_if_needed_ = false;
  clear_has_create_new_psn_linked_account_if_needed();
}
inline bool CMsgClientLogon::create_new_psn_linked_account_if_needed() const {
  return create_new_psn_linked_account_if_needed_;
}
inline void CMsgClientLogon::set_create_new_psn_linked_account_if_needed(bool value) {
  set_has_create_new_psn_linked_account_if_needed();
  create_new_psn_linked_account_if_needed_ = value;
}

// optional string sony_psn_name = 93;
inline bool CMsgClientLogon::has_sony_psn_name() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CMsgClientLogon::set_has_sony_psn_name() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CMsgClientLogon::clear_has_sony_psn_name() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CMsgClientLogon::clear_sony_psn_name() {
  if (sony_psn_name_ != &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_->clear();
  }
  clear_has_sony_psn_name();
}
inline const ::std::string& CMsgClientLogon::sony_psn_name() const {
  return *sony_psn_name_;
}
inline void CMsgClientLogon::set_sony_psn_name(const ::std::string& value) {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  sony_psn_name_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_name(const char* value) {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  sony_psn_name_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_name(const char* value, size_t size) {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  sony_psn_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sony_psn_name() {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  return sony_psn_name_;
}
inline ::std::string* CMsgClientLogon::release_sony_psn_name() {
  clear_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sony_psn_name_;
    sony_psn_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sony_psn_name(::std::string* sony_psn_name) {
  if (sony_psn_name_ != &::google::protobuf::internal::kEmptyString) {
    delete sony_psn_name_;
  }
  if (sony_psn_name) {
    set_has_sony_psn_name();
    sony_psn_name_ = sony_psn_name;
  } else {
    clear_has_sony_psn_name();
    sony_psn_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool was_converted_deprecated_msg = 70 [default = false];
inline bool CMsgClientLogon::has_was_converted_deprecated_msg() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CMsgClientLogon::set_has_was_converted_deprecated_msg() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CMsgClientLogon::clear_has_was_converted_deprecated_msg() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CMsgClientLogon::clear_was_converted_deprecated_msg() {
  was_converted_deprecated_msg_ = false;
  clear_has_was_converted_deprecated_msg();
}
inline bool CMsgClientLogon::was_converted_deprecated_msg() const {
  return was_converted_deprecated_msg_;
}
inline void CMsgClientLogon::set_was_converted_deprecated_msg(bool value) {
  set_has_was_converted_deprecated_msg();
  was_converted_deprecated_msg_ = value;
}

// optional string anon_user_target_account_name = 80;
inline bool CMsgClientLogon::has_anon_user_target_account_name() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CMsgClientLogon::set_has_anon_user_target_account_name() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CMsgClientLogon::clear_has_anon_user_target_account_name() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CMsgClientLogon::clear_anon_user_target_account_name() {
  if (anon_user_target_account_name_ != &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_->clear();
  }
  clear_has_anon_user_target_account_name();
}
inline const ::std::string& CMsgClientLogon::anon_user_target_account_name() const {
  return *anon_user_target_account_name_;
}
inline void CMsgClientLogon::set_anon_user_target_account_name(const ::std::string& value) {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  anon_user_target_account_name_->assign(value);
}
inline void CMsgClientLogon::set_anon_user_target_account_name(const char* value) {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  anon_user_target_account_name_->assign(value);
}
inline void CMsgClientLogon::set_anon_user_target_account_name(const char* value, size_t size) {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  anon_user_target_account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_anon_user_target_account_name() {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  return anon_user_target_account_name_;
}
inline ::std::string* CMsgClientLogon::release_anon_user_target_account_name() {
  clear_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = anon_user_target_account_name_;
    anon_user_target_account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_anon_user_target_account_name(::std::string* anon_user_target_account_name) {
  if (anon_user_target_account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete anon_user_target_account_name_;
  }
  if (anon_user_target_account_name) {
    set_has_anon_user_target_account_name();
    anon_user_target_account_name_ = anon_user_target_account_name;
  } else {
    clear_has_anon_user_target_account_name();
    anon_user_target_account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 resolved_user_steam_id = 81;
inline bool CMsgClientLogon::has_resolved_user_steam_id() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CMsgClientLogon::set_has_resolved_user_steam_id() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CMsgClientLogon::clear_has_resolved_user_steam_id() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CMsgClientLogon::clear_resolved_user_steam_id() {
  resolved_user_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_resolved_user_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientLogon::resolved_user_steam_id() const {
  return resolved_user_steam_id_;
}
inline void CMsgClientLogon::set_resolved_user_steam_id(::google::protobuf::uint64 value) {
  set_has_resolved_user_steam_id();
  resolved_user_steam_id_ = value;
}

// optional int32 eresult_sentryfile = 82;
inline bool CMsgClientLogon::has_eresult_sentryfile() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CMsgClientLogon::set_has_eresult_sentryfile() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CMsgClientLogon::clear_has_eresult_sentryfile() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CMsgClientLogon::clear_eresult_sentryfile() {
  eresult_sentryfile_ = 0;
  clear_has_eresult_sentryfile();
}
inline ::google::protobuf::int32 CMsgClientLogon::eresult_sentryfile() const {
  return eresult_sentryfile_;
}
inline void CMsgClientLogon::set_eresult_sentryfile(::google::protobuf::int32 value) {
  set_has_eresult_sentryfile();
  eresult_sentryfile_ = value;
}

// optional bytes sha_sentryfile = 83;
inline bool CMsgClientLogon::has_sha_sentryfile() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CMsgClientLogon::set_has_sha_sentryfile() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CMsgClientLogon::clear_has_sha_sentryfile() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CMsgClientLogon::clear_sha_sentryfile() {
  if (sha_sentryfile_ != &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_->clear();
  }
  clear_has_sha_sentryfile();
}
inline const ::std::string& CMsgClientLogon::sha_sentryfile() const {
  return *sha_sentryfile_;
}
inline void CMsgClientLogon::set_sha_sentryfile(const ::std::string& value) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(value);
}
inline void CMsgClientLogon::set_sha_sentryfile(const char* value) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(value);
}
inline void CMsgClientLogon::set_sha_sentryfile(const void* value, size_t size) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sha_sentryfile() {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  return sha_sentryfile_;
}
inline ::std::string* CMsgClientLogon::release_sha_sentryfile() {
  clear_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_sentryfile_;
    sha_sentryfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sha_sentryfile(::std::string* sha_sentryfile) {
  if (sha_sentryfile_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_sentryfile_;
  }
  if (sha_sentryfile) {
    set_has_sha_sentryfile();
    sha_sentryfile_ = sha_sentryfile;
  } else {
    clear_has_sha_sentryfile();
    sha_sentryfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string auth_code = 84;
inline bool CMsgClientLogon::has_auth_code() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CMsgClientLogon::set_has_auth_code() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CMsgClientLogon::clear_has_auth_code() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CMsgClientLogon::clear_auth_code() {
  if (auth_code_ != &::google::protobuf::internal::kEmptyString) {
    auth_code_->clear();
  }
  clear_has_auth_code();
}
inline const ::std::string& CMsgClientLogon::auth_code() const {
  return *auth_code_;
}
inline void CMsgClientLogon::set_auth_code(const ::std::string& value) {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  auth_code_->assign(value);
}
inline void CMsgClientLogon::set_auth_code(const char* value) {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  auth_code_->assign(value);
}
inline void CMsgClientLogon::set_auth_code(const char* value, size_t size) {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  auth_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_auth_code() {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  return auth_code_;
}
inline ::std::string* CMsgClientLogon::release_auth_code() {
  clear_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_code_;
    auth_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_auth_code(::std::string* auth_code) {
  if (auth_code_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_code_;
  }
  if (auth_code) {
    set_has_auth_code();
    auth_code_ = auth_code;
  } else {
    clear_has_auth_code();
    auth_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 otp_type = 85;
inline bool CMsgClientLogon::has_otp_type() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CMsgClientLogon::set_has_otp_type() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CMsgClientLogon::clear_has_otp_type() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CMsgClientLogon::clear_otp_type() {
  otp_type_ = 0;
  clear_has_otp_type();
}
inline ::google::protobuf::int32 CMsgClientLogon::otp_type() const {
  return otp_type_;
}
inline void CMsgClientLogon::set_otp_type(::google::protobuf::int32 value) {
  set_has_otp_type();
  otp_type_ = value;
}

// optional uint32 otp_value = 86;
inline bool CMsgClientLogon::has_otp_value() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CMsgClientLogon::set_has_otp_value() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CMsgClientLogon::clear_has_otp_value() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CMsgClientLogon::clear_otp_value() {
  otp_value_ = 0u;
  clear_has_otp_value();
}
inline ::google::protobuf::uint32 CMsgClientLogon::otp_value() const {
  return otp_value_;
}
inline void CMsgClientLogon::set_otp_value(::google::protobuf::uint32 value) {
  set_has_otp_value();
  otp_value_ = value;
}

// optional string otp_identifier = 87;
inline bool CMsgClientLogon::has_otp_identifier() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CMsgClientLogon::set_has_otp_identifier() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CMsgClientLogon::clear_has_otp_identifier() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CMsgClientLogon::clear_otp_identifier() {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    otp_identifier_->clear();
  }
  clear_has_otp_identifier();
}
inline const ::std::string& CMsgClientLogon::otp_identifier() const {
  return *otp_identifier_;
}
inline void CMsgClientLogon::set_otp_identifier(const ::std::string& value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientLogon::set_otp_identifier(const char* value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientLogon::set_otp_identifier(const char* value, size_t size) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_otp_identifier() {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  return otp_identifier_;
}
inline ::std::string* CMsgClientLogon::release_otp_identifier() {
  clear_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_identifier_;
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_otp_identifier(::std::string* otp_identifier) {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_identifier_;
  }
  if (otp_identifier) {
    set_has_otp_identifier();
    otp_identifier_ = otp_identifier;
  } else {
    clear_has_otp_identifier();
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool steam2_ticket_request = 88;
inline bool CMsgClientLogon::has_steam2_ticket_request() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CMsgClientLogon::set_has_steam2_ticket_request() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CMsgClientLogon::clear_has_steam2_ticket_request() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CMsgClientLogon::clear_steam2_ticket_request() {
  steam2_ticket_request_ = false;
  clear_has_steam2_ticket_request();
}
inline bool CMsgClientLogon::steam2_ticket_request() const {
  return steam2_ticket_request_;
}
inline void CMsgClientLogon::set_steam2_ticket_request(bool value) {
  set_has_steam2_ticket_request();
  steam2_ticket_request_ = value;
}

// optional int32 game_server_app_id = 94;
inline bool CMsgClientLogon::has_game_server_app_id() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CMsgClientLogon::set_has_game_server_app_id() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CMsgClientLogon::clear_has_game_server_app_id() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CMsgClientLogon::clear_game_server_app_id() {
  game_server_app_id_ = 0;
  clear_has_game_server_app_id();
}
inline ::google::protobuf::int32 CMsgClientLogon::game_server_app_id() const {
  return game_server_app_id_;
}
inline void CMsgClientLogon::set_game_server_app_id(::google::protobuf::int32 value) {
  set_has_game_server_app_id();
  game_server_app_id_ = value;
}

// optional bool steamguard_dont_remember_computer = 95;
inline bool CMsgClientLogon::has_steamguard_dont_remember_computer() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CMsgClientLogon::set_has_steamguard_dont_remember_computer() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CMsgClientLogon::clear_has_steamguard_dont_remember_computer() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CMsgClientLogon::clear_steamguard_dont_remember_computer() {
  steamguard_dont_remember_computer_ = false;
  clear_has_steamguard_dont_remember_computer();
}
inline bool CMsgClientLogon::steamguard_dont_remember_computer() const {
  return steamguard_dont_remember_computer_;
}
inline void CMsgClientLogon::set_steamguard_dont_remember_computer(bool value) {
  set_has_steamguard_dont_remember_computer();
  steamguard_dont_remember_computer_ = value;
}

// optional string machine_name = 96;
inline bool CMsgClientLogon::has_machine_name() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CMsgClientLogon::set_has_machine_name() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CMsgClientLogon::clear_has_machine_name() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CMsgClientLogon::clear_machine_name() {
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    machine_name_->clear();
  }
  clear_has_machine_name();
}
inline const ::std::string& CMsgClientLogon::machine_name() const {
  return *machine_name_;
}
inline void CMsgClientLogon::set_machine_name(const ::std::string& value) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(value);
}
inline void CMsgClientLogon::set_machine_name(const char* value) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(value);
}
inline void CMsgClientLogon::set_machine_name(const char* value, size_t size) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_machine_name() {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  return machine_name_;
}
inline ::std::string* CMsgClientLogon::release_machine_name() {
  clear_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_name_;
    machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_machine_name(::std::string* machine_name) {
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_;
  }
  if (machine_name) {
    set_has_machine_name();
    machine_name_ = machine_name;
  } else {
    clear_has_machine_name();
    machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientLogonResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLogonResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLogonResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLogonResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLogonResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientLogonResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 out_of_game_heartbeat_seconds = 2;
inline bool CMsgClientLogonResponse::has_out_of_game_heartbeat_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLogonResponse::set_has_out_of_game_heartbeat_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLogonResponse::clear_has_out_of_game_heartbeat_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLogonResponse::clear_out_of_game_heartbeat_seconds() {
  out_of_game_heartbeat_seconds_ = 0;
  clear_has_out_of_game_heartbeat_seconds();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::out_of_game_heartbeat_seconds() const {
  return out_of_game_heartbeat_seconds_;
}
inline void CMsgClientLogonResponse::set_out_of_game_heartbeat_seconds(::google::protobuf::int32 value) {
  set_has_out_of_game_heartbeat_seconds();
  out_of_game_heartbeat_seconds_ = value;
}

// optional int32 in_game_heartbeat_seconds = 3;
inline bool CMsgClientLogonResponse::has_in_game_heartbeat_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLogonResponse::set_has_in_game_heartbeat_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLogonResponse::clear_has_in_game_heartbeat_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLogonResponse::clear_in_game_heartbeat_seconds() {
  in_game_heartbeat_seconds_ = 0;
  clear_has_in_game_heartbeat_seconds();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::in_game_heartbeat_seconds() const {
  return in_game_heartbeat_seconds_;
}
inline void CMsgClientLogonResponse::set_in_game_heartbeat_seconds(::google::protobuf::int32 value) {
  set_has_in_game_heartbeat_seconds();
  in_game_heartbeat_seconds_ = value;
}

// optional uint32 public_ip = 4;
inline bool CMsgClientLogonResponse::has_public_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLogonResponse::set_has_public_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLogonResponse::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLogonResponse::clear_public_ip() {
  public_ip_ = 0u;
  clear_has_public_ip();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::public_ip() const {
  return public_ip_;
}
inline void CMsgClientLogonResponse::set_public_ip(::google::protobuf::uint32 value) {
  set_has_public_ip();
  public_ip_ = value;
}

// optional fixed32 rtime32_server_time = 5;
inline bool CMsgClientLogonResponse::has_rtime32_server_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLogonResponse::set_has_rtime32_server_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLogonResponse::clear_has_rtime32_server_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLogonResponse::clear_rtime32_server_time() {
  rtime32_server_time_ = 0u;
  clear_has_rtime32_server_time();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::rtime32_server_time() const {
  return rtime32_server_time_;
}
inline void CMsgClientLogonResponse::set_rtime32_server_time(::google::protobuf::uint32 value) {
  set_has_rtime32_server_time();
  rtime32_server_time_ = value;
}

// optional uint32 account_flags = 6;
inline bool CMsgClientLogonResponse::has_account_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientLogonResponse::set_has_account_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientLogonResponse::clear_has_account_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientLogonResponse::clear_account_flags() {
  account_flags_ = 0u;
  clear_has_account_flags();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::account_flags() const {
  return account_flags_;
}
inline void CMsgClientLogonResponse::set_account_flags(::google::protobuf::uint32 value) {
  set_has_account_flags();
  account_flags_ = value;
}

// optional uint32 cell_id = 7;
inline bool CMsgClientLogonResponse::has_cell_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientLogonResponse::set_has_cell_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientLogonResponse::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientLogonResponse::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::cell_id() const {
  return cell_id_;
}
inline void CMsgClientLogonResponse::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional string email_domain = 8;
inline bool CMsgClientLogonResponse::has_email_domain() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientLogonResponse::set_has_email_domain() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientLogonResponse::clear_has_email_domain() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientLogonResponse::clear_email_domain() {
  if (email_domain_ != &::google::protobuf::internal::kEmptyString) {
    email_domain_->clear();
  }
  clear_has_email_domain();
}
inline const ::std::string& CMsgClientLogonResponse::email_domain() const {
  return *email_domain_;
}
inline void CMsgClientLogonResponse::set_email_domain(const ::std::string& value) {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  email_domain_->assign(value);
}
inline void CMsgClientLogonResponse::set_email_domain(const char* value) {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  email_domain_->assign(value);
}
inline void CMsgClientLogonResponse::set_email_domain(const char* value, size_t size) {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  email_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_email_domain() {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  return email_domain_;
}
inline ::std::string* CMsgClientLogonResponse::release_email_domain() {
  clear_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_domain_;
    email_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_email_domain(::std::string* email_domain) {
  if (email_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete email_domain_;
  }
  if (email_domain) {
    set_has_email_domain();
    email_domain_ = email_domain;
  } else {
    clear_has_email_domain();
    email_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes steam2_ticket = 9;
inline bool CMsgClientLogonResponse::has_steam2_ticket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientLogonResponse::set_has_steam2_ticket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientLogonResponse::clear_has_steam2_ticket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientLogonResponse::clear_steam2_ticket() {
  if (steam2_ticket_ != &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_->clear();
  }
  clear_has_steam2_ticket();
}
inline const ::std::string& CMsgClientLogonResponse::steam2_ticket() const {
  return *steam2_ticket_;
}
inline void CMsgClientLogonResponse::set_steam2_ticket(const ::std::string& value) {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  steam2_ticket_->assign(value);
}
inline void CMsgClientLogonResponse::set_steam2_ticket(const char* value) {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  steam2_ticket_->assign(value);
}
inline void CMsgClientLogonResponse::set_steam2_ticket(const void* value, size_t size) {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  steam2_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_steam2_ticket() {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  return steam2_ticket_;
}
inline ::std::string* CMsgClientLogonResponse::release_steam2_ticket() {
  clear_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = steam2_ticket_;
    steam2_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_steam2_ticket(::std::string* steam2_ticket) {
  if (steam2_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete steam2_ticket_;
  }
  if (steam2_ticket) {
    set_has_steam2_ticket();
    steam2_ticket_ = steam2_ticket;
  } else {
    clear_has_steam2_ticket();
    steam2_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 eresult_extended = 10;
inline bool CMsgClientLogonResponse::has_eresult_extended() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientLogonResponse::set_has_eresult_extended() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientLogonResponse::clear_has_eresult_extended() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientLogonResponse::clear_eresult_extended() {
  eresult_extended_ = 0;
  clear_has_eresult_extended();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::eresult_extended() const {
  return eresult_extended_;
}
inline void CMsgClientLogonResponse::set_eresult_extended(::google::protobuf::int32 value) {
  set_has_eresult_extended();
  eresult_extended_ = value;
}

// optional string webapi_authenticate_user_nonce = 11;
inline bool CMsgClientLogonResponse::has_webapi_authenticate_user_nonce() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientLogonResponse::set_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientLogonResponse::clear_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientLogonResponse::clear_webapi_authenticate_user_nonce() {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_->clear();
  }
  clear_has_webapi_authenticate_user_nonce();
}
inline const ::std::string& CMsgClientLogonResponse::webapi_authenticate_user_nonce() const {
  return *webapi_authenticate_user_nonce_;
}
inline void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(const ::std::string& value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(const char* value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(const char* value, size_t size) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_webapi_authenticate_user_nonce() {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  return webapi_authenticate_user_nonce_;
}
inline ::std::string* CMsgClientLogonResponse::release_webapi_authenticate_user_nonce() {
  clear_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webapi_authenticate_user_nonce_;
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce) {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete webapi_authenticate_user_nonce_;
  }
  if (webapi_authenticate_user_nonce) {
    set_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = webapi_authenticate_user_nonce;
  } else {
    clear_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cell_id_ping_threshold = 12;
inline bool CMsgClientLogonResponse::has_cell_id_ping_threshold() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientLogonResponse::set_has_cell_id_ping_threshold() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientLogonResponse::clear_has_cell_id_ping_threshold() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientLogonResponse::clear_cell_id_ping_threshold() {
  cell_id_ping_threshold_ = 0u;
  clear_has_cell_id_ping_threshold();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::cell_id_ping_threshold() const {
  return cell_id_ping_threshold_;
}
inline void CMsgClientLogonResponse::set_cell_id_ping_threshold(::google::protobuf::uint32 value) {
  set_has_cell_id_ping_threshold();
  cell_id_ping_threshold_ = value;
}

// optional bool use_pics = 13;
inline bool CMsgClientLogonResponse::has_use_pics() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_use_pics() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientLogonResponse::clear_has_use_pics() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientLogonResponse::clear_use_pics() {
  use_pics_ = false;
  clear_has_use_pics();
}
inline bool CMsgClientLogonResponse::use_pics() const {
  return use_pics_;
}
inline void CMsgClientLogonResponse::set_use_pics(bool value) {
  set_has_use_pics();
  use_pics_ = value;
}

// optional fixed64 client_supplied_steamid = 20;
inline bool CMsgClientLogonResponse::has_client_supplied_steamid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_client_supplied_steamid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientLogonResponse::clear_has_client_supplied_steamid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientLogonResponse::clear_client_supplied_steamid() {
  client_supplied_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_client_supplied_steamid();
}
inline ::google::protobuf::uint64 CMsgClientLogonResponse::client_supplied_steamid() const {
  return client_supplied_steamid_;
}
inline void CMsgClientLogonResponse::set_client_supplied_steamid(::google::protobuf::uint64 value) {
  set_has_client_supplied_steamid();
  client_supplied_steamid_ = value;
}

// optional string ip_country_code = 21;
inline bool CMsgClientLogonResponse::has_ip_country_code() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_ip_country_code() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientLogonResponse::clear_has_ip_country_code() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientLogonResponse::clear_ip_country_code() {
  if (ip_country_code_ != &::google::protobuf::internal::kEmptyString) {
    ip_country_code_->clear();
  }
  clear_has_ip_country_code();
}
inline const ::std::string& CMsgClientLogonResponse::ip_country_code() const {
  return *ip_country_code_;
}
inline void CMsgClientLogonResponse::set_ip_country_code(const ::std::string& value) {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  ip_country_code_->assign(value);
}
inline void CMsgClientLogonResponse::set_ip_country_code(const char* value) {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  ip_country_code_->assign(value);
}
inline void CMsgClientLogonResponse::set_ip_country_code(const char* value, size_t size) {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  ip_country_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_ip_country_code() {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  return ip_country_code_;
}
inline ::std::string* CMsgClientLogonResponse::release_ip_country_code() {
  clear_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_country_code_;
    ip_country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_ip_country_code(::std::string* ip_country_code) {
  if (ip_country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_country_code_;
  }
  if (ip_country_code) {
    set_has_ip_country_code();
    ip_country_code_ = ip_country_code;
  } else {
    clear_has_ip_country_code();
    ip_country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestWebAPIAuthenticateUserNonce

// -------------------------------------------------------------------

// CMsgClientRequestWebAPIAuthenticateUserNonceResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientRequestWebAPIAuthenticateUserNonceResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string webapi_authenticate_user_nonce = 11;
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_webapi_authenticate_user_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_webapi_authenticate_user_nonce() {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_->clear();
  }
  clear_has_webapi_authenticate_user_nonce();
}
inline const ::std::string& CMsgClientRequestWebAPIAuthenticateUserNonceResponse::webapi_authenticate_user_nonce() const {
  return *webapi_authenticate_user_nonce_;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(const ::std::string& value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(const char* value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(const char* value, size_t size) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::mutable_webapi_authenticate_user_nonce() {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  return webapi_authenticate_user_nonce_;
}
inline ::std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::release_webapi_authenticate_user_nonce() {
  clear_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webapi_authenticate_user_nonce_;
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce) {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete webapi_authenticate_user_nonce_;
  }
  if (webapi_authenticate_user_nonce) {
    set_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = webapi_authenticate_user_nonce;
  } else {
    clear_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientLogOff

// -------------------------------------------------------------------

// CMsgClientLoggedOff

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLoggedOff::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLoggedOff::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLoggedOff::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLoggedOff::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLoggedOff::eresult() const {
  return eresult_;
}
inline void CMsgClientLoggedOff::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientCMList

// repeated uint32 cm_addresses = 1;
inline int CMsgClientCMList::cm_addresses_size() const {
  return cm_addresses_.size();
}
inline void CMsgClientCMList::clear_cm_addresses() {
  cm_addresses_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientCMList::cm_addresses(int index) const {
  return cm_addresses_.Get(index);
}
inline void CMsgClientCMList::set_cm_addresses(int index, ::google::protobuf::uint32 value) {
  cm_addresses_.Set(index, value);
}
inline void CMsgClientCMList::add_cm_addresses(::google::protobuf::uint32 value) {
  cm_addresses_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientCMList::cm_addresses() const {
  return cm_addresses_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientCMList::mutable_cm_addresses() {
  return &cm_addresses_;
}

// repeated uint32 cm_ports = 2;
inline int CMsgClientCMList::cm_ports_size() const {
  return cm_ports_.size();
}
inline void CMsgClientCMList::clear_cm_ports() {
  cm_ports_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientCMList::cm_ports(int index) const {
  return cm_ports_.Get(index);
}
inline void CMsgClientCMList::set_cm_ports(int index, ::google::protobuf::uint32 value) {
  cm_ports_.Set(index, value);
}
inline void CMsgClientCMList::add_cm_ports(::google::protobuf::uint32 value) {
  cm_ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientCMList::cm_ports() const {
  return cm_ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientCMList::mutable_cm_ports() {
  return &cm_ports_;
}

// -------------------------------------------------------------------

// CMsgClientP2PConnectionInfo

// optional fixed64 steam_id_dest = 1;
inline bool CMsgClientP2PConnectionInfo::has_steam_id_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientP2PConnectionInfo::set_has_steam_id_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientP2PConnectionInfo::clear_has_steam_id_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientP2PConnectionInfo::clear_steam_id_dest() {
  steam_id_dest_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_dest();
}
inline ::google::protobuf::uint64 CMsgClientP2PConnectionInfo::steam_id_dest() const {
  return steam_id_dest_;
}
inline void CMsgClientP2PConnectionInfo::set_steam_id_dest(::google::protobuf::uint64 value) {
  set_has_steam_id_dest();
  steam_id_dest_ = value;
}

// optional fixed64 steam_id_src = 2;
inline bool CMsgClientP2PConnectionInfo::has_steam_id_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientP2PConnectionInfo::set_has_steam_id_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientP2PConnectionInfo::clear_has_steam_id_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientP2PConnectionInfo::clear_steam_id_src() {
  steam_id_src_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_src();
}
inline ::google::protobuf::uint64 CMsgClientP2PConnectionInfo::steam_id_src() const {
  return steam_id_src_;
}
inline void CMsgClientP2PConnectionInfo::set_steam_id_src(::google::protobuf::uint64 value) {
  set_has_steam_id_src();
  steam_id_src_ = value;
}

// optional uint32 app_id = 3;
inline bool CMsgClientP2PConnectionInfo::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientP2PConnectionInfo::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientP2PConnectionInfo::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientP2PConnectionInfo::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientP2PConnectionInfo::app_id() const {
  return app_id_;
}
inline void CMsgClientP2PConnectionInfo::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional bytes candidate = 4;
inline bool CMsgClientP2PConnectionInfo::has_candidate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientP2PConnectionInfo::set_has_candidate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientP2PConnectionInfo::clear_has_candidate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientP2PConnectionInfo::clear_candidate() {
  if (candidate_ != &::google::protobuf::internal::kEmptyString) {
    candidate_->clear();
  }
  clear_has_candidate();
}
inline const ::std::string& CMsgClientP2PConnectionInfo::candidate() const {
  return *candidate_;
}
inline void CMsgClientP2PConnectionInfo::set_candidate(const ::std::string& value) {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  candidate_->assign(value);
}
inline void CMsgClientP2PConnectionInfo::set_candidate(const char* value) {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  candidate_->assign(value);
}
inline void CMsgClientP2PConnectionInfo::set_candidate(const void* value, size_t size) {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  candidate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientP2PConnectionInfo::mutable_candidate() {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  return candidate_;
}
inline ::std::string* CMsgClientP2PConnectionInfo::release_candidate() {
  clear_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = candidate_;
    candidate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientP2PConnectionInfo::set_allocated_candidate(::std::string* candidate) {
  if (candidate_ != &::google::protobuf::internal::kEmptyString) {
    delete candidate_;
  }
  if (candidate) {
    set_has_candidate();
    candidate_ = candidate;
  } else {
    clear_has_candidate();
    candidate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientP2PConnectionFailInfo

// optional fixed64 steam_id_dest = 1;
inline bool CMsgClientP2PConnectionFailInfo::has_steam_id_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientP2PConnectionFailInfo::set_has_steam_id_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_has_steam_id_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_steam_id_dest() {
  steam_id_dest_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_dest();
}
inline ::google::protobuf::uint64 CMsgClientP2PConnectionFailInfo::steam_id_dest() const {
  return steam_id_dest_;
}
inline void CMsgClientP2PConnectionFailInfo::set_steam_id_dest(::google::protobuf::uint64 value) {
  set_has_steam_id_dest();
  steam_id_dest_ = value;
}

// optional fixed64 steam_id_src = 2;
inline bool CMsgClientP2PConnectionFailInfo::has_steam_id_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientP2PConnectionFailInfo::set_has_steam_id_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_has_steam_id_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_steam_id_src() {
  steam_id_src_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_src();
}
inline ::google::protobuf::uint64 CMsgClientP2PConnectionFailInfo::steam_id_src() const {
  return steam_id_src_;
}
inline void CMsgClientP2PConnectionFailInfo::set_steam_id_src(::google::protobuf::uint64 value) {
  set_has_steam_id_src();
  steam_id_src_ = value;
}

// optional uint32 app_id = 3;
inline bool CMsgClientP2PConnectionFailInfo::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientP2PConnectionFailInfo::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientP2PConnectionFailInfo::app_id() const {
  return app_id_;
}
inline void CMsgClientP2PConnectionFailInfo::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 ep2p_session_error = 4;
inline bool CMsgClientP2PConnectionFailInfo::has_ep2p_session_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientP2PConnectionFailInfo::set_has_ep2p_session_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_has_ep2p_session_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientP2PConnectionFailInfo::clear_ep2p_session_error() {
  ep2p_session_error_ = 0u;
  clear_has_ep2p_session_error();
}
inline ::google::protobuf::uint32 CMsgClientP2PConnectionFailInfo::ep2p_session_error() const {
  return ep2p_session_error_;
}
inline void CMsgClientP2PConnectionFailInfo::set_ep2p_session_error(::google::protobuf::uint32 value) {
  set_has_ep2p_session_error();
  ep2p_session_error_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetAppOwnershipTicket

// optional uint32 app_id = 1;
inline bool CMsgClientGetAppOwnershipTicket::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetAppOwnershipTicket::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetAppOwnershipTicket::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetAppOwnershipTicket::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGetAppOwnershipTicket::app_id() const {
  return app_id_;
}
inline void CMsgClientGetAppOwnershipTicket::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetAppOwnershipTicketResponse

// optional uint32 eresult = 1 [default = 2];
inline bool CMsgClientGetAppOwnershipTicketResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetAppOwnershipTicketResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetAppOwnershipTicketResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientGetAppOwnershipTicketResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientGetAppOwnershipTicketResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetAppOwnershipTicketResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetAppOwnershipTicketResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGetAppOwnershipTicketResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional bytes ticket = 3;
inline bool CMsgClientGetAppOwnershipTicketResponse::has_ticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_has_ticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetAppOwnershipTicketResponse::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetAppOwnershipTicketResponse::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& CMsgClientGetAppOwnershipTicketResponse::ticket() const {
  return *ticket_;
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_ticket(const void* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetAppOwnershipTicketResponse::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* CMsgClientGetAppOwnershipTicketResponse::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetAppOwnershipTicketResponse::set_allocated_ticket(::std::string* ticket) {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_;
  }
  if (ticket) {
    set_has_ticket();
    ticket_ = ticket;
  } else {
    clear_has_ticket();
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientSessionToken

// optional uint64 token = 1;
inline bool CMsgClientSessionToken::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSessionToken::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSessionToken::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSessionToken::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 CMsgClientSessionToken::token() const {
  return token_;
}
inline void CMsgClientSessionToken::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGameConnectTokens

// optional uint32 max_tokens_to_keep = 1 [default = 10];
inline bool CMsgClientGameConnectTokens::has_max_tokens_to_keep() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGameConnectTokens::set_has_max_tokens_to_keep() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGameConnectTokens::clear_has_max_tokens_to_keep() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGameConnectTokens::clear_max_tokens_to_keep() {
  max_tokens_to_keep_ = 10u;
  clear_has_max_tokens_to_keep();
}
inline ::google::protobuf::uint32 CMsgClientGameConnectTokens::max_tokens_to_keep() const {
  return max_tokens_to_keep_;
}
inline void CMsgClientGameConnectTokens::set_max_tokens_to_keep(::google::protobuf::uint32 value) {
  set_has_max_tokens_to_keep();
  max_tokens_to_keep_ = value;
}

// repeated bytes tokens = 2;
inline int CMsgClientGameConnectTokens::tokens_size() const {
  return tokens_.size();
}
inline void CMsgClientGameConnectTokens::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& CMsgClientGameConnectTokens::tokens(int index) const {
  return tokens_.Get(index);
}
inline ::std::string* CMsgClientGameConnectTokens::mutable_tokens(int index) {
  return tokens_.Mutable(index);
}
inline void CMsgClientGameConnectTokens::set_tokens(int index, const ::std::string& value) {
  tokens_.Mutable(index)->assign(value);
}
inline void CMsgClientGameConnectTokens::set_tokens(int index, const char* value) {
  tokens_.Mutable(index)->assign(value);
}
inline void CMsgClientGameConnectTokens::set_tokens(int index, const void* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGameConnectTokens::add_tokens() {
  return tokens_.Add();
}
inline void CMsgClientGameConnectTokens::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
}
inline void CMsgClientGameConnectTokens::add_tokens(const char* value) {
  tokens_.Add()->assign(value);
}
inline void CMsgClientGameConnectTokens::add_tokens(const void* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientGameConnectTokens::tokens() const {
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientGameConnectTokens::mutable_tokens() {
  return &tokens_;
}

// -------------------------------------------------------------------

// CMsgGSServerType

// optional uint32 app_id_served = 1;
inline bool CMsgGSServerType::has_app_id_served() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSServerType::set_has_app_id_served() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSServerType::clear_has_app_id_served() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSServerType::clear_app_id_served() {
  app_id_served_ = 0u;
  clear_has_app_id_served();
}
inline ::google::protobuf::uint32 CMsgGSServerType::app_id_served() const {
  return app_id_served_;
}
inline void CMsgGSServerType::set_app_id_served(::google::protobuf::uint32 value) {
  set_has_app_id_served();
  app_id_served_ = value;
}

// optional uint32 flags = 2;
inline bool CMsgGSServerType::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSServerType::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSServerType::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSServerType::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgGSServerType::flags() const {
  return flags_;
}
inline void CMsgGSServerType::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional uint32 game_ip_address = 3;
inline bool CMsgGSServerType::has_game_ip_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGSServerType::set_has_game_ip_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGSServerType::clear_has_game_ip_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGSServerType::clear_game_ip_address() {
  game_ip_address_ = 0u;
  clear_has_game_ip_address();
}
inline ::google::protobuf::uint32 CMsgGSServerType::game_ip_address() const {
  return game_ip_address_;
}
inline void CMsgGSServerType::set_game_ip_address(::google::protobuf::uint32 value) {
  set_has_game_ip_address();
  game_ip_address_ = value;
}

// optional uint32 game_port = 4;
inline bool CMsgGSServerType::has_game_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgGSServerType::set_has_game_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgGSServerType::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgGSServerType::clear_game_port() {
  game_port_ = 0u;
  clear_has_game_port();
}
inline ::google::protobuf::uint32 CMsgGSServerType::game_port() const {
  return game_port_;
}
inline void CMsgGSServerType::set_game_port(::google::protobuf::uint32 value) {
  set_has_game_port();
  game_port_ = value;
}

// optional string game_dir = 5;
inline bool CMsgGSServerType::has_game_dir() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgGSServerType::set_has_game_dir() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgGSServerType::clear_has_game_dir() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgGSServerType::clear_game_dir() {
  if (game_dir_ != &::google::protobuf::internal::kEmptyString) {
    game_dir_->clear();
  }
  clear_has_game_dir();
}
inline const ::std::string& CMsgGSServerType::game_dir() const {
  return *game_dir_;
}
inline void CMsgGSServerType::set_game_dir(const ::std::string& value) {
  set_has_game_dir();
  if (game_dir_ == &::google::protobuf::internal::kEmptyString) {
    game_dir_ = new ::std::string;
  }
  game_dir_->assign(value);
}
inline void CMsgGSServerType::set_game_dir(const char* value) {
  set_has_game_dir();
  if (game_dir_ == &::google::protobuf::internal::kEmptyString) {
    game_dir_ = new ::std::string;
  }
  game_dir_->assign(value);
}
inline void CMsgGSServerType::set_game_dir(const char* value, size_t size) {
  set_has_game_dir();
  if (game_dir_ == &::google::protobuf::internal::kEmptyString) {
    game_dir_ = new ::std::string;
  }
  game_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGSServerType::mutable_game_dir() {
  set_has_game_dir();
  if (game_dir_ == &::google::protobuf::internal::kEmptyString) {
    game_dir_ = new ::std::string;
  }
  return game_dir_;
}
inline ::std::string* CMsgGSServerType::release_game_dir() {
  clear_has_game_dir();
  if (game_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_dir_;
    game_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGSServerType::set_allocated_game_dir(::std::string* game_dir) {
  if (game_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete game_dir_;
  }
  if (game_dir) {
    set_has_game_dir();
    game_dir_ = game_dir;
  } else {
    clear_has_game_dir();
    game_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string game_version = 6;
inline bool CMsgGSServerType::has_game_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgGSServerType::set_has_game_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgGSServerType::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgGSServerType::clear_game_version() {
  if (game_version_ != &::google::protobuf::internal::kEmptyString) {
    game_version_->clear();
  }
  clear_has_game_version();
}
inline const ::std::string& CMsgGSServerType::game_version() const {
  return *game_version_;
}
inline void CMsgGSServerType::set_game_version(const ::std::string& value) {
  set_has_game_version();
  if (game_version_ == &::google::protobuf::internal::kEmptyString) {
    game_version_ = new ::std::string;
  }
  game_version_->assign(value);
}
inline void CMsgGSServerType::set_game_version(const char* value) {
  set_has_game_version();
  if (game_version_ == &::google::protobuf::internal::kEmptyString) {
    game_version_ = new ::std::string;
  }
  game_version_->assign(value);
}
inline void CMsgGSServerType::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  if (game_version_ == &::google::protobuf::internal::kEmptyString) {
    game_version_ = new ::std::string;
  }
  game_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGSServerType::mutable_game_version() {
  set_has_game_version();
  if (game_version_ == &::google::protobuf::internal::kEmptyString) {
    game_version_ = new ::std::string;
  }
  return game_version_;
}
inline ::std::string* CMsgGSServerType::release_game_version() {
  clear_has_game_version();
  if (game_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_version_;
    game_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGSServerType::set_allocated_game_version(::std::string* game_version) {
  if (game_version_ != &::google::protobuf::internal::kEmptyString) {
    delete game_version_;
  }
  if (game_version) {
    set_has_game_version();
    game_version_ = game_version;
  } else {
    clear_has_game_version();
    game_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 game_query_port = 7;
inline bool CMsgGSServerType::has_game_query_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgGSServerType::set_has_game_query_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgGSServerType::clear_has_game_query_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgGSServerType::clear_game_query_port() {
  game_query_port_ = 0u;
  clear_has_game_query_port();
}
inline ::google::protobuf::uint32 CMsgGSServerType::game_query_port() const {
  return game_query_port_;
}
inline void CMsgGSServerType::set_game_query_port(::google::protobuf::uint32 value) {
  set_has_game_query_port();
  game_query_port_ = value;
}

// -------------------------------------------------------------------

// CMsgGSStatusReply

// optional bool is_secure = 1;
inline bool CMsgGSStatusReply::has_is_secure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSStatusReply::set_has_is_secure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSStatusReply::clear_has_is_secure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSStatusReply::clear_is_secure() {
  is_secure_ = false;
  clear_has_is_secure();
}
inline bool CMsgGSStatusReply::is_secure() const {
  return is_secure_;
}
inline void CMsgGSStatusReply::set_is_secure(bool value) {
  set_has_is_secure();
  is_secure_ = value;
}

// -------------------------------------------------------------------

// CMsgGSPlayerList_Player

// optional uint64 steam_id = 1;
inline bool CMsgGSPlayerList_Player::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSPlayerList_Player::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSPlayerList_Player::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSPlayerList_Player::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGSPlayerList_Player::steam_id() const {
  return steam_id_;
}
inline void CMsgGSPlayerList_Player::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional uint32 public_ip = 2;
inline bool CMsgGSPlayerList_Player::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSPlayerList_Player::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSPlayerList_Player::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSPlayerList_Player::clear_public_ip() {
  public_ip_ = 0u;
  clear_has_public_ip();
}
inline ::google::protobuf::uint32 CMsgGSPlayerList_Player::public_ip() const {
  return public_ip_;
}
inline void CMsgGSPlayerList_Player::set_public_ip(::google::protobuf::uint32 value) {
  set_has_public_ip();
  public_ip_ = value;
}

// optional bytes token = 3;
inline bool CMsgGSPlayerList_Player::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGSPlayerList_Player::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGSPlayerList_Player::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGSPlayerList_Player::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgGSPlayerList_Player::token() const {
  return *token_;
}
inline void CMsgGSPlayerList_Player::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgGSPlayerList_Player::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgGSPlayerList_Player::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGSPlayerList_Player::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgGSPlayerList_Player::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGSPlayerList_Player::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgGSPlayerList

// repeated .Sc.CMsgGSPlayerList.Player players = 1;
inline int CMsgGSPlayerList::players_size() const {
  return players_.size();
}
inline void CMsgGSPlayerList::clear_players() {
  players_.Clear();
}
inline const ::Sc::CMsgGSPlayerList_Player& CMsgGSPlayerList::players(int index) const {
  return players_.Get(index);
}
inline ::Sc::CMsgGSPlayerList_Player* CMsgGSPlayerList::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::Sc::CMsgGSPlayerList_Player* CMsgGSPlayerList::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGSPlayerList_Player >&
CMsgGSPlayerList::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGSPlayerList_Player >*
CMsgGSPlayerList::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// CMsgGSUserPlaying

// optional fixed64 steam_id = 1;
inline bool CMsgGSUserPlaying::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSUserPlaying::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSUserPlaying::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSUserPlaying::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGSUserPlaying::steam_id() const {
  return steam_id_;
}
inline void CMsgGSUserPlaying::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional uint32 public_ip = 2;
inline bool CMsgGSUserPlaying::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSUserPlaying::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSUserPlaying::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSUserPlaying::clear_public_ip() {
  public_ip_ = 0u;
  clear_has_public_ip();
}
inline ::google::protobuf::uint32 CMsgGSUserPlaying::public_ip() const {
  return public_ip_;
}
inline void CMsgGSUserPlaying::set_public_ip(::google::protobuf::uint32 value) {
  set_has_public_ip();
  public_ip_ = value;
}

// optional bytes token = 3;
inline bool CMsgGSUserPlaying::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGSUserPlaying::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGSUserPlaying::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGSUserPlaying::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgGSUserPlaying::token() const {
  return *token_;
}
inline void CMsgGSUserPlaying::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgGSUserPlaying::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgGSUserPlaying::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGSUserPlaying::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgGSUserPlaying::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGSUserPlaying::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgGSDisconnectNotice

// optional fixed64 steam_id = 1;
inline bool CMsgGSDisconnectNotice::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSDisconnectNotice::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSDisconnectNotice::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSDisconnectNotice::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGSDisconnectNotice::steam_id() const {
  return steam_id_;
}
inline void CMsgGSDisconnectNotice::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGamesPlayed_GamePlayed

// optional uint64 steam_id_gs = 1;
inline bool CMsgClientGamesPlayed_GamePlayed::has_steam_id_gs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_steam_id_gs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_steam_id_gs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_steam_id_gs() {
  steam_id_gs_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_gs();
}
inline ::google::protobuf::uint64 CMsgClientGamesPlayed_GamePlayed::steam_id_gs() const {
  return steam_id_gs_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_steam_id_gs(::google::protobuf::uint64 value) {
  set_has_steam_id_gs();
  steam_id_gs_ = value;
}

// optional fixed64 game_id = 2;
inline bool CMsgClientGamesPlayed_GamePlayed::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientGamesPlayed_GamePlayed::game_id() const {
  return game_id_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional uint32 game_ip_address = 3;
inline bool CMsgClientGamesPlayed_GamePlayed::has_game_ip_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_game_ip_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_game_ip_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_game_ip_address() {
  game_ip_address_ = 0u;
  clear_has_game_ip_address();
}
inline ::google::protobuf::uint32 CMsgClientGamesPlayed_GamePlayed::game_ip_address() const {
  return game_ip_address_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_ip_address(::google::protobuf::uint32 value) {
  set_has_game_ip_address();
  game_ip_address_ = value;
}

// optional uint32 game_port = 4;
inline bool CMsgClientGamesPlayed_GamePlayed::has_game_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_game_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_game_port() {
  game_port_ = 0u;
  clear_has_game_port();
}
inline ::google::protobuf::uint32 CMsgClientGamesPlayed_GamePlayed::game_port() const {
  return game_port_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_port(::google::protobuf::uint32 value) {
  set_has_game_port();
  game_port_ = value;
}

// optional bool is_secure = 5;
inline bool CMsgClientGamesPlayed_GamePlayed::has_is_secure() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_is_secure() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_is_secure() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_is_secure() {
  is_secure_ = false;
  clear_has_is_secure();
}
inline bool CMsgClientGamesPlayed_GamePlayed::is_secure() const {
  return is_secure_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_is_secure(bool value) {
  set_has_is_secure();
  is_secure_ = value;
}

// optional bytes token = 6;
inline bool CMsgClientGamesPlayed_GamePlayed::has_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgClientGamesPlayed_GamePlayed::token() const {
  return *token_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientGamesPlayed_GamePlayed::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientGamesPlayed_GamePlayed::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGamesPlayed_GamePlayed::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgClientGamesPlayed_GamePlayed::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGamesPlayed_GamePlayed::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string game_extra_info = 7;
inline bool CMsgClientGamesPlayed_GamePlayed::has_game_extra_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_game_extra_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_game_extra_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_game_extra_info() {
  if (game_extra_info_ != &::google::protobuf::internal::kEmptyString) {
    game_extra_info_->clear();
  }
  clear_has_game_extra_info();
}
inline const ::std::string& CMsgClientGamesPlayed_GamePlayed::game_extra_info() const {
  return *game_extra_info_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_extra_info(const ::std::string& value) {
  set_has_game_extra_info();
  if (game_extra_info_ == &::google::protobuf::internal::kEmptyString) {
    game_extra_info_ = new ::std::string;
  }
  game_extra_info_->assign(value);
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_extra_info(const char* value) {
  set_has_game_extra_info();
  if (game_extra_info_ == &::google::protobuf::internal::kEmptyString) {
    game_extra_info_ = new ::std::string;
  }
  game_extra_info_->assign(value);
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_extra_info(const char* value, size_t size) {
  set_has_game_extra_info();
  if (game_extra_info_ == &::google::protobuf::internal::kEmptyString) {
    game_extra_info_ = new ::std::string;
  }
  game_extra_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGamesPlayed_GamePlayed::mutable_game_extra_info() {
  set_has_game_extra_info();
  if (game_extra_info_ == &::google::protobuf::internal::kEmptyString) {
    game_extra_info_ = new ::std::string;
  }
  return game_extra_info_;
}
inline ::std::string* CMsgClientGamesPlayed_GamePlayed::release_game_extra_info() {
  clear_has_game_extra_info();
  if (game_extra_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_extra_info_;
    game_extra_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGamesPlayed_GamePlayed::set_allocated_game_extra_info(::std::string* game_extra_info) {
  if (game_extra_info_ != &::google::protobuf::internal::kEmptyString) {
    delete game_extra_info_;
  }
  if (game_extra_info) {
    set_has_game_extra_info();
    game_extra_info_ = game_extra_info;
  } else {
    clear_has_game_extra_info();
    game_extra_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes game_data_blob = 8;
inline bool CMsgClientGamesPlayed_GamePlayed::has_game_data_blob() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_game_data_blob() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_game_data_blob() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_game_data_blob() {
  if (game_data_blob_ != &::google::protobuf::internal::kEmptyString) {
    game_data_blob_->clear();
  }
  clear_has_game_data_blob();
}
inline const ::std::string& CMsgClientGamesPlayed_GamePlayed::game_data_blob() const {
  return *game_data_blob_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_data_blob(const ::std::string& value) {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  game_data_blob_->assign(value);
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_data_blob(const char* value) {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  game_data_blob_->assign(value);
}
inline void CMsgClientGamesPlayed_GamePlayed::set_game_data_blob(const void* value, size_t size) {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  game_data_blob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGamesPlayed_GamePlayed::mutable_game_data_blob() {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  return game_data_blob_;
}
inline ::std::string* CMsgClientGamesPlayed_GamePlayed::release_game_data_blob() {
  clear_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_data_blob_;
    game_data_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGamesPlayed_GamePlayed::set_allocated_game_data_blob(::std::string* game_data_blob) {
  if (game_data_blob_ != &::google::protobuf::internal::kEmptyString) {
    delete game_data_blob_;
  }
  if (game_data_blob) {
    set_has_game_data_blob();
    game_data_blob_ = game_data_blob;
  } else {
    clear_has_game_data_blob();
    game_data_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 process_id = 9;
inline bool CMsgClientGamesPlayed_GamePlayed::has_process_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_has_process_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientGamesPlayed_GamePlayed::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 CMsgClientGamesPlayed_GamePlayed::process_id() const {
  return process_id_;
}
inline void CMsgClientGamesPlayed_GamePlayed::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGamesPlayed

// repeated .Sc.CMsgClientGamesPlayed.GamePlayed games_played = 1;
inline int CMsgClientGamesPlayed::games_played_size() const {
  return games_played_.size();
}
inline void CMsgClientGamesPlayed::clear_games_played() {
  games_played_.Clear();
}
inline const ::Sc::CMsgClientGamesPlayed_GamePlayed& CMsgClientGamesPlayed::games_played(int index) const {
  return games_played_.Get(index);
}
inline ::Sc::CMsgClientGamesPlayed_GamePlayed* CMsgClientGamesPlayed::mutable_games_played(int index) {
  return games_played_.Mutable(index);
}
inline ::Sc::CMsgClientGamesPlayed_GamePlayed* CMsgClientGamesPlayed::add_games_played() {
  return games_played_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGamesPlayed_GamePlayed >&
CMsgClientGamesPlayed::games_played() const {
  return games_played_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGamesPlayed_GamePlayed >*
CMsgClientGamesPlayed::mutable_games_played() {
  return &games_played_;
}

// -------------------------------------------------------------------

// CMsgGSApprove

// optional fixed64 steam_id = 1;
inline bool CMsgGSApprove::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSApprove::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSApprove::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSApprove::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGSApprove::steam_id() const {
  return steam_id_;
}
inline void CMsgGSApprove::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgGSDeny

// optional fixed64 steam_id = 1;
inline bool CMsgGSDeny::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSDeny::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSDeny::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSDeny::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGSDeny::steam_id() const {
  return steam_id_;
}
inline void CMsgGSDeny::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional int32 edeny_reason = 2;
inline bool CMsgGSDeny::has_edeny_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSDeny::set_has_edeny_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSDeny::clear_has_edeny_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSDeny::clear_edeny_reason() {
  edeny_reason_ = 0;
  clear_has_edeny_reason();
}
inline ::google::protobuf::int32 CMsgGSDeny::edeny_reason() const {
  return edeny_reason_;
}
inline void CMsgGSDeny::set_edeny_reason(::google::protobuf::int32 value) {
  set_has_edeny_reason();
  edeny_reason_ = value;
}

// optional string deny_string = 3;
inline bool CMsgGSDeny::has_deny_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGSDeny::set_has_deny_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGSDeny::clear_has_deny_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGSDeny::clear_deny_string() {
  if (deny_string_ != &::google::protobuf::internal::kEmptyString) {
    deny_string_->clear();
  }
  clear_has_deny_string();
}
inline const ::std::string& CMsgGSDeny::deny_string() const {
  return *deny_string_;
}
inline void CMsgGSDeny::set_deny_string(const ::std::string& value) {
  set_has_deny_string();
  if (deny_string_ == &::google::protobuf::internal::kEmptyString) {
    deny_string_ = new ::std::string;
  }
  deny_string_->assign(value);
}
inline void CMsgGSDeny::set_deny_string(const char* value) {
  set_has_deny_string();
  if (deny_string_ == &::google::protobuf::internal::kEmptyString) {
    deny_string_ = new ::std::string;
  }
  deny_string_->assign(value);
}
inline void CMsgGSDeny::set_deny_string(const char* value, size_t size) {
  set_has_deny_string();
  if (deny_string_ == &::google::protobuf::internal::kEmptyString) {
    deny_string_ = new ::std::string;
  }
  deny_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGSDeny::mutable_deny_string() {
  set_has_deny_string();
  if (deny_string_ == &::google::protobuf::internal::kEmptyString) {
    deny_string_ = new ::std::string;
  }
  return deny_string_;
}
inline ::std::string* CMsgGSDeny::release_deny_string() {
  clear_has_deny_string();
  if (deny_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deny_string_;
    deny_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGSDeny::set_allocated_deny_string(::std::string* deny_string) {
  if (deny_string_ != &::google::protobuf::internal::kEmptyString) {
    delete deny_string_;
  }
  if (deny_string) {
    set_has_deny_string();
    deny_string_ = deny_string;
  } else {
    clear_has_deny_string();
    deny_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgGSKick

// optional fixed64 steam_id = 1;
inline bool CMsgGSKick::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSKick::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSKick::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSKick::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGSKick::steam_id() const {
  return steam_id_;
}
inline void CMsgGSKick::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional int32 edeny_reason = 2;
inline bool CMsgGSKick::has_edeny_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSKick::set_has_edeny_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSKick::clear_has_edeny_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSKick::clear_edeny_reason() {
  edeny_reason_ = 0;
  clear_has_edeny_reason();
}
inline ::google::protobuf::int32 CMsgGSKick::edeny_reason() const {
  return edeny_reason_;
}
inline void CMsgGSKick::set_edeny_reason(::google::protobuf::int32 value) {
  set_has_edeny_reason();
  edeny_reason_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAuthList

// optional uint32 tokens_left = 1;
inline bool CMsgClientAuthList::has_tokens_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAuthList::set_has_tokens_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAuthList::clear_has_tokens_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAuthList::clear_tokens_left() {
  tokens_left_ = 0u;
  clear_has_tokens_left();
}
inline ::google::protobuf::uint32 CMsgClientAuthList::tokens_left() const {
  return tokens_left_;
}
inline void CMsgClientAuthList::set_tokens_left(::google::protobuf::uint32 value) {
  set_has_tokens_left();
  tokens_left_ = value;
}

// optional uint32 last_request_seq = 2;
inline bool CMsgClientAuthList::has_last_request_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAuthList::set_has_last_request_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAuthList::clear_has_last_request_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAuthList::clear_last_request_seq() {
  last_request_seq_ = 0u;
  clear_has_last_request_seq();
}
inline ::google::protobuf::uint32 CMsgClientAuthList::last_request_seq() const {
  return last_request_seq_;
}
inline void CMsgClientAuthList::set_last_request_seq(::google::protobuf::uint32 value) {
  set_has_last_request_seq();
  last_request_seq_ = value;
}

// optional uint32 last_request_seq_from_server = 3;
inline bool CMsgClientAuthList::has_last_request_seq_from_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAuthList::set_has_last_request_seq_from_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAuthList::clear_has_last_request_seq_from_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAuthList::clear_last_request_seq_from_server() {
  last_request_seq_from_server_ = 0u;
  clear_has_last_request_seq_from_server();
}
inline ::google::protobuf::uint32 CMsgClientAuthList::last_request_seq_from_server() const {
  return last_request_seq_from_server_;
}
inline void CMsgClientAuthList::set_last_request_seq_from_server(::google::protobuf::uint32 value) {
  set_has_last_request_seq_from_server();
  last_request_seq_from_server_ = value;
}

// repeated .Sc.CMsgAuthTicket tickets = 4;
inline int CMsgClientAuthList::tickets_size() const {
  return tickets_.size();
}
inline void CMsgClientAuthList::clear_tickets() {
  tickets_.Clear();
}
inline const ::Sc::CMsgAuthTicket& CMsgClientAuthList::tickets(int index) const {
  return tickets_.Get(index);
}
inline ::Sc::CMsgAuthTicket* CMsgClientAuthList::mutable_tickets(int index) {
  return tickets_.Mutable(index);
}
inline ::Sc::CMsgAuthTicket* CMsgClientAuthList::add_tickets() {
  return tickets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgAuthTicket >&
CMsgClientAuthList::tickets() const {
  return tickets_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgAuthTicket >*
CMsgClientAuthList::mutable_tickets() {
  return &tickets_;
}

// repeated uint32 app_ids = 5;
inline int CMsgClientAuthList::app_ids_size() const {
  return app_ids_.size();
}
inline void CMsgClientAuthList::clear_app_ids() {
  app_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientAuthList::app_ids(int index) const {
  return app_ids_.Get(index);
}
inline void CMsgClientAuthList::set_app_ids(int index, ::google::protobuf::uint32 value) {
  app_ids_.Set(index, value);
}
inline void CMsgClientAuthList::add_app_ids(::google::protobuf::uint32 value) {
  app_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientAuthList::app_ids() const {
  return app_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientAuthList::mutable_app_ids() {
  return &app_ids_;
}

// optional uint32 message_sequence = 6;
inline bool CMsgClientAuthList::has_message_sequence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientAuthList::set_has_message_sequence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientAuthList::clear_has_message_sequence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientAuthList::clear_message_sequence() {
  message_sequence_ = 0u;
  clear_has_message_sequence();
}
inline ::google::protobuf::uint32 CMsgClientAuthList::message_sequence() const {
  return message_sequence_;
}
inline void CMsgClientAuthList::set_message_sequence(::google::protobuf::uint32 value) {
  set_has_message_sequence();
  message_sequence_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAuthListAck

// repeated uint32 ticket_crc = 1;
inline int CMsgClientAuthListAck::ticket_crc_size() const {
  return ticket_crc_.size();
}
inline void CMsgClientAuthListAck::clear_ticket_crc() {
  ticket_crc_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientAuthListAck::ticket_crc(int index) const {
  return ticket_crc_.Get(index);
}
inline void CMsgClientAuthListAck::set_ticket_crc(int index, ::google::protobuf::uint32 value) {
  ticket_crc_.Set(index, value);
}
inline void CMsgClientAuthListAck::add_ticket_crc(::google::protobuf::uint32 value) {
  ticket_crc_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientAuthListAck::ticket_crc() const {
  return ticket_crc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientAuthListAck::mutable_ticket_crc() {
  return &ticket_crc_;
}

// repeated uint32 app_ids = 2;
inline int CMsgClientAuthListAck::app_ids_size() const {
  return app_ids_.size();
}
inline void CMsgClientAuthListAck::clear_app_ids() {
  app_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientAuthListAck::app_ids(int index) const {
  return app_ids_.Get(index);
}
inline void CMsgClientAuthListAck::set_app_ids(int index, ::google::protobuf::uint32 value) {
  app_ids_.Set(index, value);
}
inline void CMsgClientAuthListAck::add_app_ids(::google::protobuf::uint32 value) {
  app_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientAuthListAck::app_ids() const {
  return app_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientAuthListAck::mutable_app_ids() {
  return &app_ids_;
}

// optional uint32 message_sequence = 3;
inline bool CMsgClientAuthListAck::has_message_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAuthListAck::set_has_message_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAuthListAck::clear_has_message_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAuthListAck::clear_message_sequence() {
  message_sequence_ = 0u;
  clear_has_message_sequence();
}
inline ::google::protobuf::uint32 CMsgClientAuthListAck::message_sequence() const {
  return message_sequence_;
}
inline void CMsgClientAuthListAck::set_message_sequence(::google::protobuf::uint32 value) {
  set_has_message_sequence();
  message_sequence_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFriendsList_Friend

// optional fixed64 ulfriendid = 1;
inline bool CMsgClientFriendsList_Friend::has_ulfriendid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendsList_Friend::set_has_ulfriendid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendsList_Friend::clear_has_ulfriendid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendsList_Friend::clear_ulfriendid() {
  ulfriendid_ = GOOGLE_ULONGLONG(0);
  clear_has_ulfriendid();
}
inline ::google::protobuf::uint64 CMsgClientFriendsList_Friend::ulfriendid() const {
  return ulfriendid_;
}
inline void CMsgClientFriendsList_Friend::set_ulfriendid(::google::protobuf::uint64 value) {
  set_has_ulfriendid();
  ulfriendid_ = value;
}

// optional uint32 efriendrelationship = 2;
inline bool CMsgClientFriendsList_Friend::has_efriendrelationship() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendsList_Friend::set_has_efriendrelationship() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendsList_Friend::clear_has_efriendrelationship() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendsList_Friend::clear_efriendrelationship() {
  efriendrelationship_ = 0u;
  clear_has_efriendrelationship();
}
inline ::google::protobuf::uint32 CMsgClientFriendsList_Friend::efriendrelationship() const {
  return efriendrelationship_;
}
inline void CMsgClientFriendsList_Friend::set_efriendrelationship(::google::protobuf::uint32 value) {
  set_has_efriendrelationship();
  efriendrelationship_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFriendsList

// optional bool bincremental = 1;
inline bool CMsgClientFriendsList::has_bincremental() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendsList::set_has_bincremental() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendsList::clear_has_bincremental() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendsList::clear_bincremental() {
  bincremental_ = false;
  clear_has_bincremental();
}
inline bool CMsgClientFriendsList::bincremental() const {
  return bincremental_;
}
inline void CMsgClientFriendsList::set_bincremental(bool value) {
  set_has_bincremental();
  bincremental_ = value;
}

// repeated .Sc.CMsgClientFriendsList.Friend friends = 2;
inline int CMsgClientFriendsList::friends_size() const {
  return friends_.size();
}
inline void CMsgClientFriendsList::clear_friends() {
  friends_.Clear();
}
inline const ::Sc::CMsgClientFriendsList_Friend& CMsgClientFriendsList::friends(int index) const {
  return friends_.Get(index);
}
inline ::Sc::CMsgClientFriendsList_Friend* CMsgClientFriendsList::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::Sc::CMsgClientFriendsList_Friend* CMsgClientFriendsList::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsList_Friend >&
CMsgClientFriendsList::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsList_Friend >*
CMsgClientFriendsList::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// CMsgClientFriendsGroupsList_FriendGroup

// optional int32 nGroupID = 1;
inline bool CMsgClientFriendsGroupsList_FriendGroup::has_ngroupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_has_ngroupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::clear_has_ngroupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::clear_ngroupid() {
  ngroupid_ = 0;
  clear_has_ngroupid();
}
inline ::google::protobuf::int32 CMsgClientFriendsGroupsList_FriendGroup::ngroupid() const {
  return ngroupid_;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_ngroupid(::google::protobuf::int32 value) {
  set_has_ngroupid();
  ngroupid_ = value;
}

// optional string strGroupName = 2;
inline bool CMsgClientFriendsGroupsList_FriendGroup::has_strgroupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_has_strgroupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::clear_has_strgroupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::clear_strgroupname() {
  if (strgroupname_ != &::google::protobuf::internal::kEmptyString) {
    strgroupname_->clear();
  }
  clear_has_strgroupname();
}
inline const ::std::string& CMsgClientFriendsGroupsList_FriendGroup::strgroupname() const {
  return *strgroupname_;
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_strgroupname(const ::std::string& value) {
  set_has_strgroupname();
  if (strgroupname_ == &::google::protobuf::internal::kEmptyString) {
    strgroupname_ = new ::std::string;
  }
  strgroupname_->assign(value);
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_strgroupname(const char* value) {
  set_has_strgroupname();
  if (strgroupname_ == &::google::protobuf::internal::kEmptyString) {
    strgroupname_ = new ::std::string;
  }
  strgroupname_->assign(value);
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_strgroupname(const char* value, size_t size) {
  set_has_strgroupname();
  if (strgroupname_ == &::google::protobuf::internal::kEmptyString) {
    strgroupname_ = new ::std::string;
  }
  strgroupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendsGroupsList_FriendGroup::mutable_strgroupname() {
  set_has_strgroupname();
  if (strgroupname_ == &::google::protobuf::internal::kEmptyString) {
    strgroupname_ = new ::std::string;
  }
  return strgroupname_;
}
inline ::std::string* CMsgClientFriendsGroupsList_FriendGroup::release_strgroupname() {
  clear_has_strgroupname();
  if (strgroupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgroupname_;
    strgroupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendsGroupsList_FriendGroup::set_allocated_strgroupname(::std::string* strgroupname) {
  if (strgroupname_ != &::google::protobuf::internal::kEmptyString) {
    delete strgroupname_;
  }
  if (strgroupname) {
    set_has_strgroupname();
    strgroupname_ = strgroupname;
  } else {
    clear_has_strgroupname();
    strgroupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientFriendsGroupsList_FriendGroupsMembership

// optional fixed64 ulSteamID = 1;
inline bool CMsgClientFriendsGroupsList_FriendGroupsMembership::has_ulsteamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::set_has_ulsteamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::clear_has_ulsteamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::clear_ulsteamid() {
  ulsteamid_ = GOOGLE_ULONGLONG(0);
  clear_has_ulsteamid();
}
inline ::google::protobuf::uint64 CMsgClientFriendsGroupsList_FriendGroupsMembership::ulsteamid() const {
  return ulsteamid_;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::set_ulsteamid(::google::protobuf::uint64 value) {
  set_has_ulsteamid();
  ulsteamid_ = value;
}

// optional int32 nGroupID = 2;
inline bool CMsgClientFriendsGroupsList_FriendGroupsMembership::has_ngroupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::set_has_ngroupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::clear_has_ngroupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::clear_ngroupid() {
  ngroupid_ = 0;
  clear_has_ngroupid();
}
inline ::google::protobuf::int32 CMsgClientFriendsGroupsList_FriendGroupsMembership::ngroupid() const {
  return ngroupid_;
}
inline void CMsgClientFriendsGroupsList_FriendGroupsMembership::set_ngroupid(::google::protobuf::int32 value) {
  set_has_ngroupid();
  ngroupid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFriendsGroupsList

// optional bool bremoval = 1;
inline bool CMsgClientFriendsGroupsList::has_bremoval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendsGroupsList::set_has_bremoval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendsGroupsList::clear_has_bremoval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendsGroupsList::clear_bremoval() {
  bremoval_ = false;
  clear_has_bremoval();
}
inline bool CMsgClientFriendsGroupsList::bremoval() const {
  return bremoval_;
}
inline void CMsgClientFriendsGroupsList::set_bremoval(bool value) {
  set_has_bremoval();
  bremoval_ = value;
}

// optional bool bincremental = 2;
inline bool CMsgClientFriendsGroupsList::has_bincremental() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendsGroupsList::set_has_bincremental() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendsGroupsList::clear_has_bincremental() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendsGroupsList::clear_bincremental() {
  bincremental_ = false;
  clear_has_bincremental();
}
inline bool CMsgClientFriendsGroupsList::bincremental() const {
  return bincremental_;
}
inline void CMsgClientFriendsGroupsList::set_bincremental(bool value) {
  set_has_bincremental();
  bincremental_ = value;
}

// repeated .Sc.CMsgClientFriendsGroupsList.FriendGroup friendGroups = 3;
inline int CMsgClientFriendsGroupsList::friendgroups_size() const {
  return friendgroups_.size();
}
inline void CMsgClientFriendsGroupsList::clear_friendgroups() {
  friendgroups_.Clear();
}
inline const ::Sc::CMsgClientFriendsGroupsList_FriendGroup& CMsgClientFriendsGroupsList::friendgroups(int index) const {
  return friendgroups_.Get(index);
}
inline ::Sc::CMsgClientFriendsGroupsList_FriendGroup* CMsgClientFriendsGroupsList::mutable_friendgroups(int index) {
  return friendgroups_.Mutable(index);
}
inline ::Sc::CMsgClientFriendsGroupsList_FriendGroup* CMsgClientFriendsGroupsList::add_friendgroups() {
  return friendgroups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroup >&
CMsgClientFriendsGroupsList::friendgroups() const {
  return friendgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroup >*
CMsgClientFriendsGroupsList::mutable_friendgroups() {
  return &friendgroups_;
}

// repeated .Sc.CMsgClientFriendsGroupsList.FriendGroupsMembership memberships = 4;
inline int CMsgClientFriendsGroupsList::memberships_size() const {
  return memberships_.size();
}
inline void CMsgClientFriendsGroupsList::clear_memberships() {
  memberships_.Clear();
}
inline const ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership& CMsgClientFriendsGroupsList::memberships(int index) const {
  return memberships_.Get(index);
}
inline ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership* CMsgClientFriendsGroupsList::mutable_memberships(int index) {
  return memberships_.Mutable(index);
}
inline ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership* CMsgClientFriendsGroupsList::add_memberships() {
  return memberships_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership >&
CMsgClientFriendsGroupsList::memberships() const {
  return memberships_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFriendsGroupsList_FriendGroupsMembership >*
CMsgClientFriendsGroupsList::mutable_memberships() {
  return &memberships_;
}

// -------------------------------------------------------------------

// CMsgClientPlayerNicknameList_PlayerNickname

// optional fixed64 steamid = 1;
inline bool CMsgClientPlayerNicknameList_PlayerNickname::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientPlayerNicknameList_PlayerNickname::steamid() const {
  return steamid_;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional string nickname = 3;
inline bool CMsgClientPlayerNicknameList_PlayerNickname::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& CMsgClientPlayerNicknameList_PlayerNickname::nickname() const {
  return *nickname_;
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPlayerNicknameList_PlayerNickname::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* CMsgClientPlayerNicknameList_PlayerNickname::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPlayerNicknameList_PlayerNickname::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientPlayerNicknameList

// optional bool removal = 1;
inline bool CMsgClientPlayerNicknameList::has_removal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPlayerNicknameList::set_has_removal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPlayerNicknameList::clear_has_removal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPlayerNicknameList::clear_removal() {
  removal_ = false;
  clear_has_removal();
}
inline bool CMsgClientPlayerNicknameList::removal() const {
  return removal_;
}
inline void CMsgClientPlayerNicknameList::set_removal(bool value) {
  set_has_removal();
  removal_ = value;
}

// optional bool incremental = 2;
inline bool CMsgClientPlayerNicknameList::has_incremental() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPlayerNicknameList::set_has_incremental() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPlayerNicknameList::clear_has_incremental() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPlayerNicknameList::clear_incremental() {
  incremental_ = false;
  clear_has_incremental();
}
inline bool CMsgClientPlayerNicknameList::incremental() const {
  return incremental_;
}
inline void CMsgClientPlayerNicknameList::set_incremental(bool value) {
  set_has_incremental();
  incremental_ = value;
}

// repeated .Sc.CMsgClientPlayerNicknameList.PlayerNickname nicknames = 3;
inline int CMsgClientPlayerNicknameList::nicknames_size() const {
  return nicknames_.size();
}
inline void CMsgClientPlayerNicknameList::clear_nicknames() {
  nicknames_.Clear();
}
inline const ::Sc::CMsgClientPlayerNicknameList_PlayerNickname& CMsgClientPlayerNicknameList::nicknames(int index) const {
  return nicknames_.Get(index);
}
inline ::Sc::CMsgClientPlayerNicknameList_PlayerNickname* CMsgClientPlayerNicknameList::mutable_nicknames(int index) {
  return nicknames_.Mutable(index);
}
inline ::Sc::CMsgClientPlayerNicknameList_PlayerNickname* CMsgClientPlayerNicknameList::add_nicknames() {
  return nicknames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPlayerNicknameList_PlayerNickname >&
CMsgClientPlayerNicknameList::nicknames() const {
  return nicknames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPlayerNicknameList_PlayerNickname >*
CMsgClientPlayerNicknameList::mutable_nicknames() {
  return &nicknames_;
}

// -------------------------------------------------------------------

// CMsgClientSetPlayerNickname

// optional fixed64 steamid = 1;
inline bool CMsgClientSetPlayerNickname::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSetPlayerNickname::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSetPlayerNickname::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSetPlayerNickname::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientSetPlayerNickname::steamid() const {
  return steamid_;
}
inline void CMsgClientSetPlayerNickname::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional string nickname = 2;
inline bool CMsgClientSetPlayerNickname::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientSetPlayerNickname::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientSetPlayerNickname::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientSetPlayerNickname::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& CMsgClientSetPlayerNickname::nickname() const {
  return *nickname_;
}
inline void CMsgClientSetPlayerNickname::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CMsgClientSetPlayerNickname::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CMsgClientSetPlayerNickname::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientSetPlayerNickname::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* CMsgClientSetPlayerNickname::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientSetPlayerNickname::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientSetPlayerNicknameResponse

// optional uint32 eresult = 1;
inline bool CMsgClientSetPlayerNicknameResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSetPlayerNicknameResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSetPlayerNicknameResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSetPlayerNicknameResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientSetPlayerNicknameResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientSetPlayerNicknameResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLicenseList_License

// optional uint32 package_id = 1;
inline bool CMsgClientLicenseList_License::has_package_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_package_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLicenseList_License::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLicenseList_License::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 CMsgClientLicenseList_License::package_id() const {
  return package_id_;
}
inline void CMsgClientLicenseList_License::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
}

// optional fixed32 time_created = 2;
inline bool CMsgClientLicenseList_License::has_time_created() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_time_created() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLicenseList_License::clear_has_time_created() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLicenseList_License::clear_time_created() {
  time_created_ = 0u;
  clear_has_time_created();
}
inline ::google::protobuf::uint32 CMsgClientLicenseList_License::time_created() const {
  return time_created_;
}
inline void CMsgClientLicenseList_License::set_time_created(::google::protobuf::uint32 value) {
  set_has_time_created();
  time_created_ = value;
}

// optional fixed32 time_next_process = 3;
inline bool CMsgClientLicenseList_License::has_time_next_process() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_time_next_process() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLicenseList_License::clear_has_time_next_process() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLicenseList_License::clear_time_next_process() {
  time_next_process_ = 0u;
  clear_has_time_next_process();
}
inline ::google::protobuf::uint32 CMsgClientLicenseList_License::time_next_process() const {
  return time_next_process_;
}
inline void CMsgClientLicenseList_License::set_time_next_process(::google::protobuf::uint32 value) {
  set_has_time_next_process();
  time_next_process_ = value;
}

// optional int32 minute_limit = 4;
inline bool CMsgClientLicenseList_License::has_minute_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_minute_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLicenseList_License::clear_has_minute_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLicenseList_License::clear_minute_limit() {
  minute_limit_ = 0;
  clear_has_minute_limit();
}
inline ::google::protobuf::int32 CMsgClientLicenseList_License::minute_limit() const {
  return minute_limit_;
}
inline void CMsgClientLicenseList_License::set_minute_limit(::google::protobuf::int32 value) {
  set_has_minute_limit();
  minute_limit_ = value;
}

// optional int32 minutes_used = 5;
inline bool CMsgClientLicenseList_License::has_minutes_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_minutes_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLicenseList_License::clear_has_minutes_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLicenseList_License::clear_minutes_used() {
  minutes_used_ = 0;
  clear_has_minutes_used();
}
inline ::google::protobuf::int32 CMsgClientLicenseList_License::minutes_used() const {
  return minutes_used_;
}
inline void CMsgClientLicenseList_License::set_minutes_used(::google::protobuf::int32 value) {
  set_has_minutes_used();
  minutes_used_ = value;
}

// optional uint32 payment_method = 6;
inline bool CMsgClientLicenseList_License::has_payment_method() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_payment_method() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientLicenseList_License::clear_has_payment_method() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientLicenseList_License::clear_payment_method() {
  payment_method_ = 0u;
  clear_has_payment_method();
}
inline ::google::protobuf::uint32 CMsgClientLicenseList_License::payment_method() const {
  return payment_method_;
}
inline void CMsgClientLicenseList_License::set_payment_method(::google::protobuf::uint32 value) {
  set_has_payment_method();
  payment_method_ = value;
}

// optional uint32 flags = 7;
inline bool CMsgClientLicenseList_License::has_flags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_flags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientLicenseList_License::clear_has_flags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientLicenseList_License::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 CMsgClientLicenseList_License::flags() const {
  return flags_;
}
inline void CMsgClientLicenseList_License::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional string purchase_country_code = 8;
inline bool CMsgClientLicenseList_License::has_purchase_country_code() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_purchase_country_code() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientLicenseList_License::clear_has_purchase_country_code() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientLicenseList_License::clear_purchase_country_code() {
  if (purchase_country_code_ != &::google::protobuf::internal::kEmptyString) {
    purchase_country_code_->clear();
  }
  clear_has_purchase_country_code();
}
inline const ::std::string& CMsgClientLicenseList_License::purchase_country_code() const {
  return *purchase_country_code_;
}
inline void CMsgClientLicenseList_License::set_purchase_country_code(const ::std::string& value) {
  set_has_purchase_country_code();
  if (purchase_country_code_ == &::google::protobuf::internal::kEmptyString) {
    purchase_country_code_ = new ::std::string;
  }
  purchase_country_code_->assign(value);
}
inline void CMsgClientLicenseList_License::set_purchase_country_code(const char* value) {
  set_has_purchase_country_code();
  if (purchase_country_code_ == &::google::protobuf::internal::kEmptyString) {
    purchase_country_code_ = new ::std::string;
  }
  purchase_country_code_->assign(value);
}
inline void CMsgClientLicenseList_License::set_purchase_country_code(const char* value, size_t size) {
  set_has_purchase_country_code();
  if (purchase_country_code_ == &::google::protobuf::internal::kEmptyString) {
    purchase_country_code_ = new ::std::string;
  }
  purchase_country_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLicenseList_License::mutable_purchase_country_code() {
  set_has_purchase_country_code();
  if (purchase_country_code_ == &::google::protobuf::internal::kEmptyString) {
    purchase_country_code_ = new ::std::string;
  }
  return purchase_country_code_;
}
inline ::std::string* CMsgClientLicenseList_License::release_purchase_country_code() {
  clear_has_purchase_country_code();
  if (purchase_country_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = purchase_country_code_;
    purchase_country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLicenseList_License::set_allocated_purchase_country_code(::std::string* purchase_country_code) {
  if (purchase_country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete purchase_country_code_;
  }
  if (purchase_country_code) {
    set_has_purchase_country_code();
    purchase_country_code_ = purchase_country_code;
  } else {
    clear_has_purchase_country_code();
    purchase_country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 license_type = 9;
inline bool CMsgClientLicenseList_License::has_license_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_license_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientLicenseList_License::clear_has_license_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientLicenseList_License::clear_license_type() {
  license_type_ = 0u;
  clear_has_license_type();
}
inline ::google::protobuf::uint32 CMsgClientLicenseList_License::license_type() const {
  return license_type_;
}
inline void CMsgClientLicenseList_License::set_license_type(::google::protobuf::uint32 value) {
  set_has_license_type();
  license_type_ = value;
}

// optional int32 territory_code = 10;
inline bool CMsgClientLicenseList_License::has_territory_code() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_territory_code() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientLicenseList_License::clear_has_territory_code() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientLicenseList_License::clear_territory_code() {
  territory_code_ = 0;
  clear_has_territory_code();
}
inline ::google::protobuf::int32 CMsgClientLicenseList_License::territory_code() const {
  return territory_code_;
}
inline void CMsgClientLicenseList_License::set_territory_code(::google::protobuf::int32 value) {
  set_has_territory_code();
  territory_code_ = value;
}

// optional int32 change_number = 11;
inline bool CMsgClientLicenseList_License::has_change_number() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientLicenseList_License::set_has_change_number() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientLicenseList_License::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientLicenseList_License::clear_change_number() {
  change_number_ = 0;
  clear_has_change_number();
}
inline ::google::protobuf::int32 CMsgClientLicenseList_License::change_number() const {
  return change_number_;
}
inline void CMsgClientLicenseList_License::set_change_number(::google::protobuf::int32 value) {
  set_has_change_number();
  change_number_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLicenseList

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLicenseList::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLicenseList::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLicenseList::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLicenseList::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLicenseList::eresult() const {
  return eresult_;
}
inline void CMsgClientLicenseList::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientLicenseList.License licenses = 2;
inline int CMsgClientLicenseList::licenses_size() const {
  return licenses_.size();
}
inline void CMsgClientLicenseList::clear_licenses() {
  licenses_.Clear();
}
inline const ::Sc::CMsgClientLicenseList_License& CMsgClientLicenseList::licenses(int index) const {
  return licenses_.Get(index);
}
inline ::Sc::CMsgClientLicenseList_License* CMsgClientLicenseList::mutable_licenses(int index) {
  return licenses_.Mutable(index);
}
inline ::Sc::CMsgClientLicenseList_License* CMsgClientLicenseList::add_licenses() {
  return licenses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLicenseList_License >&
CMsgClientLicenseList::licenses() const {
  return licenses_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLicenseList_License >*
CMsgClientLicenseList::mutable_licenses() {
  return &licenses_;
}

// -------------------------------------------------------------------

// CMsgClientLBSSetScore

// optional uint32 app_id = 1;
inline bool CMsgClientLBSSetScore::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSSetScore::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSSetScore::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSSetScore::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientLBSSetScore::app_id() const {
  return app_id_;
}
inline void CMsgClientLBSSetScore::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 leaderboard_id = 2;
inline bool CMsgClientLBSSetScore::has_leaderboard_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSSetScore::set_has_leaderboard_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSSetScore::clear_has_leaderboard_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSSetScore::clear_leaderboard_id() {
  leaderboard_id_ = 0;
  clear_has_leaderboard_id();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScore::leaderboard_id() const {
  return leaderboard_id_;
}
inline void CMsgClientLBSSetScore::set_leaderboard_id(::google::protobuf::int32 value) {
  set_has_leaderboard_id();
  leaderboard_id_ = value;
}

// optional int32 score = 3;
inline bool CMsgClientLBSSetScore::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSSetScore::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSSetScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSSetScore::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScore::score() const {
  return score_;
}
inline void CMsgClientLBSSetScore::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional bytes details = 4;
inline bool CMsgClientLBSSetScore::has_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLBSSetScore::set_has_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLBSSetScore::clear_has_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLBSSetScore::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& CMsgClientLBSSetScore::details() const {
  return *details_;
}
inline void CMsgClientLBSSetScore::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CMsgClientLBSSetScore::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CMsgClientLBSSetScore::set_details(const void* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLBSSetScore::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* CMsgClientLBSSetScore::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLBSSetScore::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 upload_score_method = 5;
inline bool CMsgClientLBSSetScore::has_upload_score_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLBSSetScore::set_has_upload_score_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLBSSetScore::clear_has_upload_score_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLBSSetScore::clear_upload_score_method() {
  upload_score_method_ = 0;
  clear_has_upload_score_method();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScore::upload_score_method() const {
  return upload_score_method_;
}
inline void CMsgClientLBSSetScore::set_upload_score_method(::google::protobuf::int32 value) {
  set_has_upload_score_method();
  upload_score_method_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLBSSetScoreResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLBSSetScoreResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSSetScoreResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSSetScoreResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSSetScoreResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScoreResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientLBSSetScoreResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 leaderboard_entry_count = 2;
inline bool CMsgClientLBSSetScoreResponse::has_leaderboard_entry_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSSetScoreResponse::set_has_leaderboard_entry_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSSetScoreResponse::clear_has_leaderboard_entry_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSSetScoreResponse::clear_leaderboard_entry_count() {
  leaderboard_entry_count_ = 0;
  clear_has_leaderboard_entry_count();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScoreResponse::leaderboard_entry_count() const {
  return leaderboard_entry_count_;
}
inline void CMsgClientLBSSetScoreResponse::set_leaderboard_entry_count(::google::protobuf::int32 value) {
  set_has_leaderboard_entry_count();
  leaderboard_entry_count_ = value;
}

// optional bool score_changed = 3;
inline bool CMsgClientLBSSetScoreResponse::has_score_changed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSSetScoreResponse::set_has_score_changed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSSetScoreResponse::clear_has_score_changed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSSetScoreResponse::clear_score_changed() {
  score_changed_ = false;
  clear_has_score_changed();
}
inline bool CMsgClientLBSSetScoreResponse::score_changed() const {
  return score_changed_;
}
inline void CMsgClientLBSSetScoreResponse::set_score_changed(bool value) {
  set_has_score_changed();
  score_changed_ = value;
}

// optional int32 global_rank_previous = 4;
inline bool CMsgClientLBSSetScoreResponse::has_global_rank_previous() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLBSSetScoreResponse::set_has_global_rank_previous() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLBSSetScoreResponse::clear_has_global_rank_previous() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLBSSetScoreResponse::clear_global_rank_previous() {
  global_rank_previous_ = 0;
  clear_has_global_rank_previous();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScoreResponse::global_rank_previous() const {
  return global_rank_previous_;
}
inline void CMsgClientLBSSetScoreResponse::set_global_rank_previous(::google::protobuf::int32 value) {
  set_has_global_rank_previous();
  global_rank_previous_ = value;
}

// optional int32 global_rank_new = 5;
inline bool CMsgClientLBSSetScoreResponse::has_global_rank_new() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLBSSetScoreResponse::set_has_global_rank_new() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLBSSetScoreResponse::clear_has_global_rank_new() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLBSSetScoreResponse::clear_global_rank_new() {
  global_rank_new_ = 0;
  clear_has_global_rank_new();
}
inline ::google::protobuf::int32 CMsgClientLBSSetScoreResponse::global_rank_new() const {
  return global_rank_new_;
}
inline void CMsgClientLBSSetScoreResponse::set_global_rank_new(::google::protobuf::int32 value) {
  set_has_global_rank_new();
  global_rank_new_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLBSSetUGC

// optional uint32 app_id = 1;
inline bool CMsgClientLBSSetUGC::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSSetUGC::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSSetUGC::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSSetUGC::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientLBSSetUGC::app_id() const {
  return app_id_;
}
inline void CMsgClientLBSSetUGC::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 leaderboard_id = 2;
inline bool CMsgClientLBSSetUGC::has_leaderboard_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSSetUGC::set_has_leaderboard_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSSetUGC::clear_has_leaderboard_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSSetUGC::clear_leaderboard_id() {
  leaderboard_id_ = 0;
  clear_has_leaderboard_id();
}
inline ::google::protobuf::int32 CMsgClientLBSSetUGC::leaderboard_id() const {
  return leaderboard_id_;
}
inline void CMsgClientLBSSetUGC::set_leaderboard_id(::google::protobuf::int32 value) {
  set_has_leaderboard_id();
  leaderboard_id_ = value;
}

// optional fixed64 ugc_id = 3;
inline bool CMsgClientLBSSetUGC::has_ugc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSSetUGC::set_has_ugc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSSetUGC::clear_has_ugc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSSetUGC::clear_ugc_id() {
  ugc_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ugc_id();
}
inline ::google::protobuf::uint64 CMsgClientLBSSetUGC::ugc_id() const {
  return ugc_id_;
}
inline void CMsgClientLBSSetUGC::set_ugc_id(::google::protobuf::uint64 value) {
  set_has_ugc_id();
  ugc_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLBSSetUGCResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLBSSetUGCResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSSetUGCResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSSetUGCResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSSetUGCResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLBSSetUGCResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientLBSSetUGCResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLBSFindOrCreateLB

// optional uint32 app_id = 1;
inline bool CMsgClientLBSFindOrCreateLB::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSFindOrCreateLB::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientLBSFindOrCreateLB::app_id() const {
  return app_id_;
}
inline void CMsgClientLBSFindOrCreateLB::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 leaderboard_sort_method = 2;
inline bool CMsgClientLBSFindOrCreateLB::has_leaderboard_sort_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSFindOrCreateLB::set_has_leaderboard_sort_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_has_leaderboard_sort_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_leaderboard_sort_method() {
  leaderboard_sort_method_ = 0;
  clear_has_leaderboard_sort_method();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLB::leaderboard_sort_method() const {
  return leaderboard_sort_method_;
}
inline void CMsgClientLBSFindOrCreateLB::set_leaderboard_sort_method(::google::protobuf::int32 value) {
  set_has_leaderboard_sort_method();
  leaderboard_sort_method_ = value;
}

// optional int32 leaderboard_display_type = 3;
inline bool CMsgClientLBSFindOrCreateLB::has_leaderboard_display_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSFindOrCreateLB::set_has_leaderboard_display_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_has_leaderboard_display_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_leaderboard_display_type() {
  leaderboard_display_type_ = 0;
  clear_has_leaderboard_display_type();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLB::leaderboard_display_type() const {
  return leaderboard_display_type_;
}
inline void CMsgClientLBSFindOrCreateLB::set_leaderboard_display_type(::google::protobuf::int32 value) {
  set_has_leaderboard_display_type();
  leaderboard_display_type_ = value;
}

// optional bool create_if_not_found = 4;
inline bool CMsgClientLBSFindOrCreateLB::has_create_if_not_found() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLBSFindOrCreateLB::set_has_create_if_not_found() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_has_create_if_not_found() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_create_if_not_found() {
  create_if_not_found_ = false;
  clear_has_create_if_not_found();
}
inline bool CMsgClientLBSFindOrCreateLB::create_if_not_found() const {
  return create_if_not_found_;
}
inline void CMsgClientLBSFindOrCreateLB::set_create_if_not_found(bool value) {
  set_has_create_if_not_found();
  create_if_not_found_ = value;
}

// optional string leaderboard_name = 5;
inline bool CMsgClientLBSFindOrCreateLB::has_leaderboard_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLBSFindOrCreateLB::set_has_leaderboard_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_has_leaderboard_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLBSFindOrCreateLB::clear_leaderboard_name() {
  if (leaderboard_name_ != &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_->clear();
  }
  clear_has_leaderboard_name();
}
inline const ::std::string& CMsgClientLBSFindOrCreateLB::leaderboard_name() const {
  return *leaderboard_name_;
}
inline void CMsgClientLBSFindOrCreateLB::set_leaderboard_name(const ::std::string& value) {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  leaderboard_name_->assign(value);
}
inline void CMsgClientLBSFindOrCreateLB::set_leaderboard_name(const char* value) {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  leaderboard_name_->assign(value);
}
inline void CMsgClientLBSFindOrCreateLB::set_leaderboard_name(const char* value, size_t size) {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  leaderboard_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLBSFindOrCreateLB::mutable_leaderboard_name() {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  return leaderboard_name_;
}
inline ::std::string* CMsgClientLBSFindOrCreateLB::release_leaderboard_name() {
  clear_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leaderboard_name_;
    leaderboard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLBSFindOrCreateLB::set_allocated_leaderboard_name(::std::string* leaderboard_name) {
  if (leaderboard_name_ != &::google::protobuf::internal::kEmptyString) {
    delete leaderboard_name_;
  }
  if (leaderboard_name) {
    set_has_leaderboard_name();
    leaderboard_name_ = leaderboard_name;
  } else {
    clear_has_leaderboard_name();
    leaderboard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientLBSFindOrCreateLBResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLBSFindOrCreateLBResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLBResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 leaderboard_id = 2;
inline bool CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_has_leaderboard_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_has_leaderboard_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_leaderboard_id() {
  leaderboard_id_ = 0;
  clear_has_leaderboard_id();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLBResponse::leaderboard_id() const {
  return leaderboard_id_;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_id(::google::protobuf::int32 value) {
  set_has_leaderboard_id();
  leaderboard_id_ = value;
}

// optional int32 leaderboard_entry_count = 3;
inline bool CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_entry_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_has_leaderboard_entry_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_has_leaderboard_entry_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_leaderboard_entry_count() {
  leaderboard_entry_count_ = 0;
  clear_has_leaderboard_entry_count();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLBResponse::leaderboard_entry_count() const {
  return leaderboard_entry_count_;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_entry_count(::google::protobuf::int32 value) {
  set_has_leaderboard_entry_count();
  leaderboard_entry_count_ = value;
}

// optional int32 leaderboard_sort_method = 4 [default = 0];
inline bool CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_sort_method() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_has_leaderboard_sort_method() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_has_leaderboard_sort_method() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_leaderboard_sort_method() {
  leaderboard_sort_method_ = 0;
  clear_has_leaderboard_sort_method();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLBResponse::leaderboard_sort_method() const {
  return leaderboard_sort_method_;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_sort_method(::google::protobuf::int32 value) {
  set_has_leaderboard_sort_method();
  leaderboard_sort_method_ = value;
}

// optional int32 leaderboard_display_type = 5 [default = 0];
inline bool CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_display_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_has_leaderboard_display_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_has_leaderboard_display_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_leaderboard_display_type() {
  leaderboard_display_type_ = 0;
  clear_has_leaderboard_display_type();
}
inline ::google::protobuf::int32 CMsgClientLBSFindOrCreateLBResponse::leaderboard_display_type() const {
  return leaderboard_display_type_;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_display_type(::google::protobuf::int32 value) {
  set_has_leaderboard_display_type();
  leaderboard_display_type_ = value;
}

// optional string leaderboard_name = 6;
inline bool CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_has_leaderboard_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_has_leaderboard_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientLBSFindOrCreateLBResponse::clear_leaderboard_name() {
  if (leaderboard_name_ != &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_->clear();
  }
  clear_has_leaderboard_name();
}
inline const ::std::string& CMsgClientLBSFindOrCreateLBResponse::leaderboard_name() const {
  return *leaderboard_name_;
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_name(const ::std::string& value) {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  leaderboard_name_->assign(value);
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_name(const char* value) {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  leaderboard_name_->assign(value);
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_leaderboard_name(const char* value, size_t size) {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  leaderboard_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLBSFindOrCreateLBResponse::mutable_leaderboard_name() {
  set_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    leaderboard_name_ = new ::std::string;
  }
  return leaderboard_name_;
}
inline ::std::string* CMsgClientLBSFindOrCreateLBResponse::release_leaderboard_name() {
  clear_has_leaderboard_name();
  if (leaderboard_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leaderboard_name_;
    leaderboard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLBSFindOrCreateLBResponse::set_allocated_leaderboard_name(::std::string* leaderboard_name) {
  if (leaderboard_name_ != &::google::protobuf::internal::kEmptyString) {
    delete leaderboard_name_;
  }
  if (leaderboard_name) {
    set_has_leaderboard_name();
    leaderboard_name_ = leaderboard_name;
  } else {
    clear_has_leaderboard_name();
    leaderboard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientLBSGetLBEntries

// optional int32 app_id = 1;
inline bool CMsgClientLBSGetLBEntries::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSGetLBEntries::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSGetLBEntries::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSGetLBEntries::clear_app_id() {
  app_id_ = 0;
  clear_has_app_id();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntries::app_id() const {
  return app_id_;
}
inline void CMsgClientLBSGetLBEntries::set_app_id(::google::protobuf::int32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 leaderboard_id = 2;
inline bool CMsgClientLBSGetLBEntries::has_leaderboard_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSGetLBEntries::set_has_leaderboard_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSGetLBEntries::clear_has_leaderboard_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSGetLBEntries::clear_leaderboard_id() {
  leaderboard_id_ = 0;
  clear_has_leaderboard_id();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntries::leaderboard_id() const {
  return leaderboard_id_;
}
inline void CMsgClientLBSGetLBEntries::set_leaderboard_id(::google::protobuf::int32 value) {
  set_has_leaderboard_id();
  leaderboard_id_ = value;
}

// optional int32 range_start = 3;
inline bool CMsgClientLBSGetLBEntries::has_range_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSGetLBEntries::set_has_range_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSGetLBEntries::clear_has_range_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSGetLBEntries::clear_range_start() {
  range_start_ = 0;
  clear_has_range_start();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntries::range_start() const {
  return range_start_;
}
inline void CMsgClientLBSGetLBEntries::set_range_start(::google::protobuf::int32 value) {
  set_has_range_start();
  range_start_ = value;
}

// optional int32 range_end = 4;
inline bool CMsgClientLBSGetLBEntries::has_range_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLBSGetLBEntries::set_has_range_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLBSGetLBEntries::clear_has_range_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLBSGetLBEntries::clear_range_end() {
  range_end_ = 0;
  clear_has_range_end();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntries::range_end() const {
  return range_end_;
}
inline void CMsgClientLBSGetLBEntries::set_range_end(::google::protobuf::int32 value) {
  set_has_range_end();
  range_end_ = value;
}

// optional int32 leaderboard_data_request = 5;
inline bool CMsgClientLBSGetLBEntries::has_leaderboard_data_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLBSGetLBEntries::set_has_leaderboard_data_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLBSGetLBEntries::clear_has_leaderboard_data_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLBSGetLBEntries::clear_leaderboard_data_request() {
  leaderboard_data_request_ = 0;
  clear_has_leaderboard_data_request();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntries::leaderboard_data_request() const {
  return leaderboard_data_request_;
}
inline void CMsgClientLBSGetLBEntries::set_leaderboard_data_request(::google::protobuf::int32 value) {
  set_has_leaderboard_data_request();
  leaderboard_data_request_ = value;
}

// repeated fixed64 steamids = 6;
inline int CMsgClientLBSGetLBEntries::steamids_size() const {
  return steamids_.size();
}
inline void CMsgClientLBSGetLBEntries::clear_steamids() {
  steamids_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientLBSGetLBEntries::steamids(int index) const {
  return steamids_.Get(index);
}
inline void CMsgClientLBSGetLBEntries::set_steamids(int index, ::google::protobuf::uint64 value) {
  steamids_.Set(index, value);
}
inline void CMsgClientLBSGetLBEntries::add_steamids(::google::protobuf::uint64 value) {
  steamids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientLBSGetLBEntries::steamids() const {
  return steamids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientLBSGetLBEntries::mutable_steamids() {
  return &steamids_;
}

// -------------------------------------------------------------------

// CMsgClientLBSGetLBEntriesResponse_Entry

// optional fixed64 steam_id_user = 1;
inline bool CMsgClientLBSGetLBEntriesResponse_Entry::has_steam_id_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_has_steam_id_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_has_steam_id_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_steam_id_user() {
  steam_id_user_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_user();
}
inline ::google::protobuf::uint64 CMsgClientLBSGetLBEntriesResponse_Entry::steam_id_user() const {
  return steam_id_user_;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_steam_id_user(::google::protobuf::uint64 value) {
  set_has_steam_id_user();
  steam_id_user_ = value;
}

// optional int32 global_rank = 2;
inline bool CMsgClientLBSGetLBEntriesResponse_Entry::has_global_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_has_global_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_has_global_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_global_rank() {
  global_rank_ = 0;
  clear_has_global_rank();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntriesResponse_Entry::global_rank() const {
  return global_rank_;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_global_rank(::google::protobuf::int32 value) {
  set_has_global_rank();
  global_rank_ = value;
}

// optional int32 score = 3;
inline bool CMsgClientLBSGetLBEntriesResponse_Entry::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntriesResponse_Entry::score() const {
  return score_;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional bytes details = 4;
inline bool CMsgClientLBSGetLBEntriesResponse_Entry::has_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_has_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_has_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& CMsgClientLBSGetLBEntriesResponse_Entry::details() const {
  return *details_;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_details(const void* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLBSGetLBEntriesResponse_Entry::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* CMsgClientLBSGetLBEntriesResponse_Entry::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 ugc_id = 5;
inline bool CMsgClientLBSGetLBEntriesResponse_Entry::has_ugc_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_has_ugc_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_has_ugc_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::clear_ugc_id() {
  ugc_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ugc_id();
}
inline ::google::protobuf::uint64 CMsgClientLBSGetLBEntriesResponse_Entry::ugc_id() const {
  return ugc_id_;
}
inline void CMsgClientLBSGetLBEntriesResponse_Entry::set_ugc_id(::google::protobuf::uint64 value) {
  set_has_ugc_id();
  ugc_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLBSGetLBEntriesResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLBSGetLBEntriesResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLBSGetLBEntriesResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLBSGetLBEntriesResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntriesResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientLBSGetLBEntriesResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 leaderboard_entry_count = 2;
inline bool CMsgClientLBSGetLBEntriesResponse::has_leaderboard_entry_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLBSGetLBEntriesResponse::set_has_leaderboard_entry_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLBSGetLBEntriesResponse::clear_has_leaderboard_entry_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLBSGetLBEntriesResponse::clear_leaderboard_entry_count() {
  leaderboard_entry_count_ = 0;
  clear_has_leaderboard_entry_count();
}
inline ::google::protobuf::int32 CMsgClientLBSGetLBEntriesResponse::leaderboard_entry_count() const {
  return leaderboard_entry_count_;
}
inline void CMsgClientLBSGetLBEntriesResponse::set_leaderboard_entry_count(::google::protobuf::int32 value) {
  set_has_leaderboard_entry_count();
  leaderboard_entry_count_ = value;
}

// repeated .Sc.CMsgClientLBSGetLBEntriesResponse.Entry entries = 3;
inline int CMsgClientLBSGetLBEntriesResponse::entries_size() const {
  return entries_.size();
}
inline void CMsgClientLBSGetLBEntriesResponse::clear_entries() {
  entries_.Clear();
}
inline const ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry& CMsgClientLBSGetLBEntriesResponse::entries(int index) const {
  return entries_.Get(index);
}
inline ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry* CMsgClientLBSGetLBEntriesResponse::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry* CMsgClientLBSGetLBEntriesResponse::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry >&
CMsgClientLBSGetLBEntriesResponse::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientLBSGetLBEntriesResponse_Entry >*
CMsgClientLBSGetLBEntriesResponse::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// CMsgClientAccountInfo

// optional string persona_name = 1;
inline bool CMsgClientAccountInfo::has_persona_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAccountInfo::set_has_persona_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAccountInfo::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAccountInfo::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientAccountInfo::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientAccountInfo::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientAccountInfo::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip_country = 2;
inline bool CMsgClientAccountInfo::has_ip_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAccountInfo::set_has_ip_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAccountInfo::clear_has_ip_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAccountInfo::clear_ip_country() {
  if (ip_country_ != &::google::protobuf::internal::kEmptyString) {
    ip_country_->clear();
  }
  clear_has_ip_country();
}
inline const ::std::string& CMsgClientAccountInfo::ip_country() const {
  return *ip_country_;
}
inline void CMsgClientAccountInfo::set_ip_country(const ::std::string& value) {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  ip_country_->assign(value);
}
inline void CMsgClientAccountInfo::set_ip_country(const char* value) {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  ip_country_->assign(value);
}
inline void CMsgClientAccountInfo::set_ip_country(const char* value, size_t size) {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  ip_country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_ip_country() {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  return ip_country_;
}
inline ::std::string* CMsgClientAccountInfo::release_ip_country() {
  clear_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_country_;
    ip_country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_ip_country(::std::string* ip_country) {
  if (ip_country_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_country_;
  }
  if (ip_country) {
    set_has_ip_country();
    ip_country_ = ip_country;
  } else {
    clear_has_ip_country();
    ip_country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes salt_password = 3;
inline bool CMsgClientAccountInfo::has_salt_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAccountInfo::set_has_salt_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAccountInfo::clear_has_salt_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAccountInfo::clear_salt_password() {
  if (salt_password_ != &::google::protobuf::internal::kEmptyString) {
    salt_password_->clear();
  }
  clear_has_salt_password();
}
inline const ::std::string& CMsgClientAccountInfo::salt_password() const {
  return *salt_password_;
}
inline void CMsgClientAccountInfo::set_salt_password(const ::std::string& value) {
  set_has_salt_password();
  if (salt_password_ == &::google::protobuf::internal::kEmptyString) {
    salt_password_ = new ::std::string;
  }
  salt_password_->assign(value);
}
inline void CMsgClientAccountInfo::set_salt_password(const char* value) {
  set_has_salt_password();
  if (salt_password_ == &::google::protobuf::internal::kEmptyString) {
    salt_password_ = new ::std::string;
  }
  salt_password_->assign(value);
}
inline void CMsgClientAccountInfo::set_salt_password(const void* value, size_t size) {
  set_has_salt_password();
  if (salt_password_ == &::google::protobuf::internal::kEmptyString) {
    salt_password_ = new ::std::string;
  }
  salt_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_salt_password() {
  set_has_salt_password();
  if (salt_password_ == &::google::protobuf::internal::kEmptyString) {
    salt_password_ = new ::std::string;
  }
  return salt_password_;
}
inline ::std::string* CMsgClientAccountInfo::release_salt_password() {
  clear_has_salt_password();
  if (salt_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = salt_password_;
    salt_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_salt_password(::std::string* salt_password) {
  if (salt_password_ != &::google::protobuf::internal::kEmptyString) {
    delete salt_password_;
  }
  if (salt_password) {
    set_has_salt_password();
    salt_password_ = salt_password;
  } else {
    clear_has_salt_password();
    salt_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sha_digest_Password = 4;
inline bool CMsgClientAccountInfo::has_sha_digest_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientAccountInfo::set_has_sha_digest_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientAccountInfo::clear_has_sha_digest_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientAccountInfo::clear_sha_digest_password() {
  if (sha_digest_password_ != &::google::protobuf::internal::kEmptyString) {
    sha_digest_password_->clear();
  }
  clear_has_sha_digest_password();
}
inline const ::std::string& CMsgClientAccountInfo::sha_digest_password() const {
  return *sha_digest_password_;
}
inline void CMsgClientAccountInfo::set_sha_digest_password(const ::std::string& value) {
  set_has_sha_digest_password();
  if (sha_digest_password_ == &::google::protobuf::internal::kEmptyString) {
    sha_digest_password_ = new ::std::string;
  }
  sha_digest_password_->assign(value);
}
inline void CMsgClientAccountInfo::set_sha_digest_password(const char* value) {
  set_has_sha_digest_password();
  if (sha_digest_password_ == &::google::protobuf::internal::kEmptyString) {
    sha_digest_password_ = new ::std::string;
  }
  sha_digest_password_->assign(value);
}
inline void CMsgClientAccountInfo::set_sha_digest_password(const void* value, size_t size) {
  set_has_sha_digest_password();
  if (sha_digest_password_ == &::google::protobuf::internal::kEmptyString) {
    sha_digest_password_ = new ::std::string;
  }
  sha_digest_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_sha_digest_password() {
  set_has_sha_digest_password();
  if (sha_digest_password_ == &::google::protobuf::internal::kEmptyString) {
    sha_digest_password_ = new ::std::string;
  }
  return sha_digest_password_;
}
inline ::std::string* CMsgClientAccountInfo::release_sha_digest_password() {
  clear_has_sha_digest_password();
  if (sha_digest_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_digest_password_;
    sha_digest_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_sha_digest_password(::std::string* sha_digest_password) {
  if (sha_digest_password_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_digest_password_;
  }
  if (sha_digest_password) {
    set_has_sha_digest_password();
    sha_digest_password_ = sha_digest_password;
  } else {
    clear_has_sha_digest_password();
    sha_digest_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 count_authed_computers = 5;
inline bool CMsgClientAccountInfo::has_count_authed_computers() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientAccountInfo::set_has_count_authed_computers() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientAccountInfo::clear_has_count_authed_computers() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientAccountInfo::clear_count_authed_computers() {
  count_authed_computers_ = 0;
  clear_has_count_authed_computers();
}
inline ::google::protobuf::int32 CMsgClientAccountInfo::count_authed_computers() const {
  return count_authed_computers_;
}
inline void CMsgClientAccountInfo::set_count_authed_computers(::google::protobuf::int32 value) {
  set_has_count_authed_computers();
  count_authed_computers_ = value;
}

// optional bool locked_with_ipt = 6;
inline bool CMsgClientAccountInfo::has_locked_with_ipt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientAccountInfo::set_has_locked_with_ipt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientAccountInfo::clear_has_locked_with_ipt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientAccountInfo::clear_locked_with_ipt() {
  locked_with_ipt_ = false;
  clear_has_locked_with_ipt();
}
inline bool CMsgClientAccountInfo::locked_with_ipt() const {
  return locked_with_ipt_;
}
inline void CMsgClientAccountInfo::set_locked_with_ipt(bool value) {
  set_has_locked_with_ipt();
  locked_with_ipt_ = value;
}

// optional uint32 account_flags = 7;
inline bool CMsgClientAccountInfo::has_account_flags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientAccountInfo::set_has_account_flags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientAccountInfo::clear_has_account_flags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientAccountInfo::clear_account_flags() {
  account_flags_ = 0u;
  clear_has_account_flags();
}
inline ::google::protobuf::uint32 CMsgClientAccountInfo::account_flags() const {
  return account_flags_;
}
inline void CMsgClientAccountInfo::set_account_flags(::google::protobuf::uint32 value) {
  set_has_account_flags();
  account_flags_ = value;
}

// optional uint64 facebook_id = 8;
inline bool CMsgClientAccountInfo::has_facebook_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientAccountInfo::set_has_facebook_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientAccountInfo::clear_has_facebook_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientAccountInfo::clear_facebook_id() {
  facebook_id_ = GOOGLE_ULONGLONG(0);
  clear_has_facebook_id();
}
inline ::google::protobuf::uint64 CMsgClientAccountInfo::facebook_id() const {
  return facebook_id_;
}
inline void CMsgClientAccountInfo::set_facebook_id(::google::protobuf::uint64 value) {
  set_has_facebook_id();
  facebook_id_ = value;
}

// optional string facebook_name = 9;
inline bool CMsgClientAccountInfo::has_facebook_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientAccountInfo::set_has_facebook_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientAccountInfo::clear_has_facebook_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientAccountInfo::clear_facebook_name() {
  if (facebook_name_ != &::google::protobuf::internal::kEmptyString) {
    facebook_name_->clear();
  }
  clear_has_facebook_name();
}
inline const ::std::string& CMsgClientAccountInfo::facebook_name() const {
  return *facebook_name_;
}
inline void CMsgClientAccountInfo::set_facebook_name(const ::std::string& value) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_facebook_name(const char* value) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_facebook_name(const char* value, size_t size) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_facebook_name() {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  return facebook_name_;
}
inline ::std::string* CMsgClientAccountInfo::release_facebook_name() {
  clear_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = facebook_name_;
    facebook_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_facebook_name(::std::string* facebook_name) {
  if (facebook_name_ != &::google::protobuf::internal::kEmptyString) {
    delete facebook_name_;
  }
  if (facebook_name) {
    set_has_facebook_name();
    facebook_name_ = facebook_name;
  } else {
    clear_has_facebook_name();
    facebook_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 steam_guard_provider = 10;
inline bool CMsgClientAccountInfo::has_steam_guard_provider() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steam_guard_provider() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientAccountInfo::clear_has_steam_guard_provider() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientAccountInfo::clear_steam_guard_provider() {
  steam_guard_provider_ = 0;
  clear_has_steam_guard_provider();
}
inline ::google::protobuf::int32 CMsgClientAccountInfo::steam_guard_provider() const {
  return steam_guard_provider_;
}
inline void CMsgClientAccountInfo::set_steam_guard_provider(::google::protobuf::int32 value) {
  set_has_steam_guard_provider();
  steam_guard_provider_ = value;
}

// optional bool steamguard_require_code_default = 11;
inline bool CMsgClientAccountInfo::has_steamguard_require_code_default() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steamguard_require_code_default() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientAccountInfo::clear_has_steamguard_require_code_default() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientAccountInfo::clear_steamguard_require_code_default() {
  steamguard_require_code_default_ = false;
  clear_has_steamguard_require_code_default();
}
inline bool CMsgClientAccountInfo::steamguard_require_code_default() const {
  return steamguard_require_code_default_;
}
inline void CMsgClientAccountInfo::set_steamguard_require_code_default(bool value) {
  set_has_steamguard_require_code_default();
  steamguard_require_code_default_ = value;
}

// optional bool steamguard_show_providers = 12;
inline bool CMsgClientAccountInfo::has_steamguard_show_providers() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steamguard_show_providers() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientAccountInfo::clear_has_steamguard_show_providers() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientAccountInfo::clear_steamguard_show_providers() {
  steamguard_show_providers_ = false;
  clear_has_steamguard_show_providers();
}
inline bool CMsgClientAccountInfo::steamguard_show_providers() const {
  return steamguard_show_providers_;
}
inline void CMsgClientAccountInfo::set_steamguard_show_providers(bool value) {
  set_has_steamguard_show_providers();
  steamguard_show_providers_ = value;
}

// optional bool steamguard_can_use_mobile_provider = 13;
inline bool CMsgClientAccountInfo::has_steamguard_can_use_mobile_provider() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steamguard_can_use_mobile_provider() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientAccountInfo::clear_has_steamguard_can_use_mobile_provider() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientAccountInfo::clear_steamguard_can_use_mobile_provider() {
  steamguard_can_use_mobile_provider_ = false;
  clear_has_steamguard_can_use_mobile_provider();
}
inline bool CMsgClientAccountInfo::steamguard_can_use_mobile_provider() const {
  return steamguard_can_use_mobile_provider_;
}
inline void CMsgClientAccountInfo::set_steamguard_can_use_mobile_provider(bool value) {
  set_has_steamguard_can_use_mobile_provider();
  steamguard_can_use_mobile_provider_ = value;
}

// optional bool steamguard_notify_newmachines = 14;
inline bool CMsgClientAccountInfo::has_steamguard_notify_newmachines() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steamguard_notify_newmachines() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientAccountInfo::clear_has_steamguard_notify_newmachines() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientAccountInfo::clear_steamguard_notify_newmachines() {
  steamguard_notify_newmachines_ = false;
  clear_has_steamguard_notify_newmachines();
}
inline bool CMsgClientAccountInfo::steamguard_notify_newmachines() const {
  return steamguard_notify_newmachines_;
}
inline void CMsgClientAccountInfo::set_steamguard_notify_newmachines(bool value) {
  set_has_steamguard_notify_newmachines();
  steamguard_notify_newmachines_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAppMinutesPlayedData_AppMinutesPlayedData

// optional uint32 app_id = 1;
inline bool CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::app_id() const {
  return app_id_;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 forever = 2;
inline bool CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::has_forever() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::set_has_forever() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::clear_has_forever() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::clear_forever() {
  forever_ = 0;
  clear_has_forever();
}
inline ::google::protobuf::int32 CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::forever() const {
  return forever_;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::set_forever(::google::protobuf::int32 value) {
  set_has_forever();
  forever_ = value;
}

// optional int32 last_two_weeks = 3;
inline bool CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::has_last_two_weeks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::set_has_last_two_weeks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::clear_has_last_two_weeks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::clear_last_two_weeks() {
  last_two_weeks_ = 0;
  clear_has_last_two_weeks();
}
inline ::google::protobuf::int32 CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::last_two_weeks() const {
  return last_two_weeks_;
}
inline void CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::set_last_two_weeks(::google::protobuf::int32 value) {
  set_has_last_two_weeks();
  last_two_weeks_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAppMinutesPlayedData

// repeated .Sc.CMsgClientAppMinutesPlayedData.AppMinutesPlayedData minutes_played = 1;
inline int CMsgClientAppMinutesPlayedData::minutes_played_size() const {
  return minutes_played_.size();
}
inline void CMsgClientAppMinutesPlayedData::clear_minutes_played() {
  minutes_played_.Clear();
}
inline const ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData& CMsgClientAppMinutesPlayedData::minutes_played(int index) const {
  return minutes_played_.Get(index);
}
inline ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* CMsgClientAppMinutesPlayedData::mutable_minutes_played(int index) {
  return minutes_played_.Mutable(index);
}
inline ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData* CMsgClientAppMinutesPlayedData::add_minutes_played() {
  return minutes_played_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData >&
CMsgClientAppMinutesPlayedData::minutes_played() const {
  return minutes_played_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppMinutesPlayedData_AppMinutesPlayedData >*
CMsgClientAppMinutesPlayedData::mutable_minutes_played() {
  return &minutes_played_;
}

// -------------------------------------------------------------------

// CMsgClientIsLimitedAccount

// optional bool bis_limited_account = 1;
inline bool CMsgClientIsLimitedAccount::has_bis_limited_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientIsLimitedAccount::set_has_bis_limited_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientIsLimitedAccount::clear_has_bis_limited_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientIsLimitedAccount::clear_bis_limited_account() {
  bis_limited_account_ = false;
  clear_has_bis_limited_account();
}
inline bool CMsgClientIsLimitedAccount::bis_limited_account() const {
  return bis_limited_account_;
}
inline void CMsgClientIsLimitedAccount::set_bis_limited_account(bool value) {
  set_has_bis_limited_account();
  bis_limited_account_ = value;
}

// optional bool bis_community_banned = 2;
inline bool CMsgClientIsLimitedAccount::has_bis_community_banned() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientIsLimitedAccount::set_has_bis_community_banned() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientIsLimitedAccount::clear_has_bis_community_banned() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientIsLimitedAccount::clear_bis_community_banned() {
  bis_community_banned_ = false;
  clear_has_bis_community_banned();
}
inline bool CMsgClientIsLimitedAccount::bis_community_banned() const {
  return bis_community_banned_;
}
inline void CMsgClientIsLimitedAccount::set_bis_community_banned(bool value) {
  set_has_bis_community_banned();
  bis_community_banned_ = value;
}

// optional bool bis_locked_account = 3;
inline bool CMsgClientIsLimitedAccount::has_bis_locked_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientIsLimitedAccount::set_has_bis_locked_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientIsLimitedAccount::clear_has_bis_locked_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientIsLimitedAccount::clear_bis_locked_account() {
  bis_locked_account_ = false;
  clear_has_bis_locked_account();
}
inline bool CMsgClientIsLimitedAccount::bis_locked_account() const {
  return bis_locked_account_;
}
inline void CMsgClientIsLimitedAccount::set_bis_locked_account(bool value) {
  set_has_bis_locked_account();
  bis_locked_account_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestFriendData

// optional uint32 persona_state_requested = 1;
inline bool CMsgClientRequestFriendData::has_persona_state_requested() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestFriendData::set_has_persona_state_requested() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestFriendData::clear_has_persona_state_requested() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestFriendData::clear_persona_state_requested() {
  persona_state_requested_ = 0u;
  clear_has_persona_state_requested();
}
inline ::google::protobuf::uint32 CMsgClientRequestFriendData::persona_state_requested() const {
  return persona_state_requested_;
}
inline void CMsgClientRequestFriendData::set_persona_state_requested(::google::protobuf::uint32 value) {
  set_has_persona_state_requested();
  persona_state_requested_ = value;
}

// repeated fixed64 friends = 2;
inline int CMsgClientRequestFriendData::friends_size() const {
  return friends_.size();
}
inline void CMsgClientRequestFriendData::clear_friends() {
  friends_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientRequestFriendData::friends(int index) const {
  return friends_.Get(index);
}
inline void CMsgClientRequestFriendData::set_friends(int index, ::google::protobuf::uint64 value) {
  friends_.Set(index, value);
}
inline void CMsgClientRequestFriendData::add_friends(::google::protobuf::uint64 value) {
  friends_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientRequestFriendData::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientRequestFriendData::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// CMsgClientChangeStatus

// optional uint32 persona_state = 1;
inline bool CMsgClientChangeStatus::has_persona_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientChangeStatus::set_has_persona_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientChangeStatus::clear_has_persona_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientChangeStatus::clear_persona_state() {
  persona_state_ = 0u;
  clear_has_persona_state();
}
inline ::google::protobuf::uint32 CMsgClientChangeStatus::persona_state() const {
  return persona_state_;
}
inline void CMsgClientChangeStatus::set_persona_state(::google::protobuf::uint32 value) {
  set_has_persona_state();
  persona_state_ = value;
}

// optional string player_name = 2;
inline bool CMsgClientChangeStatus::has_player_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientChangeStatus::set_has_player_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientChangeStatus::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientChangeStatus::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& CMsgClientChangeStatus::player_name() const {
  return *player_name_;
}
inline void CMsgClientChangeStatus::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void CMsgClientChangeStatus::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void CMsgClientChangeStatus::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientChangeStatus::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  return player_name_;
}
inline ::std::string* CMsgClientChangeStatus::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientChangeStatus::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_auto_generated_name = 3;
inline bool CMsgClientChangeStatus::has_is_auto_generated_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientChangeStatus::set_has_is_auto_generated_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientChangeStatus::clear_has_is_auto_generated_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientChangeStatus::clear_is_auto_generated_name() {
  is_auto_generated_name_ = false;
  clear_has_is_auto_generated_name();
}
inline bool CMsgClientChangeStatus::is_auto_generated_name() const {
  return is_auto_generated_name_;
}
inline void CMsgClientChangeStatus::set_is_auto_generated_name(bool value) {
  set_has_is_auto_generated_name();
  is_auto_generated_name_ = value;
}

// optional bool high_priority = 4;
inline bool CMsgClientChangeStatus::has_high_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientChangeStatus::set_has_high_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientChangeStatus::clear_has_high_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientChangeStatus::clear_high_priority() {
  high_priority_ = false;
  clear_has_high_priority();
}
inline bool CMsgClientChangeStatus::high_priority() const {
  return high_priority_;
}
inline void CMsgClientChangeStatus::set_high_priority(bool value) {
  set_has_high_priority();
  high_priority_ = value;
}

// -------------------------------------------------------------------

// CMsgPersonaChangeResponse

// optional uint32 result = 1;
inline bool CMsgPersonaChangeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPersonaChangeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPersonaChangeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPersonaChangeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CMsgPersonaChangeResponse::result() const {
  return result_;
}
inline void CMsgPersonaChangeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional string player_name = 2;
inline bool CMsgPersonaChangeResponse::has_player_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPersonaChangeResponse::set_has_player_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPersonaChangeResponse::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPersonaChangeResponse::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& CMsgPersonaChangeResponse::player_name() const {
  return *player_name_;
}
inline void CMsgPersonaChangeResponse::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void CMsgPersonaChangeResponse::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void CMsgPersonaChangeResponse::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgPersonaChangeResponse::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  return player_name_;
}
inline ::std::string* CMsgPersonaChangeResponse::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgPersonaChangeResponse::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientPersonaState_Friend

// optional fixed64 friendid = 1;
inline bool CMsgClientPersonaState_Friend::has_friendid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_friendid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPersonaState_Friend::clear_has_friendid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPersonaState_Friend::clear_friendid() {
  friendid_ = GOOGLE_ULONGLONG(0);
  clear_has_friendid();
}
inline ::google::protobuf::uint64 CMsgClientPersonaState_Friend::friendid() const {
  return friendid_;
}
inline void CMsgClientPersonaState_Friend::set_friendid(::google::protobuf::uint64 value) {
  set_has_friendid();
  friendid_ = value;
}

// optional uint32 persona_state = 2;
inline bool CMsgClientPersonaState_Friend::has_persona_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_persona_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPersonaState_Friend::clear_has_persona_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPersonaState_Friend::clear_persona_state() {
  persona_state_ = 0u;
  clear_has_persona_state();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::persona_state() const {
  return persona_state_;
}
inline void CMsgClientPersonaState_Friend::set_persona_state(::google::protobuf::uint32 value) {
  set_has_persona_state();
  persona_state_ = value;
}

// optional uint32 game_played_app_id = 3;
inline bool CMsgClientPersonaState_Friend::has_game_played_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_game_played_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientPersonaState_Friend::clear_has_game_played_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientPersonaState_Friend::clear_game_played_app_id() {
  game_played_app_id_ = 0u;
  clear_has_game_played_app_id();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::game_played_app_id() const {
  return game_played_app_id_;
}
inline void CMsgClientPersonaState_Friend::set_game_played_app_id(::google::protobuf::uint32 value) {
  set_has_game_played_app_id();
  game_played_app_id_ = value;
}

// optional uint32 game_server_ip = 4;
inline bool CMsgClientPersonaState_Friend::has_game_server_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_game_server_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientPersonaState_Friend::clear_has_game_server_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientPersonaState_Friend::clear_game_server_ip() {
  game_server_ip_ = 0u;
  clear_has_game_server_ip();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::game_server_ip() const {
  return game_server_ip_;
}
inline void CMsgClientPersonaState_Friend::set_game_server_ip(::google::protobuf::uint32 value) {
  set_has_game_server_ip();
  game_server_ip_ = value;
}

// optional uint32 game_server_port = 5;
inline bool CMsgClientPersonaState_Friend::has_game_server_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_game_server_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientPersonaState_Friend::clear_has_game_server_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientPersonaState_Friend::clear_game_server_port() {
  game_server_port_ = 0u;
  clear_has_game_server_port();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::game_server_port() const {
  return game_server_port_;
}
inline void CMsgClientPersonaState_Friend::set_game_server_port(::google::protobuf::uint32 value) {
  set_has_game_server_port();
  game_server_port_ = value;
}

// optional uint32 persona_state_flags = 6;
inline bool CMsgClientPersonaState_Friend::has_persona_state_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_persona_state_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientPersonaState_Friend::clear_has_persona_state_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientPersonaState_Friend::clear_persona_state_flags() {
  persona_state_flags_ = 0u;
  clear_has_persona_state_flags();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::persona_state_flags() const {
  return persona_state_flags_;
}
inline void CMsgClientPersonaState_Friend::set_persona_state_flags(::google::protobuf::uint32 value) {
  set_has_persona_state_flags();
  persona_state_flags_ = value;
}

// optional uint32 online_session_instances = 7;
inline bool CMsgClientPersonaState_Friend::has_online_session_instances() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_online_session_instances() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientPersonaState_Friend::clear_has_online_session_instances() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientPersonaState_Friend::clear_online_session_instances() {
  online_session_instances_ = 0u;
  clear_has_online_session_instances();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::online_session_instances() const {
  return online_session_instances_;
}
inline void CMsgClientPersonaState_Friend::set_online_session_instances(::google::protobuf::uint32 value) {
  set_has_online_session_instances();
  online_session_instances_ = value;
}

// optional uint32 published_instance_id = 8;
inline bool CMsgClientPersonaState_Friend::has_published_instance_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_published_instance_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientPersonaState_Friend::clear_has_published_instance_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientPersonaState_Friend::clear_published_instance_id() {
  published_instance_id_ = 0u;
  clear_has_published_instance_id();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::published_instance_id() const {
  return published_instance_id_;
}
inline void CMsgClientPersonaState_Friend::set_published_instance_id(::google::protobuf::uint32 value) {
  set_has_published_instance_id();
  published_instance_id_ = value;
}

// optional string player_name = 15;
inline bool CMsgClientPersonaState_Friend::has_player_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_player_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientPersonaState_Friend::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientPersonaState_Friend::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& CMsgClientPersonaState_Friend::player_name() const {
  return *player_name_;
}
inline void CMsgClientPersonaState_Friend::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPersonaState_Friend::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  return player_name_;
}
inline ::std::string* CMsgClientPersonaState_Friend::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPersonaState_Friend::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 query_port = 20;
inline bool CMsgClientPersonaState_Friend::has_query_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_query_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientPersonaState_Friend::clear_has_query_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientPersonaState_Friend::clear_query_port() {
  query_port_ = 0u;
  clear_has_query_port();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::query_port() const {
  return query_port_;
}
inline void CMsgClientPersonaState_Friend::set_query_port(::google::protobuf::uint32 value) {
  set_has_query_port();
  query_port_ = value;
}

// optional fixed64 steamid_source = 25;
inline bool CMsgClientPersonaState_Friend::has_steamid_source() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_steamid_source() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientPersonaState_Friend::clear_has_steamid_source() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientPersonaState_Friend::clear_steamid_source() {
  steamid_source_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_source();
}
inline ::google::protobuf::uint64 CMsgClientPersonaState_Friend::steamid_source() const {
  return steamid_source_;
}
inline void CMsgClientPersonaState_Friend::set_steamid_source(::google::protobuf::uint64 value) {
  set_has_steamid_source();
  steamid_source_ = value;
}

// optional bytes avatar_hash = 31;
inline bool CMsgClientPersonaState_Friend::has_avatar_hash() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_avatar_hash() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientPersonaState_Friend::clear_has_avatar_hash() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientPersonaState_Friend::clear_avatar_hash() {
  if (avatar_hash_ != &::google::protobuf::internal::kEmptyString) {
    avatar_hash_->clear();
  }
  clear_has_avatar_hash();
}
inline const ::std::string& CMsgClientPersonaState_Friend::avatar_hash() const {
  return *avatar_hash_;
}
inline void CMsgClientPersonaState_Friend::set_avatar_hash(const ::std::string& value) {
  set_has_avatar_hash();
  if (avatar_hash_ == &::google::protobuf::internal::kEmptyString) {
    avatar_hash_ = new ::std::string;
  }
  avatar_hash_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_avatar_hash(const char* value) {
  set_has_avatar_hash();
  if (avatar_hash_ == &::google::protobuf::internal::kEmptyString) {
    avatar_hash_ = new ::std::string;
  }
  avatar_hash_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_avatar_hash(const void* value, size_t size) {
  set_has_avatar_hash();
  if (avatar_hash_ == &::google::protobuf::internal::kEmptyString) {
    avatar_hash_ = new ::std::string;
  }
  avatar_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPersonaState_Friend::mutable_avatar_hash() {
  set_has_avatar_hash();
  if (avatar_hash_ == &::google::protobuf::internal::kEmptyString) {
    avatar_hash_ = new ::std::string;
  }
  return avatar_hash_;
}
inline ::std::string* CMsgClientPersonaState_Friend::release_avatar_hash() {
  clear_has_avatar_hash();
  if (avatar_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_hash_;
    avatar_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPersonaState_Friend::set_allocated_avatar_hash(::std::string* avatar_hash) {
  if (avatar_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_hash_;
  }
  if (avatar_hash) {
    set_has_avatar_hash();
    avatar_hash_ = avatar_hash;
  } else {
    clear_has_avatar_hash();
    avatar_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 last_logoff = 45;
inline bool CMsgClientPersonaState_Friend::has_last_logoff() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_last_logoff() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_last_logoff() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientPersonaState_Friend::clear_last_logoff() {
  last_logoff_ = 0u;
  clear_has_last_logoff();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::last_logoff() const {
  return last_logoff_;
}
inline void CMsgClientPersonaState_Friend::set_last_logoff(::google::protobuf::uint32 value) {
  set_has_last_logoff();
  last_logoff_ = value;
}

// optional uint32 last_logon = 46;
inline bool CMsgClientPersonaState_Friend::has_last_logon() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_last_logon() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_last_logon() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientPersonaState_Friend::clear_last_logon() {
  last_logon_ = 0u;
  clear_has_last_logon();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::last_logon() const {
  return last_logon_;
}
inline void CMsgClientPersonaState_Friend::set_last_logon(::google::protobuf::uint32 value) {
  set_has_last_logon();
  last_logon_ = value;
}

// optional uint32 clan_rank = 50;
inline bool CMsgClientPersonaState_Friend::has_clan_rank() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_clan_rank() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_clan_rank() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientPersonaState_Friend::clear_clan_rank() {
  clan_rank_ = 0u;
  clear_has_clan_rank();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState_Friend::clan_rank() const {
  return clan_rank_;
}
inline void CMsgClientPersonaState_Friend::set_clan_rank(::google::protobuf::uint32 value) {
  set_has_clan_rank();
  clan_rank_ = value;
}

// optional string game_name = 55;
inline bool CMsgClientPersonaState_Friend::has_game_name() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_game_name() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_game_name() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientPersonaState_Friend::clear_game_name() {
  if (game_name_ != &::google::protobuf::internal::kEmptyString) {
    game_name_->clear();
  }
  clear_has_game_name();
}
inline const ::std::string& CMsgClientPersonaState_Friend::game_name() const {
  return *game_name_;
}
inline void CMsgClientPersonaState_Friend::set_game_name(const ::std::string& value) {
  set_has_game_name();
  if (game_name_ == &::google::protobuf::internal::kEmptyString) {
    game_name_ = new ::std::string;
  }
  game_name_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_game_name(const char* value) {
  set_has_game_name();
  if (game_name_ == &::google::protobuf::internal::kEmptyString) {
    game_name_ = new ::std::string;
  }
  game_name_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_game_name(const char* value, size_t size) {
  set_has_game_name();
  if (game_name_ == &::google::protobuf::internal::kEmptyString) {
    game_name_ = new ::std::string;
  }
  game_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPersonaState_Friend::mutable_game_name() {
  set_has_game_name();
  if (game_name_ == &::google::protobuf::internal::kEmptyString) {
    game_name_ = new ::std::string;
  }
  return game_name_;
}
inline ::std::string* CMsgClientPersonaState_Friend::release_game_name() {
  clear_has_game_name();
  if (game_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_name_;
    game_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPersonaState_Friend::set_allocated_game_name(::std::string* game_name) {
  if (game_name_ != &::google::protobuf::internal::kEmptyString) {
    delete game_name_;
  }
  if (game_name) {
    set_has_game_name();
    game_name_ = game_name;
  } else {
    clear_has_game_name();
    game_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 gameid = 56;
inline bool CMsgClientPersonaState_Friend::has_gameid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_gameid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_gameid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientPersonaState_Friend::clear_gameid() {
  gameid_ = GOOGLE_ULONGLONG(0);
  clear_has_gameid();
}
inline ::google::protobuf::uint64 CMsgClientPersonaState_Friend::gameid() const {
  return gameid_;
}
inline void CMsgClientPersonaState_Friend::set_gameid(::google::protobuf::uint64 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional bytes game_data_blob = 60;
inline bool CMsgClientPersonaState_Friend::has_game_data_blob() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_game_data_blob() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_game_data_blob() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgClientPersonaState_Friend::clear_game_data_blob() {
  if (game_data_blob_ != &::google::protobuf::internal::kEmptyString) {
    game_data_blob_->clear();
  }
  clear_has_game_data_blob();
}
inline const ::std::string& CMsgClientPersonaState_Friend::game_data_blob() const {
  return *game_data_blob_;
}
inline void CMsgClientPersonaState_Friend::set_game_data_blob(const ::std::string& value) {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  game_data_blob_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_game_data_blob(const char* value) {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  game_data_blob_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_game_data_blob(const void* value, size_t size) {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  game_data_blob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPersonaState_Friend::mutable_game_data_blob() {
  set_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    game_data_blob_ = new ::std::string;
  }
  return game_data_blob_;
}
inline ::std::string* CMsgClientPersonaState_Friend::release_game_data_blob() {
  clear_has_game_data_blob();
  if (game_data_blob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_data_blob_;
    game_data_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPersonaState_Friend::set_allocated_game_data_blob(::std::string* game_data_blob) {
  if (game_data_blob_ != &::google::protobuf::internal::kEmptyString) {
    delete game_data_blob_;
  }
  if (game_data_blob) {
    set_has_game_data_blob();
    game_data_blob_ = game_data_blob;
  } else {
    clear_has_game_data_blob();
    game_data_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clan_tag = 65;
inline bool CMsgClientPersonaState_Friend::has_clan_tag() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_clan_tag() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_clan_tag() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgClientPersonaState_Friend::clear_clan_tag() {
  if (clan_tag_ != &::google::protobuf::internal::kEmptyString) {
    clan_tag_->clear();
  }
  clear_has_clan_tag();
}
inline const ::std::string& CMsgClientPersonaState_Friend::clan_tag() const {
  return *clan_tag_;
}
inline void CMsgClientPersonaState_Friend::set_clan_tag(const ::std::string& value) {
  set_has_clan_tag();
  if (clan_tag_ == &::google::protobuf::internal::kEmptyString) {
    clan_tag_ = new ::std::string;
  }
  clan_tag_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_clan_tag(const char* value) {
  set_has_clan_tag();
  if (clan_tag_ == &::google::protobuf::internal::kEmptyString) {
    clan_tag_ = new ::std::string;
  }
  clan_tag_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_clan_tag(const char* value, size_t size) {
  set_has_clan_tag();
  if (clan_tag_ == &::google::protobuf::internal::kEmptyString) {
    clan_tag_ = new ::std::string;
  }
  clan_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPersonaState_Friend::mutable_clan_tag() {
  set_has_clan_tag();
  if (clan_tag_ == &::google::protobuf::internal::kEmptyString) {
    clan_tag_ = new ::std::string;
  }
  return clan_tag_;
}
inline ::std::string* CMsgClientPersonaState_Friend::release_clan_tag() {
  clear_has_clan_tag();
  if (clan_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_tag_;
    clan_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPersonaState_Friend::set_allocated_clan_tag(::std::string* clan_tag) {
  if (clan_tag_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_tag_;
  }
  if (clan_tag) {
    set_has_clan_tag();
    clan_tag_ = clan_tag;
  } else {
    clear_has_clan_tag();
    clan_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string facebook_name = 66;
inline bool CMsgClientPersonaState_Friend::has_facebook_name() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_facebook_name() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_facebook_name() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CMsgClientPersonaState_Friend::clear_facebook_name() {
  if (facebook_name_ != &::google::protobuf::internal::kEmptyString) {
    facebook_name_->clear();
  }
  clear_has_facebook_name();
}
inline const ::std::string& CMsgClientPersonaState_Friend::facebook_name() const {
  return *facebook_name_;
}
inline void CMsgClientPersonaState_Friend::set_facebook_name(const ::std::string& value) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_facebook_name(const char* value) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(value);
}
inline void CMsgClientPersonaState_Friend::set_facebook_name(const char* value, size_t size) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPersonaState_Friend::mutable_facebook_name() {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  return facebook_name_;
}
inline ::std::string* CMsgClientPersonaState_Friend::release_facebook_name() {
  clear_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = facebook_name_;
    facebook_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPersonaState_Friend::set_allocated_facebook_name(::std::string* facebook_name) {
  if (facebook_name_ != &::google::protobuf::internal::kEmptyString) {
    delete facebook_name_;
  }
  if (facebook_name) {
    set_has_facebook_name();
    facebook_name_ = facebook_name;
  } else {
    clear_has_facebook_name();
    facebook_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 facebook_id = 67;
inline bool CMsgClientPersonaState_Friend::has_facebook_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgClientPersonaState_Friend::set_has_facebook_id() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CMsgClientPersonaState_Friend::clear_has_facebook_id() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CMsgClientPersonaState_Friend::clear_facebook_id() {
  facebook_id_ = GOOGLE_ULONGLONG(0);
  clear_has_facebook_id();
}
inline ::google::protobuf::uint64 CMsgClientPersonaState_Friend::facebook_id() const {
  return facebook_id_;
}
inline void CMsgClientPersonaState_Friend::set_facebook_id(::google::protobuf::uint64 value) {
  set_has_facebook_id();
  facebook_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientPersonaState

// optional uint32 status_flags = 1;
inline bool CMsgClientPersonaState::has_status_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPersonaState::set_has_status_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPersonaState::clear_has_status_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPersonaState::clear_status_flags() {
  status_flags_ = 0u;
  clear_has_status_flags();
}
inline ::google::protobuf::uint32 CMsgClientPersonaState::status_flags() const {
  return status_flags_;
}
inline void CMsgClientPersonaState::set_status_flags(::google::protobuf::uint32 value) {
  set_has_status_flags();
  status_flags_ = value;
}

// repeated .Sc.CMsgClientPersonaState.Friend friends = 2;
inline int CMsgClientPersonaState::friends_size() const {
  return friends_.size();
}
inline void CMsgClientPersonaState::clear_friends() {
  friends_.Clear();
}
inline const ::Sc::CMsgClientPersonaState_Friend& CMsgClientPersonaState::friends(int index) const {
  return friends_.Get(index);
}
inline ::Sc::CMsgClientPersonaState_Friend* CMsgClientPersonaState::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::Sc::CMsgClientPersonaState_Friend* CMsgClientPersonaState::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPersonaState_Friend >&
CMsgClientPersonaState::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPersonaState_Friend >*
CMsgClientPersonaState::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// CMsgClientFriendProfileInfo

// optional fixed64 steamid_friend = 1;
inline bool CMsgClientFriendProfileInfo::has_steamid_friend() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendProfileInfo::set_has_steamid_friend() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendProfileInfo::clear_has_steamid_friend() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendProfileInfo::clear_steamid_friend() {
  steamid_friend_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_friend();
}
inline ::google::protobuf::uint64 CMsgClientFriendProfileInfo::steamid_friend() const {
  return steamid_friend_;
}
inline void CMsgClientFriendProfileInfo::set_steamid_friend(::google::protobuf::uint64 value) {
  set_has_steamid_friend();
  steamid_friend_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFriendProfileInfoResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientFriendProfileInfoResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientFriendProfileInfoResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientFriendProfileInfoResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 steamid_friend = 2;
inline bool CMsgClientFriendProfileInfoResponse::has_steamid_friend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_steamid_friend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_steamid_friend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_steamid_friend() {
  steamid_friend_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_friend();
}
inline ::google::protobuf::uint64 CMsgClientFriendProfileInfoResponse::steamid_friend() const {
  return steamid_friend_;
}
inline void CMsgClientFriendProfileInfoResponse::set_steamid_friend(::google::protobuf::uint64 value) {
  set_has_steamid_friend();
  steamid_friend_ = value;
}

// optional uint32 time_created = 3;
inline bool CMsgClientFriendProfileInfoResponse::has_time_created() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_time_created() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_time_created() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_time_created() {
  time_created_ = 0u;
  clear_has_time_created();
}
inline ::google::protobuf::uint32 CMsgClientFriendProfileInfoResponse::time_created() const {
  return time_created_;
}
inline void CMsgClientFriendProfileInfoResponse::set_time_created(::google::protobuf::uint32 value) {
  set_has_time_created();
  time_created_ = value;
}

// optional string real_name = 4;
inline bool CMsgClientFriendProfileInfoResponse::has_real_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_real_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_real_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::kEmptyString) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& CMsgClientFriendProfileInfoResponse::real_name() const {
  return *real_name_;
}
inline void CMsgClientFriendProfileInfoResponse::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_real_name(const char* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  return real_name_;
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendProfileInfoResponse::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::kEmptyString) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city_name = 5;
inline bool CMsgClientFriendProfileInfoResponse::has_city_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_city_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_city_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_city_name() {
  if (city_name_ != &::google::protobuf::internal::kEmptyString) {
    city_name_->clear();
  }
  clear_has_city_name();
}
inline const ::std::string& CMsgClientFriendProfileInfoResponse::city_name() const {
  return *city_name_;
}
inline void CMsgClientFriendProfileInfoResponse::set_city_name(const ::std::string& value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::kEmptyString) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_city_name(const char* value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::kEmptyString) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_city_name(const char* value, size_t size) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::kEmptyString) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::mutable_city_name() {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::kEmptyString) {
    city_name_ = new ::std::string;
  }
  return city_name_;
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::release_city_name() {
  clear_has_city_name();
  if (city_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_name_;
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendProfileInfoResponse::set_allocated_city_name(::std::string* city_name) {
  if (city_name_ != &::google::protobuf::internal::kEmptyString) {
    delete city_name_;
  }
  if (city_name) {
    set_has_city_name();
    city_name_ = city_name;
  } else {
    clear_has_city_name();
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state_name = 6;
inline bool CMsgClientFriendProfileInfoResponse::has_state_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_state_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_state_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_state_name() {
  if (state_name_ != &::google::protobuf::internal::kEmptyString) {
    state_name_->clear();
  }
  clear_has_state_name();
}
inline const ::std::string& CMsgClientFriendProfileInfoResponse::state_name() const {
  return *state_name_;
}
inline void CMsgClientFriendProfileInfoResponse::set_state_name(const ::std::string& value) {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  state_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_state_name(const char* value) {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  state_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_state_name(const char* value, size_t size) {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  state_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::mutable_state_name() {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  return state_name_;
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::release_state_name() {
  clear_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_name_;
    state_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendProfileInfoResponse::set_allocated_state_name(::std::string* state_name) {
  if (state_name_ != &::google::protobuf::internal::kEmptyString) {
    delete state_name_;
  }
  if (state_name) {
    set_has_state_name();
    state_name_ = state_name;
  } else {
    clear_has_state_name();
    state_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country_name = 7;
inline bool CMsgClientFriendProfileInfoResponse::has_country_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_country_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_country_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_country_name() {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    country_name_->clear();
  }
  clear_has_country_name();
}
inline const ::std::string& CMsgClientFriendProfileInfoResponse::country_name() const {
  return *country_name_;
}
inline void CMsgClientFriendProfileInfoResponse::set_country_name(const ::std::string& value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_country_name(const char* value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_country_name(const char* value, size_t size) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::mutable_country_name() {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  return country_name_;
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::release_country_name() {
  clear_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_name_;
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendProfileInfoResponse::set_allocated_country_name(::std::string* country_name) {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    delete country_name_;
  }
  if (country_name) {
    set_has_country_name();
    country_name_ = country_name;
  } else {
    clear_has_country_name();
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string headline = 8;
inline bool CMsgClientFriendProfileInfoResponse::has_headline() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_headline() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_headline() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_headline() {
  if (headline_ != &::google::protobuf::internal::kEmptyString) {
    headline_->clear();
  }
  clear_has_headline();
}
inline const ::std::string& CMsgClientFriendProfileInfoResponse::headline() const {
  return *headline_;
}
inline void CMsgClientFriendProfileInfoResponse::set_headline(const ::std::string& value) {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  headline_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_headline(const char* value) {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  headline_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_headline(const char* value, size_t size) {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  headline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::mutable_headline() {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  return headline_;
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::release_headline() {
  clear_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headline_;
    headline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendProfileInfoResponse::set_allocated_headline(::std::string* headline) {
  if (headline_ != &::google::protobuf::internal::kEmptyString) {
    delete headline_;
  }
  if (headline) {
    set_has_headline();
    headline_ = headline;
  } else {
    clear_has_headline();
    headline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string summary = 9;
inline bool CMsgClientFriendProfileInfoResponse::has_summary() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_summary() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_summary() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_summary() {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& CMsgClientFriendProfileInfoResponse::summary() const {
  return *summary_;
}
inline void CMsgClientFriendProfileInfoResponse::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void CMsgClientFriendProfileInfoResponse::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  return summary_;
}
inline ::std::string* CMsgClientFriendProfileInfoResponse::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendProfileInfoResponse::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 recent_playtime = 10;
inline bool CMsgClientFriendProfileInfoResponse::has_recent_playtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientFriendProfileInfoResponse::set_has_recent_playtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_has_recent_playtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientFriendProfileInfoResponse::clear_recent_playtime() {
  recent_playtime_ = 0u;
  clear_has_recent_playtime();
}
inline ::google::protobuf::uint32 CMsgClientFriendProfileInfoResponse::recent_playtime() const {
  return recent_playtime_;
}
inline void CMsgClientFriendProfileInfoResponse::set_recent_playtime(::google::protobuf::uint32 value) {
  set_has_recent_playtime();
  recent_playtime_ = value;
}

// -------------------------------------------------------------------

// CMsgClientServerList_Server

// optional uint32 server_type = 1;
inline bool CMsgClientServerList_Server::has_server_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientServerList_Server::set_has_server_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientServerList_Server::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientServerList_Server::clear_server_type() {
  server_type_ = 0u;
  clear_has_server_type();
}
inline ::google::protobuf::uint32 CMsgClientServerList_Server::server_type() const {
  return server_type_;
}
inline void CMsgClientServerList_Server::set_server_type(::google::protobuf::uint32 value) {
  set_has_server_type();
  server_type_ = value;
}

// optional uint32 server_ip = 2;
inline bool CMsgClientServerList_Server::has_server_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientServerList_Server::set_has_server_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientServerList_Server::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientServerList_Server::clear_server_ip() {
  server_ip_ = 0u;
  clear_has_server_ip();
}
inline ::google::protobuf::uint32 CMsgClientServerList_Server::server_ip() const {
  return server_ip_;
}
inline void CMsgClientServerList_Server::set_server_ip(::google::protobuf::uint32 value) {
  set_has_server_ip();
  server_ip_ = value;
}

// optional uint32 server_port = 3;
inline bool CMsgClientServerList_Server::has_server_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientServerList_Server::set_has_server_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientServerList_Server::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientServerList_Server::clear_server_port() {
  server_port_ = 0u;
  clear_has_server_port();
}
inline ::google::protobuf::uint32 CMsgClientServerList_Server::server_port() const {
  return server_port_;
}
inline void CMsgClientServerList_Server::set_server_port(::google::protobuf::uint32 value) {
  set_has_server_port();
  server_port_ = value;
}

// -------------------------------------------------------------------

// CMsgClientServerList

// repeated .Sc.CMsgClientServerList.Server servers = 1;
inline int CMsgClientServerList::servers_size() const {
  return servers_.size();
}
inline void CMsgClientServerList::clear_servers() {
  servers_.Clear();
}
inline const ::Sc::CMsgClientServerList_Server& CMsgClientServerList::servers(int index) const {
  return servers_.Get(index);
}
inline ::Sc::CMsgClientServerList_Server* CMsgClientServerList::mutable_servers(int index) {
  return servers_.Mutable(index);
}
inline ::Sc::CMsgClientServerList_Server* CMsgClientServerList::add_servers() {
  return servers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServerList_Server >&
CMsgClientServerList::servers() const {
  return servers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServerList_Server >*
CMsgClientServerList::mutable_servers() {
  return &servers_;
}

// -------------------------------------------------------------------

// CMsgClientRequestedClientStats_StatsToSend

// optional uint32 client_stat = 1;
inline bool CMsgClientRequestedClientStats_StatsToSend::has_client_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestedClientStats_StatsToSend::set_has_client_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestedClientStats_StatsToSend::clear_has_client_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestedClientStats_StatsToSend::clear_client_stat() {
  client_stat_ = 0u;
  clear_has_client_stat();
}
inline ::google::protobuf::uint32 CMsgClientRequestedClientStats_StatsToSend::client_stat() const {
  return client_stat_;
}
inline void CMsgClientRequestedClientStats_StatsToSend::set_client_stat(::google::protobuf::uint32 value) {
  set_has_client_stat();
  client_stat_ = value;
}

// optional uint32 stat_aggregate_method = 2;
inline bool CMsgClientRequestedClientStats_StatsToSend::has_stat_aggregate_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestedClientStats_StatsToSend::set_has_stat_aggregate_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestedClientStats_StatsToSend::clear_has_stat_aggregate_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestedClientStats_StatsToSend::clear_stat_aggregate_method() {
  stat_aggregate_method_ = 0u;
  clear_has_stat_aggregate_method();
}
inline ::google::protobuf::uint32 CMsgClientRequestedClientStats_StatsToSend::stat_aggregate_method() const {
  return stat_aggregate_method_;
}
inline void CMsgClientRequestedClientStats_StatsToSend::set_stat_aggregate_method(::google::protobuf::uint32 value) {
  set_has_stat_aggregate_method();
  stat_aggregate_method_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestedClientStats

// repeated .Sc.CMsgClientRequestedClientStats.StatsToSend stats_to_send = 1;
inline int CMsgClientRequestedClientStats::stats_to_send_size() const {
  return stats_to_send_.size();
}
inline void CMsgClientRequestedClientStats::clear_stats_to_send() {
  stats_to_send_.Clear();
}
inline const ::Sc::CMsgClientRequestedClientStats_StatsToSend& CMsgClientRequestedClientStats::stats_to_send(int index) const {
  return stats_to_send_.Get(index);
}
inline ::Sc::CMsgClientRequestedClientStats_StatsToSend* CMsgClientRequestedClientStats::mutable_stats_to_send(int index) {
  return stats_to_send_.Mutable(index);
}
inline ::Sc::CMsgClientRequestedClientStats_StatsToSend* CMsgClientRequestedClientStats::add_stats_to_send() {
  return stats_to_send_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRequestedClientStats_StatsToSend >&
CMsgClientRequestedClientStats::stats_to_send() const {
  return stats_to_send_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRequestedClientStats_StatsToSend >*
CMsgClientRequestedClientStats::mutable_stats_to_send() {
  return &stats_to_send_;
}

// -------------------------------------------------------------------

// CMsgClientStat2_StatDetail

// optional uint32 client_stat = 1;
inline bool CMsgClientStat2_StatDetail::has_client_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStat2_StatDetail::set_has_client_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStat2_StatDetail::clear_has_client_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStat2_StatDetail::clear_client_stat() {
  client_stat_ = 0u;
  clear_has_client_stat();
}
inline ::google::protobuf::uint32 CMsgClientStat2_StatDetail::client_stat() const {
  return client_stat_;
}
inline void CMsgClientStat2_StatDetail::set_client_stat(::google::protobuf::uint32 value) {
  set_has_client_stat();
  client_stat_ = value;
}

// optional int64 ll_value = 2;
inline bool CMsgClientStat2_StatDetail::has_ll_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStat2_StatDetail::set_has_ll_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStat2_StatDetail::clear_has_ll_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStat2_StatDetail::clear_ll_value() {
  ll_value_ = GOOGLE_LONGLONG(0);
  clear_has_ll_value();
}
inline ::google::protobuf::int64 CMsgClientStat2_StatDetail::ll_value() const {
  return ll_value_;
}
inline void CMsgClientStat2_StatDetail::set_ll_value(::google::protobuf::int64 value) {
  set_has_ll_value();
  ll_value_ = value;
}

// optional uint32 time_of_day = 3;
inline bool CMsgClientStat2_StatDetail::has_time_of_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientStat2_StatDetail::set_has_time_of_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientStat2_StatDetail::clear_has_time_of_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientStat2_StatDetail::clear_time_of_day() {
  time_of_day_ = 0u;
  clear_has_time_of_day();
}
inline ::google::protobuf::uint32 CMsgClientStat2_StatDetail::time_of_day() const {
  return time_of_day_;
}
inline void CMsgClientStat2_StatDetail::set_time_of_day(::google::protobuf::uint32 value) {
  set_has_time_of_day();
  time_of_day_ = value;
}

// optional uint32 cell_id = 4;
inline bool CMsgClientStat2_StatDetail::has_cell_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientStat2_StatDetail::set_has_cell_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientStat2_StatDetail::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientStat2_StatDetail::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientStat2_StatDetail::cell_id() const {
  return cell_id_;
}
inline void CMsgClientStat2_StatDetail::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional uint32 depot_id = 5;
inline bool CMsgClientStat2_StatDetail::has_depot_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientStat2_StatDetail::set_has_depot_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientStat2_StatDetail::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientStat2_StatDetail::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientStat2_StatDetail::depot_id() const {
  return depot_id_;
}
inline void CMsgClientStat2_StatDetail::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional uint32 app_id = 6;
inline bool CMsgClientStat2_StatDetail::has_app_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientStat2_StatDetail::set_has_app_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientStat2_StatDetail::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientStat2_StatDetail::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientStat2_StatDetail::app_id() const {
  return app_id_;
}
inline void CMsgClientStat2_StatDetail::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientStat2

// repeated .Sc.CMsgClientStat2.StatDetail stat_detail = 1;
inline int CMsgClientStat2::stat_detail_size() const {
  return stat_detail_.size();
}
inline void CMsgClientStat2::clear_stat_detail() {
  stat_detail_.Clear();
}
inline const ::Sc::CMsgClientStat2_StatDetail& CMsgClientStat2::stat_detail(int index) const {
  return stat_detail_.Get(index);
}
inline ::Sc::CMsgClientStat2_StatDetail* CMsgClientStat2::mutable_stat_detail(int index) {
  return stat_detail_.Mutable(index);
}
inline ::Sc::CMsgClientStat2_StatDetail* CMsgClientStat2::add_stat_detail() {
  return stat_detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStat2_StatDetail >&
CMsgClientStat2::stat_detail() const {
  return stat_detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStat2_StatDetail >*
CMsgClientStat2::mutable_stat_detail() {
  return &stat_detail_;
}

// -------------------------------------------------------------------

// CMsgClientMMSCreateLobby

// optional uint32 app_id = 1;
inline bool CMsgClientMMSCreateLobby::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSCreateLobby::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSCreateLobby::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSCreateLobby::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSCreateLobby::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 max_members = 2;
inline bool CMsgClientMMSCreateLobby::has_max_members() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_max_members() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSCreateLobby::clear_has_max_members() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSCreateLobby::clear_max_members() {
  max_members_ = 0;
  clear_has_max_members();
}
inline ::google::protobuf::int32 CMsgClientMMSCreateLobby::max_members() const {
  return max_members_;
}
inline void CMsgClientMMSCreateLobby::set_max_members(::google::protobuf::int32 value) {
  set_has_max_members();
  max_members_ = value;
}

// optional int32 lobby_type = 3;
inline bool CMsgClientMMSCreateLobby::has_lobby_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_lobby_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSCreateLobby::clear_has_lobby_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSCreateLobby::clear_lobby_type() {
  lobby_type_ = 0;
  clear_has_lobby_type();
}
inline ::google::protobuf::int32 CMsgClientMMSCreateLobby::lobby_type() const {
  return lobby_type_;
}
inline void CMsgClientMMSCreateLobby::set_lobby_type(::google::protobuf::int32 value) {
  set_has_lobby_type();
  lobby_type_ = value;
}

// optional int32 lobby_flags = 4;
inline bool CMsgClientMMSCreateLobby::has_lobby_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_lobby_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSCreateLobby::clear_has_lobby_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSCreateLobby::clear_lobby_flags() {
  lobby_flags_ = 0;
  clear_has_lobby_flags();
}
inline ::google::protobuf::int32 CMsgClientMMSCreateLobby::lobby_flags() const {
  return lobby_flags_;
}
inline void CMsgClientMMSCreateLobby::set_lobby_flags(::google::protobuf::int32 value) {
  set_has_lobby_flags();
  lobby_flags_ = value;
}

// optional uint32 cell_id = 5;
inline bool CMsgClientMMSCreateLobby::has_cell_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_cell_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSCreateLobby::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSCreateLobby::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSCreateLobby::cell_id() const {
  return cell_id_;
}
inline void CMsgClientMMSCreateLobby::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional uint32 public_ip = 6;
inline bool CMsgClientMMSCreateLobby::has_public_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_public_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMMSCreateLobby::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMMSCreateLobby::clear_public_ip() {
  public_ip_ = 0u;
  clear_has_public_ip();
}
inline ::google::protobuf::uint32 CMsgClientMMSCreateLobby::public_ip() const {
  return public_ip_;
}
inline void CMsgClientMMSCreateLobby::set_public_ip(::google::protobuf::uint32 value) {
  set_has_public_ip();
  public_ip_ = value;
}

// optional bytes metadata = 7;
inline bool CMsgClientMMSCreateLobby::has_metadata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_metadata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientMMSCreateLobby::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientMMSCreateLobby::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSCreateLobby::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSCreateLobby::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSCreateLobby::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSCreateLobby::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSCreateLobby::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSCreateLobby::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSCreateLobby::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string persona_name_owner = 8;
inline bool CMsgClientMMSCreateLobby::has_persona_name_owner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientMMSCreateLobby::set_has_persona_name_owner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientMMSCreateLobby::clear_has_persona_name_owner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientMMSCreateLobby::clear_persona_name_owner() {
  if (persona_name_owner_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_owner_->clear();
  }
  clear_has_persona_name_owner();
}
inline const ::std::string& CMsgClientMMSCreateLobby::persona_name_owner() const {
  return *persona_name_owner_;
}
inline void CMsgClientMMSCreateLobby::set_persona_name_owner(const ::std::string& value) {
  set_has_persona_name_owner();
  if (persona_name_owner_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_owner_ = new ::std::string;
  }
  persona_name_owner_->assign(value);
}
inline void CMsgClientMMSCreateLobby::set_persona_name_owner(const char* value) {
  set_has_persona_name_owner();
  if (persona_name_owner_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_owner_ = new ::std::string;
  }
  persona_name_owner_->assign(value);
}
inline void CMsgClientMMSCreateLobby::set_persona_name_owner(const char* value, size_t size) {
  set_has_persona_name_owner();
  if (persona_name_owner_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_owner_ = new ::std::string;
  }
  persona_name_owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSCreateLobby::mutable_persona_name_owner() {
  set_has_persona_name_owner();
  if (persona_name_owner_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_owner_ = new ::std::string;
  }
  return persona_name_owner_;
}
inline ::std::string* CMsgClientMMSCreateLobby::release_persona_name_owner() {
  clear_has_persona_name_owner();
  if (persona_name_owner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_owner_;
    persona_name_owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSCreateLobby::set_allocated_persona_name_owner(::std::string* persona_name_owner) {
  if (persona_name_owner_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_owner_;
  }
  if (persona_name_owner) {
    set_has_persona_name_owner();
    persona_name_owner_ = persona_name_owner;
  } else {
    clear_has_persona_name_owner();
    persona_name_owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSCreateLobbyResponse

// optional uint32 app_id = 1;
inline bool CMsgClientMMSCreateLobbyResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSCreateLobbyResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSCreateLobbyResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSCreateLobbyResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSCreateLobbyResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSCreateLobbyResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSCreateLobbyResponse::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSCreateLobbyResponse::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSCreateLobbyResponse::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSCreateLobbyResponse::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSCreateLobbyResponse::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSCreateLobbyResponse::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional int32 eresult = 3 [default = 2];
inline bool CMsgClientMMSCreateLobbyResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSCreateLobbyResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSCreateLobbyResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSCreateLobbyResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMMSCreateLobbyResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMMSCreateLobbyResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSJoinLobby

// optional uint32 app_id = 1;
inline bool CMsgClientMMSJoinLobby::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSJoinLobby::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSJoinLobby::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSJoinLobby::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSJoinLobby::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSJoinLobby::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSJoinLobby::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSJoinLobby::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSJoinLobby::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSJoinLobby::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSJoinLobby::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSJoinLobby::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional string persona_name = 3;
inline bool CMsgClientMMSJoinLobby::has_persona_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSJoinLobby::set_has_persona_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSJoinLobby::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSJoinLobby::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientMMSJoinLobby::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientMMSJoinLobby::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSJoinLobby::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSJoinLobby::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSJoinLobby::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientMMSJoinLobby::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSJoinLobby::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSJoinLobbyResponse_Member

// optional fixed64 steam_id = 1;
inline bool CMsgClientMMSJoinLobbyResponse_Member::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientMMSJoinLobbyResponse_Member::steam_id() const {
  return steam_id_;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional string persona_name = 2;
inline bool CMsgClientMMSJoinLobbyResponse_Member::has_persona_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_has_persona_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientMMSJoinLobbyResponse_Member::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSJoinLobbyResponse_Member::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientMMSJoinLobbyResponse_Member::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes metadata = 3;
inline bool CMsgClientMMSJoinLobbyResponse_Member::has_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_has_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSJoinLobbyResponse_Member::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSJoinLobbyResponse_Member::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSJoinLobbyResponse_Member::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSJoinLobbyResponse_Member::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSJoinLobbyResponse

// optional uint32 app_id = 1;
inline bool CMsgClientMMSJoinLobbyResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSJoinLobbyResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSJoinLobbyResponse::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSJoinLobbyResponse::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional int32 chat_room_enter_response = 3;
inline bool CMsgClientMMSJoinLobbyResponse::has_chat_room_enter_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_chat_room_enter_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_chat_room_enter_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_chat_room_enter_response() {
  chat_room_enter_response_ = 0;
  clear_has_chat_room_enter_response();
}
inline ::google::protobuf::int32 CMsgClientMMSJoinLobbyResponse::chat_room_enter_response() const {
  return chat_room_enter_response_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_chat_room_enter_response(::google::protobuf::int32 value) {
  set_has_chat_room_enter_response();
  chat_room_enter_response_ = value;
}

// optional int32 max_members = 4;
inline bool CMsgClientMMSJoinLobbyResponse::has_max_members() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_max_members() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_max_members() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_max_members() {
  max_members_ = 0;
  clear_has_max_members();
}
inline ::google::protobuf::int32 CMsgClientMMSJoinLobbyResponse::max_members() const {
  return max_members_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_max_members(::google::protobuf::int32 value) {
  set_has_max_members();
  max_members_ = value;
}

// optional int32 lobby_type = 5;
inline bool CMsgClientMMSJoinLobbyResponse::has_lobby_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_lobby_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_lobby_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_lobby_type() {
  lobby_type_ = 0;
  clear_has_lobby_type();
}
inline ::google::protobuf::int32 CMsgClientMMSJoinLobbyResponse::lobby_type() const {
  return lobby_type_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_lobby_type(::google::protobuf::int32 value) {
  set_has_lobby_type();
  lobby_type_ = value;
}

// optional int32 lobby_flags = 6;
inline bool CMsgClientMMSJoinLobbyResponse::has_lobby_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_lobby_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_lobby_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_lobby_flags() {
  lobby_flags_ = 0;
  clear_has_lobby_flags();
}
inline ::google::protobuf::int32 CMsgClientMMSJoinLobbyResponse::lobby_flags() const {
  return lobby_flags_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_lobby_flags(::google::protobuf::int32 value) {
  set_has_lobby_flags();
  lobby_flags_ = value;
}

// optional fixed64 steam_id_owner = 7;
inline bool CMsgClientMMSJoinLobbyResponse::has_steam_id_owner() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_steam_id_owner() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_steam_id_owner() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_steam_id_owner() {
  steam_id_owner_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_owner();
}
inline ::google::protobuf::uint64 CMsgClientMMSJoinLobbyResponse::steam_id_owner() const {
  return steam_id_owner_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_steam_id_owner(::google::protobuf::uint64 value) {
  set_has_steam_id_owner();
  steam_id_owner_ = value;
}

// optional bytes metadata = 8;
inline bool CMsgClientMMSJoinLobbyResponse::has_metadata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientMMSJoinLobbyResponse::set_has_metadata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientMMSJoinLobbyResponse::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSJoinLobbyResponse::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSJoinLobbyResponse::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSJoinLobbyResponse::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSJoinLobbyResponse::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSJoinLobbyResponse::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSJoinLobbyResponse::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSJoinLobbyResponse::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Sc.CMsgClientMMSJoinLobbyResponse.Member members = 9;
inline int CMsgClientMMSJoinLobbyResponse::members_size() const {
  return members_.size();
}
inline void CMsgClientMMSJoinLobbyResponse::clear_members() {
  members_.Clear();
}
inline const ::Sc::CMsgClientMMSJoinLobbyResponse_Member& CMsgClientMMSJoinLobbyResponse::members(int index) const {
  return members_.Get(index);
}
inline ::Sc::CMsgClientMMSJoinLobbyResponse_Member* CMsgClientMMSJoinLobbyResponse::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::Sc::CMsgClientMMSJoinLobbyResponse_Member* CMsgClientMMSJoinLobbyResponse::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSJoinLobbyResponse_Member >&
CMsgClientMMSJoinLobbyResponse::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSJoinLobbyResponse_Member >*
CMsgClientMMSJoinLobbyResponse::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// CMsgClientMMSLeaveLobby

// optional uint32 app_id = 1;
inline bool CMsgClientMMSLeaveLobby::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSLeaveLobby::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSLeaveLobby::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSLeaveLobby::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSLeaveLobby::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSLeaveLobby::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSLeaveLobby::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSLeaveLobby::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSLeaveLobby::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSLeaveLobby::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSLeaveLobby::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSLeaveLobby::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSLeaveLobbyResponse

// optional uint32 app_id = 1;
inline bool CMsgClientMMSLeaveLobbyResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSLeaveLobbyResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSLeaveLobbyResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSLeaveLobbyResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSLeaveLobbyResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSLeaveLobbyResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSLeaveLobbyResponse::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSLeaveLobbyResponse::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSLeaveLobbyResponse::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSLeaveLobbyResponse::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSLeaveLobbyResponse::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSLeaveLobbyResponse::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional int32 eresult = 3 [default = 2];
inline bool CMsgClientMMSLeaveLobbyResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSLeaveLobbyResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSLeaveLobbyResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSLeaveLobbyResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMMSLeaveLobbyResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMMSLeaveLobbyResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSGetLobbyList_Filter

// optional string key = 1;
inline bool CMsgClientMMSGetLobbyList_Filter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CMsgClientMMSGetLobbyList_Filter::key() const {
  return *key_;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CMsgClientMMSGetLobbyList_Filter::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CMsgClientMMSGetLobbyList_Filter::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSGetLobbyList_Filter::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CMsgClientMMSGetLobbyList_Filter::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSGetLobbyList_Filter::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool CMsgClientMMSGetLobbyList_Filter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CMsgClientMMSGetLobbyList_Filter::value() const {
  return *value_;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CMsgClientMMSGetLobbyList_Filter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CMsgClientMMSGetLobbyList_Filter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSGetLobbyList_Filter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CMsgClientMMSGetLobbyList_Filter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSGetLobbyList_Filter::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 comparision = 3;
inline bool CMsgClientMMSGetLobbyList_Filter::has_comparision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_has_comparision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_has_comparision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_comparision() {
  comparision_ = 0;
  clear_has_comparision();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyList_Filter::comparision() const {
  return comparision_;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_comparision(::google::protobuf::int32 value) {
  set_has_comparision();
  comparision_ = value;
}

// optional int32 filter_type = 4;
inline bool CMsgClientMMSGetLobbyList_Filter::has_filter_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_has_filter_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_has_filter_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSGetLobbyList_Filter::clear_filter_type() {
  filter_type_ = 0;
  clear_has_filter_type();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyList_Filter::filter_type() const {
  return filter_type_;
}
inline void CMsgClientMMSGetLobbyList_Filter::set_filter_type(::google::protobuf::int32 value) {
  set_has_filter_type();
  filter_type_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSGetLobbyList

// optional uint32 app_id = 1;
inline bool CMsgClientMMSGetLobbyList::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSGetLobbyList::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSGetLobbyList::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSGetLobbyList::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSGetLobbyList::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSGetLobbyList::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 num_lobbies_requested = 3;
inline bool CMsgClientMMSGetLobbyList::has_num_lobbies_requested() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSGetLobbyList::set_has_num_lobbies_requested() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSGetLobbyList::clear_has_num_lobbies_requested() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSGetLobbyList::clear_num_lobbies_requested() {
  num_lobbies_requested_ = 0;
  clear_has_num_lobbies_requested();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyList::num_lobbies_requested() const {
  return num_lobbies_requested_;
}
inline void CMsgClientMMSGetLobbyList::set_num_lobbies_requested(::google::protobuf::int32 value) {
  set_has_num_lobbies_requested();
  num_lobbies_requested_ = value;
}

// optional uint32 cell_id = 4;
inline bool CMsgClientMMSGetLobbyList::has_cell_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSGetLobbyList::set_has_cell_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSGetLobbyList::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSGetLobbyList::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSGetLobbyList::cell_id() const {
  return cell_id_;
}
inline void CMsgClientMMSGetLobbyList::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional uint32 public_ip = 5;
inline bool CMsgClientMMSGetLobbyList::has_public_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSGetLobbyList::set_has_public_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSGetLobbyList::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSGetLobbyList::clear_public_ip() {
  public_ip_ = 0u;
  clear_has_public_ip();
}
inline ::google::protobuf::uint32 CMsgClientMMSGetLobbyList::public_ip() const {
  return public_ip_;
}
inline void CMsgClientMMSGetLobbyList::set_public_ip(::google::protobuf::uint32 value) {
  set_has_public_ip();
  public_ip_ = value;
}

// repeated .Sc.CMsgClientMMSGetLobbyList.Filter filters = 6;
inline int CMsgClientMMSGetLobbyList::filters_size() const {
  return filters_.size();
}
inline void CMsgClientMMSGetLobbyList::clear_filters() {
  filters_.Clear();
}
inline const ::Sc::CMsgClientMMSGetLobbyList_Filter& CMsgClientMMSGetLobbyList::filters(int index) const {
  return filters_.Get(index);
}
inline ::Sc::CMsgClientMMSGetLobbyList_Filter* CMsgClientMMSGetLobbyList::mutable_filters(int index) {
  return filters_.Mutable(index);
}
inline ::Sc::CMsgClientMMSGetLobbyList_Filter* CMsgClientMMSGetLobbyList::add_filters() {
  return filters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyList_Filter >&
CMsgClientMMSGetLobbyList::filters() const {
  return filters_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyList_Filter >*
CMsgClientMMSGetLobbyList::mutable_filters() {
  return &filters_;
}

// -------------------------------------------------------------------

// CMsgClientMMSGetLobbyListResponse_Lobby

// optional fixed64 steam_id = 1;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientMMSGetLobbyListResponse_Lobby::steam_id() const {
  return steam_id_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional int32 max_members = 2;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_max_members() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_max_members() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_max_members() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_max_members() {
  max_members_ = 0;
  clear_has_max_members();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyListResponse_Lobby::max_members() const {
  return max_members_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_max_members(::google::protobuf::int32 value) {
  set_has_max_members();
  max_members_ = value;
}

// optional int32 lobby_type = 3;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_lobby_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_lobby_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_lobby_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_lobby_type() {
  lobby_type_ = 0;
  clear_has_lobby_type();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyListResponse_Lobby::lobby_type() const {
  return lobby_type_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_lobby_type(::google::protobuf::int32 value) {
  set_has_lobby_type();
  lobby_type_ = value;
}

// optional int32 lobby_flags = 4;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_lobby_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_lobby_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_lobby_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_lobby_flags() {
  lobby_flags_ = 0;
  clear_has_lobby_flags();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyListResponse_Lobby::lobby_flags() const {
  return lobby_flags_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_lobby_flags(::google::protobuf::int32 value) {
  set_has_lobby_flags();
  lobby_flags_ = value;
}

// optional bytes metadata = 5;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_metadata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_metadata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSGetLobbyListResponse_Lobby::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSGetLobbyListResponse_Lobby::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSGetLobbyListResponse_Lobby::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num_members = 6;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_num_members() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_num_members() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_num_members() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_num_members() {
  num_members_ = 0;
  clear_has_num_members();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyListResponse_Lobby::num_members() const {
  return num_members_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_num_members(::google::protobuf::int32 value) {
  set_has_num_members();
  num_members_ = value;
}

// optional float distance = 7;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float CMsgClientMMSGetLobbyListResponse_Lobby::distance() const {
  return distance_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_distance(float value) {
  set_has_distance();
  distance_ = value;
}

// optional int64 weight = 8;
inline bool CMsgClientMMSGetLobbyListResponse_Lobby::has_weight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_has_weight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_has_weight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::clear_weight() {
  weight_ = GOOGLE_LONGLONG(0);
  clear_has_weight();
}
inline ::google::protobuf::int64 CMsgClientMMSGetLobbyListResponse_Lobby::weight() const {
  return weight_;
}
inline void CMsgClientMMSGetLobbyListResponse_Lobby::set_weight(::google::protobuf::int64 value) {
  set_has_weight();
  weight_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSGetLobbyListResponse

// optional uint32 app_id = 1;
inline bool CMsgClientMMSGetLobbyListResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSGetLobbyListResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSGetLobbyListResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSGetLobbyListResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSGetLobbyListResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 eresult = 3 [default = 2];
inline bool CMsgClientMMSGetLobbyListResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSGetLobbyListResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSGetLobbyListResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSGetLobbyListResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMMSGetLobbyListResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMMSGetLobbyListResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientMMSGetLobbyListResponse.Lobby lobbies = 4;
inline int CMsgClientMMSGetLobbyListResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgClientMMSGetLobbyListResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline const ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby& CMsgClientMMSGetLobbyListResponse::lobbies(int index) const {
  return lobbies_.Get(index);
}
inline ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby* CMsgClientMMSGetLobbyListResponse::mutable_lobbies(int index) {
  return lobbies_.Mutable(index);
}
inline ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby* CMsgClientMMSGetLobbyListResponse::add_lobbies() {
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby >&
CMsgClientMMSGetLobbyListResponse::lobbies() const {
  return lobbies_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSGetLobbyListResponse_Lobby >*
CMsgClientMMSGetLobbyListResponse::mutable_lobbies() {
  return &lobbies_;
}

// -------------------------------------------------------------------

// CMsgClientMMSSetLobbyData

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSetLobbyData::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSetLobbyData::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyData::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSetLobbyData::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSetLobbyData::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSetLobbyData::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyData::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSetLobbyData::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_member = 3;
inline bool CMsgClientMMSSetLobbyData::has_steam_id_member() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_steam_id_member() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_steam_id_member() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSetLobbyData::clear_steam_id_member() {
  steam_id_member_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_member();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyData::steam_id_member() const {
  return steam_id_member_;
}
inline void CMsgClientMMSSetLobbyData::set_steam_id_member(::google::protobuf::uint64 value) {
  set_has_steam_id_member();
  steam_id_member_ = value;
}

// optional int32 max_members = 4;
inline bool CMsgClientMMSSetLobbyData::has_max_members() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_max_members() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_max_members() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSSetLobbyData::clear_max_members() {
  max_members_ = 0;
  clear_has_max_members();
}
inline ::google::protobuf::int32 CMsgClientMMSSetLobbyData::max_members() const {
  return max_members_;
}
inline void CMsgClientMMSSetLobbyData::set_max_members(::google::protobuf::int32 value) {
  set_has_max_members();
  max_members_ = value;
}

// optional int32 lobby_type = 5;
inline bool CMsgClientMMSSetLobbyData::has_lobby_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_lobby_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_lobby_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSSetLobbyData::clear_lobby_type() {
  lobby_type_ = 0;
  clear_has_lobby_type();
}
inline ::google::protobuf::int32 CMsgClientMMSSetLobbyData::lobby_type() const {
  return lobby_type_;
}
inline void CMsgClientMMSSetLobbyData::set_lobby_type(::google::protobuf::int32 value) {
  set_has_lobby_type();
  lobby_type_ = value;
}

// optional int32 lobby_flags = 6;
inline bool CMsgClientMMSSetLobbyData::has_lobby_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_lobby_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_lobby_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMMSSetLobbyData::clear_lobby_flags() {
  lobby_flags_ = 0;
  clear_has_lobby_flags();
}
inline ::google::protobuf::int32 CMsgClientMMSSetLobbyData::lobby_flags() const {
  return lobby_flags_;
}
inline void CMsgClientMMSSetLobbyData::set_lobby_flags(::google::protobuf::int32 value) {
  set_has_lobby_flags();
  lobby_flags_ = value;
}

// optional bytes metadata = 7;
inline bool CMsgClientMMSSetLobbyData::has_metadata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientMMSSetLobbyData::set_has_metadata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientMMSSetLobbyData::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientMMSSetLobbyData::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSSetLobbyData::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSSetLobbyData::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSSetLobbyData::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSSetLobbyData::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSSetLobbyData::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSSetLobbyData::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSSetLobbyData::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSSetLobbyDataResponse

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSetLobbyDataResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSetLobbyDataResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSetLobbyDataResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSetLobbyDataResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyDataResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSetLobbyDataResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSetLobbyDataResponse::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSetLobbyDataResponse::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSetLobbyDataResponse::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSetLobbyDataResponse::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyDataResponse::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSetLobbyDataResponse::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional int32 eresult = 3 [default = 2];
inline bool CMsgClientMMSSetLobbyDataResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSetLobbyDataResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSetLobbyDataResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSetLobbyDataResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMMSSetLobbyDataResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMMSSetLobbyDataResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSGetLobbyData

// optional uint32 app_id = 1;
inline bool CMsgClientMMSGetLobbyData::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSGetLobbyData::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSGetLobbyData::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSGetLobbyData::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSGetLobbyData::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSGetLobbyData::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSGetLobbyData::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSGetLobbyData::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSGetLobbyData::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSGetLobbyData::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSGetLobbyData::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSGetLobbyData::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSLobbyData_Member

// optional fixed64 steam_id = 1;
inline bool CMsgClientMMSLobbyData_Member::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSLobbyData_Member::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSLobbyData_Member::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSLobbyData_Member::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyData_Member::steam_id() const {
  return steam_id_;
}
inline void CMsgClientMMSLobbyData_Member::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional string persona_name = 2;
inline bool CMsgClientMMSLobbyData_Member::has_persona_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSLobbyData_Member::set_has_persona_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSLobbyData_Member::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSLobbyData_Member::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientMMSLobbyData_Member::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientMMSLobbyData_Member::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSLobbyData_Member::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSLobbyData_Member::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSLobbyData_Member::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientMMSLobbyData_Member::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSLobbyData_Member::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes metadata = 3;
inline bool CMsgClientMMSLobbyData_Member::has_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSLobbyData_Member::set_has_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSLobbyData_Member::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSLobbyData_Member::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSLobbyData_Member::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSLobbyData_Member::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSLobbyData_Member::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSLobbyData_Member::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSLobbyData_Member::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSLobbyData_Member::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSLobbyData_Member::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSLobbyData

// optional uint32 app_id = 1;
inline bool CMsgClientMMSLobbyData::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSLobbyData::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSLobbyData::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSLobbyData::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSLobbyData::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSLobbyData::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSLobbyData::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSLobbyData::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyData::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSLobbyData::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional int32 num_members = 3;
inline bool CMsgClientMMSLobbyData::has_num_members() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_num_members() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSLobbyData::clear_has_num_members() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSLobbyData::clear_num_members() {
  num_members_ = 0;
  clear_has_num_members();
}
inline ::google::protobuf::int32 CMsgClientMMSLobbyData::num_members() const {
  return num_members_;
}
inline void CMsgClientMMSLobbyData::set_num_members(::google::protobuf::int32 value) {
  set_has_num_members();
  num_members_ = value;
}

// optional int32 max_members = 4;
inline bool CMsgClientMMSLobbyData::has_max_members() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_max_members() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSLobbyData::clear_has_max_members() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSLobbyData::clear_max_members() {
  max_members_ = 0;
  clear_has_max_members();
}
inline ::google::protobuf::int32 CMsgClientMMSLobbyData::max_members() const {
  return max_members_;
}
inline void CMsgClientMMSLobbyData::set_max_members(::google::protobuf::int32 value) {
  set_has_max_members();
  max_members_ = value;
}

// optional int32 lobby_type = 5;
inline bool CMsgClientMMSLobbyData::has_lobby_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_lobby_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSLobbyData::clear_has_lobby_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSLobbyData::clear_lobby_type() {
  lobby_type_ = 0;
  clear_has_lobby_type();
}
inline ::google::protobuf::int32 CMsgClientMMSLobbyData::lobby_type() const {
  return lobby_type_;
}
inline void CMsgClientMMSLobbyData::set_lobby_type(::google::protobuf::int32 value) {
  set_has_lobby_type();
  lobby_type_ = value;
}

// optional int32 lobby_flags = 6;
inline bool CMsgClientMMSLobbyData::has_lobby_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_lobby_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMMSLobbyData::clear_has_lobby_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMMSLobbyData::clear_lobby_flags() {
  lobby_flags_ = 0;
  clear_has_lobby_flags();
}
inline ::google::protobuf::int32 CMsgClientMMSLobbyData::lobby_flags() const {
  return lobby_flags_;
}
inline void CMsgClientMMSLobbyData::set_lobby_flags(::google::protobuf::int32 value) {
  set_has_lobby_flags();
  lobby_flags_ = value;
}

// optional fixed64 steam_id_owner = 7;
inline bool CMsgClientMMSLobbyData::has_steam_id_owner() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_steam_id_owner() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientMMSLobbyData::clear_has_steam_id_owner() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientMMSLobbyData::clear_steam_id_owner() {
  steam_id_owner_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_owner();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyData::steam_id_owner() const {
  return steam_id_owner_;
}
inline void CMsgClientMMSLobbyData::set_steam_id_owner(::google::protobuf::uint64 value) {
  set_has_steam_id_owner();
  steam_id_owner_ = value;
}

// optional bytes metadata = 8;
inline bool CMsgClientMMSLobbyData::has_metadata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_metadata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientMMSLobbyData::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientMMSLobbyData::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& CMsgClientMMSLobbyData::metadata() const {
  return *metadata_;
}
inline void CMsgClientMMSLobbyData::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSLobbyData::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
}
inline void CMsgClientMMSLobbyData::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSLobbyData::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    metadata_ = new ::std::string;
  }
  return metadata_;
}
inline ::std::string* CMsgClientMMSLobbyData::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSLobbyData::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::kEmptyString) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Sc.CMsgClientMMSLobbyData.Member members = 9;
inline int CMsgClientMMSLobbyData::members_size() const {
  return members_.size();
}
inline void CMsgClientMMSLobbyData::clear_members() {
  members_.Clear();
}
inline const ::Sc::CMsgClientMMSLobbyData_Member& CMsgClientMMSLobbyData::members(int index) const {
  return members_.Get(index);
}
inline ::Sc::CMsgClientMMSLobbyData_Member* CMsgClientMMSLobbyData::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::Sc::CMsgClientMMSLobbyData_Member* CMsgClientMMSLobbyData::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSLobbyData_Member >&
CMsgClientMMSLobbyData::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMMSLobbyData_Member >*
CMsgClientMMSLobbyData::mutable_members() {
  return &members_;
}

// optional uint32 lobby_cellid = 10;
inline bool CMsgClientMMSLobbyData::has_lobby_cellid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientMMSLobbyData::set_has_lobby_cellid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientMMSLobbyData::clear_has_lobby_cellid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientMMSLobbyData::clear_lobby_cellid() {
  lobby_cellid_ = 0u;
  clear_has_lobby_cellid();
}
inline ::google::protobuf::uint32 CMsgClientMMSLobbyData::lobby_cellid() const {
  return lobby_cellid_;
}
inline void CMsgClientMMSLobbyData::set_lobby_cellid(::google::protobuf::uint32 value) {
  set_has_lobby_cellid();
  lobby_cellid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSSendLobbyChatMsg

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSendLobbyChatMsg::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSendLobbyChatMsg::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSendLobbyChatMsg::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSendLobbyChatMsg::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_target = 3;
inline bool CMsgClientMMSSendLobbyChatMsg::has_steam_id_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_has_steam_id_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_has_steam_id_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_steam_id_target() {
  steam_id_target_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_target();
}
inline ::google::protobuf::uint64 CMsgClientMMSSendLobbyChatMsg::steam_id_target() const {
  return steam_id_target_;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_steam_id_target(::google::protobuf::uint64 value) {
  set_has_steam_id_target();
  steam_id_target_ = value;
}

// optional bytes lobby_message = 4;
inline bool CMsgClientMMSSendLobbyChatMsg::has_lobby_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_has_lobby_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_has_lobby_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSSendLobbyChatMsg::clear_lobby_message() {
  if (lobby_message_ != &::google::protobuf::internal::kEmptyString) {
    lobby_message_->clear();
  }
  clear_has_lobby_message();
}
inline const ::std::string& CMsgClientMMSSendLobbyChatMsg::lobby_message() const {
  return *lobby_message_;
}
inline void CMsgClientMMSSendLobbyChatMsg::set_lobby_message(const ::std::string& value) {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  lobby_message_->assign(value);
}
inline void CMsgClientMMSSendLobbyChatMsg::set_lobby_message(const char* value) {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  lobby_message_->assign(value);
}
inline void CMsgClientMMSSendLobbyChatMsg::set_lobby_message(const void* value, size_t size) {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  lobby_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSSendLobbyChatMsg::mutable_lobby_message() {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  return lobby_message_;
}
inline ::std::string* CMsgClientMMSSendLobbyChatMsg::release_lobby_message() {
  clear_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lobby_message_;
    lobby_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSSendLobbyChatMsg::set_allocated_lobby_message(::std::string* lobby_message) {
  if (lobby_message_ != &::google::protobuf::internal::kEmptyString) {
    delete lobby_message_;
  }
  if (lobby_message) {
    set_has_lobby_message();
    lobby_message_ = lobby_message;
  } else {
    clear_has_lobby_message();
    lobby_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSLobbyChatMsg

// optional uint32 app_id = 1;
inline bool CMsgClientMMSLobbyChatMsg::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSLobbyChatMsg::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSLobbyChatMsg::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSLobbyChatMsg::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSLobbyChatMsg::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSLobbyChatMsg::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyChatMsg::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSLobbyChatMsg::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_sender = 3;
inline bool CMsgClientMMSLobbyChatMsg::has_steam_id_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSLobbyChatMsg::set_has_steam_id_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_has_steam_id_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_steam_id_sender() {
  steam_id_sender_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_sender();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyChatMsg::steam_id_sender() const {
  return steam_id_sender_;
}
inline void CMsgClientMMSLobbyChatMsg::set_steam_id_sender(::google::protobuf::uint64 value) {
  set_has_steam_id_sender();
  steam_id_sender_ = value;
}

// optional bytes lobby_message = 4;
inline bool CMsgClientMMSLobbyChatMsg::has_lobby_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSLobbyChatMsg::set_has_lobby_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_has_lobby_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSLobbyChatMsg::clear_lobby_message() {
  if (lobby_message_ != &::google::protobuf::internal::kEmptyString) {
    lobby_message_->clear();
  }
  clear_has_lobby_message();
}
inline const ::std::string& CMsgClientMMSLobbyChatMsg::lobby_message() const {
  return *lobby_message_;
}
inline void CMsgClientMMSLobbyChatMsg::set_lobby_message(const ::std::string& value) {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  lobby_message_->assign(value);
}
inline void CMsgClientMMSLobbyChatMsg::set_lobby_message(const char* value) {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  lobby_message_->assign(value);
}
inline void CMsgClientMMSLobbyChatMsg::set_lobby_message(const void* value, size_t size) {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  lobby_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSLobbyChatMsg::mutable_lobby_message() {
  set_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    lobby_message_ = new ::std::string;
  }
  return lobby_message_;
}
inline ::std::string* CMsgClientMMSLobbyChatMsg::release_lobby_message() {
  clear_has_lobby_message();
  if (lobby_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lobby_message_;
    lobby_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSLobbyChatMsg::set_allocated_lobby_message(::std::string* lobby_message) {
  if (lobby_message_ != &::google::protobuf::internal::kEmptyString) {
    delete lobby_message_;
  }
  if (lobby_message) {
    set_has_lobby_message();
    lobby_message_ = lobby_message;
  } else {
    clear_has_lobby_message();
    lobby_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSSetLobbyOwner

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSetLobbyOwner::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSetLobbyOwner::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSetLobbyOwner::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSetLobbyOwner::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyOwner::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSetLobbyOwner::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSetLobbyOwner::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSetLobbyOwner::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSetLobbyOwner::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSetLobbyOwner::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyOwner::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSetLobbyOwner::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_new_owner = 3;
inline bool CMsgClientMMSSetLobbyOwner::has_steam_id_new_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSetLobbyOwner::set_has_steam_id_new_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSetLobbyOwner::clear_has_steam_id_new_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSetLobbyOwner::clear_steam_id_new_owner() {
  steam_id_new_owner_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_new_owner();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyOwner::steam_id_new_owner() const {
  return steam_id_new_owner_;
}
inline void CMsgClientMMSSetLobbyOwner::set_steam_id_new_owner(::google::protobuf::uint64 value) {
  set_has_steam_id_new_owner();
  steam_id_new_owner_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSSetLobbyOwnerResponse

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSetLobbyOwnerResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyOwnerResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSetLobbyOwnerResponse::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyOwnerResponse::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional int32 eresult = 3 [default = 2];
inline bool CMsgClientMMSSetLobbyOwnerResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMMSSetLobbyOwnerResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMMSSetLobbyOwnerResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSSetLobbyLinked

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSetLobbyLinked::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSetLobbyLinked::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSetLobbyLinked::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSetLobbyLinked::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyLinked::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSetLobbyLinked::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSetLobbyLinked::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSetLobbyLinked::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSetLobbyLinked::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSetLobbyLinked::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyLinked::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSetLobbyLinked::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_lobby2 = 3;
inline bool CMsgClientMMSSetLobbyLinked::has_steam_id_lobby2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSetLobbyLinked::set_has_steam_id_lobby2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSetLobbyLinked::clear_has_steam_id_lobby2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSetLobbyLinked::clear_steam_id_lobby2() {
  steam_id_lobby2_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby2();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyLinked::steam_id_lobby2() const {
  return steam_id_lobby2_;
}
inline void CMsgClientMMSSetLobbyLinked::set_steam_id_lobby2(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby2();
  steam_id_lobby2_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSSetLobbyGameServer

// optional uint32 app_id = 1;
inline bool CMsgClientMMSSetLobbyGameServer::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSSetLobbyGameServer::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyGameServer::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSSetLobbyGameServer::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSSetLobbyGameServer::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSSetLobbyGameServer::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyGameServer::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSSetLobbyGameServer::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional uint32 game_server_ip = 3;
inline bool CMsgClientMMSSetLobbyGameServer::has_game_server_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSSetLobbyGameServer::set_has_game_server_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_has_game_server_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_game_server_ip() {
  game_server_ip_ = 0u;
  clear_has_game_server_ip();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyGameServer::game_server_ip() const {
  return game_server_ip_;
}
inline void CMsgClientMMSSetLobbyGameServer::set_game_server_ip(::google::protobuf::uint32 value) {
  set_has_game_server_ip();
  game_server_ip_ = value;
}

// optional uint32 game_server_port = 4;
inline bool CMsgClientMMSSetLobbyGameServer::has_game_server_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSSetLobbyGameServer::set_has_game_server_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_has_game_server_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_game_server_port() {
  game_server_port_ = 0u;
  clear_has_game_server_port();
}
inline ::google::protobuf::uint32 CMsgClientMMSSetLobbyGameServer::game_server_port() const {
  return game_server_port_;
}
inline void CMsgClientMMSSetLobbyGameServer::set_game_server_port(::google::protobuf::uint32 value) {
  set_has_game_server_port();
  game_server_port_ = value;
}

// optional fixed64 game_server_steam_id = 5;
inline bool CMsgClientMMSSetLobbyGameServer::has_game_server_steam_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSSetLobbyGameServer::set_has_game_server_steam_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_has_game_server_steam_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSSetLobbyGameServer::clear_game_server_steam_id() {
  game_server_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_server_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientMMSSetLobbyGameServer::game_server_steam_id() const {
  return game_server_steam_id_;
}
inline void CMsgClientMMSSetLobbyGameServer::set_game_server_steam_id(::google::protobuf::uint64 value) {
  set_has_game_server_steam_id();
  game_server_steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSLobbyGameServerSet

// optional uint32 app_id = 1;
inline bool CMsgClientMMSLobbyGameServerSet::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSLobbyGameServerSet::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSLobbyGameServerSet::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSLobbyGameServerSet::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSLobbyGameServerSet::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSLobbyGameServerSet::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyGameServerSet::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSLobbyGameServerSet::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional uint32 game_server_ip = 3;
inline bool CMsgClientMMSLobbyGameServerSet::has_game_server_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSLobbyGameServerSet::set_has_game_server_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_has_game_server_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_game_server_ip() {
  game_server_ip_ = 0u;
  clear_has_game_server_ip();
}
inline ::google::protobuf::uint32 CMsgClientMMSLobbyGameServerSet::game_server_ip() const {
  return game_server_ip_;
}
inline void CMsgClientMMSLobbyGameServerSet::set_game_server_ip(::google::protobuf::uint32 value) {
  set_has_game_server_ip();
  game_server_ip_ = value;
}

// optional uint32 game_server_port = 4;
inline bool CMsgClientMMSLobbyGameServerSet::has_game_server_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSLobbyGameServerSet::set_has_game_server_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_has_game_server_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_game_server_port() {
  game_server_port_ = 0u;
  clear_has_game_server_port();
}
inline ::google::protobuf::uint32 CMsgClientMMSLobbyGameServerSet::game_server_port() const {
  return game_server_port_;
}
inline void CMsgClientMMSLobbyGameServerSet::set_game_server_port(::google::protobuf::uint32 value) {
  set_has_game_server_port();
  game_server_port_ = value;
}

// optional fixed64 game_server_steam_id = 5;
inline bool CMsgClientMMSLobbyGameServerSet::has_game_server_steam_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMMSLobbyGameServerSet::set_has_game_server_steam_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_has_game_server_steam_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMMSLobbyGameServerSet::clear_game_server_steam_id() {
  game_server_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_server_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientMMSLobbyGameServerSet::game_server_steam_id() const {
  return game_server_steam_id_;
}
inline void CMsgClientMMSLobbyGameServerSet::set_game_server_steam_id(::google::protobuf::uint64 value) {
  set_has_game_server_steam_id();
  game_server_steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMMSUserJoinedLobby

// optional uint32 app_id = 1;
inline bool CMsgClientMMSUserJoinedLobby::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSUserJoinedLobby::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSUserJoinedLobby::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSUserJoinedLobby::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSUserJoinedLobby::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSUserJoinedLobby::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSUserJoinedLobby::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSUserJoinedLobby::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_user = 3;
inline bool CMsgClientMMSUserJoinedLobby::has_steam_id_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSUserJoinedLobby::set_has_steam_id_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_has_steam_id_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_steam_id_user() {
  steam_id_user_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_user();
}
inline ::google::protobuf::uint64 CMsgClientMMSUserJoinedLobby::steam_id_user() const {
  return steam_id_user_;
}
inline void CMsgClientMMSUserJoinedLobby::set_steam_id_user(::google::protobuf::uint64 value) {
  set_has_steam_id_user();
  steam_id_user_ = value;
}

// optional string persona_name = 4;
inline bool CMsgClientMMSUserJoinedLobby::has_persona_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSUserJoinedLobby::set_has_persona_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSUserJoinedLobby::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientMMSUserJoinedLobby::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientMMSUserJoinedLobby::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSUserJoinedLobby::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSUserJoinedLobby::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSUserJoinedLobby::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientMMSUserJoinedLobby::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSUserJoinedLobby::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSUserLeftLobby

// optional uint32 app_id = 1;
inline bool CMsgClientMMSUserLeftLobby::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSUserLeftLobby::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSUserLeftLobby::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSUserLeftLobby::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSUserLeftLobby::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSUserLeftLobby::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSUserLeftLobby::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSUserLeftLobby::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSUserLeftLobby::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSUserLeftLobby::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSUserLeftLobby::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSUserLeftLobby::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_user = 3;
inline bool CMsgClientMMSUserLeftLobby::has_steam_id_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSUserLeftLobby::set_has_steam_id_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSUserLeftLobby::clear_has_steam_id_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSUserLeftLobby::clear_steam_id_user() {
  steam_id_user_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_user();
}
inline ::google::protobuf::uint64 CMsgClientMMSUserLeftLobby::steam_id_user() const {
  return steam_id_user_;
}
inline void CMsgClientMMSUserLeftLobby::set_steam_id_user(::google::protobuf::uint64 value) {
  set_has_steam_id_user();
  steam_id_user_ = value;
}

// optional string persona_name = 4;
inline bool CMsgClientMMSUserLeftLobby::has_persona_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMMSUserLeftLobby::set_has_persona_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMMSUserLeftLobby::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMMSUserLeftLobby::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientMMSUserLeftLobby::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientMMSUserLeftLobby::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSUserLeftLobby::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientMMSUserLeftLobby::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMMSUserLeftLobby::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientMMSUserLeftLobby::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMMSUserLeftLobby::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMMSInviteToLobby

// optional uint32 app_id = 1;
inline bool CMsgClientMMSInviteToLobby::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMMSInviteToLobby::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMMSInviteToLobby::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMMSInviteToLobby::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientMMSInviteToLobby::app_id() const {
  return app_id_;
}
inline void CMsgClientMMSInviteToLobby::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 steam_id_lobby = 2;
inline bool CMsgClientMMSInviteToLobby::has_steam_id_lobby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMMSInviteToLobby::set_has_steam_id_lobby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMMSInviteToLobby::clear_has_steam_id_lobby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMMSInviteToLobby::clear_steam_id_lobby() {
  steam_id_lobby_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_lobby();
}
inline ::google::protobuf::uint64 CMsgClientMMSInviteToLobby::steam_id_lobby() const {
  return steam_id_lobby_;
}
inline void CMsgClientMMSInviteToLobby::set_steam_id_lobby(::google::protobuf::uint64 value) {
  set_has_steam_id_lobby();
  steam_id_lobby_ = value;
}

// optional fixed64 steam_id_user_invited = 3;
inline bool CMsgClientMMSInviteToLobby::has_steam_id_user_invited() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMMSInviteToLobby::set_has_steam_id_user_invited() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMMSInviteToLobby::clear_has_steam_id_user_invited() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMMSInviteToLobby::clear_steam_id_user_invited() {
  steam_id_user_invited_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_user_invited();
}
inline ::google::protobuf::uint64 CMsgClientMMSInviteToLobby::steam_id_user_invited() const {
  return steam_id_user_invited_;
}
inline void CMsgClientMMSInviteToLobby::set_steam_id_user_invited(::google::protobuf::uint64 value) {
  set_has_steam_id_user_invited();
  steam_id_user_invited_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUDSInviteToGame

// optional fixed64 steam_id_dest = 1;
inline bool CMsgClientUDSInviteToGame::has_steam_id_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUDSInviteToGame::set_has_steam_id_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUDSInviteToGame::clear_has_steam_id_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUDSInviteToGame::clear_steam_id_dest() {
  steam_id_dest_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_dest();
}
inline ::google::protobuf::uint64 CMsgClientUDSInviteToGame::steam_id_dest() const {
  return steam_id_dest_;
}
inline void CMsgClientUDSInviteToGame::set_steam_id_dest(::google::protobuf::uint64 value) {
  set_has_steam_id_dest();
  steam_id_dest_ = value;
}

// optional fixed64 steam_id_src = 2;
inline bool CMsgClientUDSInviteToGame::has_steam_id_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUDSInviteToGame::set_has_steam_id_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUDSInviteToGame::clear_has_steam_id_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUDSInviteToGame::clear_steam_id_src() {
  steam_id_src_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_src();
}
inline ::google::protobuf::uint64 CMsgClientUDSInviteToGame::steam_id_src() const {
  return steam_id_src_;
}
inline void CMsgClientUDSInviteToGame::set_steam_id_src(::google::protobuf::uint64 value) {
  set_has_steam_id_src();
  steam_id_src_ = value;
}

// optional string connect_string = 3;
inline bool CMsgClientUDSInviteToGame::has_connect_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUDSInviteToGame::set_has_connect_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUDSInviteToGame::clear_has_connect_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUDSInviteToGame::clear_connect_string() {
  if (connect_string_ != &::google::protobuf::internal::kEmptyString) {
    connect_string_->clear();
  }
  clear_has_connect_string();
}
inline const ::std::string& CMsgClientUDSInviteToGame::connect_string() const {
  return *connect_string_;
}
inline void CMsgClientUDSInviteToGame::set_connect_string(const ::std::string& value) {
  set_has_connect_string();
  if (connect_string_ == &::google::protobuf::internal::kEmptyString) {
    connect_string_ = new ::std::string;
  }
  connect_string_->assign(value);
}
inline void CMsgClientUDSInviteToGame::set_connect_string(const char* value) {
  set_has_connect_string();
  if (connect_string_ == &::google::protobuf::internal::kEmptyString) {
    connect_string_ = new ::std::string;
  }
  connect_string_->assign(value);
}
inline void CMsgClientUDSInviteToGame::set_connect_string(const char* value, size_t size) {
  set_has_connect_string();
  if (connect_string_ == &::google::protobuf::internal::kEmptyString) {
    connect_string_ = new ::std::string;
  }
  connect_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUDSInviteToGame::mutable_connect_string() {
  set_has_connect_string();
  if (connect_string_ == &::google::protobuf::internal::kEmptyString) {
    connect_string_ = new ::std::string;
  }
  return connect_string_;
}
inline ::std::string* CMsgClientUDSInviteToGame::release_connect_string() {
  clear_has_connect_string();
  if (connect_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connect_string_;
    connect_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUDSInviteToGame::set_allocated_connect_string(::std::string* connect_string) {
  if (connect_string_ != &::google::protobuf::internal::kEmptyString) {
    delete connect_string_;
  }
  if (connect_string) {
    set_has_connect_string();
    connect_string_ = connect_string;
  } else {
    clear_has_connect_string();
    connect_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientChatInvite

// optional fixed64 steam_id_invited = 1;
inline bool CMsgClientChatInvite::has_steam_id_invited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientChatInvite::set_has_steam_id_invited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientChatInvite::clear_has_steam_id_invited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientChatInvite::clear_steam_id_invited() {
  steam_id_invited_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_invited();
}
inline ::google::protobuf::uint64 CMsgClientChatInvite::steam_id_invited() const {
  return steam_id_invited_;
}
inline void CMsgClientChatInvite::set_steam_id_invited(::google::protobuf::uint64 value) {
  set_has_steam_id_invited();
  steam_id_invited_ = value;
}

// optional fixed64 steam_id_chat = 2;
inline bool CMsgClientChatInvite::has_steam_id_chat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientChatInvite::set_has_steam_id_chat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientChatInvite::clear_has_steam_id_chat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientChatInvite::clear_steam_id_chat() {
  steam_id_chat_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_chat();
}
inline ::google::protobuf::uint64 CMsgClientChatInvite::steam_id_chat() const {
  return steam_id_chat_;
}
inline void CMsgClientChatInvite::set_steam_id_chat(::google::protobuf::uint64 value) {
  set_has_steam_id_chat();
  steam_id_chat_ = value;
}

// optional fixed64 steam_id_patron = 3;
inline bool CMsgClientChatInvite::has_steam_id_patron() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientChatInvite::set_has_steam_id_patron() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientChatInvite::clear_has_steam_id_patron() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientChatInvite::clear_steam_id_patron() {
  steam_id_patron_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_patron();
}
inline ::google::protobuf::uint64 CMsgClientChatInvite::steam_id_patron() const {
  return steam_id_patron_;
}
inline void CMsgClientChatInvite::set_steam_id_patron(::google::protobuf::uint64 value) {
  set_has_steam_id_patron();
  steam_id_patron_ = value;
}

// optional int32 chatroom_type = 4;
inline bool CMsgClientChatInvite::has_chatroom_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientChatInvite::set_has_chatroom_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientChatInvite::clear_has_chatroom_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientChatInvite::clear_chatroom_type() {
  chatroom_type_ = 0;
  clear_has_chatroom_type();
}
inline ::google::protobuf::int32 CMsgClientChatInvite::chatroom_type() const {
  return chatroom_type_;
}
inline void CMsgClientChatInvite::set_chatroom_type(::google::protobuf::int32 value) {
  set_has_chatroom_type();
  chatroom_type_ = value;
}

// optional fixed64 steam_id_friend_chat = 5;
inline bool CMsgClientChatInvite::has_steam_id_friend_chat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientChatInvite::set_has_steam_id_friend_chat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientChatInvite::clear_has_steam_id_friend_chat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientChatInvite::clear_steam_id_friend_chat() {
  steam_id_friend_chat_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_friend_chat();
}
inline ::google::protobuf::uint64 CMsgClientChatInvite::steam_id_friend_chat() const {
  return steam_id_friend_chat_;
}
inline void CMsgClientChatInvite::set_steam_id_friend_chat(::google::protobuf::uint64 value) {
  set_has_steam_id_friend_chat();
  steam_id_friend_chat_ = value;
}

// optional string chat_name = 6;
inline bool CMsgClientChatInvite::has_chat_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientChatInvite::set_has_chat_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientChatInvite::clear_has_chat_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientChatInvite::clear_chat_name() {
  if (chat_name_ != &::google::protobuf::internal::kEmptyString) {
    chat_name_->clear();
  }
  clear_has_chat_name();
}
inline const ::std::string& CMsgClientChatInvite::chat_name() const {
  return *chat_name_;
}
inline void CMsgClientChatInvite::set_chat_name(const ::std::string& value) {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  chat_name_->assign(value);
}
inline void CMsgClientChatInvite::set_chat_name(const char* value) {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  chat_name_->assign(value);
}
inline void CMsgClientChatInvite::set_chat_name(const char* value, size_t size) {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  chat_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientChatInvite::mutable_chat_name() {
  set_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    chat_name_ = new ::std::string;
  }
  return chat_name_;
}
inline ::std::string* CMsgClientChatInvite::release_chat_name() {
  clear_has_chat_name();
  if (chat_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_name_;
    chat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientChatInvite::set_allocated_chat_name(::std::string* chat_name) {
  if (chat_name_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_name_;
  }
  if (chat_name) {
    set_has_chat_name();
    chat_name_ = chat_name;
  } else {
    clear_has_chat_name();
    chat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 game_id = 7;
inline bool CMsgClientChatInvite::has_game_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientChatInvite::set_has_game_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientChatInvite::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientChatInvite::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientChatInvite::game_id() const {
  return game_id_;
}
inline void CMsgClientChatInvite::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientConnectionStats_Stats_Logon

// optional int32 connect_attempts = 1;
inline bool CMsgClientConnectionStats_Stats_Logon::has_connect_attempts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_has_connect_attempts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_has_connect_attempts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_connect_attempts() {
  connect_attempts_ = 0;
  clear_has_connect_attempts();
}
inline ::google::protobuf::int32 CMsgClientConnectionStats_Stats_Logon::connect_attempts() const {
  return connect_attempts_;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_connect_attempts(::google::protobuf::int32 value) {
  set_has_connect_attempts();
  connect_attempts_ = value;
}

// optional int32 connect_successes = 2;
inline bool CMsgClientConnectionStats_Stats_Logon::has_connect_successes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_has_connect_successes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_has_connect_successes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_connect_successes() {
  connect_successes_ = 0;
  clear_has_connect_successes();
}
inline ::google::protobuf::int32 CMsgClientConnectionStats_Stats_Logon::connect_successes() const {
  return connect_successes_;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_connect_successes(::google::protobuf::int32 value) {
  set_has_connect_successes();
  connect_successes_ = value;
}

// optional int32 connect_failures = 3;
inline bool CMsgClientConnectionStats_Stats_Logon::has_connect_failures() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_has_connect_failures() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_has_connect_failures() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_connect_failures() {
  connect_failures_ = 0;
  clear_has_connect_failures();
}
inline ::google::protobuf::int32 CMsgClientConnectionStats_Stats_Logon::connect_failures() const {
  return connect_failures_;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_connect_failures(::google::protobuf::int32 value) {
  set_has_connect_failures();
  connect_failures_ = value;
}

// optional int32 connections_dropped = 4;
inline bool CMsgClientConnectionStats_Stats_Logon::has_connections_dropped() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_has_connections_dropped() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_has_connections_dropped() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientConnectionStats_Stats_Logon::clear_connections_dropped() {
  connections_dropped_ = 0;
  clear_has_connections_dropped();
}
inline ::google::protobuf::int32 CMsgClientConnectionStats_Stats_Logon::connections_dropped() const {
  return connections_dropped_;
}
inline void CMsgClientConnectionStats_Stats_Logon::set_connections_dropped(::google::protobuf::int32 value) {
  set_has_connections_dropped();
  connections_dropped_ = value;
}

// -------------------------------------------------------------------

// CMsgClientConnectionStats_Stats_UDP

// optional uint64 pkts_sent = 1;
inline bool CMsgClientConnectionStats_Stats_UDP::has_pkts_sent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_has_pkts_sent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_has_pkts_sent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_pkts_sent() {
  pkts_sent_ = GOOGLE_ULONGLONG(0);
  clear_has_pkts_sent();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_UDP::pkts_sent() const {
  return pkts_sent_;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_pkts_sent(::google::protobuf::uint64 value) {
  set_has_pkts_sent();
  pkts_sent_ = value;
}

// optional uint64 bytes_sent = 2;
inline bool CMsgClientConnectionStats_Stats_UDP::has_bytes_sent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_has_bytes_sent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_has_bytes_sent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_bytes_sent() {
  bytes_sent_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_sent();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_UDP::bytes_sent() const {
  return bytes_sent_;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_bytes_sent(::google::protobuf::uint64 value) {
  set_has_bytes_sent();
  bytes_sent_ = value;
}

// optional uint64 pkts_recv = 3;
inline bool CMsgClientConnectionStats_Stats_UDP::has_pkts_recv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_has_pkts_recv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_has_pkts_recv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_pkts_recv() {
  pkts_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_pkts_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_UDP::pkts_recv() const {
  return pkts_recv_;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_pkts_recv(::google::protobuf::uint64 value) {
  set_has_pkts_recv();
  pkts_recv_ = value;
}

// optional uint64 pkts_processed = 4;
inline bool CMsgClientConnectionStats_Stats_UDP::has_pkts_processed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_has_pkts_processed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_has_pkts_processed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_pkts_processed() {
  pkts_processed_ = GOOGLE_ULONGLONG(0);
  clear_has_pkts_processed();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_UDP::pkts_processed() const {
  return pkts_processed_;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_pkts_processed(::google::protobuf::uint64 value) {
  set_has_pkts_processed();
  pkts_processed_ = value;
}

// optional uint64 bytes_recv = 5;
inline bool CMsgClientConnectionStats_Stats_UDP::has_bytes_recv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_has_bytes_recv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_has_bytes_recv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientConnectionStats_Stats_UDP::clear_bytes_recv() {
  bytes_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_UDP::bytes_recv() const {
  return bytes_recv_;
}
inline void CMsgClientConnectionStats_Stats_UDP::set_bytes_recv(::google::protobuf::uint64 value) {
  set_has_bytes_recv();
  bytes_recv_ = value;
}

// -------------------------------------------------------------------

// CMsgClientConnectionStats_Stats_VConn

// optional uint32 connections_udp = 1;
inline bool CMsgClientConnectionStats_Stats_VConn::has_connections_udp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_connections_udp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_connections_udp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_connections_udp() {
  connections_udp_ = 0u;
  clear_has_connections_udp();
}
inline ::google::protobuf::uint32 CMsgClientConnectionStats_Stats_VConn::connections_udp() const {
  return connections_udp_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_connections_udp(::google::protobuf::uint32 value) {
  set_has_connections_udp();
  connections_udp_ = value;
}

// optional uint32 connections_tcp = 2;
inline bool CMsgClientConnectionStats_Stats_VConn::has_connections_tcp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_connections_tcp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_connections_tcp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_connections_tcp() {
  connections_tcp_ = 0u;
  clear_has_connections_tcp();
}
inline ::google::protobuf::uint32 CMsgClientConnectionStats_Stats_VConn::connections_tcp() const {
  return connections_tcp_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_connections_tcp(::google::protobuf::uint32 value) {
  set_has_connections_tcp();
  connections_tcp_ = value;
}

// optional .Sc.CMsgClientConnectionStats.Stats_UDP stats_udp = 3;
inline bool CMsgClientConnectionStats_Stats_VConn::has_stats_udp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_stats_udp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_stats_udp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_stats_udp() {
  if (stats_udp_ != NULL) stats_udp_->::Sc::CMsgClientConnectionStats_Stats_UDP::Clear();
  clear_has_stats_udp();
}
inline const ::Sc::CMsgClientConnectionStats_Stats_UDP& CMsgClientConnectionStats_Stats_VConn::stats_udp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_udp_ != NULL ? *stats_udp_ : *default_instance().stats_udp_;
#else
  return stats_udp_ != NULL ? *stats_udp_ : *default_instance_->stats_udp_;
#endif
}
inline ::Sc::CMsgClientConnectionStats_Stats_UDP* CMsgClientConnectionStats_Stats_VConn::mutable_stats_udp() {
  set_has_stats_udp();
  if (stats_udp_ == NULL) stats_udp_ = new ::Sc::CMsgClientConnectionStats_Stats_UDP;
  return stats_udp_;
}
inline ::Sc::CMsgClientConnectionStats_Stats_UDP* CMsgClientConnectionStats_Stats_VConn::release_stats_udp() {
  clear_has_stats_udp();
  ::Sc::CMsgClientConnectionStats_Stats_UDP* temp = stats_udp_;
  stats_udp_ = NULL;
  return temp;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_allocated_stats_udp(::Sc::CMsgClientConnectionStats_Stats_UDP* stats_udp) {
  delete stats_udp_;
  stats_udp_ = stats_udp;
  if (stats_udp) {
    set_has_stats_udp();
  } else {
    clear_has_stats_udp();
  }
}

// optional uint64 pkts_abandoned = 4;
inline bool CMsgClientConnectionStats_Stats_VConn::has_pkts_abandoned() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_pkts_abandoned() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_pkts_abandoned() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_pkts_abandoned() {
  pkts_abandoned_ = GOOGLE_ULONGLONG(0);
  clear_has_pkts_abandoned();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::pkts_abandoned() const {
  return pkts_abandoned_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_pkts_abandoned(::google::protobuf::uint64 value) {
  set_has_pkts_abandoned();
  pkts_abandoned_ = value;
}

// optional uint64 conn_req_received = 5;
inline bool CMsgClientConnectionStats_Stats_VConn::has_conn_req_received() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_conn_req_received() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_conn_req_received() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_conn_req_received() {
  conn_req_received_ = GOOGLE_ULONGLONG(0);
  clear_has_conn_req_received();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::conn_req_received() const {
  return conn_req_received_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_conn_req_received(::google::protobuf::uint64 value) {
  set_has_conn_req_received();
  conn_req_received_ = value;
}

// optional uint64 pkts_resent = 6;
inline bool CMsgClientConnectionStats_Stats_VConn::has_pkts_resent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_pkts_resent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_pkts_resent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_pkts_resent() {
  pkts_resent_ = GOOGLE_ULONGLONG(0);
  clear_has_pkts_resent();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::pkts_resent() const {
  return pkts_resent_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_pkts_resent(::google::protobuf::uint64 value) {
  set_has_pkts_resent();
  pkts_resent_ = value;
}

// optional uint64 msgs_sent = 7;
inline bool CMsgClientConnectionStats_Stats_VConn::has_msgs_sent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_msgs_sent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_msgs_sent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_msgs_sent() {
  msgs_sent_ = GOOGLE_ULONGLONG(0);
  clear_has_msgs_sent();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::msgs_sent() const {
  return msgs_sent_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_msgs_sent(::google::protobuf::uint64 value) {
  set_has_msgs_sent();
  msgs_sent_ = value;
}

// optional uint64 msgs_sent_failed = 8;
inline bool CMsgClientConnectionStats_Stats_VConn::has_msgs_sent_failed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_msgs_sent_failed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_msgs_sent_failed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_msgs_sent_failed() {
  msgs_sent_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_msgs_sent_failed();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::msgs_sent_failed() const {
  return msgs_sent_failed_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_msgs_sent_failed(::google::protobuf::uint64 value) {
  set_has_msgs_sent_failed();
  msgs_sent_failed_ = value;
}

// optional uint64 msgs_recv = 9;
inline bool CMsgClientConnectionStats_Stats_VConn::has_msgs_recv() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_msgs_recv() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_msgs_recv() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_msgs_recv() {
  msgs_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_msgs_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::msgs_recv() const {
  return msgs_recv_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_msgs_recv(::google::protobuf::uint64 value) {
  set_has_msgs_recv();
  msgs_recv_ = value;
}

// optional uint64 datagrams_sent = 10;
inline bool CMsgClientConnectionStats_Stats_VConn::has_datagrams_sent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_datagrams_sent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_datagrams_sent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_datagrams_sent() {
  datagrams_sent_ = GOOGLE_ULONGLONG(0);
  clear_has_datagrams_sent();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::datagrams_sent() const {
  return datagrams_sent_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_datagrams_sent(::google::protobuf::uint64 value) {
  set_has_datagrams_sent();
  datagrams_sent_ = value;
}

// optional uint64 datagrams_recv = 11;
inline bool CMsgClientConnectionStats_Stats_VConn::has_datagrams_recv() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_datagrams_recv() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_datagrams_recv() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_datagrams_recv() {
  datagrams_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_datagrams_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::datagrams_recv() const {
  return datagrams_recv_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_datagrams_recv(::google::protobuf::uint64 value) {
  set_has_datagrams_recv();
  datagrams_recv_ = value;
}

// optional uint64 bad_pkts_recv = 12;
inline bool CMsgClientConnectionStats_Stats_VConn::has_bad_pkts_recv() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_bad_pkts_recv() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_bad_pkts_recv() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_bad_pkts_recv() {
  bad_pkts_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_bad_pkts_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::bad_pkts_recv() const {
  return bad_pkts_recv_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_bad_pkts_recv(::google::protobuf::uint64 value) {
  set_has_bad_pkts_recv();
  bad_pkts_recv_ = value;
}

// optional uint64 unknown_conn_pkts_recv = 13;
inline bool CMsgClientConnectionStats_Stats_VConn::has_unknown_conn_pkts_recv() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_unknown_conn_pkts_recv() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_unknown_conn_pkts_recv() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_unknown_conn_pkts_recv() {
  unknown_conn_pkts_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_unknown_conn_pkts_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::unknown_conn_pkts_recv() const {
  return unknown_conn_pkts_recv_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_unknown_conn_pkts_recv(::google::protobuf::uint64 value) {
  set_has_unknown_conn_pkts_recv();
  unknown_conn_pkts_recv_ = value;
}

// optional uint64 missed_pkts_recv = 14;
inline bool CMsgClientConnectionStats_Stats_VConn::has_missed_pkts_recv() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_missed_pkts_recv() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_missed_pkts_recv() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_missed_pkts_recv() {
  missed_pkts_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_missed_pkts_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::missed_pkts_recv() const {
  return missed_pkts_recv_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_missed_pkts_recv(::google::protobuf::uint64 value) {
  set_has_missed_pkts_recv();
  missed_pkts_recv_ = value;
}

// optional uint64 dup_pkts_recv = 15;
inline bool CMsgClientConnectionStats_Stats_VConn::has_dup_pkts_recv() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_dup_pkts_recv() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_dup_pkts_recv() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_dup_pkts_recv() {
  dup_pkts_recv_ = GOOGLE_ULONGLONG(0);
  clear_has_dup_pkts_recv();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::dup_pkts_recv() const {
  return dup_pkts_recv_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_dup_pkts_recv(::google::protobuf::uint64 value) {
  set_has_dup_pkts_recv();
  dup_pkts_recv_ = value;
}

// optional uint64 failed_connect_challenges = 16;
inline bool CMsgClientConnectionStats_Stats_VConn::has_failed_connect_challenges() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_failed_connect_challenges() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_failed_connect_challenges() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_failed_connect_challenges() {
  failed_connect_challenges_ = GOOGLE_ULONGLONG(0);
  clear_has_failed_connect_challenges();
}
inline ::google::protobuf::uint64 CMsgClientConnectionStats_Stats_VConn::failed_connect_challenges() const {
  return failed_connect_challenges_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_failed_connect_challenges(::google::protobuf::uint64 value) {
  set_has_failed_connect_challenges();
  failed_connect_challenges_ = value;
}

// optional uint32 micro_sec_avg_latency = 17;
inline bool CMsgClientConnectionStats_Stats_VConn::has_micro_sec_avg_latency() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_micro_sec_avg_latency() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_micro_sec_avg_latency() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_micro_sec_avg_latency() {
  micro_sec_avg_latency_ = 0u;
  clear_has_micro_sec_avg_latency();
}
inline ::google::protobuf::uint32 CMsgClientConnectionStats_Stats_VConn::micro_sec_avg_latency() const {
  return micro_sec_avg_latency_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_micro_sec_avg_latency(::google::protobuf::uint32 value) {
  set_has_micro_sec_avg_latency();
  micro_sec_avg_latency_ = value;
}

// optional uint32 micro_sec_min_latency = 18;
inline bool CMsgClientConnectionStats_Stats_VConn::has_micro_sec_min_latency() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_micro_sec_min_latency() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_micro_sec_min_latency() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_micro_sec_min_latency() {
  micro_sec_min_latency_ = 0u;
  clear_has_micro_sec_min_latency();
}
inline ::google::protobuf::uint32 CMsgClientConnectionStats_Stats_VConn::micro_sec_min_latency() const {
  return micro_sec_min_latency_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_micro_sec_min_latency(::google::protobuf::uint32 value) {
  set_has_micro_sec_min_latency();
  micro_sec_min_latency_ = value;
}

// optional uint32 micro_sec_max_latency = 19;
inline bool CMsgClientConnectionStats_Stats_VConn::has_micro_sec_max_latency() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_micro_sec_max_latency() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_micro_sec_max_latency() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_micro_sec_max_latency() {
  micro_sec_max_latency_ = 0u;
  clear_has_micro_sec_max_latency();
}
inline ::google::protobuf::uint32 CMsgClientConnectionStats_Stats_VConn::micro_sec_max_latency() const {
  return micro_sec_max_latency_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_micro_sec_max_latency(::google::protobuf::uint32 value) {
  set_has_micro_sec_max_latency();
  micro_sec_max_latency_ = value;
}

// optional uint32 mem_pool_msg_in_use = 20;
inline bool CMsgClientConnectionStats_Stats_VConn::has_mem_pool_msg_in_use() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_has_mem_pool_msg_in_use() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_has_mem_pool_msg_in_use() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CMsgClientConnectionStats_Stats_VConn::clear_mem_pool_msg_in_use() {
  mem_pool_msg_in_use_ = 0u;
  clear_has_mem_pool_msg_in_use();
}
inline ::google::protobuf::uint32 CMsgClientConnectionStats_Stats_VConn::mem_pool_msg_in_use() const {
  return mem_pool_msg_in_use_;
}
inline void CMsgClientConnectionStats_Stats_VConn::set_mem_pool_msg_in_use(::google::protobuf::uint32 value) {
  set_has_mem_pool_msg_in_use();
  mem_pool_msg_in_use_ = value;
}

// -------------------------------------------------------------------

// CMsgClientConnectionStats

// optional .Sc.CMsgClientConnectionStats.Stats_Logon stats_logon = 1;
inline bool CMsgClientConnectionStats::has_stats_logon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientConnectionStats::set_has_stats_logon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientConnectionStats::clear_has_stats_logon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientConnectionStats::clear_stats_logon() {
  if (stats_logon_ != NULL) stats_logon_->::Sc::CMsgClientConnectionStats_Stats_Logon::Clear();
  clear_has_stats_logon();
}
inline const ::Sc::CMsgClientConnectionStats_Stats_Logon& CMsgClientConnectionStats::stats_logon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_logon_ != NULL ? *stats_logon_ : *default_instance().stats_logon_;
#else
  return stats_logon_ != NULL ? *stats_logon_ : *default_instance_->stats_logon_;
#endif
}
inline ::Sc::CMsgClientConnectionStats_Stats_Logon* CMsgClientConnectionStats::mutable_stats_logon() {
  set_has_stats_logon();
  if (stats_logon_ == NULL) stats_logon_ = new ::Sc::CMsgClientConnectionStats_Stats_Logon;
  return stats_logon_;
}
inline ::Sc::CMsgClientConnectionStats_Stats_Logon* CMsgClientConnectionStats::release_stats_logon() {
  clear_has_stats_logon();
  ::Sc::CMsgClientConnectionStats_Stats_Logon* temp = stats_logon_;
  stats_logon_ = NULL;
  return temp;
}
inline void CMsgClientConnectionStats::set_allocated_stats_logon(::Sc::CMsgClientConnectionStats_Stats_Logon* stats_logon) {
  delete stats_logon_;
  stats_logon_ = stats_logon;
  if (stats_logon) {
    set_has_stats_logon();
  } else {
    clear_has_stats_logon();
  }
}

// optional .Sc.CMsgClientConnectionStats.Stats_VConn stats_vconn = 2;
inline bool CMsgClientConnectionStats::has_stats_vconn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientConnectionStats::set_has_stats_vconn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientConnectionStats::clear_has_stats_vconn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientConnectionStats::clear_stats_vconn() {
  if (stats_vconn_ != NULL) stats_vconn_->::Sc::CMsgClientConnectionStats_Stats_VConn::Clear();
  clear_has_stats_vconn();
}
inline const ::Sc::CMsgClientConnectionStats_Stats_VConn& CMsgClientConnectionStats::stats_vconn() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_vconn_ != NULL ? *stats_vconn_ : *default_instance().stats_vconn_;
#else
  return stats_vconn_ != NULL ? *stats_vconn_ : *default_instance_->stats_vconn_;
#endif
}
inline ::Sc::CMsgClientConnectionStats_Stats_VConn* CMsgClientConnectionStats::mutable_stats_vconn() {
  set_has_stats_vconn();
  if (stats_vconn_ == NULL) stats_vconn_ = new ::Sc::CMsgClientConnectionStats_Stats_VConn;
  return stats_vconn_;
}
inline ::Sc::CMsgClientConnectionStats_Stats_VConn* CMsgClientConnectionStats::release_stats_vconn() {
  clear_has_stats_vconn();
  ::Sc::CMsgClientConnectionStats_Stats_VConn* temp = stats_vconn_;
  stats_vconn_ = NULL;
  return temp;
}
inline void CMsgClientConnectionStats::set_allocated_stats_vconn(::Sc::CMsgClientConnectionStats_Stats_VConn* stats_vconn) {
  delete stats_vconn_;
  stats_vconn_ = stats_vconn;
  if (stats_vconn) {
    set_has_stats_vconn();
  } else {
    clear_has_stats_vconn();
  }
}

// -------------------------------------------------------------------

// CMsgClientServersAvailable_Server_Types_Available

// optional uint32 server = 1;
inline bool CMsgClientServersAvailable_Server_Types_Available::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientServersAvailable_Server_Types_Available::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientServersAvailable_Server_Types_Available::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientServersAvailable_Server_Types_Available::clear_server() {
  server_ = 0u;
  clear_has_server();
}
inline ::google::protobuf::uint32 CMsgClientServersAvailable_Server_Types_Available::server() const {
  return server_;
}
inline void CMsgClientServersAvailable_Server_Types_Available::set_server(::google::protobuf::uint32 value) {
  set_has_server();
  server_ = value;
}

// optional bool changed = 2;
inline bool CMsgClientServersAvailable_Server_Types_Available::has_changed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientServersAvailable_Server_Types_Available::set_has_changed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientServersAvailable_Server_Types_Available::clear_has_changed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientServersAvailable_Server_Types_Available::clear_changed() {
  changed_ = false;
  clear_has_changed();
}
inline bool CMsgClientServersAvailable_Server_Types_Available::changed() const {
  return changed_;
}
inline void CMsgClientServersAvailable_Server_Types_Available::set_changed(bool value) {
  set_has_changed();
  changed_ = value;
}

// -------------------------------------------------------------------

// CMsgClientServersAvailable

// repeated .Sc.CMsgClientServersAvailable.Server_Types_Available server_types_available = 1;
inline int CMsgClientServersAvailable::server_types_available_size() const {
  return server_types_available_.size();
}
inline void CMsgClientServersAvailable::clear_server_types_available() {
  server_types_available_.Clear();
}
inline const ::Sc::CMsgClientServersAvailable_Server_Types_Available& CMsgClientServersAvailable::server_types_available(int index) const {
  return server_types_available_.Get(index);
}
inline ::Sc::CMsgClientServersAvailable_Server_Types_Available* CMsgClientServersAvailable::mutable_server_types_available(int index) {
  return server_types_available_.Mutable(index);
}
inline ::Sc::CMsgClientServersAvailable_Server_Types_Available* CMsgClientServersAvailable::add_server_types_available() {
  return server_types_available_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServersAvailable_Server_Types_Available >&
CMsgClientServersAvailable::server_types_available() const {
  return server_types_available_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientServersAvailable_Server_Types_Available >*
CMsgClientServersAvailable::mutable_server_types_available() {
  return &server_types_available_;
}

// optional uint32 server_type_for_auth_services = 2;
inline bool CMsgClientServersAvailable::has_server_type_for_auth_services() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientServersAvailable::set_has_server_type_for_auth_services() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientServersAvailable::clear_has_server_type_for_auth_services() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientServersAvailable::clear_server_type_for_auth_services() {
  server_type_for_auth_services_ = 0u;
  clear_has_server_type_for_auth_services();
}
inline ::google::protobuf::uint32 CMsgClientServersAvailable::server_type_for_auth_services() const {
  return server_type_for_auth_services_;
}
inline void CMsgClientServersAvailable::set_server_type_for_auth_services(::google::protobuf::uint32 value) {
  set_has_server_type_for_auth_services();
  server_type_for_auth_services_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetUserStats

// optional fixed64 game_id = 1;
inline bool CMsgClientGetUserStats::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetUserStats::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetUserStats::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetUserStats::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientGetUserStats::game_id() const {
  return game_id_;
}
inline void CMsgClientGetUserStats::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional uint32 crc_stats = 2;
inline bool CMsgClientGetUserStats::has_crc_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetUserStats::set_has_crc_stats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetUserStats::clear_has_crc_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetUserStats::clear_crc_stats() {
  crc_stats_ = 0u;
  clear_has_crc_stats();
}
inline ::google::protobuf::uint32 CMsgClientGetUserStats::crc_stats() const {
  return crc_stats_;
}
inline void CMsgClientGetUserStats::set_crc_stats(::google::protobuf::uint32 value) {
  set_has_crc_stats();
  crc_stats_ = value;
}

// optional int32 schema_local_version = 3;
inline bool CMsgClientGetUserStats::has_schema_local_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetUserStats::set_has_schema_local_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetUserStats::clear_has_schema_local_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetUserStats::clear_schema_local_version() {
  schema_local_version_ = 0;
  clear_has_schema_local_version();
}
inline ::google::protobuf::int32 CMsgClientGetUserStats::schema_local_version() const {
  return schema_local_version_;
}
inline void CMsgClientGetUserStats::set_schema_local_version(::google::protobuf::int32 value) {
  set_has_schema_local_version();
  schema_local_version_ = value;
}

// optional fixed64 steam_id_for_user = 4;
inline bool CMsgClientGetUserStats::has_steam_id_for_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGetUserStats::set_has_steam_id_for_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGetUserStats::clear_has_steam_id_for_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGetUserStats::clear_steam_id_for_user() {
  steam_id_for_user_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_for_user();
}
inline ::google::protobuf::uint64 CMsgClientGetUserStats::steam_id_for_user() const {
  return steam_id_for_user_;
}
inline void CMsgClientGetUserStats::set_steam_id_for_user(::google::protobuf::uint64 value) {
  set_has_steam_id_for_user();
  steam_id_for_user_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetUserStatsResponse_Stats

// optional uint32 stat_id = 1;
inline bool CMsgClientGetUserStatsResponse_Stats::has_stat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetUserStatsResponse_Stats::set_has_stat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetUserStatsResponse_Stats::clear_has_stat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetUserStatsResponse_Stats::clear_stat_id() {
  stat_id_ = 0u;
  clear_has_stat_id();
}
inline ::google::protobuf::uint32 CMsgClientGetUserStatsResponse_Stats::stat_id() const {
  return stat_id_;
}
inline void CMsgClientGetUserStatsResponse_Stats::set_stat_id(::google::protobuf::uint32 value) {
  set_has_stat_id();
  stat_id_ = value;
}

// optional uint32 stat_value = 2;
inline bool CMsgClientGetUserStatsResponse_Stats::has_stat_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetUserStatsResponse_Stats::set_has_stat_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetUserStatsResponse_Stats::clear_has_stat_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetUserStatsResponse_Stats::clear_stat_value() {
  stat_value_ = 0u;
  clear_has_stat_value();
}
inline ::google::protobuf::uint32 CMsgClientGetUserStatsResponse_Stats::stat_value() const {
  return stat_value_;
}
inline void CMsgClientGetUserStatsResponse_Stats::set_stat_value(::google::protobuf::uint32 value) {
  set_has_stat_value();
  stat_value_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetUserStatsResponse_Achievement_Blocks

// optional uint32 achievement_id = 1;
inline bool CMsgClientGetUserStatsResponse_Achievement_Blocks::has_achievement_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::set_has_achievement_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::clear_has_achievement_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::clear_achievement_id() {
  achievement_id_ = 0u;
  clear_has_achievement_id();
}
inline ::google::protobuf::uint32 CMsgClientGetUserStatsResponse_Achievement_Blocks::achievement_id() const {
  return achievement_id_;
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::set_achievement_id(::google::protobuf::uint32 value) {
  set_has_achievement_id();
  achievement_id_ = value;
}

// repeated fixed32 unlock_time = 2;
inline int CMsgClientGetUserStatsResponse_Achievement_Blocks::unlock_time_size() const {
  return unlock_time_.size();
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::clear_unlock_time() {
  unlock_time_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientGetUserStatsResponse_Achievement_Blocks::unlock_time(int index) const {
  return unlock_time_.Get(index);
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::set_unlock_time(int index, ::google::protobuf::uint32 value) {
  unlock_time_.Set(index, value);
}
inline void CMsgClientGetUserStatsResponse_Achievement_Blocks::add_unlock_time(::google::protobuf::uint32 value) {
  unlock_time_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientGetUserStatsResponse_Achievement_Blocks::unlock_time() const {
  return unlock_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientGetUserStatsResponse_Achievement_Blocks::mutable_unlock_time() {
  return &unlock_time_;
}

// -------------------------------------------------------------------

// CMsgClientGetUserStatsResponse

// optional fixed64 game_id = 1;
inline bool CMsgClientGetUserStatsResponse::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetUserStatsResponse::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetUserStatsResponse::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetUserStatsResponse::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientGetUserStatsResponse::game_id() const {
  return game_id_;
}
inline void CMsgClientGetUserStatsResponse::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional int32 eresult = 2 [default = 2];
inline bool CMsgClientGetUserStatsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetUserStatsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetUserStatsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetUserStatsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientGetUserStatsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientGetUserStatsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 crc_stats = 3;
inline bool CMsgClientGetUserStatsResponse::has_crc_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetUserStatsResponse::set_has_crc_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetUserStatsResponse::clear_has_crc_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetUserStatsResponse::clear_crc_stats() {
  crc_stats_ = 0u;
  clear_has_crc_stats();
}
inline ::google::protobuf::uint32 CMsgClientGetUserStatsResponse::crc_stats() const {
  return crc_stats_;
}
inline void CMsgClientGetUserStatsResponse::set_crc_stats(::google::protobuf::uint32 value) {
  set_has_crc_stats();
  crc_stats_ = value;
}

// optional bytes schema = 4;
inline bool CMsgClientGetUserStatsResponse::has_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGetUserStatsResponse::set_has_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGetUserStatsResponse::clear_has_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGetUserStatsResponse::clear_schema() {
  if (schema_ != &::google::protobuf::internal::kEmptyString) {
    schema_->clear();
  }
  clear_has_schema();
}
inline const ::std::string& CMsgClientGetUserStatsResponse::schema() const {
  return *schema_;
}
inline void CMsgClientGetUserStatsResponse::set_schema(const ::std::string& value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::kEmptyString) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void CMsgClientGetUserStatsResponse::set_schema(const char* value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::kEmptyString) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void CMsgClientGetUserStatsResponse::set_schema(const void* value, size_t size) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::kEmptyString) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetUserStatsResponse::mutable_schema() {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::kEmptyString) {
    schema_ = new ::std::string;
  }
  return schema_;
}
inline ::std::string* CMsgClientGetUserStatsResponse::release_schema() {
  clear_has_schema();
  if (schema_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schema_;
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetUserStatsResponse::set_allocated_schema(::std::string* schema) {
  if (schema_ != &::google::protobuf::internal::kEmptyString) {
    delete schema_;
  }
  if (schema) {
    set_has_schema();
    schema_ = schema;
  } else {
    clear_has_schema();
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Sc.CMsgClientGetUserStatsResponse.Stats stats = 5;
inline int CMsgClientGetUserStatsResponse::stats_size() const {
  return stats_.size();
}
inline void CMsgClientGetUserStatsResponse::clear_stats() {
  stats_.Clear();
}
inline const ::Sc::CMsgClientGetUserStatsResponse_Stats& CMsgClientGetUserStatsResponse::stats(int index) const {
  return stats_.Get(index);
}
inline ::Sc::CMsgClientGetUserStatsResponse_Stats* CMsgClientGetUserStatsResponse::mutable_stats(int index) {
  return stats_.Mutable(index);
}
inline ::Sc::CMsgClientGetUserStatsResponse_Stats* CMsgClientGetUserStatsResponse::add_stats() {
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Stats >&
CMsgClientGetUserStatsResponse::stats() const {
  return stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Stats >*
CMsgClientGetUserStatsResponse::mutable_stats() {
  return &stats_;
}

// repeated .Sc.CMsgClientGetUserStatsResponse.Achievement_Blocks achievement_blocks = 6;
inline int CMsgClientGetUserStatsResponse::achievement_blocks_size() const {
  return achievement_blocks_.size();
}
inline void CMsgClientGetUserStatsResponse::clear_achievement_blocks() {
  achievement_blocks_.Clear();
}
inline const ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks& CMsgClientGetUserStatsResponse::achievement_blocks(int index) const {
  return achievement_blocks_.Get(index);
}
inline ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks* CMsgClientGetUserStatsResponse::mutable_achievement_blocks(int index) {
  return achievement_blocks_.Mutable(index);
}
inline ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks* CMsgClientGetUserStatsResponse::add_achievement_blocks() {
  return achievement_blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks >&
CMsgClientGetUserStatsResponse::achievement_blocks() const {
  return achievement_blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetUserStatsResponse_Achievement_Blocks >*
CMsgClientGetUserStatsResponse::mutable_achievement_blocks() {
  return &achievement_blocks_;
}

// -------------------------------------------------------------------

// CMsgClientStoreUserStatsResponse_Stats_Failed_Validation

// optional uint32 stat_id = 1;
inline bool CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::has_stat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::set_has_stat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::clear_has_stat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::clear_stat_id() {
  stat_id_ = 0u;
  clear_has_stat_id();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::stat_id() const {
  return stat_id_;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::set_stat_id(::google::protobuf::uint32 value) {
  set_has_stat_id();
  stat_id_ = value;
}

// optional uint32 reverted_stat_value = 2;
inline bool CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::has_reverted_stat_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::set_has_reverted_stat_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::clear_has_reverted_stat_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::clear_reverted_stat_value() {
  reverted_stat_value_ = 0u;
  clear_has_reverted_stat_value();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::reverted_stat_value() const {
  return reverted_stat_value_;
}
inline void CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::set_reverted_stat_value(::google::protobuf::uint32 value) {
  set_has_reverted_stat_value();
  reverted_stat_value_ = value;
}

// -------------------------------------------------------------------

// CMsgClientStoreUserStatsResponse

// optional fixed64 game_id = 1;
inline bool CMsgClientStoreUserStatsResponse::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStoreUserStatsResponse::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStoreUserStatsResponse::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStoreUserStatsResponse::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientStoreUserStatsResponse::game_id() const {
  return game_id_;
}
inline void CMsgClientStoreUserStatsResponse::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional int32 eresult = 2 [default = 2];
inline bool CMsgClientStoreUserStatsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStoreUserStatsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStoreUserStatsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStoreUserStatsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientStoreUserStatsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientStoreUserStatsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 crc_stats = 3;
inline bool CMsgClientStoreUserStatsResponse::has_crc_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientStoreUserStatsResponse::set_has_crc_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientStoreUserStatsResponse::clear_has_crc_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientStoreUserStatsResponse::clear_crc_stats() {
  crc_stats_ = 0u;
  clear_has_crc_stats();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStatsResponse::crc_stats() const {
  return crc_stats_;
}
inline void CMsgClientStoreUserStatsResponse::set_crc_stats(::google::protobuf::uint32 value) {
  set_has_crc_stats();
  crc_stats_ = value;
}

// repeated .Sc.CMsgClientStoreUserStatsResponse.Stats_Failed_Validation stats_failed_validation = 4;
inline int CMsgClientStoreUserStatsResponse::stats_failed_validation_size() const {
  return stats_failed_validation_.size();
}
inline void CMsgClientStoreUserStatsResponse::clear_stats_failed_validation() {
  stats_failed_validation_.Clear();
}
inline const ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation& CMsgClientStoreUserStatsResponse::stats_failed_validation(int index) const {
  return stats_failed_validation_.Get(index);
}
inline ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* CMsgClientStoreUserStatsResponse::mutable_stats_failed_validation(int index) {
  return stats_failed_validation_.Mutable(index);
}
inline ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation* CMsgClientStoreUserStatsResponse::add_stats_failed_validation() {
  return stats_failed_validation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation >&
CMsgClientStoreUserStatsResponse::stats_failed_validation() const {
  return stats_failed_validation_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStatsResponse_Stats_Failed_Validation >*
CMsgClientStoreUserStatsResponse::mutable_stats_failed_validation() {
  return &stats_failed_validation_;
}

// optional bool stats_out_of_date = 5;
inline bool CMsgClientStoreUserStatsResponse::has_stats_out_of_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientStoreUserStatsResponse::set_has_stats_out_of_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientStoreUserStatsResponse::clear_has_stats_out_of_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientStoreUserStatsResponse::clear_stats_out_of_date() {
  stats_out_of_date_ = false;
  clear_has_stats_out_of_date();
}
inline bool CMsgClientStoreUserStatsResponse::stats_out_of_date() const {
  return stats_out_of_date_;
}
inline void CMsgClientStoreUserStatsResponse::set_stats_out_of_date(bool value) {
  set_has_stats_out_of_date();
  stats_out_of_date_ = value;
}

// -------------------------------------------------------------------

// CMsgClientStoreUserStats2_Stats

// optional uint32 stat_id = 1;
inline bool CMsgClientStoreUserStats2_Stats::has_stat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStoreUserStats2_Stats::set_has_stat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStoreUserStats2_Stats::clear_has_stat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStoreUserStats2_Stats::clear_stat_id() {
  stat_id_ = 0u;
  clear_has_stat_id();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStats2_Stats::stat_id() const {
  return stat_id_;
}
inline void CMsgClientStoreUserStats2_Stats::set_stat_id(::google::protobuf::uint32 value) {
  set_has_stat_id();
  stat_id_ = value;
}

// optional uint32 stat_value = 2;
inline bool CMsgClientStoreUserStats2_Stats::has_stat_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStoreUserStats2_Stats::set_has_stat_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStoreUserStats2_Stats::clear_has_stat_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStoreUserStats2_Stats::clear_stat_value() {
  stat_value_ = 0u;
  clear_has_stat_value();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStats2_Stats::stat_value() const {
  return stat_value_;
}
inline void CMsgClientStoreUserStats2_Stats::set_stat_value(::google::protobuf::uint32 value) {
  set_has_stat_value();
  stat_value_ = value;
}

// -------------------------------------------------------------------

// CMsgClientStoreUserStats2

// optional fixed64 game_id = 1;
inline bool CMsgClientStoreUserStats2::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStoreUserStats2::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStoreUserStats2::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStoreUserStats2::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientStoreUserStats2::game_id() const {
  return game_id_;
}
inline void CMsgClientStoreUserStats2::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional fixed64 settor_steam_id = 2;
inline bool CMsgClientStoreUserStats2::has_settor_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStoreUserStats2::set_has_settor_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStoreUserStats2::clear_has_settor_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStoreUserStats2::clear_settor_steam_id() {
  settor_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_settor_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientStoreUserStats2::settor_steam_id() const {
  return settor_steam_id_;
}
inline void CMsgClientStoreUserStats2::set_settor_steam_id(::google::protobuf::uint64 value) {
  set_has_settor_steam_id();
  settor_steam_id_ = value;
}

// optional fixed64 settee_steam_id = 3;
inline bool CMsgClientStoreUserStats2::has_settee_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientStoreUserStats2::set_has_settee_steam_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientStoreUserStats2::clear_has_settee_steam_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientStoreUserStats2::clear_settee_steam_id() {
  settee_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_settee_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientStoreUserStats2::settee_steam_id() const {
  return settee_steam_id_;
}
inline void CMsgClientStoreUserStats2::set_settee_steam_id(::google::protobuf::uint64 value) {
  set_has_settee_steam_id();
  settee_steam_id_ = value;
}

// optional uint32 crc_stats = 4;
inline bool CMsgClientStoreUserStats2::has_crc_stats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientStoreUserStats2::set_has_crc_stats() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientStoreUserStats2::clear_has_crc_stats() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientStoreUserStats2::clear_crc_stats() {
  crc_stats_ = 0u;
  clear_has_crc_stats();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStats2::crc_stats() const {
  return crc_stats_;
}
inline void CMsgClientStoreUserStats2::set_crc_stats(::google::protobuf::uint32 value) {
  set_has_crc_stats();
  crc_stats_ = value;
}

// optional bool explicit_reset = 5;
inline bool CMsgClientStoreUserStats2::has_explicit_reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientStoreUserStats2::set_has_explicit_reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientStoreUserStats2::clear_has_explicit_reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientStoreUserStats2::clear_explicit_reset() {
  explicit_reset_ = false;
  clear_has_explicit_reset();
}
inline bool CMsgClientStoreUserStats2::explicit_reset() const {
  return explicit_reset_;
}
inline void CMsgClientStoreUserStats2::set_explicit_reset(bool value) {
  set_has_explicit_reset();
  explicit_reset_ = value;
}

// repeated .Sc.CMsgClientStoreUserStats2.Stats stats = 6;
inline int CMsgClientStoreUserStats2::stats_size() const {
  return stats_.size();
}
inline void CMsgClientStoreUserStats2::clear_stats() {
  stats_.Clear();
}
inline const ::Sc::CMsgClientStoreUserStats2_Stats& CMsgClientStoreUserStats2::stats(int index) const {
  return stats_.Get(index);
}
inline ::Sc::CMsgClientStoreUserStats2_Stats* CMsgClientStoreUserStats2::mutable_stats(int index) {
  return stats_.Mutable(index);
}
inline ::Sc::CMsgClientStoreUserStats2_Stats* CMsgClientStoreUserStats2::add_stats() {
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats2_Stats >&
CMsgClientStoreUserStats2::stats() const {
  return stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats2_Stats >*
CMsgClientStoreUserStats2::mutable_stats() {
  return &stats_;
}

// -------------------------------------------------------------------

// CMsgClientStatsUpdated_Updated_Stats

// optional uint32 stat_id = 1;
inline bool CMsgClientStatsUpdated_Updated_Stats::has_stat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStatsUpdated_Updated_Stats::set_has_stat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStatsUpdated_Updated_Stats::clear_has_stat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStatsUpdated_Updated_Stats::clear_stat_id() {
  stat_id_ = 0u;
  clear_has_stat_id();
}
inline ::google::protobuf::uint32 CMsgClientStatsUpdated_Updated_Stats::stat_id() const {
  return stat_id_;
}
inline void CMsgClientStatsUpdated_Updated_Stats::set_stat_id(::google::protobuf::uint32 value) {
  set_has_stat_id();
  stat_id_ = value;
}

// optional uint32 stat_value = 2;
inline bool CMsgClientStatsUpdated_Updated_Stats::has_stat_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStatsUpdated_Updated_Stats::set_has_stat_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStatsUpdated_Updated_Stats::clear_has_stat_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStatsUpdated_Updated_Stats::clear_stat_value() {
  stat_value_ = 0u;
  clear_has_stat_value();
}
inline ::google::protobuf::uint32 CMsgClientStatsUpdated_Updated_Stats::stat_value() const {
  return stat_value_;
}
inline void CMsgClientStatsUpdated_Updated_Stats::set_stat_value(::google::protobuf::uint32 value) {
  set_has_stat_value();
  stat_value_ = value;
}

// -------------------------------------------------------------------

// CMsgClientStatsUpdated

// optional fixed64 steam_id = 1;
inline bool CMsgClientStatsUpdated::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStatsUpdated::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStatsUpdated::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStatsUpdated::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientStatsUpdated::steam_id() const {
  return steam_id_;
}
inline void CMsgClientStatsUpdated::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional fixed64 game_id = 2;
inline bool CMsgClientStatsUpdated::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStatsUpdated::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStatsUpdated::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStatsUpdated::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientStatsUpdated::game_id() const {
  return game_id_;
}
inline void CMsgClientStatsUpdated::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional uint32 crc_stats = 3;
inline bool CMsgClientStatsUpdated::has_crc_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientStatsUpdated::set_has_crc_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientStatsUpdated::clear_has_crc_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientStatsUpdated::clear_crc_stats() {
  crc_stats_ = 0u;
  clear_has_crc_stats();
}
inline ::google::protobuf::uint32 CMsgClientStatsUpdated::crc_stats() const {
  return crc_stats_;
}
inline void CMsgClientStatsUpdated::set_crc_stats(::google::protobuf::uint32 value) {
  set_has_crc_stats();
  crc_stats_ = value;
}

// repeated .Sc.CMsgClientStatsUpdated.Updated_Stats updated_stats = 4;
inline int CMsgClientStatsUpdated::updated_stats_size() const {
  return updated_stats_.size();
}
inline void CMsgClientStatsUpdated::clear_updated_stats() {
  updated_stats_.Clear();
}
inline const ::Sc::CMsgClientStatsUpdated_Updated_Stats& CMsgClientStatsUpdated::updated_stats(int index) const {
  return updated_stats_.Get(index);
}
inline ::Sc::CMsgClientStatsUpdated_Updated_Stats* CMsgClientStatsUpdated::mutable_updated_stats(int index) {
  return updated_stats_.Mutable(index);
}
inline ::Sc::CMsgClientStatsUpdated_Updated_Stats* CMsgClientStatsUpdated::add_updated_stats() {
  return updated_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStatsUpdated_Updated_Stats >&
CMsgClientStatsUpdated::updated_stats() const {
  return updated_stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStatsUpdated_Updated_Stats >*
CMsgClientStatsUpdated::mutable_updated_stats() {
  return &updated_stats_;
}

// -------------------------------------------------------------------

// CMsgClientStoreUserStats_Stats_To_Store

// optional uint32 stat_id = 1;
inline bool CMsgClientStoreUserStats_Stats_To_Store::has_stat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::set_has_stat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::clear_has_stat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::clear_stat_id() {
  stat_id_ = 0u;
  clear_has_stat_id();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStats_Stats_To_Store::stat_id() const {
  return stat_id_;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::set_stat_id(::google::protobuf::uint32 value) {
  set_has_stat_id();
  stat_id_ = value;
}

// optional uint32 stat_value = 2;
inline bool CMsgClientStoreUserStats_Stats_To_Store::has_stat_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::set_has_stat_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::clear_has_stat_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::clear_stat_value() {
  stat_value_ = 0u;
  clear_has_stat_value();
}
inline ::google::protobuf::uint32 CMsgClientStoreUserStats_Stats_To_Store::stat_value() const {
  return stat_value_;
}
inline void CMsgClientStoreUserStats_Stats_To_Store::set_stat_value(::google::protobuf::uint32 value) {
  set_has_stat_value();
  stat_value_ = value;
}

// -------------------------------------------------------------------

// CMsgClientStoreUserStats

// optional fixed64 game_id = 1;
inline bool CMsgClientStoreUserStats::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientStoreUserStats::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientStoreUserStats::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientStoreUserStats::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientStoreUserStats::game_id() const {
  return game_id_;
}
inline void CMsgClientStoreUserStats::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional bool explicit_reset = 2;
inline bool CMsgClientStoreUserStats::has_explicit_reset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientStoreUserStats::set_has_explicit_reset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientStoreUserStats::clear_has_explicit_reset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientStoreUserStats::clear_explicit_reset() {
  explicit_reset_ = false;
  clear_has_explicit_reset();
}
inline bool CMsgClientStoreUserStats::explicit_reset() const {
  return explicit_reset_;
}
inline void CMsgClientStoreUserStats::set_explicit_reset(bool value) {
  set_has_explicit_reset();
  explicit_reset_ = value;
}

// repeated .Sc.CMsgClientStoreUserStats.Stats_To_Store stats_to_store = 3;
inline int CMsgClientStoreUserStats::stats_to_store_size() const {
  return stats_to_store_.size();
}
inline void CMsgClientStoreUserStats::clear_stats_to_store() {
  stats_to_store_.Clear();
}
inline const ::Sc::CMsgClientStoreUserStats_Stats_To_Store& CMsgClientStoreUserStats::stats_to_store(int index) const {
  return stats_to_store_.Get(index);
}
inline ::Sc::CMsgClientStoreUserStats_Stats_To_Store* CMsgClientStoreUserStats::mutable_stats_to_store(int index) {
  return stats_to_store_.Mutable(index);
}
inline ::Sc::CMsgClientStoreUserStats_Stats_To_Store* CMsgClientStoreUserStats::add_stats_to_store() {
  return stats_to_store_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats_Stats_To_Store >&
CMsgClientStoreUserStats::stats_to_store() const {
  return stats_to_store_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientStoreUserStats_Stats_To_Store >*
CMsgClientStoreUserStats::mutable_stats_to_store() {
  return &stats_to_store_;
}

// -------------------------------------------------------------------

// CMsgClientGetClientDetails

// -------------------------------------------------------------------

// CMsgClientReportOverlayDetourFailure

// repeated string failure_strings = 1;
inline int CMsgClientReportOverlayDetourFailure::failure_strings_size() const {
  return failure_strings_.size();
}
inline void CMsgClientReportOverlayDetourFailure::clear_failure_strings() {
  failure_strings_.Clear();
}
inline const ::std::string& CMsgClientReportOverlayDetourFailure::failure_strings(int index) const {
  return failure_strings_.Get(index);
}
inline ::std::string* CMsgClientReportOverlayDetourFailure::mutable_failure_strings(int index) {
  return failure_strings_.Mutable(index);
}
inline void CMsgClientReportOverlayDetourFailure::set_failure_strings(int index, const ::std::string& value) {
  failure_strings_.Mutable(index)->assign(value);
}
inline void CMsgClientReportOverlayDetourFailure::set_failure_strings(int index, const char* value) {
  failure_strings_.Mutable(index)->assign(value);
}
inline void CMsgClientReportOverlayDetourFailure::set_failure_strings(int index, const char* value, size_t size) {
  failure_strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientReportOverlayDetourFailure::add_failure_strings() {
  return failure_strings_.Add();
}
inline void CMsgClientReportOverlayDetourFailure::add_failure_strings(const ::std::string& value) {
  failure_strings_.Add()->assign(value);
}
inline void CMsgClientReportOverlayDetourFailure::add_failure_strings(const char* value) {
  failure_strings_.Add()->assign(value);
}
inline void CMsgClientReportOverlayDetourFailure::add_failure_strings(const char* value, size_t size) {
  failure_strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientReportOverlayDetourFailure::failure_strings() const {
  return failure_strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientReportOverlayDetourFailure::mutable_failure_strings() {
  return &failure_strings_;
}

// -------------------------------------------------------------------

// CMsgClientGetClientDetailsResponse_Game

// optional uint32 appid = 1;
inline bool CMsgClientGetClientDetailsResponse_Game::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetClientDetailsResponse_Game::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetClientDetailsResponse_Game::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetClientDetailsResponse_Game::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientGetClientDetailsResponse_Game::appid() const {
  return appid_;
}
inline void CMsgClientGetClientDetailsResponse_Game::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string extra_info = 2;
inline bool CMsgClientGetClientDetailsResponse_Game::has_extra_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetClientDetailsResponse_Game::set_has_extra_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetClientDetailsResponse_Game::clear_has_extra_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetClientDetailsResponse_Game::clear_extra_info() {
  if (extra_info_ != &::google::protobuf::internal::kEmptyString) {
    extra_info_->clear();
  }
  clear_has_extra_info();
}
inline const ::std::string& CMsgClientGetClientDetailsResponse_Game::extra_info() const {
  return *extra_info_;
}
inline void CMsgClientGetClientDetailsResponse_Game::set_extra_info(const ::std::string& value) {
  set_has_extra_info();
  if (extra_info_ == &::google::protobuf::internal::kEmptyString) {
    extra_info_ = new ::std::string;
  }
  extra_info_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse_Game::set_extra_info(const char* value) {
  set_has_extra_info();
  if (extra_info_ == &::google::protobuf::internal::kEmptyString) {
    extra_info_ = new ::std::string;
  }
  extra_info_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse_Game::set_extra_info(const char* value, size_t size) {
  set_has_extra_info();
  if (extra_info_ == &::google::protobuf::internal::kEmptyString) {
    extra_info_ = new ::std::string;
  }
  extra_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientDetailsResponse_Game::mutable_extra_info() {
  set_has_extra_info();
  if (extra_info_ == &::google::protobuf::internal::kEmptyString) {
    extra_info_ = new ::std::string;
  }
  return extra_info_;
}
inline ::std::string* CMsgClientGetClientDetailsResponse_Game::release_extra_info() {
  clear_has_extra_info();
  if (extra_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_info_;
    extra_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientDetailsResponse_Game::set_allocated_extra_info(::std::string* extra_info) {
  if (extra_info_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_info_;
  }
  if (extra_info) {
    set_has_extra_info();
    extra_info_ = extra_info;
  } else {
    clear_has_extra_info();
    extra_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 time_running_sec = 3;
inline bool CMsgClientGetClientDetailsResponse_Game::has_time_running_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetClientDetailsResponse_Game::set_has_time_running_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetClientDetailsResponse_Game::clear_has_time_running_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetClientDetailsResponse_Game::clear_time_running_sec() {
  time_running_sec_ = 0u;
  clear_has_time_running_sec();
}
inline ::google::protobuf::uint32 CMsgClientGetClientDetailsResponse_Game::time_running_sec() const {
  return time_running_sec_;
}
inline void CMsgClientGetClientDetailsResponse_Game::set_time_running_sec(::google::protobuf::uint32 value) {
  set_has_time_running_sec();
  time_running_sec_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetClientDetailsResponse

// optional uint32 package_version = 1;
inline bool CMsgClientGetClientDetailsResponse::has_package_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_package_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_package_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetClientDetailsResponse::clear_package_version() {
  package_version_ = 0u;
  clear_has_package_version();
}
inline ::google::protobuf::uint32 CMsgClientGetClientDetailsResponse::package_version() const {
  return package_version_;
}
inline void CMsgClientGetClientDetailsResponse::set_package_version(::google::protobuf::uint32 value) {
  set_has_package_version();
  package_version_ = value;
}

// optional uint32 protocol_version = 8;
inline bool CMsgClientGetClientDetailsResponse::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetClientDetailsResponse::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 CMsgClientGetClientDetailsResponse::protocol_version() const {
  return protocol_version_;
}
inline void CMsgClientGetClientDetailsResponse::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// optional string os = 2;
inline bool CMsgClientGetClientDetailsResponse::has_os() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_os() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_os() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetClientDetailsResponse::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& CMsgClientGetClientDetailsResponse::os() const {
  return *os_;
}
inline void CMsgClientGetClientDetailsResponse::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientDetailsResponse::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* CMsgClientGetClientDetailsResponse::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientDetailsResponse::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine_name = 3;
inline bool CMsgClientGetClientDetailsResponse::has_machine_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_machine_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_machine_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGetClientDetailsResponse::clear_machine_name() {
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    machine_name_->clear();
  }
  clear_has_machine_name();
}
inline const ::std::string& CMsgClientGetClientDetailsResponse::machine_name() const {
  return *machine_name_;
}
inline void CMsgClientGetClientDetailsResponse::set_machine_name(const ::std::string& value) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_machine_name(const char* value) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_machine_name(const char* value, size_t size) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientDetailsResponse::mutable_machine_name() {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  return machine_name_;
}
inline ::std::string* CMsgClientGetClientDetailsResponse::release_machine_name() {
  clear_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_name_;
    machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientDetailsResponse::set_allocated_machine_name(::std::string* machine_name) {
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_;
  }
  if (machine_name) {
    set_has_machine_name();
    machine_name_ = machine_name;
  } else {
    clear_has_machine_name();
    machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip_public = 4;
inline bool CMsgClientGetClientDetailsResponse::has_ip_public() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_ip_public() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_ip_public() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientGetClientDetailsResponse::clear_ip_public() {
  if (ip_public_ != &::google::protobuf::internal::kEmptyString) {
    ip_public_->clear();
  }
  clear_has_ip_public();
}
inline const ::std::string& CMsgClientGetClientDetailsResponse::ip_public() const {
  return *ip_public_;
}
inline void CMsgClientGetClientDetailsResponse::set_ip_public(const ::std::string& value) {
  set_has_ip_public();
  if (ip_public_ == &::google::protobuf::internal::kEmptyString) {
    ip_public_ = new ::std::string;
  }
  ip_public_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_ip_public(const char* value) {
  set_has_ip_public();
  if (ip_public_ == &::google::protobuf::internal::kEmptyString) {
    ip_public_ = new ::std::string;
  }
  ip_public_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_ip_public(const char* value, size_t size) {
  set_has_ip_public();
  if (ip_public_ == &::google::protobuf::internal::kEmptyString) {
    ip_public_ = new ::std::string;
  }
  ip_public_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientDetailsResponse::mutable_ip_public() {
  set_has_ip_public();
  if (ip_public_ == &::google::protobuf::internal::kEmptyString) {
    ip_public_ = new ::std::string;
  }
  return ip_public_;
}
inline ::std::string* CMsgClientGetClientDetailsResponse::release_ip_public() {
  clear_has_ip_public();
  if (ip_public_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_public_;
    ip_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientDetailsResponse::set_allocated_ip_public(::std::string* ip_public) {
  if (ip_public_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_public_;
  }
  if (ip_public) {
    set_has_ip_public();
    ip_public_ = ip_public;
  } else {
    clear_has_ip_public();
    ip_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip_private = 5;
inline bool CMsgClientGetClientDetailsResponse::has_ip_private() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_ip_private() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_ip_private() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientGetClientDetailsResponse::clear_ip_private() {
  if (ip_private_ != &::google::protobuf::internal::kEmptyString) {
    ip_private_->clear();
  }
  clear_has_ip_private();
}
inline const ::std::string& CMsgClientGetClientDetailsResponse::ip_private() const {
  return *ip_private_;
}
inline void CMsgClientGetClientDetailsResponse::set_ip_private(const ::std::string& value) {
  set_has_ip_private();
  if (ip_private_ == &::google::protobuf::internal::kEmptyString) {
    ip_private_ = new ::std::string;
  }
  ip_private_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_ip_private(const char* value) {
  set_has_ip_private();
  if (ip_private_ == &::google::protobuf::internal::kEmptyString) {
    ip_private_ = new ::std::string;
  }
  ip_private_->assign(value);
}
inline void CMsgClientGetClientDetailsResponse::set_ip_private(const char* value, size_t size) {
  set_has_ip_private();
  if (ip_private_ == &::google::protobuf::internal::kEmptyString) {
    ip_private_ = new ::std::string;
  }
  ip_private_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientDetailsResponse::mutable_ip_private() {
  set_has_ip_private();
  if (ip_private_ == &::google::protobuf::internal::kEmptyString) {
    ip_private_ = new ::std::string;
  }
  return ip_private_;
}
inline ::std::string* CMsgClientGetClientDetailsResponse::release_ip_private() {
  clear_has_ip_private();
  if (ip_private_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_private_;
    ip_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientDetailsResponse::set_allocated_ip_private(::std::string* ip_private) {
  if (ip_private_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_private_;
  }
  if (ip_private) {
    set_has_ip_private();
    ip_private_ = ip_private;
  } else {
    clear_has_ip_private();
    ip_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 bytes_available = 7;
inline bool CMsgClientGetClientDetailsResponse::has_bytes_available() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientGetClientDetailsResponse::set_has_bytes_available() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientGetClientDetailsResponse::clear_has_bytes_available() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientGetClientDetailsResponse::clear_bytes_available() {
  bytes_available_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_available();
}
inline ::google::protobuf::uint64 CMsgClientGetClientDetailsResponse::bytes_available() const {
  return bytes_available_;
}
inline void CMsgClientGetClientDetailsResponse::set_bytes_available(::google::protobuf::uint64 value) {
  set_has_bytes_available();
  bytes_available_ = value;
}

// repeated .Sc.CMsgClientGetClientDetailsResponse.Game games_running = 6;
inline int CMsgClientGetClientDetailsResponse::games_running_size() const {
  return games_running_.size();
}
inline void CMsgClientGetClientDetailsResponse::clear_games_running() {
  games_running_.Clear();
}
inline const ::Sc::CMsgClientGetClientDetailsResponse_Game& CMsgClientGetClientDetailsResponse::games_running(int index) const {
  return games_running_.Get(index);
}
inline ::Sc::CMsgClientGetClientDetailsResponse_Game* CMsgClientGetClientDetailsResponse::mutable_games_running(int index) {
  return games_running_.Mutable(index);
}
inline ::Sc::CMsgClientGetClientDetailsResponse_Game* CMsgClientGetClientDetailsResponse::add_games_running() {
  return games_running_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientDetailsResponse_Game >&
CMsgClientGetClientDetailsResponse::games_running() const {
  return games_running_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientDetailsResponse_Game >*
CMsgClientGetClientDetailsResponse::mutable_games_running() {
  return &games_running_;
}

// -------------------------------------------------------------------

// CMsgClientGetClientAppList

// optional bool media = 1;
inline bool CMsgClientGetClientAppList::has_media() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetClientAppList::set_has_media() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetClientAppList::clear_has_media() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetClientAppList::clear_media() {
  media_ = false;
  clear_has_media();
}
inline bool CMsgClientGetClientAppList::media() const {
  return media_;
}
inline void CMsgClientGetClientAppList::set_media(bool value) {
  set_has_media();
  media_ = value;
}

// optional bool tools = 2;
inline bool CMsgClientGetClientAppList::has_tools() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetClientAppList::set_has_tools() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetClientAppList::clear_has_tools() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetClientAppList::clear_tools() {
  tools_ = false;
  clear_has_tools();
}
inline bool CMsgClientGetClientAppList::tools() const {
  return tools_;
}
inline void CMsgClientGetClientAppList::set_tools(bool value) {
  set_has_tools();
  tools_ = value;
}

// optional bool games = 3;
inline bool CMsgClientGetClientAppList::has_games() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetClientAppList::set_has_games() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetClientAppList::clear_has_games() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetClientAppList::clear_games() {
  games_ = false;
  clear_has_games();
}
inline bool CMsgClientGetClientAppList::games() const {
  return games_;
}
inline void CMsgClientGetClientAppList::set_games(bool value) {
  set_has_games();
  games_ = value;
}

// optional bool only_installed = 4;
inline bool CMsgClientGetClientAppList::has_only_installed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGetClientAppList::set_has_only_installed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGetClientAppList::clear_has_only_installed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGetClientAppList::clear_only_installed() {
  only_installed_ = false;
  clear_has_only_installed();
}
inline bool CMsgClientGetClientAppList::only_installed() const {
  return only_installed_;
}
inline void CMsgClientGetClientAppList::set_only_installed(bool value) {
  set_has_only_installed();
  only_installed_ = value;
}

// optional bool only_changing = 5;
inline bool CMsgClientGetClientAppList::has_only_changing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientGetClientAppList::set_has_only_changing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientGetClientAppList::clear_has_only_changing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientGetClientAppList::clear_only_changing() {
  only_changing_ = false;
  clear_has_only_changing();
}
inline bool CMsgClientGetClientAppList::only_changing() const {
  return only_changing_;
}
inline void CMsgClientGetClientAppList::set_only_changing(bool value) {
  set_has_only_changing();
  only_changing_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetClientAppListResponse_App_DLC

// optional uint32 appid = 1;
inline bool CMsgClientGetClientAppListResponse_App_DLC::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientGetClientAppListResponse_App_DLC::appid() const {
  return appid_;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional bool installed = 2;
inline bool CMsgClientGetClientAppListResponse_App_DLC::has_installed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::set_has_installed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::clear_has_installed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::clear_installed() {
  installed_ = false;
  clear_has_installed();
}
inline bool CMsgClientGetClientAppListResponse_App_DLC::installed() const {
  return installed_;
}
inline void CMsgClientGetClientAppListResponse_App_DLC::set_installed(bool value) {
  set_has_installed();
  installed_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetClientAppListResponse_App

// optional uint32 appid = 1;
inline bool CMsgClientGetClientAppListResponse_App::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientGetClientAppListResponse_App::appid() const {
  return appid_;
}
inline void CMsgClientGetClientAppListResponse_App::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string category = 2;
inline bool CMsgClientGetClientAppListResponse_App::has_category() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_category() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_category() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& CMsgClientGetClientAppListResponse_App::category() const {
  return *category_;
}
inline void CMsgClientGetClientAppListResponse_App::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void CMsgClientGetClientAppListResponse_App::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void CMsgClientGetClientAppListResponse_App::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientAppListResponse_App::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* CMsgClientGetClientAppListResponse_App::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientAppListResponse_App::set_allocated_category(::std::string* category) {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    delete category_;
  }
  if (category) {
    set_has_category();
    category_ = category;
  } else {
    clear_has_category();
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string app_type = 10;
inline bool CMsgClientGetClientAppListResponse_App::has_app_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_app_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_app_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_app_type() {
  if (app_type_ != &::google::protobuf::internal::kEmptyString) {
    app_type_->clear();
  }
  clear_has_app_type();
}
inline const ::std::string& CMsgClientGetClientAppListResponse_App::app_type() const {
  return *app_type_;
}
inline void CMsgClientGetClientAppListResponse_App::set_app_type(const ::std::string& value) {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  app_type_->assign(value);
}
inline void CMsgClientGetClientAppListResponse_App::set_app_type(const char* value) {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  app_type_->assign(value);
}
inline void CMsgClientGetClientAppListResponse_App::set_app_type(const char* value, size_t size) {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  app_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetClientAppListResponse_App::mutable_app_type() {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  return app_type_;
}
inline ::std::string* CMsgClientGetClientAppListResponse_App::release_app_type() {
  clear_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_type_;
    app_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetClientAppListResponse_App::set_allocated_app_type(::std::string* app_type) {
  if (app_type_ != &::google::protobuf::internal::kEmptyString) {
    delete app_type_;
  }
  if (app_type) {
    set_has_app_type();
    app_type_ = app_type;
  } else {
    clear_has_app_type();
    app_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool favorite = 3;
inline bool CMsgClientGetClientAppListResponse_App::has_favorite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_favorite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_favorite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_favorite() {
  favorite_ = false;
  clear_has_favorite();
}
inline bool CMsgClientGetClientAppListResponse_App::favorite() const {
  return favorite_;
}
inline void CMsgClientGetClientAppListResponse_App::set_favorite(bool value) {
  set_has_favorite();
  favorite_ = value;
}

// optional bool installed = 4;
inline bool CMsgClientGetClientAppListResponse_App::has_installed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_installed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_installed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_installed() {
  installed_ = false;
  clear_has_installed();
}
inline bool CMsgClientGetClientAppListResponse_App::installed() const {
  return installed_;
}
inline void CMsgClientGetClientAppListResponse_App::set_installed(bool value) {
  set_has_installed();
  installed_ = value;
}

// optional bool auto_update = 5;
inline bool CMsgClientGetClientAppListResponse_App::has_auto_update() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_auto_update() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_auto_update() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_auto_update() {
  auto_update_ = false;
  clear_has_auto_update();
}
inline bool CMsgClientGetClientAppListResponse_App::auto_update() const {
  return auto_update_;
}
inline void CMsgClientGetClientAppListResponse_App::set_auto_update(bool value) {
  set_has_auto_update();
  auto_update_ = value;
}

// optional uint64 bytes_downloaded = 6;
inline bool CMsgClientGetClientAppListResponse_App::has_bytes_downloaded() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_bytes_downloaded() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_bytes_downloaded() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_bytes_downloaded() {
  bytes_downloaded_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_downloaded();
}
inline ::google::protobuf::uint64 CMsgClientGetClientAppListResponse_App::bytes_downloaded() const {
  return bytes_downloaded_;
}
inline void CMsgClientGetClientAppListResponse_App::set_bytes_downloaded(::google::protobuf::uint64 value) {
  set_has_bytes_downloaded();
  bytes_downloaded_ = value;
}

// optional uint64 bytes_needed = 7;
inline bool CMsgClientGetClientAppListResponse_App::has_bytes_needed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_bytes_needed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_bytes_needed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_bytes_needed() {
  bytes_needed_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_needed();
}
inline ::google::protobuf::uint64 CMsgClientGetClientAppListResponse_App::bytes_needed() const {
  return bytes_needed_;
}
inline void CMsgClientGetClientAppListResponse_App::set_bytes_needed(::google::protobuf::uint64 value) {
  set_has_bytes_needed();
  bytes_needed_ = value;
}

// optional uint32 bytes_download_rate = 8;
inline bool CMsgClientGetClientAppListResponse_App::has_bytes_download_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_bytes_download_rate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_bytes_download_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_bytes_download_rate() {
  bytes_download_rate_ = 0u;
  clear_has_bytes_download_rate();
}
inline ::google::protobuf::uint32 CMsgClientGetClientAppListResponse_App::bytes_download_rate() const {
  return bytes_download_rate_;
}
inline void CMsgClientGetClientAppListResponse_App::set_bytes_download_rate(::google::protobuf::uint32 value) {
  set_has_bytes_download_rate();
  bytes_download_rate_ = value;
}

// optional bool download_paused = 11;
inline bool CMsgClientGetClientAppListResponse_App::has_download_paused() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_download_paused() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_download_paused() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_download_paused() {
  download_paused_ = false;
  clear_has_download_paused();
}
inline bool CMsgClientGetClientAppListResponse_App::download_paused() const {
  return download_paused_;
}
inline void CMsgClientGetClientAppListResponse_App::set_download_paused(bool value) {
  set_has_download_paused();
  download_paused_ = value;
}

// optional uint32 num_downloading = 12;
inline bool CMsgClientGetClientAppListResponse_App::has_num_downloading() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_num_downloading() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_num_downloading() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_num_downloading() {
  num_downloading_ = 0u;
  clear_has_num_downloading();
}
inline ::google::protobuf::uint32 CMsgClientGetClientAppListResponse_App::num_downloading() const {
  return num_downloading_;
}
inline void CMsgClientGetClientAppListResponse_App::set_num_downloading(::google::protobuf::uint32 value) {
  set_has_num_downloading();
  num_downloading_ = value;
}

// optional uint32 num_paused = 13;
inline bool CMsgClientGetClientAppListResponse_App::has_num_paused() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_num_paused() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_num_paused() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_num_paused() {
  num_paused_ = 0u;
  clear_has_num_paused();
}
inline ::google::protobuf::uint32 CMsgClientGetClientAppListResponse_App::num_paused() const {
  return num_paused_;
}
inline void CMsgClientGetClientAppListResponse_App::set_num_paused(::google::protobuf::uint32 value) {
  set_has_num_paused();
  num_paused_ = value;
}

// optional bool changing = 14;
inline bool CMsgClientGetClientAppListResponse_App::has_changing() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_changing() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_changing() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_changing() {
  changing_ = false;
  clear_has_changing();
}
inline bool CMsgClientGetClientAppListResponse_App::changing() const {
  return changing_;
}
inline void CMsgClientGetClientAppListResponse_App::set_changing(bool value) {
  set_has_changing();
  changing_ = value;
}

// optional bool available_on_platform = 15;
inline bool CMsgClientGetClientAppListResponse_App::has_available_on_platform() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientGetClientAppListResponse_App::set_has_available_on_platform() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_has_available_on_platform() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientGetClientAppListResponse_App::clear_available_on_platform() {
  available_on_platform_ = false;
  clear_has_available_on_platform();
}
inline bool CMsgClientGetClientAppListResponse_App::available_on_platform() const {
  return available_on_platform_;
}
inline void CMsgClientGetClientAppListResponse_App::set_available_on_platform(bool value) {
  set_has_available_on_platform();
  available_on_platform_ = value;
}

// repeated .Sc.CMsgClientGetClientAppListResponse.App.DLC dlcs = 9;
inline int CMsgClientGetClientAppListResponse_App::dlcs_size() const {
  return dlcs_.size();
}
inline void CMsgClientGetClientAppListResponse_App::clear_dlcs() {
  dlcs_.Clear();
}
inline const ::Sc::CMsgClientGetClientAppListResponse_App_DLC& CMsgClientGetClientAppListResponse_App::dlcs(int index) const {
  return dlcs_.Get(index);
}
inline ::Sc::CMsgClientGetClientAppListResponse_App_DLC* CMsgClientGetClientAppListResponse_App::mutable_dlcs(int index) {
  return dlcs_.Mutable(index);
}
inline ::Sc::CMsgClientGetClientAppListResponse_App_DLC* CMsgClientGetClientAppListResponse_App::add_dlcs() {
  return dlcs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App_DLC >&
CMsgClientGetClientAppListResponse_App::dlcs() const {
  return dlcs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App_DLC >*
CMsgClientGetClientAppListResponse_App::mutable_dlcs() {
  return &dlcs_;
}

// -------------------------------------------------------------------

// CMsgClientGetClientAppListResponse

// repeated .Sc.CMsgClientGetClientAppListResponse.App apps = 1;
inline int CMsgClientGetClientAppListResponse::apps_size() const {
  return apps_.size();
}
inline void CMsgClientGetClientAppListResponse::clear_apps() {
  apps_.Clear();
}
inline const ::Sc::CMsgClientGetClientAppListResponse_App& CMsgClientGetClientAppListResponse::apps(int index) const {
  return apps_.Get(index);
}
inline ::Sc::CMsgClientGetClientAppListResponse_App* CMsgClientGetClientAppListResponse::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::Sc::CMsgClientGetClientAppListResponse_App* CMsgClientGetClientAppListResponse::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App >&
CMsgClientGetClientAppListResponse::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetClientAppListResponse_App >*
CMsgClientGetClientAppListResponse::mutable_apps() {
  return &apps_;
}

// optional uint64 bytes_available = 2;
inline bool CMsgClientGetClientAppListResponse::has_bytes_available() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetClientAppListResponse::set_has_bytes_available() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetClientAppListResponse::clear_has_bytes_available() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetClientAppListResponse::clear_bytes_available() {
  bytes_available_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_available();
}
inline ::google::protobuf::uint64 CMsgClientGetClientAppListResponse::bytes_available() const {
  return bytes_available_;
}
inline void CMsgClientGetClientAppListResponse::set_bytes_available(::google::protobuf::uint64 value) {
  set_has_bytes_available();
  bytes_available_ = value;
}

// -------------------------------------------------------------------

// CMsgClientInstallClientApp

// optional uint32 appid = 1;
inline bool CMsgClientInstallClientApp::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientInstallClientApp::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientInstallClientApp::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientInstallClientApp::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientInstallClientApp::appid() const {
  return appid_;
}
inline void CMsgClientInstallClientApp::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientInstallClientAppResponse

// optional uint32 result = 1;
inline bool CMsgClientInstallClientAppResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientInstallClientAppResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientInstallClientAppResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientInstallClientAppResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CMsgClientInstallClientAppResponse::result() const {
  return result_;
}
inline void CMsgClientInstallClientAppResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUninstallClientApp

// optional uint32 appid = 1;
inline bool CMsgClientUninstallClientApp::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUninstallClientApp::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUninstallClientApp::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUninstallClientApp::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientUninstallClientApp::appid() const {
  return appid_;
}
inline void CMsgClientUninstallClientApp::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUninstallClientAppResponse

// optional uint32 result = 1;
inline bool CMsgClientUninstallClientAppResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUninstallClientAppResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUninstallClientAppResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUninstallClientAppResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CMsgClientUninstallClientAppResponse::result() const {
  return result_;
}
inline void CMsgClientUninstallClientAppResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CMsgClientSetClientAppUpdateState

// optional uint32 appid = 1;
inline bool CMsgClientSetClientAppUpdateState::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSetClientAppUpdateState::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSetClientAppUpdateState::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSetClientAppUpdateState::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientSetClientAppUpdateState::appid() const {
  return appid_;
}
inline void CMsgClientSetClientAppUpdateState::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional bool update = 2;
inline bool CMsgClientSetClientAppUpdateState::has_update() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientSetClientAppUpdateState::set_has_update() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientSetClientAppUpdateState::clear_has_update() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientSetClientAppUpdateState::clear_update() {
  update_ = false;
  clear_has_update();
}
inline bool CMsgClientSetClientAppUpdateState::update() const {
  return update_;
}
inline void CMsgClientSetClientAppUpdateState::set_update(bool value) {
  set_has_update();
  update_ = value;
}

// -------------------------------------------------------------------

// CMsgClientSetClientAppUpdateStateResponse

// optional uint32 result = 1;
inline bool CMsgClientSetClientAppUpdateStateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSetClientAppUpdateStateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSetClientAppUpdateStateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSetClientAppUpdateStateResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CMsgClientSetClientAppUpdateStateResponse::result() const {
  return result_;
}
inline void CMsgClientSetClientAppUpdateStateResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSUploadFileRequest

// optional uint32 app_id = 1;
inline bool CMsgClientUFSUploadFileRequest::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSUploadFileRequest::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSUploadFileRequest::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSUploadFileRequest::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 file_size = 2;
inline bool CMsgClientUFSUploadFileRequest::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSUploadFileRequest::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSUploadFileRequest::file_size() const {
  return file_size_;
}
inline void CMsgClientUFSUploadFileRequest::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional uint32 raw_file_size = 3;
inline bool CMsgClientUFSUploadFileRequest::has_raw_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_raw_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_raw_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSUploadFileRequest::clear_raw_file_size() {
  raw_file_size_ = 0u;
  clear_has_raw_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSUploadFileRequest::raw_file_size() const {
  return raw_file_size_;
}
inline void CMsgClientUFSUploadFileRequest::set_raw_file_size(::google::protobuf::uint32 value) {
  set_has_raw_file_size();
  raw_file_size_ = value;
}

// optional bytes sha_file = 4;
inline bool CMsgClientUFSUploadFileRequest::has_sha_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_sha_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUFSUploadFileRequest::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSUploadFileRequest::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSUploadFileRequest::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSUploadFileRequest::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSUploadFileRequest::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSUploadFileRequest::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSUploadFileRequest::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSUploadFileRequest::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time_stamp = 5;
inline bool CMsgClientUFSUploadFileRequest::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUFSUploadFileRequest::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::uint64 CMsgClientUFSUploadFileRequest::time_stamp() const {
  return time_stamp_;
}
inline void CMsgClientUFSUploadFileRequest::set_time_stamp(::google::protobuf::uint64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
}

// optional string file_name = 6;
inline bool CMsgClientUFSUploadFileRequest::has_file_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_file_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUFSUploadFileRequest::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSUploadFileRequest::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSUploadFileRequest::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSUploadFileRequest::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSUploadFileRequest::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSUploadFileRequest::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSUploadFileRequest::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSUploadFileRequest::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platforms_to_sync_deprecated = 7;
inline bool CMsgClientUFSUploadFileRequest::has_platforms_to_sync_deprecated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_platforms_to_sync_deprecated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_platforms_to_sync_deprecated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUFSUploadFileRequest::clear_platforms_to_sync_deprecated() {
  platforms_to_sync_deprecated_ = 0u;
  clear_has_platforms_to_sync_deprecated();
}
inline ::google::protobuf::uint32 CMsgClientUFSUploadFileRequest::platforms_to_sync_deprecated() const {
  return platforms_to_sync_deprecated_;
}
inline void CMsgClientUFSUploadFileRequest::set_platforms_to_sync_deprecated(::google::protobuf::uint32 value) {
  set_has_platforms_to_sync_deprecated();
  platforms_to_sync_deprecated_ = value;
}

// optional uint32 platforms_to_sync = 8 [default = 4294967295];
inline bool CMsgClientUFSUploadFileRequest::has_platforms_to_sync() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUFSUploadFileRequest::set_has_platforms_to_sync() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUFSUploadFileRequest::clear_has_platforms_to_sync() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUFSUploadFileRequest::clear_platforms_to_sync() {
  platforms_to_sync_ = 4294967295u;
  clear_has_platforms_to_sync();
}
inline ::google::protobuf::uint32 CMsgClientUFSUploadFileRequest::platforms_to_sync() const {
  return platforms_to_sync_;
}
inline void CMsgClientUFSUploadFileRequest::set_platforms_to_sync(::google::protobuf::uint32 value) {
  set_has_platforms_to_sync();
  platforms_to_sync_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSUploadFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSUploadFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSUploadFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSUploadFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSUploadFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSUploadFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSUploadFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional bytes sha_file = 2;
inline bool CMsgClientUFSUploadFileResponse::has_sha_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSUploadFileResponse::set_has_sha_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSUploadFileResponse::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSUploadFileResponse::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSUploadFileResponse::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSUploadFileResponse::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSUploadFileResponse::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSUploadFileResponse::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSUploadFileResponse::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSUploadFileResponse::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSUploadFileResponse::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSFileChunk

// optional bytes sha_file = 1;
inline bool CMsgClientUFSFileChunk::has_sha_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSFileChunk::set_has_sha_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSFileChunk::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSFileChunk::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSFileChunk::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSFileChunk::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSFileChunk::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSFileChunk::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSFileChunk::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSFileChunk::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSFileChunk::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 file_start = 2;
inline bool CMsgClientUFSFileChunk::has_file_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSFileChunk::set_has_file_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSFileChunk::clear_has_file_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSFileChunk::clear_file_start() {
  file_start_ = 0u;
  clear_has_file_start();
}
inline ::google::protobuf::uint32 CMsgClientUFSFileChunk::file_start() const {
  return file_start_;
}
inline void CMsgClientUFSFileChunk::set_file_start(::google::protobuf::uint32 value) {
  set_has_file_start();
  file_start_ = value;
}

// optional bytes data = 3;
inline bool CMsgClientUFSFileChunk::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSFileChunk::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSFileChunk::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSFileChunk::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientUFSFileChunk::data() const {
  return *data_;
}
inline void CMsgClientUFSFileChunk::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientUFSFileChunk::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientUFSFileChunk::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSFileChunk::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientUFSFileChunk::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSFileChunk::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSTransferHeartbeat

// -------------------------------------------------------------------

// CMsgClientUFSUploadFileFinished

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSUploadFileFinished::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSUploadFileFinished::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSUploadFileFinished::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSUploadFileFinished::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSUploadFileFinished::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSUploadFileFinished::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional bytes sha_file = 2;
inline bool CMsgClientUFSUploadFileFinished::has_sha_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSUploadFileFinished::set_has_sha_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSUploadFileFinished::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSUploadFileFinished::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSUploadFileFinished::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSUploadFileFinished::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSUploadFileFinished::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSUploadFileFinished::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSUploadFileFinished::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSUploadFileFinished::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSUploadFileFinished::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSDeleteFileRequest

// optional uint32 app_id = 1;
inline bool CMsgClientUFSDeleteFileRequest::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSDeleteFileRequest::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSDeleteFileRequest::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSDeleteFileRequest::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSDeleteFileRequest::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSDeleteFileRequest::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUFSDeleteFileRequest::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSDeleteFileRequest::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSDeleteFileRequest::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSDeleteFileRequest::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSDeleteFileRequest::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSDeleteFileRequest::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSDeleteFileRequest::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSDeleteFileRequest::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSDeleteFileRequest::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSDeleteFileRequest::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSDeleteFileRequest::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_explicit_delete = 3;
inline bool CMsgClientUFSDeleteFileRequest::has_is_explicit_delete() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSDeleteFileRequest::set_has_is_explicit_delete() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSDeleteFileRequest::clear_has_is_explicit_delete() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSDeleteFileRequest::clear_is_explicit_delete() {
  is_explicit_delete_ = false;
  clear_has_is_explicit_delete();
}
inline bool CMsgClientUFSDeleteFileRequest::is_explicit_delete() const {
  return is_explicit_delete_;
}
inline void CMsgClientUFSDeleteFileRequest::set_is_explicit_delete(bool value) {
  set_has_is_explicit_delete();
  is_explicit_delete_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSDeleteFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSDeleteFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSDeleteFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSDeleteFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSDeleteFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSDeleteFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSDeleteFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUFSDeleteFileResponse::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSDeleteFileResponse::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSDeleteFileResponse::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSDeleteFileResponse::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSDeleteFileResponse::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSDeleteFileResponse::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSDeleteFileResponse::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSDeleteFileResponse::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSDeleteFileResponse::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSDeleteFileResponse::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSDeleteFileResponse::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSGetFileListForApp

// repeated uint32 apps_to_query = 1;
inline int CMsgClientUFSGetFileListForApp::apps_to_query_size() const {
  return apps_to_query_.size();
}
inline void CMsgClientUFSGetFileListForApp::clear_apps_to_query() {
  apps_to_query_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetFileListForApp::apps_to_query(int index) const {
  return apps_to_query_.Get(index);
}
inline void CMsgClientUFSGetFileListForApp::set_apps_to_query(int index, ::google::protobuf::uint32 value) {
  apps_to_query_.Set(index, value);
}
inline void CMsgClientUFSGetFileListForApp::add_apps_to_query(::google::protobuf::uint32 value) {
  apps_to_query_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientUFSGetFileListForApp::apps_to_query() const {
  return apps_to_query_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientUFSGetFileListForApp::mutable_apps_to_query() {
  return &apps_to_query_;
}

// -------------------------------------------------------------------

// CMsgClientUFSGetFileListForAppResponse_File

// optional uint32 app_id = 1;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetFileListForAppResponse_File::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSGetFileListForAppResponse_File::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetFileListForAppResponse_File::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSGetFileListForAppResponse_File::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sha_file = 3;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_sha_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_sha_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSGetFileListForAppResponse_File::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetFileListForAppResponse_File::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSGetFileListForAppResponse_File::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time_stamp = 4;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::uint64 CMsgClientUFSGetFileListForAppResponse_File::time_stamp() const {
  return time_stamp_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_time_stamp(::google::protobuf::uint64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
}

// optional uint32 raw_file_size = 5;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_raw_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_raw_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_raw_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_raw_file_size() {
  raw_file_size_ = 0u;
  clear_has_raw_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetFileListForAppResponse_File::raw_file_size() const {
  return raw_file_size_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_raw_file_size(::google::protobuf::uint32 value) {
  set_has_raw_file_size();
  raw_file_size_ = value;
}

// optional bool is_explicit_delete = 6;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_is_explicit_delete() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_is_explicit_delete() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_is_explicit_delete() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_is_explicit_delete() {
  is_explicit_delete_ = false;
  clear_has_is_explicit_delete();
}
inline bool CMsgClientUFSGetFileListForAppResponse_File::is_explicit_delete() const {
  return is_explicit_delete_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_is_explicit_delete(bool value) {
  set_has_is_explicit_delete();
  is_explicit_delete_ = value;
}

// optional uint32 platforms_to_sync = 7;
inline bool CMsgClientUFSGetFileListForAppResponse_File::has_platforms_to_sync() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_has_platforms_to_sync() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_has_platforms_to_sync() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::clear_platforms_to_sync() {
  platforms_to_sync_ = 0u;
  clear_has_platforms_to_sync();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetFileListForAppResponse_File::platforms_to_sync() const {
  return platforms_to_sync_;
}
inline void CMsgClientUFSGetFileListForAppResponse_File::set_platforms_to_sync(::google::protobuf::uint32 value) {
  set_has_platforms_to_sync();
  platforms_to_sync_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSGetFileListForAppResponse

// repeated .Sc.CMsgClientUFSGetFileListForAppResponse.File files = 1;
inline int CMsgClientUFSGetFileListForAppResponse::files_size() const {
  return files_.size();
}
inline void CMsgClientUFSGetFileListForAppResponse::clear_files() {
  files_.Clear();
}
inline const ::Sc::CMsgClientUFSGetFileListForAppResponse_File& CMsgClientUFSGetFileListForAppResponse::files(int index) const {
  return files_.Get(index);
}
inline ::Sc::CMsgClientUFSGetFileListForAppResponse_File* CMsgClientUFSGetFileListForAppResponse::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::Sc::CMsgClientUFSGetFileListForAppResponse_File* CMsgClientUFSGetFileListForAppResponse::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUFSGetFileListForAppResponse_File >&
CMsgClientUFSGetFileListForAppResponse::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUFSGetFileListForAppResponse_File >*
CMsgClientUFSGetFileListForAppResponse::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// CMsgClientUFSDownloadRequest

// optional uint32 app_id = 1;
inline bool CMsgClientUFSDownloadRequest::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSDownloadRequest::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSDownloadRequest::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSDownloadRequest::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSDownloadRequest::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSDownloadRequest::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUFSDownloadRequest::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSDownloadRequest::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSDownloadRequest::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSDownloadRequest::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSDownloadRequest::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSDownloadRequest::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSDownloadRequest::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSDownloadRequest::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSDownloadRequest::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSDownloadRequest::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSDownloadRequest::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSDownloadResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSDownloadResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSDownloadResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSDownloadResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSDownloadResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientUFSDownloadResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSDownloadResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSDownloadResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSDownloadResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 file_size = 3;
inline bool CMsgClientUFSDownloadResponse::has_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSDownloadResponse::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSDownloadResponse::file_size() const {
  return file_size_;
}
inline void CMsgClientUFSDownloadResponse::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional uint32 raw_file_size = 4;
inline bool CMsgClientUFSDownloadResponse::has_raw_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_raw_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_raw_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUFSDownloadResponse::clear_raw_file_size() {
  raw_file_size_ = 0u;
  clear_has_raw_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSDownloadResponse::raw_file_size() const {
  return raw_file_size_;
}
inline void CMsgClientUFSDownloadResponse::set_raw_file_size(::google::protobuf::uint32 value) {
  set_has_raw_file_size();
  raw_file_size_ = value;
}

// optional bytes sha_file = 5;
inline bool CMsgClientUFSDownloadResponse::has_sha_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_sha_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUFSDownloadResponse::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSDownloadResponse::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSDownloadResponse::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSDownloadResponse::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSDownloadResponse::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSDownloadResponse::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSDownloadResponse::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSDownloadResponse::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time_stamp = 6;
inline bool CMsgClientUFSDownloadResponse::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUFSDownloadResponse::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::uint64 CMsgClientUFSDownloadResponse::time_stamp() const {
  return time_stamp_;
}
inline void CMsgClientUFSDownloadResponse::set_time_stamp(::google::protobuf::uint64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
}

// optional bool is_explicit_delete = 7;
inline bool CMsgClientUFSDownloadResponse::has_is_explicit_delete() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUFSDownloadResponse::set_has_is_explicit_delete() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUFSDownloadResponse::clear_has_is_explicit_delete() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUFSDownloadResponse::clear_is_explicit_delete() {
  is_explicit_delete_ = false;
  clear_has_is_explicit_delete();
}
inline bool CMsgClientUFSDownloadResponse::is_explicit_delete() const {
  return is_explicit_delete_;
}
inline void CMsgClientUFSDownloadResponse::set_is_explicit_delete(bool value) {
  set_has_is_explicit_delete();
  is_explicit_delete_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSLoginRequest

// optional uint32 protocol_version = 1;
inline bool CMsgClientUFSLoginRequest::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSLoginRequest::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSLoginRequest::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSLoginRequest::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 CMsgClientUFSLoginRequest::protocol_version() const {
  return protocol_version_;
}
inline void CMsgClientUFSLoginRequest::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// optional uint64 am_session_token = 2;
inline bool CMsgClientUFSLoginRequest::has_am_session_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSLoginRequest::set_has_am_session_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSLoginRequest::clear_has_am_session_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSLoginRequest::clear_am_session_token() {
  am_session_token_ = GOOGLE_ULONGLONG(0);
  clear_has_am_session_token();
}
inline ::google::protobuf::uint64 CMsgClientUFSLoginRequest::am_session_token() const {
  return am_session_token_;
}
inline void CMsgClientUFSLoginRequest::set_am_session_token(::google::protobuf::uint64 value) {
  set_has_am_session_token();
  am_session_token_ = value;
}

// repeated uint32 apps = 3;
inline int CMsgClientUFSLoginRequest::apps_size() const {
  return apps_.size();
}
inline void CMsgClientUFSLoginRequest::clear_apps() {
  apps_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientUFSLoginRequest::apps(int index) const {
  return apps_.Get(index);
}
inline void CMsgClientUFSLoginRequest::set_apps(int index, ::google::protobuf::uint32 value) {
  apps_.Set(index, value);
}
inline void CMsgClientUFSLoginRequest::add_apps(::google::protobuf::uint32 value) {
  apps_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientUFSLoginRequest::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientUFSLoginRequest::mutable_apps() {
  return &apps_;
}

// -------------------------------------------------------------------

// CMsgClientUFSLoginResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSLoginResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSLoginResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSLoginResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSLoginResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSLoginResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSLoginResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestEncryptedAppTicket

// optional uint32 app_id = 1;
inline bool CMsgClientRequestEncryptedAppTicket::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestEncryptedAppTicket::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestEncryptedAppTicket::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestEncryptedAppTicket::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientRequestEncryptedAppTicket::app_id() const {
  return app_id_;
}
inline void CMsgClientRequestEncryptedAppTicket::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional bytes userdata = 2;
inline bool CMsgClientRequestEncryptedAppTicket::has_userdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestEncryptedAppTicket::set_has_userdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestEncryptedAppTicket::clear_has_userdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestEncryptedAppTicket::clear_userdata() {
  if (userdata_ != &::google::protobuf::internal::kEmptyString) {
    userdata_->clear();
  }
  clear_has_userdata();
}
inline const ::std::string& CMsgClientRequestEncryptedAppTicket::userdata() const {
  return *userdata_;
}
inline void CMsgClientRequestEncryptedAppTicket::set_userdata(const ::std::string& value) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::kEmptyString) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(value);
}
inline void CMsgClientRequestEncryptedAppTicket::set_userdata(const char* value) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::kEmptyString) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(value);
}
inline void CMsgClientRequestEncryptedAppTicket::set_userdata(const void* value, size_t size) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::kEmptyString) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestEncryptedAppTicket::mutable_userdata() {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::kEmptyString) {
    userdata_ = new ::std::string;
  }
  return userdata_;
}
inline ::std::string* CMsgClientRequestEncryptedAppTicket::release_userdata() {
  clear_has_userdata();
  if (userdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userdata_;
    userdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestEncryptedAppTicket::set_allocated_userdata(::std::string* userdata) {
  if (userdata_ != &::google::protobuf::internal::kEmptyString) {
    delete userdata_;
  }
  if (userdata) {
    set_has_userdata();
    userdata_ = userdata;
  } else {
    clear_has_userdata();
    userdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestEncryptedAppTicketResponse

// optional uint32 app_id = 1;
inline bool CMsgClientRequestEncryptedAppTicketResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientRequestEncryptedAppTicketResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 eresult = 2 [default = 2];
inline bool CMsgClientRequestEncryptedAppTicketResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientRequestEncryptedAppTicketResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional .Sc.EncryptedAppTicket encrypted_app_ticket = 3;
inline bool CMsgClientRequestEncryptedAppTicketResponse::has_encrypted_app_ticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::set_has_encrypted_app_ticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::clear_has_encrypted_app_ticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::clear_encrypted_app_ticket() {
  if (encrypted_app_ticket_ != NULL) encrypted_app_ticket_->::Sc::EncryptedAppTicket::Clear();
  clear_has_encrypted_app_ticket();
}
inline const ::Sc::EncryptedAppTicket& CMsgClientRequestEncryptedAppTicketResponse::encrypted_app_ticket() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return encrypted_app_ticket_ != NULL ? *encrypted_app_ticket_ : *default_instance().encrypted_app_ticket_;
#else
  return encrypted_app_ticket_ != NULL ? *encrypted_app_ticket_ : *default_instance_->encrypted_app_ticket_;
#endif
}
inline ::Sc::EncryptedAppTicket* CMsgClientRequestEncryptedAppTicketResponse::mutable_encrypted_app_ticket() {
  set_has_encrypted_app_ticket();
  if (encrypted_app_ticket_ == NULL) encrypted_app_ticket_ = new ::Sc::EncryptedAppTicket;
  return encrypted_app_ticket_;
}
inline ::Sc::EncryptedAppTicket* CMsgClientRequestEncryptedAppTicketResponse::release_encrypted_app_ticket() {
  clear_has_encrypted_app_ticket();
  ::Sc::EncryptedAppTicket* temp = encrypted_app_ticket_;
  encrypted_app_ticket_ = NULL;
  return temp;
}
inline void CMsgClientRequestEncryptedAppTicketResponse::set_allocated_encrypted_app_ticket(::Sc::EncryptedAppTicket* encrypted_app_ticket) {
  delete encrypted_app_ticket_;
  encrypted_app_ticket_ = encrypted_app_ticket;
  if (encrypted_app_ticket) {
    set_has_encrypted_app_ticket();
  } else {
    clear_has_encrypted_app_ticket();
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestOAuthTokenForApp

// optional uint32 app_id = 1;
inline bool CMsgClientRequestOAuthTokenForApp::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestOAuthTokenForApp::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestOAuthTokenForApp::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestOAuthTokenForApp::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientRequestOAuthTokenForApp::app_id() const {
  return app_id_;
}
inline void CMsgClientRequestOAuthTokenForApp::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string oauth_scope = 2;
inline bool CMsgClientRequestOAuthTokenForApp::has_oauth_scope() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestOAuthTokenForApp::set_has_oauth_scope() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestOAuthTokenForApp::clear_has_oauth_scope() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestOAuthTokenForApp::clear_oauth_scope() {
  if (oauth_scope_ != &::google::protobuf::internal::kEmptyString) {
    oauth_scope_->clear();
  }
  clear_has_oauth_scope();
}
inline const ::std::string& CMsgClientRequestOAuthTokenForApp::oauth_scope() const {
  return *oauth_scope_;
}
inline void CMsgClientRequestOAuthTokenForApp::set_oauth_scope(const ::std::string& value) {
  set_has_oauth_scope();
  if (oauth_scope_ == &::google::protobuf::internal::kEmptyString) {
    oauth_scope_ = new ::std::string;
  }
  oauth_scope_->assign(value);
}
inline void CMsgClientRequestOAuthTokenForApp::set_oauth_scope(const char* value) {
  set_has_oauth_scope();
  if (oauth_scope_ == &::google::protobuf::internal::kEmptyString) {
    oauth_scope_ = new ::std::string;
  }
  oauth_scope_->assign(value);
}
inline void CMsgClientRequestOAuthTokenForApp::set_oauth_scope(const char* value, size_t size) {
  set_has_oauth_scope();
  if (oauth_scope_ == &::google::protobuf::internal::kEmptyString) {
    oauth_scope_ = new ::std::string;
  }
  oauth_scope_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestOAuthTokenForApp::mutable_oauth_scope() {
  set_has_oauth_scope();
  if (oauth_scope_ == &::google::protobuf::internal::kEmptyString) {
    oauth_scope_ = new ::std::string;
  }
  return oauth_scope_;
}
inline ::std::string* CMsgClientRequestOAuthTokenForApp::release_oauth_scope() {
  clear_has_oauth_scope();
  if (oauth_scope_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oauth_scope_;
    oauth_scope_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestOAuthTokenForApp::set_allocated_oauth_scope(::std::string* oauth_scope) {
  if (oauth_scope_ != &::google::protobuf::internal::kEmptyString) {
    delete oauth_scope_;
  }
  if (oauth_scope) {
    set_has_oauth_scope();
    oauth_scope_ = oauth_scope;
  } else {
    clear_has_oauth_scope();
    oauth_scope_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestOAuthTokenForAppResponse

// optional uint32 app_id = 1;
inline bool CMsgClientRequestOAuthTokenForAppResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientRequestOAuthTokenForAppResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 eresult = 2 [default = 2];
inline bool CMsgClientRequestOAuthTokenForAppResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientRequestOAuthTokenForAppResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string oauth_token = 3;
inline bool CMsgClientRequestOAuthTokenForAppResponse::has_oauth_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_has_oauth_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::clear_has_oauth_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::clear_oauth_token() {
  if (oauth_token_ != &::google::protobuf::internal::kEmptyString) {
    oauth_token_->clear();
  }
  clear_has_oauth_token();
}
inline const ::std::string& CMsgClientRequestOAuthTokenForAppResponse::oauth_token() const {
  return *oauth_token_;
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_oauth_token(const ::std::string& value) {
  set_has_oauth_token();
  if (oauth_token_ == &::google::protobuf::internal::kEmptyString) {
    oauth_token_ = new ::std::string;
  }
  oauth_token_->assign(value);
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_oauth_token(const char* value) {
  set_has_oauth_token();
  if (oauth_token_ == &::google::protobuf::internal::kEmptyString) {
    oauth_token_ = new ::std::string;
  }
  oauth_token_->assign(value);
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_oauth_token(const char* value, size_t size) {
  set_has_oauth_token();
  if (oauth_token_ == &::google::protobuf::internal::kEmptyString) {
    oauth_token_ = new ::std::string;
  }
  oauth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestOAuthTokenForAppResponse::mutable_oauth_token() {
  set_has_oauth_token();
  if (oauth_token_ == &::google::protobuf::internal::kEmptyString) {
    oauth_token_ = new ::std::string;
  }
  return oauth_token_;
}
inline ::std::string* CMsgClientRequestOAuthTokenForAppResponse::release_oauth_token() {
  clear_has_oauth_token();
  if (oauth_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oauth_token_;
    oauth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestOAuthTokenForAppResponse::set_allocated_oauth_token(::std::string* oauth_token) {
  if (oauth_token_ != &::google::protobuf::internal::kEmptyString) {
    delete oauth_token_;
  }
  if (oauth_token) {
    set_has_oauth_token();
    oauth_token_ = oauth_token;
  } else {
    clear_has_oauth_token();
    oauth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientWalletInfoUpdate

// optional bool has_wallet = 1;
inline bool CMsgClientWalletInfoUpdate::has_has_wallet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientWalletInfoUpdate::set_has_has_wallet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientWalletInfoUpdate::clear_has_has_wallet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientWalletInfoUpdate::clear_has_wallet() {
  has_wallet_ = false;
  clear_has_has_wallet();
}
inline bool CMsgClientWalletInfoUpdate::has_wallet() const {
  return has_wallet_;
}
inline void CMsgClientWalletInfoUpdate::set_has_wallet(bool value) {
  set_has_has_wallet();
  has_wallet_ = value;
}

// optional int32 balance = 2;
inline bool CMsgClientWalletInfoUpdate::has_balance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientWalletInfoUpdate::set_has_balance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientWalletInfoUpdate::clear_has_balance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientWalletInfoUpdate::clear_balance() {
  balance_ = 0;
  clear_has_balance();
}
inline ::google::protobuf::int32 CMsgClientWalletInfoUpdate::balance() const {
  return balance_;
}
inline void CMsgClientWalletInfoUpdate::set_balance(::google::protobuf::int32 value) {
  set_has_balance();
  balance_ = value;
}

// optional int32 currency = 3;
inline bool CMsgClientWalletInfoUpdate::has_currency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientWalletInfoUpdate::set_has_currency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientWalletInfoUpdate::clear_has_currency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientWalletInfoUpdate::clear_currency() {
  currency_ = 0;
  clear_has_currency();
}
inline ::google::protobuf::int32 CMsgClientWalletInfoUpdate::currency() const {
  return currency_;
}
inline void CMsgClientWalletInfoUpdate::set_currency(::google::protobuf::int32 value) {
  set_has_currency();
  currency_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAppInfoUpdate

// optional uint32 last_changenumber = 1;
inline bool CMsgClientAppInfoUpdate::has_last_changenumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAppInfoUpdate::set_has_last_changenumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAppInfoUpdate::clear_has_last_changenumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAppInfoUpdate::clear_last_changenumber() {
  last_changenumber_ = 0u;
  clear_has_last_changenumber();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoUpdate::last_changenumber() const {
  return last_changenumber_;
}
inline void CMsgClientAppInfoUpdate::set_last_changenumber(::google::protobuf::uint32 value) {
  set_has_last_changenumber();
  last_changenumber_ = value;
}

// optional bool send_changelist = 2;
inline bool CMsgClientAppInfoUpdate::has_send_changelist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppInfoUpdate::set_has_send_changelist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppInfoUpdate::clear_has_send_changelist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppInfoUpdate::clear_send_changelist() {
  send_changelist_ = false;
  clear_has_send_changelist();
}
inline bool CMsgClientAppInfoUpdate::send_changelist() const {
  return send_changelist_;
}
inline void CMsgClientAppInfoUpdate::set_send_changelist(bool value) {
  set_has_send_changelist();
  send_changelist_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAppInfoChanges

// optional uint32 current_change_number = 1;
inline bool CMsgClientAppInfoChanges::has_current_change_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAppInfoChanges::set_has_current_change_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAppInfoChanges::clear_has_current_change_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAppInfoChanges::clear_current_change_number() {
  current_change_number_ = 0u;
  clear_has_current_change_number();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoChanges::current_change_number() const {
  return current_change_number_;
}
inline void CMsgClientAppInfoChanges::set_current_change_number(::google::protobuf::uint32 value) {
  set_has_current_change_number();
  current_change_number_ = value;
}

// optional bool force_full_update = 2;
inline bool CMsgClientAppInfoChanges::has_force_full_update() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppInfoChanges::set_has_force_full_update() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppInfoChanges::clear_has_force_full_update() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppInfoChanges::clear_force_full_update() {
  force_full_update_ = false;
  clear_has_force_full_update();
}
inline bool CMsgClientAppInfoChanges::force_full_update() const {
  return force_full_update_;
}
inline void CMsgClientAppInfoChanges::set_force_full_update(bool value) {
  set_has_force_full_update();
  force_full_update_ = value;
}

// repeated uint32 appIDs = 3;
inline int CMsgClientAppInfoChanges::appids_size() const {
  return appids_.size();
}
inline void CMsgClientAppInfoChanges::clear_appids() {
  appids_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoChanges::appids(int index) const {
  return appids_.Get(index);
}
inline void CMsgClientAppInfoChanges::set_appids(int index, ::google::protobuf::uint32 value) {
  appids_.Set(index, value);
}
inline void CMsgClientAppInfoChanges::add_appids(::google::protobuf::uint32 value) {
  appids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientAppInfoChanges::appids() const {
  return appids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientAppInfoChanges::mutable_appids() {
  return &appids_;
}

// -------------------------------------------------------------------

// CMsgClientAppInfoRequest_App

// optional uint32 app_id = 1;
inline bool CMsgClientAppInfoRequest_App::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAppInfoRequest_App::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAppInfoRequest_App::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAppInfoRequest_App::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoRequest_App::app_id() const {
  return app_id_;
}
inline void CMsgClientAppInfoRequest_App::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 section_flags = 2;
inline bool CMsgClientAppInfoRequest_App::has_section_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppInfoRequest_App::set_has_section_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppInfoRequest_App::clear_has_section_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppInfoRequest_App::clear_section_flags() {
  section_flags_ = 0u;
  clear_has_section_flags();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoRequest_App::section_flags() const {
  return section_flags_;
}
inline void CMsgClientAppInfoRequest_App::set_section_flags(::google::protobuf::uint32 value) {
  set_has_section_flags();
  section_flags_ = value;
}

// repeated uint32 section_CRC = 3;
inline int CMsgClientAppInfoRequest_App::section_crc_size() const {
  return section_crc_.size();
}
inline void CMsgClientAppInfoRequest_App::clear_section_crc() {
  section_crc_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoRequest_App::section_crc(int index) const {
  return section_crc_.Get(index);
}
inline void CMsgClientAppInfoRequest_App::set_section_crc(int index, ::google::protobuf::uint32 value) {
  section_crc_.Set(index, value);
}
inline void CMsgClientAppInfoRequest_App::add_section_crc(::google::protobuf::uint32 value) {
  section_crc_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientAppInfoRequest_App::section_crc() const {
  return section_crc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientAppInfoRequest_App::mutable_section_crc() {
  return &section_crc_;
}

// -------------------------------------------------------------------

// CMsgClientAppInfoRequest

// repeated .Sc.CMsgClientAppInfoRequest.App apps = 1;
inline int CMsgClientAppInfoRequest::apps_size() const {
  return apps_.size();
}
inline void CMsgClientAppInfoRequest::clear_apps() {
  apps_.Clear();
}
inline const ::Sc::CMsgClientAppInfoRequest_App& CMsgClientAppInfoRequest::apps(int index) const {
  return apps_.Get(index);
}
inline ::Sc::CMsgClientAppInfoRequest_App* CMsgClientAppInfoRequest::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::Sc::CMsgClientAppInfoRequest_App* CMsgClientAppInfoRequest::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoRequest_App >&
CMsgClientAppInfoRequest::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoRequest_App >*
CMsgClientAppInfoRequest::mutable_apps() {
  return &apps_;
}

// optional bool supports_batches = 2 [default = false];
inline bool CMsgClientAppInfoRequest::has_supports_batches() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppInfoRequest::set_has_supports_batches() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppInfoRequest::clear_has_supports_batches() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppInfoRequest::clear_supports_batches() {
  supports_batches_ = false;
  clear_has_supports_batches();
}
inline bool CMsgClientAppInfoRequest::supports_batches() const {
  return supports_batches_;
}
inline void CMsgClientAppInfoRequest::set_supports_batches(bool value) {
  set_has_supports_batches();
  supports_batches_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAppInfoResponse_App_Section

// optional uint32 section_id = 1;
inline bool CMsgClientAppInfoResponse_App_Section::has_section_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAppInfoResponse_App_Section::set_has_section_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAppInfoResponse_App_Section::clear_has_section_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAppInfoResponse_App_Section::clear_section_id() {
  section_id_ = 0u;
  clear_has_section_id();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoResponse_App_Section::section_id() const {
  return section_id_;
}
inline void CMsgClientAppInfoResponse_App_Section::set_section_id(::google::protobuf::uint32 value) {
  set_has_section_id();
  section_id_ = value;
}

// optional bytes section_kv = 2;
inline bool CMsgClientAppInfoResponse_App_Section::has_section_kv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppInfoResponse_App_Section::set_has_section_kv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppInfoResponse_App_Section::clear_has_section_kv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppInfoResponse_App_Section::clear_section_kv() {
  if (section_kv_ != &::google::protobuf::internal::kEmptyString) {
    section_kv_->clear();
  }
  clear_has_section_kv();
}
inline const ::std::string& CMsgClientAppInfoResponse_App_Section::section_kv() const {
  return *section_kv_;
}
inline void CMsgClientAppInfoResponse_App_Section::set_section_kv(const ::std::string& value) {
  set_has_section_kv();
  if (section_kv_ == &::google::protobuf::internal::kEmptyString) {
    section_kv_ = new ::std::string;
  }
  section_kv_->assign(value);
}
inline void CMsgClientAppInfoResponse_App_Section::set_section_kv(const char* value) {
  set_has_section_kv();
  if (section_kv_ == &::google::protobuf::internal::kEmptyString) {
    section_kv_ = new ::std::string;
  }
  section_kv_->assign(value);
}
inline void CMsgClientAppInfoResponse_App_Section::set_section_kv(const void* value, size_t size) {
  set_has_section_kv();
  if (section_kv_ == &::google::protobuf::internal::kEmptyString) {
    section_kv_ = new ::std::string;
  }
  section_kv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAppInfoResponse_App_Section::mutable_section_kv() {
  set_has_section_kv();
  if (section_kv_ == &::google::protobuf::internal::kEmptyString) {
    section_kv_ = new ::std::string;
  }
  return section_kv_;
}
inline ::std::string* CMsgClientAppInfoResponse_App_Section::release_section_kv() {
  clear_has_section_kv();
  if (section_kv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = section_kv_;
    section_kv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAppInfoResponse_App_Section::set_allocated_section_kv(::std::string* section_kv) {
  if (section_kv_ != &::google::protobuf::internal::kEmptyString) {
    delete section_kv_;
  }
  if (section_kv) {
    set_has_section_kv();
    section_kv_ = section_kv;
  } else {
    clear_has_section_kv();
    section_kv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientAppInfoResponse_App

// optional uint32 app_id = 1;
inline bool CMsgClientAppInfoResponse_App::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAppInfoResponse_App::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAppInfoResponse_App::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAppInfoResponse_App::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoResponse_App::app_id() const {
  return app_id_;
}
inline void CMsgClientAppInfoResponse_App::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 change_number = 2;
inline bool CMsgClientAppInfoResponse_App::has_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAppInfoResponse_App::set_has_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAppInfoResponse_App::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAppInfoResponse_App::clear_change_number() {
  change_number_ = 0u;
  clear_has_change_number();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoResponse_App::change_number() const {
  return change_number_;
}
inline void CMsgClientAppInfoResponse_App::set_change_number(::google::protobuf::uint32 value) {
  set_has_change_number();
  change_number_ = value;
}

// repeated .Sc.CMsgClientAppInfoResponse.App.Section sections = 3;
inline int CMsgClientAppInfoResponse_App::sections_size() const {
  return sections_.size();
}
inline void CMsgClientAppInfoResponse_App::clear_sections() {
  sections_.Clear();
}
inline const ::Sc::CMsgClientAppInfoResponse_App_Section& CMsgClientAppInfoResponse_App::sections(int index) const {
  return sections_.Get(index);
}
inline ::Sc::CMsgClientAppInfoResponse_App_Section* CMsgClientAppInfoResponse_App::mutable_sections(int index) {
  return sections_.Mutable(index);
}
inline ::Sc::CMsgClientAppInfoResponse_App_Section* CMsgClientAppInfoResponse_App::add_sections() {
  return sections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App_Section >&
CMsgClientAppInfoResponse_App::sections() const {
  return sections_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App_Section >*
CMsgClientAppInfoResponse_App::mutable_sections() {
  return &sections_;
}

// -------------------------------------------------------------------

// CMsgClientAppInfoResponse

// repeated .Sc.CMsgClientAppInfoResponse.App apps = 1;
inline int CMsgClientAppInfoResponse::apps_size() const {
  return apps_.size();
}
inline void CMsgClientAppInfoResponse::clear_apps() {
  apps_.Clear();
}
inline const ::Sc::CMsgClientAppInfoResponse_App& CMsgClientAppInfoResponse::apps(int index) const {
  return apps_.Get(index);
}
inline ::Sc::CMsgClientAppInfoResponse_App* CMsgClientAppInfoResponse::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::Sc::CMsgClientAppInfoResponse_App* CMsgClientAppInfoResponse::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App >&
CMsgClientAppInfoResponse::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAppInfoResponse_App >*
CMsgClientAppInfoResponse::mutable_apps() {
  return &apps_;
}

// repeated uint32 apps_unknown = 2;
inline int CMsgClientAppInfoResponse::apps_unknown_size() const {
  return apps_unknown_.size();
}
inline void CMsgClientAppInfoResponse::clear_apps_unknown() {
  apps_unknown_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoResponse::apps_unknown(int index) const {
  return apps_unknown_.Get(index);
}
inline void CMsgClientAppInfoResponse::set_apps_unknown(int index, ::google::protobuf::uint32 value) {
  apps_unknown_.Set(index, value);
}
inline void CMsgClientAppInfoResponse::add_apps_unknown(::google::protobuf::uint32 value) {
  apps_unknown_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientAppInfoResponse::apps_unknown() const {
  return apps_unknown_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientAppInfoResponse::mutable_apps_unknown() {
  return &apps_unknown_;
}

// optional uint32 apps_pending = 3;
inline bool CMsgClientAppInfoResponse::has_apps_pending() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAppInfoResponse::set_has_apps_pending() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAppInfoResponse::clear_has_apps_pending() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAppInfoResponse::clear_apps_pending() {
  apps_pending_ = 0u;
  clear_has_apps_pending();
}
inline ::google::protobuf::uint32 CMsgClientAppInfoResponse::apps_pending() const {
  return apps_pending_;
}
inline void CMsgClientAppInfoResponse::set_apps_pending(::google::protobuf::uint32 value) {
  set_has_apps_pending();
  apps_pending_ = value;
}

// -------------------------------------------------------------------

// CMsgClientPackageInfoRequest

// repeated uint32 package_ids = 1;
inline int CMsgClientPackageInfoRequest::package_ids_size() const {
  return package_ids_.size();
}
inline void CMsgClientPackageInfoRequest::clear_package_ids() {
  package_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientPackageInfoRequest::package_ids(int index) const {
  return package_ids_.Get(index);
}
inline void CMsgClientPackageInfoRequest::set_package_ids(int index, ::google::protobuf::uint32 value) {
  package_ids_.Set(index, value);
}
inline void CMsgClientPackageInfoRequest::add_package_ids(::google::protobuf::uint32 value) {
  package_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientPackageInfoRequest::package_ids() const {
  return package_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientPackageInfoRequest::mutable_package_ids() {
  return &package_ids_;
}

// optional bool meta_data_only = 2;
inline bool CMsgClientPackageInfoRequest::has_meta_data_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPackageInfoRequest::set_has_meta_data_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPackageInfoRequest::clear_has_meta_data_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPackageInfoRequest::clear_meta_data_only() {
  meta_data_only_ = false;
  clear_has_meta_data_only();
}
inline bool CMsgClientPackageInfoRequest::meta_data_only() const {
  return meta_data_only_;
}
inline void CMsgClientPackageInfoRequest::set_meta_data_only(bool value) {
  set_has_meta_data_only();
  meta_data_only_ = value;
}

// -------------------------------------------------------------------

// CMsgClientPackageInfoResponse_Package

// optional uint32 package_id = 1;
inline bool CMsgClientPackageInfoResponse_Package::has_package_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPackageInfoResponse_Package::set_has_package_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 CMsgClientPackageInfoResponse_Package::package_id() const {
  return package_id_;
}
inline void CMsgClientPackageInfoResponse_Package::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
}

// optional uint32 change_number = 2;
inline bool CMsgClientPackageInfoResponse_Package::has_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPackageInfoResponse_Package::set_has_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_change_number() {
  change_number_ = 0u;
  clear_has_change_number();
}
inline ::google::protobuf::uint32 CMsgClientPackageInfoResponse_Package::change_number() const {
  return change_number_;
}
inline void CMsgClientPackageInfoResponse_Package::set_change_number(::google::protobuf::uint32 value) {
  set_has_change_number();
  change_number_ = value;
}

// optional bytes sha = 3;
inline bool CMsgClientPackageInfoResponse_Package::has_sha() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientPackageInfoResponse_Package::set_has_sha() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_has_sha() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_sha() {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    sha_->clear();
  }
  clear_has_sha();
}
inline const ::std::string& CMsgClientPackageInfoResponse_Package::sha() const {
  return *sha_;
}
inline void CMsgClientPackageInfoResponse_Package::set_sha(const ::std::string& value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgClientPackageInfoResponse_Package::set_sha(const char* value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgClientPackageInfoResponse_Package::set_sha(const void* value, size_t size) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPackageInfoResponse_Package::mutable_sha() {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  return sha_;
}
inline ::std::string* CMsgClientPackageInfoResponse_Package::release_sha() {
  clear_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_;
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPackageInfoResponse_Package::set_allocated_sha(::std::string* sha) {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_;
  }
  if (sha) {
    set_has_sha();
    sha_ = sha;
  } else {
    clear_has_sha();
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes buffer = 4;
inline bool CMsgClientPackageInfoResponse_Package::has_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientPackageInfoResponse_Package::set_has_buffer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientPackageInfoResponse_Package::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& CMsgClientPackageInfoResponse_Package::buffer() const {
  return *buffer_;
}
inline void CMsgClientPackageInfoResponse_Package::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgClientPackageInfoResponse_Package::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgClientPackageInfoResponse_Package::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPackageInfoResponse_Package::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* CMsgClientPackageInfoResponse_Package::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPackageInfoResponse_Package::set_allocated_buffer(::std::string* buffer) {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_;
  }
  if (buffer) {
    set_has_buffer();
    buffer_ = buffer;
  } else {
    clear_has_buffer();
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientPackageInfoResponse

// repeated .Sc.CMsgClientPackageInfoResponse.Package packages = 1;
inline int CMsgClientPackageInfoResponse::packages_size() const {
  return packages_.size();
}
inline void CMsgClientPackageInfoResponse::clear_packages() {
  packages_.Clear();
}
inline const ::Sc::CMsgClientPackageInfoResponse_Package& CMsgClientPackageInfoResponse::packages(int index) const {
  return packages_.Get(index);
}
inline ::Sc::CMsgClientPackageInfoResponse_Package* CMsgClientPackageInfoResponse::mutable_packages(int index) {
  return packages_.Mutable(index);
}
inline ::Sc::CMsgClientPackageInfoResponse_Package* CMsgClientPackageInfoResponse::add_packages() {
  return packages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPackageInfoResponse_Package >&
CMsgClientPackageInfoResponse::packages() const {
  return packages_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientPackageInfoResponse_Package >*
CMsgClientPackageInfoResponse::mutable_packages() {
  return &packages_;
}

// repeated uint32 packages_unknown = 2;
inline int CMsgClientPackageInfoResponse::packages_unknown_size() const {
  return packages_unknown_.size();
}
inline void CMsgClientPackageInfoResponse::clear_packages_unknown() {
  packages_unknown_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientPackageInfoResponse::packages_unknown(int index) const {
  return packages_unknown_.Get(index);
}
inline void CMsgClientPackageInfoResponse::set_packages_unknown(int index, ::google::protobuf::uint32 value) {
  packages_unknown_.Set(index, value);
}
inline void CMsgClientPackageInfoResponse::add_packages_unknown(::google::protobuf::uint32 value) {
  packages_unknown_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientPackageInfoResponse::packages_unknown() const {
  return packages_unknown_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientPackageInfoResponse::mutable_packages_unknown() {
  return &packages_unknown_;
}

// optional uint32 packages_pending = 3;
inline bool CMsgClientPackageInfoResponse::has_packages_pending() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientPackageInfoResponse::set_has_packages_pending() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientPackageInfoResponse::clear_has_packages_pending() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientPackageInfoResponse::clear_packages_pending() {
  packages_pending_ = 0u;
  clear_has_packages_pending();
}
inline ::google::protobuf::uint32 CMsgClientPackageInfoResponse::packages_pending() const {
  return packages_pending_;
}
inline void CMsgClientPackageInfoResponse::set_packages_pending(::google::protobuf::uint32 value) {
  set_has_packages_pending();
  packages_pending_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSChangesSinceRequest

// optional uint32 since_change_number = 1;
inline bool CMsgPICSChangesSinceRequest::has_since_change_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSChangesSinceRequest::set_has_since_change_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSChangesSinceRequest::clear_has_since_change_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSChangesSinceRequest::clear_since_change_number() {
  since_change_number_ = 0u;
  clear_has_since_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceRequest::since_change_number() const {
  return since_change_number_;
}
inline void CMsgPICSChangesSinceRequest::set_since_change_number(::google::protobuf::uint32 value) {
  set_has_since_change_number();
  since_change_number_ = value;
}

// optional bool send_app_info_changes = 2;
inline bool CMsgPICSChangesSinceRequest::has_send_app_info_changes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSChangesSinceRequest::set_has_send_app_info_changes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSChangesSinceRequest::clear_has_send_app_info_changes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSChangesSinceRequest::clear_send_app_info_changes() {
  send_app_info_changes_ = false;
  clear_has_send_app_info_changes();
}
inline bool CMsgPICSChangesSinceRequest::send_app_info_changes() const {
  return send_app_info_changes_;
}
inline void CMsgPICSChangesSinceRequest::set_send_app_info_changes(bool value) {
  set_has_send_app_info_changes();
  send_app_info_changes_ = value;
}

// optional bool send_package_info_changes = 3;
inline bool CMsgPICSChangesSinceRequest::has_send_package_info_changes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSChangesSinceRequest::set_has_send_package_info_changes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSChangesSinceRequest::clear_has_send_package_info_changes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSChangesSinceRequest::clear_send_package_info_changes() {
  send_package_info_changes_ = false;
  clear_has_send_package_info_changes();
}
inline bool CMsgPICSChangesSinceRequest::send_package_info_changes() const {
  return send_package_info_changes_;
}
inline void CMsgPICSChangesSinceRequest::set_send_package_info_changes(bool value) {
  set_has_send_package_info_changes();
  send_package_info_changes_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSChangesSinceResponse_PackageChange

// optional uint32 packageid = 1;
inline bool CMsgPICSChangesSinceResponse_PackageChange::has_packageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::set_has_packageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::clear_has_packageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::clear_packageid() {
  packageid_ = 0u;
  clear_has_packageid();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceResponse_PackageChange::packageid() const {
  return packageid_;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::set_packageid(::google::protobuf::uint32 value) {
  set_has_packageid();
  packageid_ = value;
}

// optional uint32 change_number = 2;
inline bool CMsgPICSChangesSinceResponse_PackageChange::has_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::set_has_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::clear_change_number() {
  change_number_ = 0u;
  clear_has_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceResponse_PackageChange::change_number() const {
  return change_number_;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::set_change_number(::google::protobuf::uint32 value) {
  set_has_change_number();
  change_number_ = value;
}

// optional bool needs_token = 3;
inline bool CMsgPICSChangesSinceResponse_PackageChange::has_needs_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::set_has_needs_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::clear_has_needs_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::clear_needs_token() {
  needs_token_ = false;
  clear_has_needs_token();
}
inline bool CMsgPICSChangesSinceResponse_PackageChange::needs_token() const {
  return needs_token_;
}
inline void CMsgPICSChangesSinceResponse_PackageChange::set_needs_token(bool value) {
  set_has_needs_token();
  needs_token_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSChangesSinceResponse_AppChange

// optional uint32 appid = 1;
inline bool CMsgPICSChangesSinceResponse_AppChange::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSChangesSinceResponse_AppChange::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSChangesSinceResponse_AppChange::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSChangesSinceResponse_AppChange::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceResponse_AppChange::appid() const {
  return appid_;
}
inline void CMsgPICSChangesSinceResponse_AppChange::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional uint32 change_number = 2;
inline bool CMsgPICSChangesSinceResponse_AppChange::has_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSChangesSinceResponse_AppChange::set_has_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSChangesSinceResponse_AppChange::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSChangesSinceResponse_AppChange::clear_change_number() {
  change_number_ = 0u;
  clear_has_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceResponse_AppChange::change_number() const {
  return change_number_;
}
inline void CMsgPICSChangesSinceResponse_AppChange::set_change_number(::google::protobuf::uint32 value) {
  set_has_change_number();
  change_number_ = value;
}

// optional bool needs_token = 3;
inline bool CMsgPICSChangesSinceResponse_AppChange::has_needs_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSChangesSinceResponse_AppChange::set_has_needs_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSChangesSinceResponse_AppChange::clear_has_needs_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSChangesSinceResponse_AppChange::clear_needs_token() {
  needs_token_ = false;
  clear_has_needs_token();
}
inline bool CMsgPICSChangesSinceResponse_AppChange::needs_token() const {
  return needs_token_;
}
inline void CMsgPICSChangesSinceResponse_AppChange::set_needs_token(bool value) {
  set_has_needs_token();
  needs_token_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSChangesSinceResponse

// optional uint32 current_change_number = 1;
inline bool CMsgPICSChangesSinceResponse::has_current_change_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSChangesSinceResponse::set_has_current_change_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSChangesSinceResponse::clear_has_current_change_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSChangesSinceResponse::clear_current_change_number() {
  current_change_number_ = 0u;
  clear_has_current_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceResponse::current_change_number() const {
  return current_change_number_;
}
inline void CMsgPICSChangesSinceResponse::set_current_change_number(::google::protobuf::uint32 value) {
  set_has_current_change_number();
  current_change_number_ = value;
}

// optional uint32 since_change_number = 2;
inline bool CMsgPICSChangesSinceResponse::has_since_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSChangesSinceResponse::set_has_since_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSChangesSinceResponse::clear_has_since_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSChangesSinceResponse::clear_since_change_number() {
  since_change_number_ = 0u;
  clear_has_since_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSChangesSinceResponse::since_change_number() const {
  return since_change_number_;
}
inline void CMsgPICSChangesSinceResponse::set_since_change_number(::google::protobuf::uint32 value) {
  set_has_since_change_number();
  since_change_number_ = value;
}

// optional bool force_full_update = 3;
inline bool CMsgPICSChangesSinceResponse::has_force_full_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSChangesSinceResponse::set_has_force_full_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSChangesSinceResponse::clear_has_force_full_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSChangesSinceResponse::clear_force_full_update() {
  force_full_update_ = false;
  clear_has_force_full_update();
}
inline bool CMsgPICSChangesSinceResponse::force_full_update() const {
  return force_full_update_;
}
inline void CMsgPICSChangesSinceResponse::set_force_full_update(bool value) {
  set_has_force_full_update();
  force_full_update_ = value;
}

// repeated .Sc.CMsgPICSChangesSinceResponse.PackageChange package_changes = 4;
inline int CMsgPICSChangesSinceResponse::package_changes_size() const {
  return package_changes_.size();
}
inline void CMsgPICSChangesSinceResponse::clear_package_changes() {
  package_changes_.Clear();
}
inline const ::Sc::CMsgPICSChangesSinceResponse_PackageChange& CMsgPICSChangesSinceResponse::package_changes(int index) const {
  return package_changes_.Get(index);
}
inline ::Sc::CMsgPICSChangesSinceResponse_PackageChange* CMsgPICSChangesSinceResponse::mutable_package_changes(int index) {
  return package_changes_.Mutable(index);
}
inline ::Sc::CMsgPICSChangesSinceResponse_PackageChange* CMsgPICSChangesSinceResponse::add_package_changes() {
  return package_changes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_PackageChange >&
CMsgPICSChangesSinceResponse::package_changes() const {
  return package_changes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_PackageChange >*
CMsgPICSChangesSinceResponse::mutable_package_changes() {
  return &package_changes_;
}

// repeated .Sc.CMsgPICSChangesSinceResponse.AppChange app_changes = 5;
inline int CMsgPICSChangesSinceResponse::app_changes_size() const {
  return app_changes_.size();
}
inline void CMsgPICSChangesSinceResponse::clear_app_changes() {
  app_changes_.Clear();
}
inline const ::Sc::CMsgPICSChangesSinceResponse_AppChange& CMsgPICSChangesSinceResponse::app_changes(int index) const {
  return app_changes_.Get(index);
}
inline ::Sc::CMsgPICSChangesSinceResponse_AppChange* CMsgPICSChangesSinceResponse::mutable_app_changes(int index) {
  return app_changes_.Mutable(index);
}
inline ::Sc::CMsgPICSChangesSinceResponse_AppChange* CMsgPICSChangesSinceResponse::add_app_changes() {
  return app_changes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_AppChange >&
CMsgPICSChangesSinceResponse::app_changes() const {
  return app_changes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSChangesSinceResponse_AppChange >*
CMsgPICSChangesSinceResponse::mutable_app_changes() {
  return &app_changes_;
}

// -------------------------------------------------------------------

// CMsgPICSProductInfoRequest_AppInfo

// optional uint32 appid = 1;
inline bool CMsgPICSProductInfoRequest_AppInfo::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSProductInfoRequest_AppInfo::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSProductInfoRequest_AppInfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSProductInfoRequest_AppInfo::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoRequest_AppInfo::appid() const {
  return appid_;
}
inline void CMsgPICSProductInfoRequest_AppInfo::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional uint64 access_token = 2;
inline bool CMsgPICSProductInfoRequest_AppInfo::has_access_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSProductInfoRequest_AppInfo::set_has_access_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSProductInfoRequest_AppInfo::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSProductInfoRequest_AppInfo::clear_access_token() {
  access_token_ = GOOGLE_ULONGLONG(0);
  clear_has_access_token();
}
inline ::google::protobuf::uint64 CMsgPICSProductInfoRequest_AppInfo::access_token() const {
  return access_token_;
}
inline void CMsgPICSProductInfoRequest_AppInfo::set_access_token(::google::protobuf::uint64 value) {
  set_has_access_token();
  access_token_ = value;
}

// optional bool only_public = 3;
inline bool CMsgPICSProductInfoRequest_AppInfo::has_only_public() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSProductInfoRequest_AppInfo::set_has_only_public() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSProductInfoRequest_AppInfo::clear_has_only_public() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSProductInfoRequest_AppInfo::clear_only_public() {
  only_public_ = false;
  clear_has_only_public();
}
inline bool CMsgPICSProductInfoRequest_AppInfo::only_public() const {
  return only_public_;
}
inline void CMsgPICSProductInfoRequest_AppInfo::set_only_public(bool value) {
  set_has_only_public();
  only_public_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSProductInfoRequest_PackageInfo

// optional uint32 packageid = 1;
inline bool CMsgPICSProductInfoRequest_PackageInfo::has_packageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::set_has_packageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::clear_has_packageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::clear_packageid() {
  packageid_ = 0u;
  clear_has_packageid();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoRequest_PackageInfo::packageid() const {
  return packageid_;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::set_packageid(::google::protobuf::uint32 value) {
  set_has_packageid();
  packageid_ = value;
}

// optional uint64 access_token = 2;
inline bool CMsgPICSProductInfoRequest_PackageInfo::has_access_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::set_has_access_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::clear_access_token() {
  access_token_ = GOOGLE_ULONGLONG(0);
  clear_has_access_token();
}
inline ::google::protobuf::uint64 CMsgPICSProductInfoRequest_PackageInfo::access_token() const {
  return access_token_;
}
inline void CMsgPICSProductInfoRequest_PackageInfo::set_access_token(::google::protobuf::uint64 value) {
  set_has_access_token();
  access_token_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSProductInfoRequest

// repeated .Sc.CMsgPICSProductInfoRequest.PackageInfo packages = 1;
inline int CMsgPICSProductInfoRequest::packages_size() const {
  return packages_.size();
}
inline void CMsgPICSProductInfoRequest::clear_packages() {
  packages_.Clear();
}
inline const ::Sc::CMsgPICSProductInfoRequest_PackageInfo& CMsgPICSProductInfoRequest::packages(int index) const {
  return packages_.Get(index);
}
inline ::Sc::CMsgPICSProductInfoRequest_PackageInfo* CMsgPICSProductInfoRequest::mutable_packages(int index) {
  return packages_.Mutable(index);
}
inline ::Sc::CMsgPICSProductInfoRequest_PackageInfo* CMsgPICSProductInfoRequest::add_packages() {
  return packages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_PackageInfo >&
CMsgPICSProductInfoRequest::packages() const {
  return packages_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_PackageInfo >*
CMsgPICSProductInfoRequest::mutable_packages() {
  return &packages_;
}

// repeated .Sc.CMsgPICSProductInfoRequest.AppInfo apps = 2;
inline int CMsgPICSProductInfoRequest::apps_size() const {
  return apps_.size();
}
inline void CMsgPICSProductInfoRequest::clear_apps() {
  apps_.Clear();
}
inline const ::Sc::CMsgPICSProductInfoRequest_AppInfo& CMsgPICSProductInfoRequest::apps(int index) const {
  return apps_.Get(index);
}
inline ::Sc::CMsgPICSProductInfoRequest_AppInfo* CMsgPICSProductInfoRequest::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::Sc::CMsgPICSProductInfoRequest_AppInfo* CMsgPICSProductInfoRequest::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_AppInfo >&
CMsgPICSProductInfoRequest::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoRequest_AppInfo >*
CMsgPICSProductInfoRequest::mutable_apps() {
  return &apps_;
}

// optional bool meta_data_only = 3;
inline bool CMsgPICSProductInfoRequest::has_meta_data_only() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSProductInfoRequest::set_has_meta_data_only() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSProductInfoRequest::clear_has_meta_data_only() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSProductInfoRequest::clear_meta_data_only() {
  meta_data_only_ = false;
  clear_has_meta_data_only();
}
inline bool CMsgPICSProductInfoRequest::meta_data_only() const {
  return meta_data_only_;
}
inline void CMsgPICSProductInfoRequest::set_meta_data_only(bool value) {
  set_has_meta_data_only();
  meta_data_only_ = value;
}

// optional uint32 num_prev_failed = 4;
inline bool CMsgPICSProductInfoRequest::has_num_prev_failed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPICSProductInfoRequest::set_has_num_prev_failed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgPICSProductInfoRequest::clear_has_num_prev_failed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgPICSProductInfoRequest::clear_num_prev_failed() {
  num_prev_failed_ = 0u;
  clear_has_num_prev_failed();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoRequest::num_prev_failed() const {
  return num_prev_failed_;
}
inline void CMsgPICSProductInfoRequest::set_num_prev_failed(::google::protobuf::uint32 value) {
  set_has_num_prev_failed();
  num_prev_failed_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSProductInfoResponse_AppInfo

// optional uint32 appid = 1;
inline bool CMsgPICSProductInfoResponse_AppInfo::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoResponse_AppInfo::appid() const {
  return appid_;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional uint32 change_number = 2;
inline bool CMsgPICSProductInfoResponse_AppInfo::has_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_has_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_change_number() {
  change_number_ = 0u;
  clear_has_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoResponse_AppInfo::change_number() const {
  return change_number_;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_change_number(::google::protobuf::uint32 value) {
  set_has_change_number();
  change_number_ = value;
}

// optional bool missing_token = 3;
inline bool CMsgPICSProductInfoResponse_AppInfo::has_missing_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_has_missing_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_has_missing_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_missing_token() {
  missing_token_ = false;
  clear_has_missing_token();
}
inline bool CMsgPICSProductInfoResponse_AppInfo::missing_token() const {
  return missing_token_;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_missing_token(bool value) {
  set_has_missing_token();
  missing_token_ = value;
}

// optional bytes sha = 4;
inline bool CMsgPICSProductInfoResponse_AppInfo::has_sha() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_has_sha() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_has_sha() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_sha() {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    sha_->clear();
  }
  clear_has_sha();
}
inline const ::std::string& CMsgPICSProductInfoResponse_AppInfo::sha() const {
  return *sha_;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_sha(const ::std::string& value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_sha(const char* value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_sha(const void* value, size_t size) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgPICSProductInfoResponse_AppInfo::mutable_sha() {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  return sha_;
}
inline ::std::string* CMsgPICSProductInfoResponse_AppInfo::release_sha() {
  clear_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_;
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_allocated_sha(::std::string* sha) {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_;
  }
  if (sha) {
    set_has_sha();
    sha_ = sha;
  } else {
    clear_has_sha();
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes buffer = 5;
inline bool CMsgPICSProductInfoResponse_AppInfo::has_buffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_has_buffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& CMsgPICSProductInfoResponse_AppInfo::buffer() const {
  return *buffer_;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgPICSProductInfoResponse_AppInfo::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* CMsgPICSProductInfoResponse_AppInfo::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_allocated_buffer(::std::string* buffer) {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_;
  }
  if (buffer) {
    set_has_buffer();
    buffer_ = buffer;
  } else {
    clear_has_buffer();
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool only_public = 6;
inline bool CMsgPICSProductInfoResponse_AppInfo::has_only_public() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_has_only_public() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_has_only_public() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgPICSProductInfoResponse_AppInfo::clear_only_public() {
  only_public_ = false;
  clear_has_only_public();
}
inline bool CMsgPICSProductInfoResponse_AppInfo::only_public() const {
  return only_public_;
}
inline void CMsgPICSProductInfoResponse_AppInfo::set_only_public(bool value) {
  set_has_only_public();
  only_public_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSProductInfoResponse_PackageInfo

// optional uint32 packageid = 1;
inline bool CMsgPICSProductInfoResponse_PackageInfo::has_packageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_has_packageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_has_packageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_packageid() {
  packageid_ = 0u;
  clear_has_packageid();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoResponse_PackageInfo::packageid() const {
  return packageid_;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_packageid(::google::protobuf::uint32 value) {
  set_has_packageid();
  packageid_ = value;
}

// optional uint32 change_number = 2;
inline bool CMsgPICSProductInfoResponse_PackageInfo::has_change_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_has_change_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_has_change_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_change_number() {
  change_number_ = 0u;
  clear_has_change_number();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoResponse_PackageInfo::change_number() const {
  return change_number_;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_change_number(::google::protobuf::uint32 value) {
  set_has_change_number();
  change_number_ = value;
}

// optional bool missing_token = 3;
inline bool CMsgPICSProductInfoResponse_PackageInfo::has_missing_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_has_missing_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_has_missing_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_missing_token() {
  missing_token_ = false;
  clear_has_missing_token();
}
inline bool CMsgPICSProductInfoResponse_PackageInfo::missing_token() const {
  return missing_token_;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_missing_token(bool value) {
  set_has_missing_token();
  missing_token_ = value;
}

// optional bytes sha = 4;
inline bool CMsgPICSProductInfoResponse_PackageInfo::has_sha() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_has_sha() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_has_sha() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_sha() {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    sha_->clear();
  }
  clear_has_sha();
}
inline const ::std::string& CMsgPICSProductInfoResponse_PackageInfo::sha() const {
  return *sha_;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_sha(const ::std::string& value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_sha(const char* value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_sha(const void* value, size_t size) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgPICSProductInfoResponse_PackageInfo::mutable_sha() {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  return sha_;
}
inline ::std::string* CMsgPICSProductInfoResponse_PackageInfo::release_sha() {
  clear_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_;
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_allocated_sha(::std::string* sha) {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_;
  }
  if (sha) {
    set_has_sha();
    sha_ = sha;
  } else {
    clear_has_sha();
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes buffer = 5;
inline bool CMsgPICSProductInfoResponse_PackageInfo::has_buffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_has_buffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& CMsgPICSProductInfoResponse_PackageInfo::buffer() const {
  return *buffer_;
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgPICSProductInfoResponse_PackageInfo::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* CMsgPICSProductInfoResponse_PackageInfo::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgPICSProductInfoResponse_PackageInfo::set_allocated_buffer(::std::string* buffer) {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_;
  }
  if (buffer) {
    set_has_buffer();
    buffer_ = buffer;
  } else {
    clear_has_buffer();
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgPICSProductInfoResponse

// repeated .Sc.CMsgPICSProductInfoResponse.AppInfo apps = 1;
inline int CMsgPICSProductInfoResponse::apps_size() const {
  return apps_.size();
}
inline void CMsgPICSProductInfoResponse::clear_apps() {
  apps_.Clear();
}
inline const ::Sc::CMsgPICSProductInfoResponse_AppInfo& CMsgPICSProductInfoResponse::apps(int index) const {
  return apps_.Get(index);
}
inline ::Sc::CMsgPICSProductInfoResponse_AppInfo* CMsgPICSProductInfoResponse::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::Sc::CMsgPICSProductInfoResponse_AppInfo* CMsgPICSProductInfoResponse::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_AppInfo >&
CMsgPICSProductInfoResponse::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_AppInfo >*
CMsgPICSProductInfoResponse::mutable_apps() {
  return &apps_;
}

// repeated uint32 unknown_appids = 2;
inline int CMsgPICSProductInfoResponse::unknown_appids_size() const {
  return unknown_appids_.size();
}
inline void CMsgPICSProductInfoResponse::clear_unknown_appids() {
  unknown_appids_.Clear();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoResponse::unknown_appids(int index) const {
  return unknown_appids_.Get(index);
}
inline void CMsgPICSProductInfoResponse::set_unknown_appids(int index, ::google::protobuf::uint32 value) {
  unknown_appids_.Set(index, value);
}
inline void CMsgPICSProductInfoResponse::add_unknown_appids(::google::protobuf::uint32 value) {
  unknown_appids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgPICSProductInfoResponse::unknown_appids() const {
  return unknown_appids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgPICSProductInfoResponse::mutable_unknown_appids() {
  return &unknown_appids_;
}

// repeated .Sc.CMsgPICSProductInfoResponse.PackageInfo packages = 3;
inline int CMsgPICSProductInfoResponse::packages_size() const {
  return packages_.size();
}
inline void CMsgPICSProductInfoResponse::clear_packages() {
  packages_.Clear();
}
inline const ::Sc::CMsgPICSProductInfoResponse_PackageInfo& CMsgPICSProductInfoResponse::packages(int index) const {
  return packages_.Get(index);
}
inline ::Sc::CMsgPICSProductInfoResponse_PackageInfo* CMsgPICSProductInfoResponse::mutable_packages(int index) {
  return packages_.Mutable(index);
}
inline ::Sc::CMsgPICSProductInfoResponse_PackageInfo* CMsgPICSProductInfoResponse::add_packages() {
  return packages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_PackageInfo >&
CMsgPICSProductInfoResponse::packages() const {
  return packages_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSProductInfoResponse_PackageInfo >*
CMsgPICSProductInfoResponse::mutable_packages() {
  return &packages_;
}

// repeated uint32 unknown_packageids = 4;
inline int CMsgPICSProductInfoResponse::unknown_packageids_size() const {
  return unknown_packageids_.size();
}
inline void CMsgPICSProductInfoResponse::clear_unknown_packageids() {
  unknown_packageids_.Clear();
}
inline ::google::protobuf::uint32 CMsgPICSProductInfoResponse::unknown_packageids(int index) const {
  return unknown_packageids_.Get(index);
}
inline void CMsgPICSProductInfoResponse::set_unknown_packageids(int index, ::google::protobuf::uint32 value) {
  unknown_packageids_.Set(index, value);
}
inline void CMsgPICSProductInfoResponse::add_unknown_packageids(::google::protobuf::uint32 value) {
  unknown_packageids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgPICSProductInfoResponse::unknown_packageids() const {
  return unknown_packageids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgPICSProductInfoResponse::mutable_unknown_packageids() {
  return &unknown_packageids_;
}

// optional bool meta_data_only = 5;
inline bool CMsgPICSProductInfoResponse::has_meta_data_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPICSProductInfoResponse::set_has_meta_data_only() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgPICSProductInfoResponse::clear_has_meta_data_only() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgPICSProductInfoResponse::clear_meta_data_only() {
  meta_data_only_ = false;
  clear_has_meta_data_only();
}
inline bool CMsgPICSProductInfoResponse::meta_data_only() const {
  return meta_data_only_;
}
inline void CMsgPICSProductInfoResponse::set_meta_data_only(bool value) {
  set_has_meta_data_only();
  meta_data_only_ = value;
}

// optional bool response_pending = 6;
inline bool CMsgPICSProductInfoResponse::has_response_pending() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgPICSProductInfoResponse::set_has_response_pending() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgPICSProductInfoResponse::clear_has_response_pending() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgPICSProductInfoResponse::clear_response_pending() {
  response_pending_ = false;
  clear_has_response_pending();
}
inline bool CMsgPICSProductInfoResponse::response_pending() const {
  return response_pending_;
}
inline void CMsgPICSProductInfoResponse::set_response_pending(bool value) {
  set_has_response_pending();
  response_pending_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSAccessTokenRequest

// repeated uint32 packageids = 1;
inline int CMsgPICSAccessTokenRequest::packageids_size() const {
  return packageids_.size();
}
inline void CMsgPICSAccessTokenRequest::clear_packageids() {
  packageids_.Clear();
}
inline ::google::protobuf::uint32 CMsgPICSAccessTokenRequest::packageids(int index) const {
  return packageids_.Get(index);
}
inline void CMsgPICSAccessTokenRequest::set_packageids(int index, ::google::protobuf::uint32 value) {
  packageids_.Set(index, value);
}
inline void CMsgPICSAccessTokenRequest::add_packageids(::google::protobuf::uint32 value) {
  packageids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgPICSAccessTokenRequest::packageids() const {
  return packageids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgPICSAccessTokenRequest::mutable_packageids() {
  return &packageids_;
}

// repeated uint32 appids = 2;
inline int CMsgPICSAccessTokenRequest::appids_size() const {
  return appids_.size();
}
inline void CMsgPICSAccessTokenRequest::clear_appids() {
  appids_.Clear();
}
inline ::google::protobuf::uint32 CMsgPICSAccessTokenRequest::appids(int index) const {
  return appids_.Get(index);
}
inline void CMsgPICSAccessTokenRequest::set_appids(int index, ::google::protobuf::uint32 value) {
  appids_.Set(index, value);
}
inline void CMsgPICSAccessTokenRequest::add_appids(::google::protobuf::uint32 value) {
  appids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgPICSAccessTokenRequest::appids() const {
  return appids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgPICSAccessTokenRequest::mutable_appids() {
  return &appids_;
}

// -------------------------------------------------------------------

// CMsgPICSAccessTokenResponse_PackageToken

// optional uint32 packageid = 1;
inline bool CMsgPICSAccessTokenResponse_PackageToken::has_packageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::set_has_packageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::clear_has_packageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::clear_packageid() {
  packageid_ = 0u;
  clear_has_packageid();
}
inline ::google::protobuf::uint32 CMsgPICSAccessTokenResponse_PackageToken::packageid() const {
  return packageid_;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::set_packageid(::google::protobuf::uint32 value) {
  set_has_packageid();
  packageid_ = value;
}

// optional uint64 access_token = 2;
inline bool CMsgPICSAccessTokenResponse_PackageToken::has_access_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::set_has_access_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::clear_access_token() {
  access_token_ = GOOGLE_ULONGLONG(0);
  clear_has_access_token();
}
inline ::google::protobuf::uint64 CMsgPICSAccessTokenResponse_PackageToken::access_token() const {
  return access_token_;
}
inline void CMsgPICSAccessTokenResponse_PackageToken::set_access_token(::google::protobuf::uint64 value) {
  set_has_access_token();
  access_token_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSAccessTokenResponse_AppToken

// optional uint32 appid = 1;
inline bool CMsgPICSAccessTokenResponse_AppToken::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPICSAccessTokenResponse_AppToken::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgPICSAccessTokenResponse_AppToken::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgPICSAccessTokenResponse_AppToken::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgPICSAccessTokenResponse_AppToken::appid() const {
  return appid_;
}
inline void CMsgPICSAccessTokenResponse_AppToken::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional uint64 access_token = 2;
inline bool CMsgPICSAccessTokenResponse_AppToken::has_access_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPICSAccessTokenResponse_AppToken::set_has_access_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgPICSAccessTokenResponse_AppToken::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgPICSAccessTokenResponse_AppToken::clear_access_token() {
  access_token_ = GOOGLE_ULONGLONG(0);
  clear_has_access_token();
}
inline ::google::protobuf::uint64 CMsgPICSAccessTokenResponse_AppToken::access_token() const {
  return access_token_;
}
inline void CMsgPICSAccessTokenResponse_AppToken::set_access_token(::google::protobuf::uint64 value) {
  set_has_access_token();
  access_token_ = value;
}

// -------------------------------------------------------------------

// CMsgPICSAccessTokenResponse

// repeated .Sc.CMsgPICSAccessTokenResponse.PackageToken package_access_tokens = 1;
inline int CMsgPICSAccessTokenResponse::package_access_tokens_size() const {
  return package_access_tokens_.size();
}
inline void CMsgPICSAccessTokenResponse::clear_package_access_tokens() {
  package_access_tokens_.Clear();
}
inline const ::Sc::CMsgPICSAccessTokenResponse_PackageToken& CMsgPICSAccessTokenResponse::package_access_tokens(int index) const {
  return package_access_tokens_.Get(index);
}
inline ::Sc::CMsgPICSAccessTokenResponse_PackageToken* CMsgPICSAccessTokenResponse::mutable_package_access_tokens(int index) {
  return package_access_tokens_.Mutable(index);
}
inline ::Sc::CMsgPICSAccessTokenResponse_PackageToken* CMsgPICSAccessTokenResponse::add_package_access_tokens() {
  return package_access_tokens_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_PackageToken >&
CMsgPICSAccessTokenResponse::package_access_tokens() const {
  return package_access_tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_PackageToken >*
CMsgPICSAccessTokenResponse::mutable_package_access_tokens() {
  return &package_access_tokens_;
}

// repeated uint32 package_denied_tokens = 2;
inline int CMsgPICSAccessTokenResponse::package_denied_tokens_size() const {
  return package_denied_tokens_.size();
}
inline void CMsgPICSAccessTokenResponse::clear_package_denied_tokens() {
  package_denied_tokens_.Clear();
}
inline ::google::protobuf::uint32 CMsgPICSAccessTokenResponse::package_denied_tokens(int index) const {
  return package_denied_tokens_.Get(index);
}
inline void CMsgPICSAccessTokenResponse::set_package_denied_tokens(int index, ::google::protobuf::uint32 value) {
  package_denied_tokens_.Set(index, value);
}
inline void CMsgPICSAccessTokenResponse::add_package_denied_tokens(::google::protobuf::uint32 value) {
  package_denied_tokens_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgPICSAccessTokenResponse::package_denied_tokens() const {
  return package_denied_tokens_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgPICSAccessTokenResponse::mutable_package_denied_tokens() {
  return &package_denied_tokens_;
}

// repeated .Sc.CMsgPICSAccessTokenResponse.AppToken app_access_tokens = 3;
inline int CMsgPICSAccessTokenResponse::app_access_tokens_size() const {
  return app_access_tokens_.size();
}
inline void CMsgPICSAccessTokenResponse::clear_app_access_tokens() {
  app_access_tokens_.Clear();
}
inline const ::Sc::CMsgPICSAccessTokenResponse_AppToken& CMsgPICSAccessTokenResponse::app_access_tokens(int index) const {
  return app_access_tokens_.Get(index);
}
inline ::Sc::CMsgPICSAccessTokenResponse_AppToken* CMsgPICSAccessTokenResponse::mutable_app_access_tokens(int index) {
  return app_access_tokens_.Mutable(index);
}
inline ::Sc::CMsgPICSAccessTokenResponse_AppToken* CMsgPICSAccessTokenResponse::add_app_access_tokens() {
  return app_access_tokens_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_AppToken >&
CMsgPICSAccessTokenResponse::app_access_tokens() const {
  return app_access_tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgPICSAccessTokenResponse_AppToken >*
CMsgPICSAccessTokenResponse::mutable_app_access_tokens() {
  return &app_access_tokens_;
}

// repeated uint32 app_denied_tokens = 4;
inline int CMsgPICSAccessTokenResponse::app_denied_tokens_size() const {
  return app_denied_tokens_.size();
}
inline void CMsgPICSAccessTokenResponse::clear_app_denied_tokens() {
  app_denied_tokens_.Clear();
}
inline ::google::protobuf::uint32 CMsgPICSAccessTokenResponse::app_denied_tokens(int index) const {
  return app_denied_tokens_.Get(index);
}
inline void CMsgPICSAccessTokenResponse::set_app_denied_tokens(int index, ::google::protobuf::uint32 value) {
  app_denied_tokens_.Set(index, value);
}
inline void CMsgPICSAccessTokenResponse::add_app_denied_tokens(::google::protobuf::uint32 value) {
  app_denied_tokens_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgPICSAccessTokenResponse::app_denied_tokens() const {
  return app_denied_tokens_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgPICSAccessTokenResponse::mutable_app_denied_tokens() {
  return &app_denied_tokens_;
}

// -------------------------------------------------------------------

// CMsgClientUFSGetUGCDetails

// optional fixed64 hcontent = 1 [default = 18446744073709551615];
inline bool CMsgClientUFSGetUGCDetails::has_hcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSGetUGCDetails::set_has_hcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSGetUGCDetails::clear_has_hcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSGetUGCDetails::clear_hcontent() {
  hcontent_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_hcontent();
}
inline ::google::protobuf::uint64 CMsgClientUFSGetUGCDetails::hcontent() const {
  return hcontent_;
}
inline void CMsgClientUFSGetUGCDetails::set_hcontent(::google::protobuf::uint64 value) {
  set_has_hcontent();
  hcontent_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSGetUGCDetailsResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSGetUGCDetailsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSGetUGCDetailsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string url = 2;
inline bool CMsgClientUFSGetUGCDetailsResponse::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CMsgClientUFSGetUGCDetailsResponse::url() const {
  return *url_;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetUGCDetailsResponse::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* CMsgClientUFSGetUGCDetailsResponse::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 app_id = 3;
inline bool CMsgClientUFSGetUGCDetailsResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetUGCDetailsResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string filename = 4;
inline bool CMsgClientUFSGetUGCDetailsResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientUFSGetUGCDetailsResponse::filename() const {
  return *filename_;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetUGCDetailsResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientUFSGetUGCDetailsResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 steamid_creator = 5;
inline bool CMsgClientUFSGetUGCDetailsResponse::has_steamid_creator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_has_steamid_creator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_has_steamid_creator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_steamid_creator() {
  steamid_creator_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_creator();
}
inline ::google::protobuf::uint64 CMsgClientUFSGetUGCDetailsResponse::steamid_creator() const {
  return steamid_creator_;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_steamid_creator(::google::protobuf::uint64 value) {
  set_has_steamid_creator();
  steamid_creator_ = value;
}

// optional uint32 file_size = 6;
inline bool CMsgClientUFSGetUGCDetailsResponse::has_file_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_has_file_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUFSGetUGCDetailsResponse::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetUGCDetailsResponse::file_size() const {
  return file_size_;
}
inline void CMsgClientUFSGetUGCDetailsResponse::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSGetSingleFileInfo

// optional uint32 app_id = 1;
inline bool CMsgClientUFSGetSingleFileInfo::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfo::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSGetSingleFileInfo::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSGetSingleFileInfo::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetSingleFileInfo::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSGetSingleFileInfo::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUFSGetSingleFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSGetSingleFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSGetSingleFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSGetSingleFileInfo::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSGetSingleFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSGetSingleFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSGetSingleFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetSingleFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSGetSingleFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetSingleFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSGetSingleFileInfoResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSGetSingleFileInfoResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetSingleFileInfoResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 3;
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSGetSingleFileInfoResponse::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetSingleFileInfoResponse::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSGetSingleFileInfoResponse::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sha_file = 4;
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_sha_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_sha_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUFSGetSingleFileInfoResponse::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSGetSingleFileInfoResponse::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUFSGetSingleFileInfoResponse::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time_stamp = 5;
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::uint64 CMsgClientUFSGetSingleFileInfoResponse::time_stamp() const {
  return time_stamp_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_time_stamp(::google::protobuf::uint64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
}

// optional uint32 raw_file_size = 6;
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_raw_file_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_raw_file_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_raw_file_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_raw_file_size() {
  raw_file_size_ = 0u;
  clear_has_raw_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUFSGetSingleFileInfoResponse::raw_file_size() const {
  return raw_file_size_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_raw_file_size(::google::protobuf::uint32 value) {
  set_has_raw_file_size();
  raw_file_size_ = value;
}

// optional bool is_explicit_delete = 7;
inline bool CMsgClientUFSGetSingleFileInfoResponse::has_is_explicit_delete() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_has_is_explicit_delete() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_has_is_explicit_delete() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::clear_is_explicit_delete() {
  is_explicit_delete_ = false;
  clear_has_is_explicit_delete();
}
inline bool CMsgClientUFSGetSingleFileInfoResponse::is_explicit_delete() const {
  return is_explicit_delete_;
}
inline void CMsgClientUFSGetSingleFileInfoResponse::set_is_explicit_delete(bool value) {
  set_has_is_explicit_delete();
  is_explicit_delete_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUFSShareFile

// optional uint32 app_id = 1;
inline bool CMsgClientUFSShareFile::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSShareFile::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSShareFile::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSShareFile::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUFSShareFile::app_id() const {
  return app_id_;
}
inline void CMsgClientUFSShareFile::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUFSShareFile::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSShareFile::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSShareFile::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSShareFile::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUFSShareFile::file_name() const {
  return *file_name_;
}
inline void CMsgClientUFSShareFile::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSShareFile::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUFSShareFile::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUFSShareFile::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUFSShareFile::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUFSShareFile::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUFSShareFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUFSShareFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUFSShareFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUFSShareFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUFSShareFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUFSShareFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUFSShareFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 hcontent = 2 [default = 18446744073709551615];
inline bool CMsgClientUFSShareFileResponse::has_hcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUFSShareFileResponse::set_has_hcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUFSShareFileResponse::clear_has_hcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUFSShareFileResponse::clear_hcontent() {
  hcontent_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_hcontent();
}
inline ::google::protobuf::uint64 CMsgClientUFSShareFileResponse::hcontent() const {
  return hcontent_;
}
inline void CMsgClientUFSShareFileResponse::set_hcontent(::google::protobuf::uint64 value) {
  set_has_hcontent();
  hcontent_ = value;
}

// -------------------------------------------------------------------

// CMsgClientNewLoginKey

// optional uint32 unique_id = 1;
inline bool CMsgClientNewLoginKey::has_unique_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientNewLoginKey::set_has_unique_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientNewLoginKey::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientNewLoginKey::clear_unique_id() {
  unique_id_ = 0u;
  clear_has_unique_id();
}
inline ::google::protobuf::uint32 CMsgClientNewLoginKey::unique_id() const {
  return unique_id_;
}
inline void CMsgClientNewLoginKey::set_unique_id(::google::protobuf::uint32 value) {
  set_has_unique_id();
  unique_id_ = value;
}

// optional string login_key = 2;
inline bool CMsgClientNewLoginKey::has_login_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientNewLoginKey::set_has_login_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientNewLoginKey::clear_has_login_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientNewLoginKey::clear_login_key() {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    login_key_->clear();
  }
  clear_has_login_key();
}
inline const ::std::string& CMsgClientNewLoginKey::login_key() const {
  return *login_key_;
}
inline void CMsgClientNewLoginKey::set_login_key(const ::std::string& value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientNewLoginKey::set_login_key(const char* value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientNewLoginKey::set_login_key(const char* value, size_t size) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientNewLoginKey::mutable_login_key() {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  return login_key_;
}
inline ::std::string* CMsgClientNewLoginKey::release_login_key() {
  clear_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_key_;
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientNewLoginKey::set_allocated_login_key(::std::string* login_key) {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    delete login_key_;
  }
  if (login_key) {
    set_has_login_key();
    login_key_ = login_key;
  } else {
    clear_has_login_key();
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientNewLoginKeyAccepted

// optional uint32 unique_id = 1;
inline bool CMsgClientNewLoginKeyAccepted::has_unique_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientNewLoginKeyAccepted::set_has_unique_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientNewLoginKeyAccepted::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientNewLoginKeyAccepted::clear_unique_id() {
  unique_id_ = 0u;
  clear_has_unique_id();
}
inline ::google::protobuf::uint32 CMsgClientNewLoginKeyAccepted::unique_id() const {
  return unique_id_;
}
inline void CMsgClientNewLoginKeyAccepted::set_unique_id(::google::protobuf::uint32 value) {
  set_has_unique_id();
  unique_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAMGetClanOfficers

// optional fixed64 steamid_clan = 1;
inline bool CMsgClientAMGetClanOfficers::has_steamid_clan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAMGetClanOfficers::set_has_steamid_clan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAMGetClanOfficers::clear_has_steamid_clan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAMGetClanOfficers::clear_steamid_clan() {
  steamid_clan_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_clan();
}
inline ::google::protobuf::uint64 CMsgClientAMGetClanOfficers::steamid_clan() const {
  return steamid_clan_;
}
inline void CMsgClientAMGetClanOfficers::set_steamid_clan(::google::protobuf::uint64 value) {
  set_has_steamid_clan();
  steamid_clan_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAMGetClanOfficersResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientAMGetClanOfficersResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAMGetClanOfficersResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAMGetClanOfficersResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAMGetClanOfficersResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientAMGetClanOfficersResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientAMGetClanOfficersResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 steamid_clan = 2;
inline bool CMsgClientAMGetClanOfficersResponse::has_steamid_clan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAMGetClanOfficersResponse::set_has_steamid_clan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAMGetClanOfficersResponse::clear_has_steamid_clan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAMGetClanOfficersResponse::clear_steamid_clan() {
  steamid_clan_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_clan();
}
inline ::google::protobuf::uint64 CMsgClientAMGetClanOfficersResponse::steamid_clan() const {
  return steamid_clan_;
}
inline void CMsgClientAMGetClanOfficersResponse::set_steamid_clan(::google::protobuf::uint64 value) {
  set_has_steamid_clan();
  steamid_clan_ = value;
}

// optional int32 officer_count = 3;
inline bool CMsgClientAMGetClanOfficersResponse::has_officer_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAMGetClanOfficersResponse::set_has_officer_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAMGetClanOfficersResponse::clear_has_officer_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAMGetClanOfficersResponse::clear_officer_count() {
  officer_count_ = 0;
  clear_has_officer_count();
}
inline ::google::protobuf::int32 CMsgClientAMGetClanOfficersResponse::officer_count() const {
  return officer_count_;
}
inline void CMsgClientAMGetClanOfficersResponse::set_officer_count(::google::protobuf::int32 value) {
  set_has_officer_count();
  officer_count_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAMGetPersonaNameHistory_IdInstance

// optional fixed64 steamid = 1;
inline bool CMsgClientAMGetPersonaNameHistory_IdInstance::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAMGetPersonaNameHistory_IdInstance::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistory_IdInstance::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistory_IdInstance::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientAMGetPersonaNameHistory_IdInstance::steamid() const {
  return steamid_;
}
inline void CMsgClientAMGetPersonaNameHistory_IdInstance::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAMGetPersonaNameHistory

// optional int32 id_count = 1;
inline bool CMsgClientAMGetPersonaNameHistory::has_id_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAMGetPersonaNameHistory::set_has_id_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistory::clear_has_id_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistory::clear_id_count() {
  id_count_ = 0;
  clear_has_id_count();
}
inline ::google::protobuf::int32 CMsgClientAMGetPersonaNameHistory::id_count() const {
  return id_count_;
}
inline void CMsgClientAMGetPersonaNameHistory::set_id_count(::google::protobuf::int32 value) {
  set_has_id_count();
  id_count_ = value;
}

// repeated .Sc.CMsgClientAMGetPersonaNameHistory.IdInstance Ids = 2;
inline int CMsgClientAMGetPersonaNameHistory::ids_size() const {
  return ids_.size();
}
inline void CMsgClientAMGetPersonaNameHistory::clear_ids() {
  ids_.Clear();
}
inline const ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance& CMsgClientAMGetPersonaNameHistory::ids(int index) const {
  return ids_.Get(index);
}
inline ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance* CMsgClientAMGetPersonaNameHistory::mutable_ids(int index) {
  return ids_.Mutable(index);
}
inline ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance* CMsgClientAMGetPersonaNameHistory::add_ids() {
  return ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance >&
CMsgClientAMGetPersonaNameHistory::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistory_IdInstance >*
CMsgClientAMGetPersonaNameHistory::mutable_ids() {
  return &ids_;
}

// -------------------------------------------------------------------

// CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance

// optional fixed32 name_since = 1;
inline bool CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::has_name_since() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_has_name_since() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::clear_has_name_since() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::clear_name_since() {
  name_since_ = 0u;
  clear_has_name_since();
}
inline ::google::protobuf::uint32 CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::name_since() const {
  return name_since_;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_name_since(::google::protobuf::uint32 value) {
  set_has_name_since();
  name_since_ = value;
}

// optional string name = 2;
inline bool CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::name() const {
  return *name_;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::eresult() const {
  return eresult_;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 steamid = 2;
inline bool CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::has_steamid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::set_has_steamid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::steamid() const {
  return steamid_;
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// repeated .Sc.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance names = 3;
inline int CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::names_size() const {
  return names_.size();
}
inline void CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::clear_names() {
  names_.Clear();
}
inline const ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance& CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::names(int index) const {
  return names_.Get(index);
}
inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::mutable_names(int index) {
  return names_.Mutable(index);
}
inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance* CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::add_names() {
  return names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance >&
CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance >*
CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// CMsgClientAMGetPersonaNameHistoryResponse

// repeated .Sc.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance responses = 2;
inline int CMsgClientAMGetPersonaNameHistoryResponse::responses_size() const {
  return responses_.size();
}
inline void CMsgClientAMGetPersonaNameHistoryResponse::clear_responses() {
  responses_.Clear();
}
inline const ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance& CMsgClientAMGetPersonaNameHistoryResponse::responses(int index) const {
  return responses_.Get(index);
}
inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* CMsgClientAMGetPersonaNameHistoryResponse::mutable_responses(int index) {
  return responses_.Mutable(index);
}
inline ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance* CMsgClientAMGetPersonaNameHistoryResponse::add_responses() {
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance >&
CMsgClientAMGetPersonaNameHistoryResponse::responses() const {
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance >*
CMsgClientAMGetPersonaNameHistoryResponse::mutable_responses() {
  return &responses_;
}

// -------------------------------------------------------------------

// CMsgClientDeregisterWithServer

// optional uint32 eservertype = 1;
inline bool CMsgClientDeregisterWithServer::has_eservertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDeregisterWithServer::set_has_eservertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDeregisterWithServer::clear_has_eservertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDeregisterWithServer::clear_eservertype() {
  eservertype_ = 0u;
  clear_has_eservertype();
}
inline ::google::protobuf::uint32 CMsgClientDeregisterWithServer::eservertype() const {
  return eservertype_;
}
inline void CMsgClientDeregisterWithServer::set_eservertype(::google::protobuf::uint32 value) {
  set_has_eservertype();
  eservertype_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientDeregisterWithServer::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientDeregisterWithServer::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientDeregisterWithServer::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientDeregisterWithServer::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientDeregisterWithServer::app_id() const {
  return app_id_;
}
inline void CMsgClientDeregisterWithServer::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientClanState_NameInfo

// optional string clan_name = 1;
inline bool CMsgClientClanState_NameInfo::has_clan_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientClanState_NameInfo::set_has_clan_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientClanState_NameInfo::clear_has_clan_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientClanState_NameInfo::clear_clan_name() {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    clan_name_->clear();
  }
  clear_has_clan_name();
}
inline const ::std::string& CMsgClientClanState_NameInfo::clan_name() const {
  return *clan_name_;
}
inline void CMsgClientClanState_NameInfo::set_clan_name(const ::std::string& value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void CMsgClientClanState_NameInfo::set_clan_name(const char* value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void CMsgClientClanState_NameInfo::set_clan_name(const char* value, size_t size) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientClanState_NameInfo::mutable_clan_name() {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  return clan_name_;
}
inline ::std::string* CMsgClientClanState_NameInfo::release_clan_name() {
  clear_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_name_;
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientClanState_NameInfo::set_allocated_clan_name(::std::string* clan_name) {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_name_;
  }
  if (clan_name) {
    set_has_clan_name();
    clan_name_ = clan_name;
  } else {
    clear_has_clan_name();
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sha_avatar = 2;
inline bool CMsgClientClanState_NameInfo::has_sha_avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientClanState_NameInfo::set_has_sha_avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientClanState_NameInfo::clear_has_sha_avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientClanState_NameInfo::clear_sha_avatar() {
  if (sha_avatar_ != &::google::protobuf::internal::kEmptyString) {
    sha_avatar_->clear();
  }
  clear_has_sha_avatar();
}
inline const ::std::string& CMsgClientClanState_NameInfo::sha_avatar() const {
  return *sha_avatar_;
}
inline void CMsgClientClanState_NameInfo::set_sha_avatar(const ::std::string& value) {
  set_has_sha_avatar();
  if (sha_avatar_ == &::google::protobuf::internal::kEmptyString) {
    sha_avatar_ = new ::std::string;
  }
  sha_avatar_->assign(value);
}
inline void CMsgClientClanState_NameInfo::set_sha_avatar(const char* value) {
  set_has_sha_avatar();
  if (sha_avatar_ == &::google::protobuf::internal::kEmptyString) {
    sha_avatar_ = new ::std::string;
  }
  sha_avatar_->assign(value);
}
inline void CMsgClientClanState_NameInfo::set_sha_avatar(const void* value, size_t size) {
  set_has_sha_avatar();
  if (sha_avatar_ == &::google::protobuf::internal::kEmptyString) {
    sha_avatar_ = new ::std::string;
  }
  sha_avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientClanState_NameInfo::mutable_sha_avatar() {
  set_has_sha_avatar();
  if (sha_avatar_ == &::google::protobuf::internal::kEmptyString) {
    sha_avatar_ = new ::std::string;
  }
  return sha_avatar_;
}
inline ::std::string* CMsgClientClanState_NameInfo::release_sha_avatar() {
  clear_has_sha_avatar();
  if (sha_avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_avatar_;
    sha_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientClanState_NameInfo::set_allocated_sha_avatar(::std::string* sha_avatar) {
  if (sha_avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_avatar_;
  }
  if (sha_avatar) {
    set_has_sha_avatar();
    sha_avatar_ = sha_avatar;
  } else {
    clear_has_sha_avatar();
    sha_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientClanState_UserCounts

// optional uint32 members = 1;
inline bool CMsgClientClanState_UserCounts::has_members() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientClanState_UserCounts::set_has_members() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientClanState_UserCounts::clear_has_members() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientClanState_UserCounts::clear_members() {
  members_ = 0u;
  clear_has_members();
}
inline ::google::protobuf::uint32 CMsgClientClanState_UserCounts::members() const {
  return members_;
}
inline void CMsgClientClanState_UserCounts::set_members(::google::protobuf::uint32 value) {
  set_has_members();
  members_ = value;
}

// optional uint32 online = 2;
inline bool CMsgClientClanState_UserCounts::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientClanState_UserCounts::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientClanState_UserCounts::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientClanState_UserCounts::clear_online() {
  online_ = 0u;
  clear_has_online();
}
inline ::google::protobuf::uint32 CMsgClientClanState_UserCounts::online() const {
  return online_;
}
inline void CMsgClientClanState_UserCounts::set_online(::google::protobuf::uint32 value) {
  set_has_online();
  online_ = value;
}

// optional uint32 chatting = 3;
inline bool CMsgClientClanState_UserCounts::has_chatting() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientClanState_UserCounts::set_has_chatting() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientClanState_UserCounts::clear_has_chatting() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientClanState_UserCounts::clear_chatting() {
  chatting_ = 0u;
  clear_has_chatting();
}
inline ::google::protobuf::uint32 CMsgClientClanState_UserCounts::chatting() const {
  return chatting_;
}
inline void CMsgClientClanState_UserCounts::set_chatting(::google::protobuf::uint32 value) {
  set_has_chatting();
  chatting_ = value;
}

// optional uint32 in_game = 4;
inline bool CMsgClientClanState_UserCounts::has_in_game() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientClanState_UserCounts::set_has_in_game() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientClanState_UserCounts::clear_has_in_game() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientClanState_UserCounts::clear_in_game() {
  in_game_ = 0u;
  clear_has_in_game();
}
inline ::google::protobuf::uint32 CMsgClientClanState_UserCounts::in_game() const {
  return in_game_;
}
inline void CMsgClientClanState_UserCounts::set_in_game(::google::protobuf::uint32 value) {
  set_has_in_game();
  in_game_ = value;
}

// -------------------------------------------------------------------

// CMsgClientClanState_Event

// optional fixed64 gid = 1;
inline bool CMsgClientClanState_Event::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientClanState_Event::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientClanState_Event::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientClanState_Event::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 CMsgClientClanState_Event::gid() const {
  return gid_;
}
inline void CMsgClientClanState_Event::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 event_time = 2;
inline bool CMsgClientClanState_Event::has_event_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientClanState_Event::set_has_event_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientClanState_Event::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientClanState_Event::clear_event_time() {
  event_time_ = 0u;
  clear_has_event_time();
}
inline ::google::protobuf::uint32 CMsgClientClanState_Event::event_time() const {
  return event_time_;
}
inline void CMsgClientClanState_Event::set_event_time(::google::protobuf::uint32 value) {
  set_has_event_time();
  event_time_ = value;
}

// optional string headline = 3;
inline bool CMsgClientClanState_Event::has_headline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientClanState_Event::set_has_headline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientClanState_Event::clear_has_headline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientClanState_Event::clear_headline() {
  if (headline_ != &::google::protobuf::internal::kEmptyString) {
    headline_->clear();
  }
  clear_has_headline();
}
inline const ::std::string& CMsgClientClanState_Event::headline() const {
  return *headline_;
}
inline void CMsgClientClanState_Event::set_headline(const ::std::string& value) {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  headline_->assign(value);
}
inline void CMsgClientClanState_Event::set_headline(const char* value) {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  headline_->assign(value);
}
inline void CMsgClientClanState_Event::set_headline(const char* value, size_t size) {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  headline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientClanState_Event::mutable_headline() {
  set_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    headline_ = new ::std::string;
  }
  return headline_;
}
inline ::std::string* CMsgClientClanState_Event::release_headline() {
  clear_has_headline();
  if (headline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headline_;
    headline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientClanState_Event::set_allocated_headline(::std::string* headline) {
  if (headline_ != &::google::protobuf::internal::kEmptyString) {
    delete headline_;
  }
  if (headline) {
    set_has_headline();
    headline_ = headline;
  } else {
    clear_has_headline();
    headline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 game_id = 4;
inline bool CMsgClientClanState_Event::has_game_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientClanState_Event::set_has_game_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientClanState_Event::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientClanState_Event::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 CMsgClientClanState_Event::game_id() const {
  return game_id_;
}
inline void CMsgClientClanState_Event::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// optional bool just_posted = 5;
inline bool CMsgClientClanState_Event::has_just_posted() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientClanState_Event::set_has_just_posted() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientClanState_Event::clear_has_just_posted() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientClanState_Event::clear_just_posted() {
  just_posted_ = false;
  clear_has_just_posted();
}
inline bool CMsgClientClanState_Event::just_posted() const {
  return just_posted_;
}
inline void CMsgClientClanState_Event::set_just_posted(bool value) {
  set_has_just_posted();
  just_posted_ = value;
}

// -------------------------------------------------------------------

// CMsgClientClanState

// optional fixed64 steamid_clan = 1;
inline bool CMsgClientClanState::has_steamid_clan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientClanState::set_has_steamid_clan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientClanState::clear_has_steamid_clan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientClanState::clear_steamid_clan() {
  steamid_clan_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_clan();
}
inline ::google::protobuf::uint64 CMsgClientClanState::steamid_clan() const {
  return steamid_clan_;
}
inline void CMsgClientClanState::set_steamid_clan(::google::protobuf::uint64 value) {
  set_has_steamid_clan();
  steamid_clan_ = value;
}

// optional uint32 m_unStatusFlags = 2;
inline bool CMsgClientClanState::has_m_unstatusflags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientClanState::set_has_m_unstatusflags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientClanState::clear_has_m_unstatusflags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientClanState::clear_m_unstatusflags() {
  m_unstatusflags_ = 0u;
  clear_has_m_unstatusflags();
}
inline ::google::protobuf::uint32 CMsgClientClanState::m_unstatusflags() const {
  return m_unstatusflags_;
}
inline void CMsgClientClanState::set_m_unstatusflags(::google::protobuf::uint32 value) {
  set_has_m_unstatusflags();
  m_unstatusflags_ = value;
}

// optional uint32 clan_account_flags = 3;
inline bool CMsgClientClanState::has_clan_account_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientClanState::set_has_clan_account_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientClanState::clear_has_clan_account_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientClanState::clear_clan_account_flags() {
  clan_account_flags_ = 0u;
  clear_has_clan_account_flags();
}
inline ::google::protobuf::uint32 CMsgClientClanState::clan_account_flags() const {
  return clan_account_flags_;
}
inline void CMsgClientClanState::set_clan_account_flags(::google::protobuf::uint32 value) {
  set_has_clan_account_flags();
  clan_account_flags_ = value;
}

// optional .Sc.CMsgClientClanState.NameInfo name_info = 4;
inline bool CMsgClientClanState::has_name_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientClanState::set_has_name_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientClanState::clear_has_name_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientClanState::clear_name_info() {
  if (name_info_ != NULL) name_info_->::Sc::CMsgClientClanState_NameInfo::Clear();
  clear_has_name_info();
}
inline const ::Sc::CMsgClientClanState_NameInfo& CMsgClientClanState::name_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return name_info_ != NULL ? *name_info_ : *default_instance().name_info_;
#else
  return name_info_ != NULL ? *name_info_ : *default_instance_->name_info_;
#endif
}
inline ::Sc::CMsgClientClanState_NameInfo* CMsgClientClanState::mutable_name_info() {
  set_has_name_info();
  if (name_info_ == NULL) name_info_ = new ::Sc::CMsgClientClanState_NameInfo;
  return name_info_;
}
inline ::Sc::CMsgClientClanState_NameInfo* CMsgClientClanState::release_name_info() {
  clear_has_name_info();
  ::Sc::CMsgClientClanState_NameInfo* temp = name_info_;
  name_info_ = NULL;
  return temp;
}
inline void CMsgClientClanState::set_allocated_name_info(::Sc::CMsgClientClanState_NameInfo* name_info) {
  delete name_info_;
  name_info_ = name_info;
  if (name_info) {
    set_has_name_info();
  } else {
    clear_has_name_info();
  }
}

// optional .Sc.CMsgClientClanState.UserCounts user_counts = 5;
inline bool CMsgClientClanState::has_user_counts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientClanState::set_has_user_counts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientClanState::clear_has_user_counts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientClanState::clear_user_counts() {
  if (user_counts_ != NULL) user_counts_->::Sc::CMsgClientClanState_UserCounts::Clear();
  clear_has_user_counts();
}
inline const ::Sc::CMsgClientClanState_UserCounts& CMsgClientClanState::user_counts() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_counts_ != NULL ? *user_counts_ : *default_instance().user_counts_;
#else
  return user_counts_ != NULL ? *user_counts_ : *default_instance_->user_counts_;
#endif
}
inline ::Sc::CMsgClientClanState_UserCounts* CMsgClientClanState::mutable_user_counts() {
  set_has_user_counts();
  if (user_counts_ == NULL) user_counts_ = new ::Sc::CMsgClientClanState_UserCounts;
  return user_counts_;
}
inline ::Sc::CMsgClientClanState_UserCounts* CMsgClientClanState::release_user_counts() {
  clear_has_user_counts();
  ::Sc::CMsgClientClanState_UserCounts* temp = user_counts_;
  user_counts_ = NULL;
  return temp;
}
inline void CMsgClientClanState::set_allocated_user_counts(::Sc::CMsgClientClanState_UserCounts* user_counts) {
  delete user_counts_;
  user_counts_ = user_counts;
  if (user_counts) {
    set_has_user_counts();
  } else {
    clear_has_user_counts();
  }
}

// repeated .Sc.CMsgClientClanState.Event events = 6;
inline int CMsgClientClanState::events_size() const {
  return events_.size();
}
inline void CMsgClientClanState::clear_events() {
  events_.Clear();
}
inline const ::Sc::CMsgClientClanState_Event& CMsgClientClanState::events(int index) const {
  return events_.Get(index);
}
inline ::Sc::CMsgClientClanState_Event* CMsgClientClanState::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::Sc::CMsgClientClanState_Event* CMsgClientClanState::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >&
CMsgClientClanState::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >*
CMsgClientClanState::mutable_events() {
  return &events_;
}

// repeated .Sc.CMsgClientClanState.Event announcements = 7;
inline int CMsgClientClanState::announcements_size() const {
  return announcements_.size();
}
inline void CMsgClientClanState::clear_announcements() {
  announcements_.Clear();
}
inline const ::Sc::CMsgClientClanState_Event& CMsgClientClanState::announcements(int index) const {
  return announcements_.Get(index);
}
inline ::Sc::CMsgClientClanState_Event* CMsgClientClanState::mutable_announcements(int index) {
  return announcements_.Mutable(index);
}
inline ::Sc::CMsgClientClanState_Event* CMsgClientClanState::add_announcements() {
  return announcements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >&
CMsgClientClanState::announcements() const {
  return announcements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientClanState_Event >*
CMsgClientClanState::mutable_announcements() {
  return &announcements_;
}

// -------------------------------------------------------------------

// CMsgClientFriendMsg

// optional fixed64 steamid = 1;
inline bool CMsgClientFriendMsg::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendMsg::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendMsg::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendMsg::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientFriendMsg::steamid() const {
  return steamid_;
}
inline void CMsgClientFriendMsg::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional int32 chat_entry_type = 2;
inline bool CMsgClientFriendMsg::has_chat_entry_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendMsg::set_has_chat_entry_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendMsg::clear_has_chat_entry_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendMsg::clear_chat_entry_type() {
  chat_entry_type_ = 0;
  clear_has_chat_entry_type();
}
inline ::google::protobuf::int32 CMsgClientFriendMsg::chat_entry_type() const {
  return chat_entry_type_;
}
inline void CMsgClientFriendMsg::set_chat_entry_type(::google::protobuf::int32 value) {
  set_has_chat_entry_type();
  chat_entry_type_ = value;
}

// optional bytes message = 3;
inline bool CMsgClientFriendMsg::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientFriendMsg::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientFriendMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientFriendMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CMsgClientFriendMsg::message() const {
  return *message_;
}
inline void CMsgClientFriendMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgClientFriendMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgClientFriendMsg::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* CMsgClientFriendMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientFriendMsgIncoming

// optional fixed64 steamid_from = 1;
inline bool CMsgClientFriendMsgIncoming::has_steamid_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendMsgIncoming::set_has_steamid_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendMsgIncoming::clear_has_steamid_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendMsgIncoming::clear_steamid_from() {
  steamid_from_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_from();
}
inline ::google::protobuf::uint64 CMsgClientFriendMsgIncoming::steamid_from() const {
  return steamid_from_;
}
inline void CMsgClientFriendMsgIncoming::set_steamid_from(::google::protobuf::uint64 value) {
  set_has_steamid_from();
  steamid_from_ = value;
}

// optional int32 chat_entry_type = 2;
inline bool CMsgClientFriendMsgIncoming::has_chat_entry_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendMsgIncoming::set_has_chat_entry_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendMsgIncoming::clear_has_chat_entry_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendMsgIncoming::clear_chat_entry_type() {
  chat_entry_type_ = 0;
  clear_has_chat_entry_type();
}
inline ::google::protobuf::int32 CMsgClientFriendMsgIncoming::chat_entry_type() const {
  return chat_entry_type_;
}
inline void CMsgClientFriendMsgIncoming::set_chat_entry_type(::google::protobuf::int32 value) {
  set_has_chat_entry_type();
  chat_entry_type_ = value;
}

// optional bool from_limited_account = 3;
inline bool CMsgClientFriendMsgIncoming::has_from_limited_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientFriendMsgIncoming::set_has_from_limited_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientFriendMsgIncoming::clear_has_from_limited_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientFriendMsgIncoming::clear_from_limited_account() {
  from_limited_account_ = false;
  clear_has_from_limited_account();
}
inline bool CMsgClientFriendMsgIncoming::from_limited_account() const {
  return from_limited_account_;
}
inline void CMsgClientFriendMsgIncoming::set_from_limited_account(bool value) {
  set_has_from_limited_account();
  from_limited_account_ = value;
}

// optional bytes message = 4;
inline bool CMsgClientFriendMsgIncoming::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientFriendMsgIncoming::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientFriendMsgIncoming::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientFriendMsgIncoming::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CMsgClientFriendMsgIncoming::message() const {
  return *message_;
}
inline void CMsgClientFriendMsgIncoming::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgClientFriendMsgIncoming::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgClientFriendMsgIncoming::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendMsgIncoming::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* CMsgClientFriendMsgIncoming::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendMsgIncoming::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientAddFriend

// optional fixed64 steamid_to_add = 1;
inline bool CMsgClientAddFriend::has_steamid_to_add() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAddFriend::set_has_steamid_to_add() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAddFriend::clear_has_steamid_to_add() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAddFriend::clear_steamid_to_add() {
  steamid_to_add_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_to_add();
}
inline ::google::protobuf::uint64 CMsgClientAddFriend::steamid_to_add() const {
  return steamid_to_add_;
}
inline void CMsgClientAddFriend::set_steamid_to_add(::google::protobuf::uint64 value) {
  set_has_steamid_to_add();
  steamid_to_add_ = value;
}

// optional string accountname_or_email_to_add = 2;
inline bool CMsgClientAddFriend::has_accountname_or_email_to_add() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAddFriend::set_has_accountname_or_email_to_add() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAddFriend::clear_has_accountname_or_email_to_add() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAddFriend::clear_accountname_or_email_to_add() {
  if (accountname_or_email_to_add_ != &::google::protobuf::internal::kEmptyString) {
    accountname_or_email_to_add_->clear();
  }
  clear_has_accountname_or_email_to_add();
}
inline const ::std::string& CMsgClientAddFriend::accountname_or_email_to_add() const {
  return *accountname_or_email_to_add_;
}
inline void CMsgClientAddFriend::set_accountname_or_email_to_add(const ::std::string& value) {
  set_has_accountname_or_email_to_add();
  if (accountname_or_email_to_add_ == &::google::protobuf::internal::kEmptyString) {
    accountname_or_email_to_add_ = new ::std::string;
  }
  accountname_or_email_to_add_->assign(value);
}
inline void CMsgClientAddFriend::set_accountname_or_email_to_add(const char* value) {
  set_has_accountname_or_email_to_add();
  if (accountname_or_email_to_add_ == &::google::protobuf::internal::kEmptyString) {
    accountname_or_email_to_add_ = new ::std::string;
  }
  accountname_or_email_to_add_->assign(value);
}
inline void CMsgClientAddFriend::set_accountname_or_email_to_add(const char* value, size_t size) {
  set_has_accountname_or_email_to_add();
  if (accountname_or_email_to_add_ == &::google::protobuf::internal::kEmptyString) {
    accountname_or_email_to_add_ = new ::std::string;
  }
  accountname_or_email_to_add_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAddFriend::mutable_accountname_or_email_to_add() {
  set_has_accountname_or_email_to_add();
  if (accountname_or_email_to_add_ == &::google::protobuf::internal::kEmptyString) {
    accountname_or_email_to_add_ = new ::std::string;
  }
  return accountname_or_email_to_add_;
}
inline ::std::string* CMsgClientAddFriend::release_accountname_or_email_to_add() {
  clear_has_accountname_or_email_to_add();
  if (accountname_or_email_to_add_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountname_or_email_to_add_;
    accountname_or_email_to_add_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAddFriend::set_allocated_accountname_or_email_to_add(::std::string* accountname_or_email_to_add) {
  if (accountname_or_email_to_add_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_or_email_to_add_;
  }
  if (accountname_or_email_to_add) {
    set_has_accountname_or_email_to_add();
    accountname_or_email_to_add_ = accountname_or_email_to_add;
  } else {
    clear_has_accountname_or_email_to_add();
    accountname_or_email_to_add_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientAddFriendResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientAddFriendResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAddFriendResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAddFriendResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAddFriendResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientAddFriendResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientAddFriendResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 steam_id_added = 2;
inline bool CMsgClientAddFriendResponse::has_steam_id_added() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAddFriendResponse::set_has_steam_id_added() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAddFriendResponse::clear_has_steam_id_added() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAddFriendResponse::clear_steam_id_added() {
  steam_id_added_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_added();
}
inline ::google::protobuf::uint64 CMsgClientAddFriendResponse::steam_id_added() const {
  return steam_id_added_;
}
inline void CMsgClientAddFriendResponse::set_steam_id_added(::google::protobuf::uint64 value) {
  set_has_steam_id_added();
  steam_id_added_ = value;
}

// optional string persona_name_added = 3;
inline bool CMsgClientAddFriendResponse::has_persona_name_added() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAddFriendResponse::set_has_persona_name_added() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAddFriendResponse::clear_has_persona_name_added() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAddFriendResponse::clear_persona_name_added() {
  if (persona_name_added_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_added_->clear();
  }
  clear_has_persona_name_added();
}
inline const ::std::string& CMsgClientAddFriendResponse::persona_name_added() const {
  return *persona_name_added_;
}
inline void CMsgClientAddFriendResponse::set_persona_name_added(const ::std::string& value) {
  set_has_persona_name_added();
  if (persona_name_added_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_added_ = new ::std::string;
  }
  persona_name_added_->assign(value);
}
inline void CMsgClientAddFriendResponse::set_persona_name_added(const char* value) {
  set_has_persona_name_added();
  if (persona_name_added_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_added_ = new ::std::string;
  }
  persona_name_added_->assign(value);
}
inline void CMsgClientAddFriendResponse::set_persona_name_added(const char* value, size_t size) {
  set_has_persona_name_added();
  if (persona_name_added_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_added_ = new ::std::string;
  }
  persona_name_added_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAddFriendResponse::mutable_persona_name_added() {
  set_has_persona_name_added();
  if (persona_name_added_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_added_ = new ::std::string;
  }
  return persona_name_added_;
}
inline ::std::string* CMsgClientAddFriendResponse::release_persona_name_added() {
  clear_has_persona_name_added();
  if (persona_name_added_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_added_;
    persona_name_added_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAddFriendResponse::set_allocated_persona_name_added(::std::string* persona_name_added) {
  if (persona_name_added_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_added_;
  }
  if (persona_name_added) {
    set_has_persona_name_added();
    persona_name_added_ = persona_name_added;
  } else {
    clear_has_persona_name_added();
    persona_name_added_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRemoveFriend

// optional fixed64 friendid = 1;
inline bool CMsgClientRemoveFriend::has_friendid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRemoveFriend::set_has_friendid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRemoveFriend::clear_has_friendid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRemoveFriend::clear_friendid() {
  friendid_ = GOOGLE_ULONGLONG(0);
  clear_has_friendid();
}
inline ::google::protobuf::uint64 CMsgClientRemoveFriend::friendid() const {
  return friendid_;
}
inline void CMsgClientRemoveFriend::set_friendid(::google::protobuf::uint64 value) {
  set_has_friendid();
  friendid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientHideFriend

// optional fixed64 friendid = 1;
inline bool CMsgClientHideFriend::has_friendid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientHideFriend::set_has_friendid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientHideFriend::clear_has_friendid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientHideFriend::clear_friendid() {
  friendid_ = GOOGLE_ULONGLONG(0);
  clear_has_friendid();
}
inline ::google::protobuf::uint64 CMsgClientHideFriend::friendid() const {
  return friendid_;
}
inline void CMsgClientHideFriend::set_friendid(::google::protobuf::uint64 value) {
  set_has_friendid();
  friendid_ = value;
}

// optional bool hide = 2;
inline bool CMsgClientHideFriend::has_hide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientHideFriend::set_has_hide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientHideFriend::clear_has_hide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientHideFriend::clear_hide() {
  hide_ = false;
  clear_has_hide();
}
inline bool CMsgClientHideFriend::hide() const {
  return hide_;
}
inline void CMsgClientHideFriend::set_hide(bool value) {
  set_has_hide();
  hide_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMAddScreenshot_Tag

// optional string tag_name = 1;
inline bool CMsgClientUCMAddScreenshot_Tag::has_tag_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMAddScreenshot_Tag::set_has_tag_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMAddScreenshot_Tag::clear_has_tag_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMAddScreenshot_Tag::clear_tag_name() {
  if (tag_name_ != &::google::protobuf::internal::kEmptyString) {
    tag_name_->clear();
  }
  clear_has_tag_name();
}
inline const ::std::string& CMsgClientUCMAddScreenshot_Tag::tag_name() const {
  return *tag_name_;
}
inline void CMsgClientUCMAddScreenshot_Tag::set_tag_name(const ::std::string& value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
}
inline void CMsgClientUCMAddScreenshot_Tag::set_tag_name(const char* value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
}
inline void CMsgClientUCMAddScreenshot_Tag::set_tag_name(const char* value, size_t size) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMAddScreenshot_Tag::mutable_tag_name() {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    tag_name_ = new ::std::string;
  }
  return tag_name_;
}
inline ::std::string* CMsgClientUCMAddScreenshot_Tag::release_tag_name() {
  clear_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_name_;
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMAddScreenshot_Tag::set_allocated_tag_name(::std::string* tag_name) {
  if (tag_name_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_name_;
  }
  if (tag_name) {
    set_has_tag_name();
    tag_name_ = tag_name;
  } else {
    clear_has_tag_name();
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tag_value = 2;
inline bool CMsgClientUCMAddScreenshot_Tag::has_tag_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMAddScreenshot_Tag::set_has_tag_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMAddScreenshot_Tag::clear_has_tag_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMAddScreenshot_Tag::clear_tag_value() {
  if (tag_value_ != &::google::protobuf::internal::kEmptyString) {
    tag_value_->clear();
  }
  clear_has_tag_value();
}
inline const ::std::string& CMsgClientUCMAddScreenshot_Tag::tag_value() const {
  return *tag_value_;
}
inline void CMsgClientUCMAddScreenshot_Tag::set_tag_value(const ::std::string& value) {
  set_has_tag_value();
  if (tag_value_ == &::google::protobuf::internal::kEmptyString) {
    tag_value_ = new ::std::string;
  }
  tag_value_->assign(value);
}
inline void CMsgClientUCMAddScreenshot_Tag::set_tag_value(const char* value) {
  set_has_tag_value();
  if (tag_value_ == &::google::protobuf::internal::kEmptyString) {
    tag_value_ = new ::std::string;
  }
  tag_value_->assign(value);
}
inline void CMsgClientUCMAddScreenshot_Tag::set_tag_value(const char* value, size_t size) {
  set_has_tag_value();
  if (tag_value_ == &::google::protobuf::internal::kEmptyString) {
    tag_value_ = new ::std::string;
  }
  tag_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMAddScreenshot_Tag::mutable_tag_value() {
  set_has_tag_value();
  if (tag_value_ == &::google::protobuf::internal::kEmptyString) {
    tag_value_ = new ::std::string;
  }
  return tag_value_;
}
inline ::std::string* CMsgClientUCMAddScreenshot_Tag::release_tag_value() {
  clear_has_tag_value();
  if (tag_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_value_;
    tag_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMAddScreenshot_Tag::set_allocated_tag_value(::std::string* tag_value) {
  if (tag_value_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_value_;
  }
  if (tag_value) {
    set_has_tag_value();
    tag_value_ = tag_value;
  } else {
    clear_has_tag_value();
    tag_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUCMAddScreenshot

// optional uint32 appid = 1;
inline bool CMsgClientUCMAddScreenshot::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMAddScreenshot::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientUCMAddScreenshot::appid() const {
  return appid_;
}
inline void CMsgClientUCMAddScreenshot::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string filename = 2;
inline bool CMsgClientUCMAddScreenshot::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMAddScreenshot::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientUCMAddScreenshot::filename() const {
  return *filename_;
}
inline void CMsgClientUCMAddScreenshot::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMAddScreenshot::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientUCMAddScreenshot::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMAddScreenshot::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string thumbname = 3;
inline bool CMsgClientUCMAddScreenshot::has_thumbname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_thumbname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_thumbname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMAddScreenshot::clear_thumbname() {
  if (thumbname_ != &::google::protobuf::internal::kEmptyString) {
    thumbname_->clear();
  }
  clear_has_thumbname();
}
inline const ::std::string& CMsgClientUCMAddScreenshot::thumbname() const {
  return *thumbname_;
}
inline void CMsgClientUCMAddScreenshot::set_thumbname(const ::std::string& value) {
  set_has_thumbname();
  if (thumbname_ == &::google::protobuf::internal::kEmptyString) {
    thumbname_ = new ::std::string;
  }
  thumbname_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_thumbname(const char* value) {
  set_has_thumbname();
  if (thumbname_ == &::google::protobuf::internal::kEmptyString) {
    thumbname_ = new ::std::string;
  }
  thumbname_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_thumbname(const char* value, size_t size) {
  set_has_thumbname();
  if (thumbname_ == &::google::protobuf::internal::kEmptyString) {
    thumbname_ = new ::std::string;
  }
  thumbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMAddScreenshot::mutable_thumbname() {
  set_has_thumbname();
  if (thumbname_ == &::google::protobuf::internal::kEmptyString) {
    thumbname_ = new ::std::string;
  }
  return thumbname_;
}
inline ::std::string* CMsgClientUCMAddScreenshot::release_thumbname() {
  clear_has_thumbname();
  if (thumbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thumbname_;
    thumbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMAddScreenshot::set_allocated_thumbname(::std::string* thumbname) {
  if (thumbname_ != &::google::protobuf::internal::kEmptyString) {
    delete thumbname_;
  }
  if (thumbname) {
    set_has_thumbname();
    thumbname_ = thumbname;
  } else {
    clear_has_thumbname();
    thumbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 rtime32_created = 4;
inline bool CMsgClientUCMAddScreenshot::has_rtime32_created() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_rtime32_created() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_rtime32_created() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMAddScreenshot::clear_rtime32_created() {
  rtime32_created_ = 0u;
  clear_has_rtime32_created();
}
inline ::google::protobuf::uint32 CMsgClientUCMAddScreenshot::rtime32_created() const {
  return rtime32_created_;
}
inline void CMsgClientUCMAddScreenshot::set_rtime32_created(::google::protobuf::uint32 value) {
  set_has_rtime32_created();
  rtime32_created_ = value;
}

// optional uint32 width = 5;
inline bool CMsgClientUCMAddScreenshot::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUCMAddScreenshot::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 CMsgClientUCMAddScreenshot::width() const {
  return width_;
}
inline void CMsgClientUCMAddScreenshot::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 6;
inline bool CMsgClientUCMAddScreenshot::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUCMAddScreenshot::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 CMsgClientUCMAddScreenshot::height() const {
  return height_;
}
inline void CMsgClientUCMAddScreenshot::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// optional uint32 permissions = 7;
inline bool CMsgClientUCMAddScreenshot::has_permissions() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_permissions() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_permissions() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUCMAddScreenshot::clear_permissions() {
  permissions_ = 0u;
  clear_has_permissions();
}
inline ::google::protobuf::uint32 CMsgClientUCMAddScreenshot::permissions() const {
  return permissions_;
}
inline void CMsgClientUCMAddScreenshot::set_permissions(::google::protobuf::uint32 value) {
  set_has_permissions();
  permissions_ = value;
}

// optional string caption = 8;
inline bool CMsgClientUCMAddScreenshot::has_caption() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_caption() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_caption() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUCMAddScreenshot::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& CMsgClientUCMAddScreenshot::caption() const {
  return *caption_;
}
inline void CMsgClientUCMAddScreenshot::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMAddScreenshot::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* CMsgClientUCMAddScreenshot::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMAddScreenshot::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string shortcut_name = 9;
inline bool CMsgClientUCMAddScreenshot::has_shortcut_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_shortcut_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_shortcut_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUCMAddScreenshot::clear_shortcut_name() {
  if (shortcut_name_ != &::google::protobuf::internal::kEmptyString) {
    shortcut_name_->clear();
  }
  clear_has_shortcut_name();
}
inline const ::std::string& CMsgClientUCMAddScreenshot::shortcut_name() const {
  return *shortcut_name_;
}
inline void CMsgClientUCMAddScreenshot::set_shortcut_name(const ::std::string& value) {
  set_has_shortcut_name();
  if (shortcut_name_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_name_ = new ::std::string;
  }
  shortcut_name_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_shortcut_name(const char* value) {
  set_has_shortcut_name();
  if (shortcut_name_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_name_ = new ::std::string;
  }
  shortcut_name_->assign(value);
}
inline void CMsgClientUCMAddScreenshot::set_shortcut_name(const char* value, size_t size) {
  set_has_shortcut_name();
  if (shortcut_name_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_name_ = new ::std::string;
  }
  shortcut_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMAddScreenshot::mutable_shortcut_name() {
  set_has_shortcut_name();
  if (shortcut_name_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_name_ = new ::std::string;
  }
  return shortcut_name_;
}
inline ::std::string* CMsgClientUCMAddScreenshot::release_shortcut_name() {
  clear_has_shortcut_name();
  if (shortcut_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shortcut_name_;
    shortcut_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMAddScreenshot::set_allocated_shortcut_name(::std::string* shortcut_name) {
  if (shortcut_name_ != &::google::protobuf::internal::kEmptyString) {
    delete shortcut_name_;
  }
  if (shortcut_name) {
    set_has_shortcut_name();
    shortcut_name_ = shortcut_name;
  } else {
    clear_has_shortcut_name();
    shortcut_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Sc.CMsgClientUCMAddScreenshot.Tag tag = 10;
inline int CMsgClientUCMAddScreenshot::tag_size() const {
  return tag_.size();
}
inline void CMsgClientUCMAddScreenshot::clear_tag() {
  tag_.Clear();
}
inline const ::Sc::CMsgClientUCMAddScreenshot_Tag& CMsgClientUCMAddScreenshot::tag(int index) const {
  return tag_.Get(index);
}
inline ::Sc::CMsgClientUCMAddScreenshot_Tag* CMsgClientUCMAddScreenshot::mutable_tag(int index) {
  return tag_.Mutable(index);
}
inline ::Sc::CMsgClientUCMAddScreenshot_Tag* CMsgClientUCMAddScreenshot::add_tag() {
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMAddScreenshot_Tag >&
CMsgClientUCMAddScreenshot::tag() const {
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMAddScreenshot_Tag >*
CMsgClientUCMAddScreenshot::mutable_tag() {
  return &tag_;
}

// repeated fixed64 tagged_steamid = 11;
inline int CMsgClientUCMAddScreenshot::tagged_steamid_size() const {
  return tagged_steamid_.size();
}
inline void CMsgClientUCMAddScreenshot::clear_tagged_steamid() {
  tagged_steamid_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientUCMAddScreenshot::tagged_steamid(int index) const {
  return tagged_steamid_.Get(index);
}
inline void CMsgClientUCMAddScreenshot::set_tagged_steamid(int index, ::google::protobuf::uint64 value) {
  tagged_steamid_.Set(index, value);
}
inline void CMsgClientUCMAddScreenshot::add_tagged_steamid(::google::protobuf::uint64 value) {
  tagged_steamid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientUCMAddScreenshot::tagged_steamid() const {
  return tagged_steamid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientUCMAddScreenshot::mutable_tagged_steamid() {
  return &tagged_steamid_;
}

// optional bool spoiler_tag = 12;
inline bool CMsgClientUCMAddScreenshot::has_spoiler_tag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientUCMAddScreenshot::set_has_spoiler_tag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientUCMAddScreenshot::clear_has_spoiler_tag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientUCMAddScreenshot::clear_spoiler_tag() {
  spoiler_tag_ = false;
  clear_has_spoiler_tag();
}
inline bool CMsgClientUCMAddScreenshot::spoiler_tag() const {
  return spoiler_tag_;
}
inline void CMsgClientUCMAddScreenshot::set_spoiler_tag(bool value) {
  set_has_spoiler_tag();
  spoiler_tag_ = value;
}

// repeated uint64 tagged_publishedfileid = 13;
inline int CMsgClientUCMAddScreenshot::tagged_publishedfileid_size() const {
  return tagged_publishedfileid_.size();
}
inline void CMsgClientUCMAddScreenshot::clear_tagged_publishedfileid() {
  tagged_publishedfileid_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientUCMAddScreenshot::tagged_publishedfileid(int index) const {
  return tagged_publishedfileid_.Get(index);
}
inline void CMsgClientUCMAddScreenshot::set_tagged_publishedfileid(int index, ::google::protobuf::uint64 value) {
  tagged_publishedfileid_.Set(index, value);
}
inline void CMsgClientUCMAddScreenshot::add_tagged_publishedfileid(::google::protobuf::uint64 value) {
  tagged_publishedfileid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientUCMAddScreenshot::tagged_publishedfileid() const {
  return tagged_publishedfileid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientUCMAddScreenshot::mutable_tagged_publishedfileid() {
  return &tagged_publishedfileid_;
}

// -------------------------------------------------------------------

// CMsgClientUCMAddScreenshotResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMAddScreenshotResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMAddScreenshotResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMAddScreenshotResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMAddScreenshotResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMAddScreenshotResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMAddScreenshotResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 screenshotid = 2 [default = 18446744073709551615];
inline bool CMsgClientUCMAddScreenshotResponse::has_screenshotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMAddScreenshotResponse::set_has_screenshotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMAddScreenshotResponse::clear_has_screenshotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMAddScreenshotResponse::clear_screenshotid() {
  screenshotid_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_screenshotid();
}
inline ::google::protobuf::uint64 CMsgClientUCMAddScreenshotResponse::screenshotid() const {
  return screenshotid_;
}
inline void CMsgClientUCMAddScreenshotResponse::set_screenshotid(::google::protobuf::uint64 value) {
  set_has_screenshotid();
  screenshotid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMDeleteScreenshot

// optional fixed64 screenshotid = 1 [default = 18446744073709551615];
inline bool CMsgClientUCMDeleteScreenshot::has_screenshotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMDeleteScreenshot::set_has_screenshotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMDeleteScreenshot::clear_has_screenshotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMDeleteScreenshot::clear_screenshotid() {
  screenshotid_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_screenshotid();
}
inline ::google::protobuf::uint64 CMsgClientUCMDeleteScreenshot::screenshotid() const {
  return screenshotid_;
}
inline void CMsgClientUCMDeleteScreenshot::set_screenshotid(::google::protobuf::uint64 value) {
  set_has_screenshotid();
  screenshotid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMDeleteScreenshotResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMDeleteScreenshotResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMDeleteScreenshotResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMDeleteScreenshotResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMDeleteScreenshotResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMDeleteScreenshotResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMDeleteScreenshotResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMPublishFile

// optional uint32 app_id = 1;
inline bool CMsgClientUCMPublishFile::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMPublishFile::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMPublishFile::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishFile::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMPublishFile::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string file_name = 2;
inline bool CMsgClientUCMPublishFile::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMPublishFile::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMPublishFile::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUCMPublishFile::file_name() const {
  return *file_name_;
}
inline void CMsgClientUCMPublishFile::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string preview_file_name = 3;
inline bool CMsgClientUCMPublishFile::has_preview_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_preview_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMPublishFile::clear_has_preview_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMPublishFile::clear_preview_file_name() {
  if (preview_file_name_ != &::google::protobuf::internal::kEmptyString) {
    preview_file_name_->clear();
  }
  clear_has_preview_file_name();
}
inline const ::std::string& CMsgClientUCMPublishFile::preview_file_name() const {
  return *preview_file_name_;
}
inline void CMsgClientUCMPublishFile::set_preview_file_name(const ::std::string& value) {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  preview_file_name_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_preview_file_name(const char* value) {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  preview_file_name_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_preview_file_name(const char* value, size_t size) {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  preview_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_preview_file_name() {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  return preview_file_name_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_preview_file_name() {
  clear_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preview_file_name_;
    preview_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_preview_file_name(::std::string* preview_file_name) {
  if (preview_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete preview_file_name_;
  }
  if (preview_file_name) {
    set_has_preview_file_name();
    preview_file_name_ = preview_file_name;
  } else {
    clear_has_preview_file_name();
    preview_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 consumer_app_id = 4;
inline bool CMsgClientUCMPublishFile::has_consumer_app_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_consumer_app_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMPublishFile::clear_has_consumer_app_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMPublishFile::clear_consumer_app_id() {
  consumer_app_id_ = 0u;
  clear_has_consumer_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishFile::consumer_app_id() const {
  return consumer_app_id_;
}
inline void CMsgClientUCMPublishFile::set_consumer_app_id(::google::protobuf::uint32 value) {
  set_has_consumer_app_id();
  consumer_app_id_ = value;
}

// optional string title = 5;
inline bool CMsgClientUCMPublishFile::has_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUCMPublishFile::clear_has_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUCMPublishFile::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& CMsgClientUCMPublishFile::title() const {
  return *title_;
}
inline void CMsgClientUCMPublishFile::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool CMsgClientUCMPublishFile::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUCMPublishFile::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUCMPublishFile::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CMsgClientUCMPublishFile::description() const {
  return *description_;
}
inline void CMsgClientUCMPublishFile::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string tags = 8;
inline int CMsgClientUCMPublishFile::tags_size() const {
  return tags_.size();
}
inline void CMsgClientUCMPublishFile::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CMsgClientUCMPublishFile::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CMsgClientUCMPublishFile::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMPublishFile::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMPublishFile::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::add_tags() {
  return tags_.Add();
}
inline void CMsgClientUCMPublishFile::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CMsgClientUCMPublishFile::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CMsgClientUCMPublishFile::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientUCMPublishFile::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientUCMPublishFile::mutable_tags() {
  return &tags_;
}

// optional bool workshop_file = 9;
inline bool CMsgClientUCMPublishFile::has_workshop_file() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_workshop_file() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUCMPublishFile::clear_has_workshop_file() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUCMPublishFile::clear_workshop_file() {
  workshop_file_ = false;
  clear_has_workshop_file();
}
inline bool CMsgClientUCMPublishFile::workshop_file() const {
  return workshop_file_;
}
inline void CMsgClientUCMPublishFile::set_workshop_file(bool value) {
  set_has_workshop_file();
  workshop_file_ = value;
}

// optional int32 visibility = 10;
inline bool CMsgClientUCMPublishFile::has_visibility() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_visibility() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUCMPublishFile::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUCMPublishFile::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::google::protobuf::int32 CMsgClientUCMPublishFile::visibility() const {
  return visibility_;
}
inline void CMsgClientUCMPublishFile::set_visibility(::google::protobuf::int32 value) {
  set_has_visibility();
  visibility_ = value;
}

// optional uint32 file_type = 11;
inline bool CMsgClientUCMPublishFile::has_file_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_file_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientUCMPublishFile::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientUCMPublishFile::clear_file_type() {
  file_type_ = 0u;
  clear_has_file_type();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishFile::file_type() const {
  return file_type_;
}
inline void CMsgClientUCMPublishFile::set_file_type(::google::protobuf::uint32 value) {
  set_has_file_type();
  file_type_ = value;
}

// optional string url = 12;
inline bool CMsgClientUCMPublishFile::has_url() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_url() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientUCMPublishFile::clear_has_url() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientUCMPublishFile::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CMsgClientUCMPublishFile::url() const {
  return *url_;
}
inline void CMsgClientUCMPublishFile::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 video_provider = 13;
inline bool CMsgClientUCMPublishFile::has_video_provider() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_video_provider() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientUCMPublishFile::clear_has_video_provider() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientUCMPublishFile::clear_video_provider() {
  video_provider_ = 0u;
  clear_has_video_provider();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishFile::video_provider() const {
  return video_provider_;
}
inline void CMsgClientUCMPublishFile::set_video_provider(::google::protobuf::uint32 value) {
  set_has_video_provider();
  video_provider_ = value;
}

// optional string video_account_name = 14;
inline bool CMsgClientUCMPublishFile::has_video_account_name() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_video_account_name() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientUCMPublishFile::clear_has_video_account_name() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientUCMPublishFile::clear_video_account_name() {
  if (video_account_name_ != &::google::protobuf::internal::kEmptyString) {
    video_account_name_->clear();
  }
  clear_has_video_account_name();
}
inline const ::std::string& CMsgClientUCMPublishFile::video_account_name() const {
  return *video_account_name_;
}
inline void CMsgClientUCMPublishFile::set_video_account_name(const ::std::string& value) {
  set_has_video_account_name();
  if (video_account_name_ == &::google::protobuf::internal::kEmptyString) {
    video_account_name_ = new ::std::string;
  }
  video_account_name_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_video_account_name(const char* value) {
  set_has_video_account_name();
  if (video_account_name_ == &::google::protobuf::internal::kEmptyString) {
    video_account_name_ = new ::std::string;
  }
  video_account_name_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_video_account_name(const char* value, size_t size) {
  set_has_video_account_name();
  if (video_account_name_ == &::google::protobuf::internal::kEmptyString) {
    video_account_name_ = new ::std::string;
  }
  video_account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_video_account_name() {
  set_has_video_account_name();
  if (video_account_name_ == &::google::protobuf::internal::kEmptyString) {
    video_account_name_ = new ::std::string;
  }
  return video_account_name_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_video_account_name() {
  clear_has_video_account_name();
  if (video_account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_account_name_;
    video_account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_video_account_name(::std::string* video_account_name) {
  if (video_account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete video_account_name_;
  }
  if (video_account_name) {
    set_has_video_account_name();
    video_account_name_ = video_account_name;
  } else {
    clear_has_video_account_name();
    video_account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string video_identifier = 15;
inline bool CMsgClientUCMPublishFile::has_video_identifier() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientUCMPublishFile::set_has_video_identifier() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientUCMPublishFile::clear_has_video_identifier() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientUCMPublishFile::clear_video_identifier() {
  if (video_identifier_ != &::google::protobuf::internal::kEmptyString) {
    video_identifier_->clear();
  }
  clear_has_video_identifier();
}
inline const ::std::string& CMsgClientUCMPublishFile::video_identifier() const {
  return *video_identifier_;
}
inline void CMsgClientUCMPublishFile::set_video_identifier(const ::std::string& value) {
  set_has_video_identifier();
  if (video_identifier_ == &::google::protobuf::internal::kEmptyString) {
    video_identifier_ = new ::std::string;
  }
  video_identifier_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_video_identifier(const char* value) {
  set_has_video_identifier();
  if (video_identifier_ == &::google::protobuf::internal::kEmptyString) {
    video_identifier_ = new ::std::string;
  }
  video_identifier_->assign(value);
}
inline void CMsgClientUCMPublishFile::set_video_identifier(const char* value, size_t size) {
  set_has_video_identifier();
  if (video_identifier_ == &::google::protobuf::internal::kEmptyString) {
    video_identifier_ = new ::std::string;
  }
  video_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMPublishFile::mutable_video_identifier() {
  set_has_video_identifier();
  if (video_identifier_ == &::google::protobuf::internal::kEmptyString) {
    video_identifier_ = new ::std::string;
  }
  return video_identifier_;
}
inline ::std::string* CMsgClientUCMPublishFile::release_video_identifier() {
  clear_has_video_identifier();
  if (video_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_identifier_;
    video_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMPublishFile::set_allocated_video_identifier(::std::string* video_identifier) {
  if (video_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete video_identifier_;
  }
  if (video_identifier) {
    set_has_video_identifier();
    video_identifier_ = video_identifier;
  } else {
    clear_has_video_identifier();
    video_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUCMPublishFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMPublishFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMPublishFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMPublishFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMPublishFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMPublishFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMPublishFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 published_file_id = 2 [default = 18446744073709551615];
inline bool CMsgClientUCMPublishFileResponse::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMPublishFileResponse::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMPublishFileResponse::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMPublishFileResponse::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMPublishFileResponse::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMPublishFileResponse::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMUpdatePublishedFile

// optional uint32 app_id = 1;
inline bool CMsgClientUCMUpdatePublishedFile::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMUpdatePublishedFile::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 published_file_id = 2;
inline bool CMsgClientUCMUpdatePublishedFile::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMUpdatePublishedFile::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional string file_name = 3;
inline bool CMsgClientUCMUpdatePublishedFile::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::file_name() const {
  return *file_name_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMUpdatePublishedFile::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string preview_file_name = 4;
inline bool CMsgClientUCMUpdatePublishedFile::has_preview_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_preview_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_preview_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_preview_file_name() {
  if (preview_file_name_ != &::google::protobuf::internal::kEmptyString) {
    preview_file_name_->clear();
  }
  clear_has_preview_file_name();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::preview_file_name() const {
  return *preview_file_name_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_preview_file_name(const ::std::string& value) {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  preview_file_name_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_preview_file_name(const char* value) {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  preview_file_name_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_preview_file_name(const char* value, size_t size) {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  preview_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_preview_file_name() {
  set_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    preview_file_name_ = new ::std::string;
  }
  return preview_file_name_;
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::release_preview_file_name() {
  clear_has_preview_file_name();
  if (preview_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preview_file_name_;
    preview_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMUpdatePublishedFile::set_allocated_preview_file_name(::std::string* preview_file_name) {
  if (preview_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete preview_file_name_;
  }
  if (preview_file_name) {
    set_has_preview_file_name();
    preview_file_name_ = preview_file_name;
  } else {
    clear_has_preview_file_name();
    preview_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 5;
inline bool CMsgClientUCMUpdatePublishedFile::has_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::title() const {
  return *title_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMUpdatePublishedFile::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool CMsgClientUCMUpdatePublishedFile::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::description() const {
  return *description_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMUpdatePublishedFile::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string tags = 7;
inline int CMsgClientUCMUpdatePublishedFile::tags_size() const {
  return tags_.size();
}
inline void CMsgClientUCMUpdatePublishedFile::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CMsgClientUCMUpdatePublishedFile::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::add_tags() {
  return tags_.Add();
}
inline void CMsgClientUCMUpdatePublishedFile::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientUCMUpdatePublishedFile::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientUCMUpdatePublishedFile::mutable_tags() {
  return &tags_;
}

// optional int32 visibility = 8;
inline bool CMsgClientUCMUpdatePublishedFile::has_visibility() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_visibility() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::google::protobuf::int32 CMsgClientUCMUpdatePublishedFile::visibility() const {
  return visibility_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_visibility(::google::protobuf::int32 value) {
  set_has_visibility();
  visibility_ = value;
}

// optional bool update_file = 9;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_file() {
  update_file_ = false;
  clear_has_update_file();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_file() const {
  return update_file_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_file(bool value) {
  set_has_update_file();
  update_file_ = value;
}

// optional bool update_preview_file = 10;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_preview_file() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_preview_file() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_preview_file() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_preview_file() {
  update_preview_file_ = false;
  clear_has_update_preview_file();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_preview_file() const {
  return update_preview_file_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_preview_file(bool value) {
  set_has_update_preview_file();
  update_preview_file_ = value;
}

// optional bool update_title = 11;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_title() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_title() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_title() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_title() {
  update_title_ = false;
  clear_has_update_title();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_title() const {
  return update_title_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_title(bool value) {
  set_has_update_title();
  update_title_ = value;
}

// optional bool update_description = 12;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_description() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_description() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_description() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_description() {
  update_description_ = false;
  clear_has_update_description();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_description() const {
  return update_description_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_description(bool value) {
  set_has_update_description();
  update_description_ = value;
}

// optional bool update_tags = 13;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_tags() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_tags() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_tags() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_tags() {
  update_tags_ = false;
  clear_has_update_tags();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_tags() const {
  return update_tags_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_tags(bool value) {
  set_has_update_tags();
  update_tags_ = value;
}

// optional bool update_visibility = 14;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_visibility() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_visibility() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_visibility() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_visibility() {
  update_visibility_ = false;
  clear_has_update_visibility();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_visibility() const {
  return update_visibility_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_visibility(bool value) {
  set_has_update_visibility();
  update_visibility_ = value;
}

// optional string change_description = 15;
inline bool CMsgClientUCMUpdatePublishedFile::has_change_description() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_change_description() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_change_description() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_change_description() {
  if (change_description_ != &::google::protobuf::internal::kEmptyString) {
    change_description_->clear();
  }
  clear_has_change_description();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::change_description() const {
  return *change_description_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_change_description(const ::std::string& value) {
  set_has_change_description();
  if (change_description_ == &::google::protobuf::internal::kEmptyString) {
    change_description_ = new ::std::string;
  }
  change_description_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_change_description(const char* value) {
  set_has_change_description();
  if (change_description_ == &::google::protobuf::internal::kEmptyString) {
    change_description_ = new ::std::string;
  }
  change_description_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_change_description(const char* value, size_t size) {
  set_has_change_description();
  if (change_description_ == &::google::protobuf::internal::kEmptyString) {
    change_description_ = new ::std::string;
  }
  change_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_change_description() {
  set_has_change_description();
  if (change_description_ == &::google::protobuf::internal::kEmptyString) {
    change_description_ = new ::std::string;
  }
  return change_description_;
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::release_change_description() {
  clear_has_change_description();
  if (change_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = change_description_;
    change_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMUpdatePublishedFile::set_allocated_change_description(::std::string* change_description) {
  if (change_description_ != &::google::protobuf::internal::kEmptyString) {
    delete change_description_;
  }
  if (change_description) {
    set_has_change_description();
    change_description_ = change_description;
  } else {
    clear_has_change_description();
    change_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool update_url = 16;
inline bool CMsgClientUCMUpdatePublishedFile::has_update_url() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_update_url() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_update_url() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_update_url() {
  update_url_ = false;
  clear_has_update_url();
}
inline bool CMsgClientUCMUpdatePublishedFile::update_url() const {
  return update_url_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_update_url(bool value) {
  set_has_update_url();
  update_url_ = value;
}

// optional string url = 17;
inline bool CMsgClientUCMUpdatePublishedFile::has_url() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFile::set_has_url() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_has_url() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientUCMUpdatePublishedFile::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CMsgClientUCMUpdatePublishedFile::url() const {
  return *url_;
}
inline void CMsgClientUCMUpdatePublishedFile::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUCMUpdatePublishedFile::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* CMsgClientUCMUpdatePublishedFile::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMUpdatePublishedFile::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUCMUpdatePublishedFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMUpdatePublishedFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMUpdatePublishedFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMUpdatePublishedFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMUpdatePublishedFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMUpdatePublishedFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMUpdatePublishedFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMGetPublishedFileDetails

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMGetPublishedFileDetails::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetails::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMGetPublishedFileDetails::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMGetPublishedFileDetails::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFileDetails::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMGetPublishedFileDetails::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMGetPublishedFileDetailsResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMGetPublishedFileDetailsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 published_file_id = 2 [default = 18446744073709551615];
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFileDetailsResponse::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional fixed64 creator_steam_id = 3;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_creator_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_creator_steam_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_creator_steam_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_creator_steam_id() {
  creator_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_creator_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFileDetailsResponse::creator_steam_id() const {
  return creator_steam_id_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_creator_steam_id(::google::protobuf::uint64 value) {
  set_has_creator_steam_id();
  creator_steam_id_ = value;
}

// optional uint32 creator_app_id = 4;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_creator_app_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_creator_app_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_creator_app_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_creator_app_id() {
  creator_app_id_ = 0u;
  clear_has_creator_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::creator_app_id() const {
  return creator_app_id_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_creator_app_id(::google::protobuf::uint32 value) {
  set_has_creator_app_id();
  creator_app_id_ = value;
}

// optional uint32 consumer_app_id = 5;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_consumer_app_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_consumer_app_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_consumer_app_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_consumer_app_id() {
  consumer_app_id_ = 0u;
  clear_has_consumer_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::consumer_app_id() const {
  return consumer_app_id_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_consumer_app_id(::google::protobuf::uint32 value) {
  set_has_consumer_app_id();
  consumer_app_id_ = value;
}

// optional fixed64 file_hcontent = 6 [default = 18446744073709551615];
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_file_hcontent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_file_hcontent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_file_hcontent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_file_hcontent() {
  file_hcontent_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_file_hcontent();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFileDetailsResponse::file_hcontent() const {
  return file_hcontent_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_file_hcontent(::google::protobuf::uint64 value) {
  set_has_file_hcontent();
  file_hcontent_ = value;
}

// optional fixed64 preview_hcontent = 7 [default = 18446744073709551615];
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_preview_hcontent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_preview_hcontent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_preview_hcontent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_preview_hcontent() {
  preview_hcontent_ = GOOGLE_ULONGLONG(18446744073709551615);
  clear_has_preview_hcontent();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFileDetailsResponse::preview_hcontent() const {
  return preview_hcontent_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_preview_hcontent(::google::protobuf::uint64 value) {
  set_has_preview_hcontent();
  preview_hcontent_ = value;
}

// optional string title = 8;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_title() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_title() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_title() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& CMsgClientUCMGetPublishedFileDetailsResponse::title() const {
  return *title_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 9;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CMsgClientUCMGetPublishedFileDetailsResponse::description() const {
  return *description_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 rtime32_created = 10;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_rtime32_created() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_rtime32_created() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_rtime32_created() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_rtime32_created() {
  rtime32_created_ = 0u;
  clear_has_rtime32_created();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::rtime32_created() const {
  return rtime32_created_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_rtime32_created(::google::protobuf::uint32 value) {
  set_has_rtime32_created();
  rtime32_created_ = value;
}

// optional fixed32 rtime32_updated = 11;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_rtime32_updated() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_rtime32_updated() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_rtime32_updated() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_rtime32_updated() {
  rtime32_updated_ = 0u;
  clear_has_rtime32_updated();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::rtime32_updated() const {
  return rtime32_updated_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_rtime32_updated(::google::protobuf::uint32 value) {
  set_has_rtime32_updated();
  rtime32_updated_ = value;
}

// optional int32 visibility = 12;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_visibility() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_visibility() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::google::protobuf::int32 CMsgClientUCMGetPublishedFileDetailsResponse::visibility() const {
  return visibility_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_visibility(::google::protobuf::int32 value) {
  set_has_visibility();
  visibility_ = value;
}

// optional bool banned = 13;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_banned() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_banned() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_banned() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_banned() {
  banned_ = false;
  clear_has_banned();
}
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::banned() const {
  return banned_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_banned(bool value) {
  set_has_banned();
  banned_ = value;
}

// repeated string tag = 14;
inline int CMsgClientUCMGetPublishedFileDetailsResponse::tag_size() const {
  return tag_.size();
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_tag() {
  tag_.Clear();
}
inline const ::std::string& CMsgClientUCMGetPublishedFileDetailsResponse::tag(int index) const {
  return tag_.Get(index);
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::mutable_tag(int index) {
  return tag_.Mutable(index);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_tag(int index, const ::std::string& value) {
  tag_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_tag(int index, const char* value) {
  tag_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_tag(int index, const char* value, size_t size) {
  tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::add_tag() {
  return tag_.Add();
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::add_tag(const ::std::string& value) {
  tag_.Add()->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::add_tag(const char* value) {
  tag_.Add()->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::add_tag(const char* value, size_t size) {
  tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientUCMGetPublishedFileDetailsResponse::tag() const {
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientUCMGetPublishedFileDetailsResponse::mutable_tag() {
  return &tag_;
}

// optional string filename = 15;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_filename() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_filename() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientUCMGetPublishedFileDetailsResponse::filename() const {
  return *filename_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 file_size = 16;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_file_size() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_file_size() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_file_size() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::file_size() const {
  return file_size_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional uint32 preview_file_size = 17;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_preview_file_size() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_preview_file_size() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_preview_file_size() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_preview_file_size() {
  preview_file_size_ = 0u;
  clear_has_preview_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::preview_file_size() const {
  return preview_file_size_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_preview_file_size(::google::protobuf::uint32 value) {
  set_has_preview_file_size();
  preview_file_size_ = value;
}

// optional string url = 18;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_url() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_url() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_url() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CMsgClientUCMGetPublishedFileDetailsResponse::url() const {
  return *url_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* CMsgClientUCMGetPublishedFileDetailsResponse::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 file_type = 19;
inline bool CMsgClientUCMGetPublishedFileDetailsResponse::has_file_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_has_file_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_has_file_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::clear_file_type() {
  file_type_ = 0u;
  clear_has_file_type();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFileDetailsResponse::file_type() const {
  return file_type_;
}
inline void CMsgClientUCMGetPublishedFileDetailsResponse::set_file_type(::google::protobuf::uint32 value) {
  set_has_file_type();
  file_type_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMDeletePublishedFile

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMDeletePublishedFile::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMDeletePublishedFile::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMDeletePublishedFile::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMDeletePublishedFile::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMDeletePublishedFile::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMDeletePublishedFile::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMDeletePublishedFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMDeletePublishedFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMDeletePublishedFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMDeletePublishedFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMDeletePublishedFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMDeletePublishedFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMDeletePublishedFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserPublishedFiles

// optional uint32 app_id = 1;
inline bool CMsgClientUCMEnumerateUserPublishedFiles::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserPublishedFiles::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 start_index = 2;
inline bool CMsgClientUCMEnumerateUserPublishedFiles::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserPublishedFiles::start_index() const {
  return start_index_;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional uint32 sort_order = 3;
inline bool CMsgClientUCMEnumerateUserPublishedFiles::has_sort_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::set_has_sort_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::clear_has_sort_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::clear_sort_order() {
  sort_order_ = 0u;
  clear_has_sort_order();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserPublishedFiles::sort_order() const {
  return sort_order_;
}
inline void CMsgClientUCMEnumerateUserPublishedFiles::set_sort_order(::google::protobuf::uint32 value) {
  set_has_sort_order();
  sort_order_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserPublishedFilesResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMEnumerateUserPublishedFilesResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMEnumerateUserPublishedFilesResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId published_files = 2;
inline int CMsgClientUCMEnumerateUserPublishedFilesResponse::published_files_size() const {
  return published_files_.size();
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::clear_published_files() {
  published_files_.Clear();
}
inline const ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId& CMsgClientUCMEnumerateUserPublishedFilesResponse::published_files(int index) const {
  return published_files_.Get(index);
}
inline ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* CMsgClientUCMEnumerateUserPublishedFilesResponse::mutable_published_files(int index) {
  return published_files_.Mutable(index);
}
inline ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId* CMsgClientUCMEnumerateUserPublishedFilesResponse::add_published_files() {
  return published_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId >&
CMsgClientUCMEnumerateUserPublishedFilesResponse::published_files() const {
  return published_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId >*
CMsgClientUCMEnumerateUserPublishedFilesResponse::mutable_published_files() {
  return &published_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgClientUCMEnumerateUserPublishedFilesResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserPublishedFilesResponse::total_results() const {
  return total_results_;
}
inline void CMsgClientUCMEnumerateUserPublishedFilesResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMSubscribePublishedFile

// optional uint32 app_id = 1;
inline bool CMsgClientUCMSubscribePublishedFile::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMSubscribePublishedFile::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMSubscribePublishedFile::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMSubscribePublishedFile::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMSubscribePublishedFile::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMSubscribePublishedFile::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 published_file_id = 2;
inline bool CMsgClientUCMSubscribePublishedFile::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMSubscribePublishedFile::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMSubscribePublishedFile::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMSubscribePublishedFile::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMSubscribePublishedFile::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMSubscribePublishedFile::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMSubscribePublishedFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMSubscribePublishedFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMSubscribePublishedFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMSubscribePublishedFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMSubscribePublishedFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMSubscribePublishedFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMSubscribePublishedFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserSubscribedFiles

// optional uint32 app_id = 1;
inline bool CMsgClientUCMEnumerateUserSubscribedFiles::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFiles::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 start_index = 2;
inline bool CMsgClientUCMEnumerateUserSubscribedFiles::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFiles::start_index() const {
  return start_index_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional uint32 list_type = 3 [default = 1];
inline bool CMsgClientUCMEnumerateUserSubscribedFiles::has_list_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_has_list_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_has_list_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_list_type() {
  list_type_ = 1u;
  clear_has_list_type();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFiles::list_type() const {
  return list_type_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_list_type(::google::protobuf::uint32 value) {
  set_has_list_type();
  list_type_ = value;
}

// optional uint32 matching_file_type = 4 [default = 0];
inline bool CMsgClientUCMEnumerateUserSubscribedFiles::has_matching_file_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_has_matching_file_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_has_matching_file_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::clear_matching_file_type() {
  matching_file_type_ = 0u;
  clear_has_matching_file_type();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFiles::matching_file_type() const {
  return matching_file_type_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFiles::set_matching_file_type(::google::protobuf::uint32 value) {
  set_has_matching_file_type();
  matching_file_type_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional fixed32 rtime32_subscribed = 2 [default = 0];
inline bool CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::has_rtime32_subscribed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::set_has_rtime32_subscribed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::clear_has_rtime32_subscribed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::clear_rtime32_subscribed() {
  rtime32_subscribed_ = 0u;
  clear_has_rtime32_subscribed();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::rtime32_subscribed() const {
  return rtime32_subscribed_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::set_rtime32_subscribed(::google::protobuf::uint32 value) {
  set_has_rtime32_subscribed();
  rtime32_subscribed_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserSubscribedFilesResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMEnumerateUserSubscribedFilesResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMEnumerateUserSubscribedFilesResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId subscribed_files = 2;
inline int CMsgClientUCMEnumerateUserSubscribedFilesResponse::subscribed_files_size() const {
  return subscribed_files_.size();
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::clear_subscribed_files() {
  subscribed_files_.Clear();
}
inline const ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId& CMsgClientUCMEnumerateUserSubscribedFilesResponse::subscribed_files(int index) const {
  return subscribed_files_.Get(index);
}
inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* CMsgClientUCMEnumerateUserSubscribedFilesResponse::mutable_subscribed_files(int index) {
  return subscribed_files_.Mutable(index);
}
inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId* CMsgClientUCMEnumerateUserSubscribedFilesResponse::add_subscribed_files() {
  return subscribed_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId >&
CMsgClientUCMEnumerateUserSubscribedFilesResponse::subscribed_files() const {
  return subscribed_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId >*
CMsgClientUCMEnumerateUserSubscribedFilesResponse::mutable_subscribed_files() {
  return &subscribed_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesResponse::total_results() const {
  return total_results_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates

// optional uint32 app_id = 1;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 start_index = 2;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::start_index() const {
  return start_index_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional fixed32 start_time = 3;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::start_time() const {
  return start_time_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional fixed32 rtime32_subscribed = 2 [default = 0];
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::has_rtime32_subscribed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_has_rtime32_subscribed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_has_rtime32_subscribed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_rtime32_subscribed() {
  rtime32_subscribed_ = 0u;
  clear_has_rtime32_subscribed();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::rtime32_subscribed() const {
  return rtime32_subscribed_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_rtime32_subscribed(::google::protobuf::uint32 value) {
  set_has_rtime32_subscribed();
  rtime32_subscribed_ = value;
}

// optional uint32 appid = 3;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::appid() const {
  return appid_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional fixed64 file_hcontent = 4;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::has_file_hcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_has_file_hcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_has_file_hcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_file_hcontent() {
  file_hcontent_ = GOOGLE_ULONGLONG(0);
  clear_has_file_hcontent();
}
inline ::google::protobuf::uint64 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::file_hcontent() const {
  return file_hcontent_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_file_hcontent(::google::protobuf::uint64 value) {
  set_has_file_hcontent();
  file_hcontent_ = value;
}

// optional uint32 file_size = 5;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::file_size() const {
  return file_size_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional fixed32 rtime32_last_updated = 6;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::has_rtime32_last_updated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_has_rtime32_last_updated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_has_rtime32_last_updated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::clear_rtime32_last_updated() {
  rtime32_last_updated_ = 0u;
  clear_has_rtime32_last_updated();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::rtime32_last_updated() const {
  return rtime32_last_updated_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::set_rtime32_last_updated(::google::protobuf::uint32 value) {
  set_has_rtime32_last_updated();
  rtime32_last_updated_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId subscribed_files = 2;
inline int CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::subscribed_files_size() const {
  return subscribed_files_.size();
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::clear_subscribed_files() {
  subscribed_files_.Clear();
}
inline const ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId& CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::subscribed_files(int index) const {
  return subscribed_files_.Get(index);
}
inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::mutable_subscribed_files(int index) {
  return subscribed_files_.Mutable(index);
}
inline ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId* CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::add_subscribed_files() {
  return subscribed_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId >&
CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::subscribed_files() const {
  return subscribed_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId >*
CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::mutable_subscribed_files() {
  return &subscribed_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::total_results() const {
  return total_results_;
}
inline void CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMUnsubscribePublishedFile

// optional uint32 app_id = 1;
inline bool CMsgClientUCMUnsubscribePublishedFile::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMUnsubscribePublishedFile::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMUnsubscribePublishedFile::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMUnsubscribePublishedFile::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMUnsubscribePublishedFile::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMUnsubscribePublishedFile::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 published_file_id = 2;
inline bool CMsgClientUCMUnsubscribePublishedFile::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMUnsubscribePublishedFile::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMUnsubscribePublishedFile::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMUnsubscribePublishedFile::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMUnsubscribePublishedFile::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMUnsubscribePublishedFile::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMUnsubscribePublishedFileResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMUnsubscribePublishedFileResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMUnsubscribePublishedFileResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMUnsubscribePublishedFileResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMUnsubscribePublishedFileResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMUnsubscribePublishedFileResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMUnsubscribePublishedFileResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMPublishedFileSubscribed

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMPublishedFileSubscribed::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMPublishedFileSubscribed::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientUCMPublishedFileSubscribed::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishedFileSubscribed::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 file_hcontent = 3;
inline bool CMsgClientUCMPublishedFileSubscribed::has_file_hcontent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_has_file_hcontent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_has_file_hcontent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_file_hcontent() {
  file_hcontent_ = GOOGLE_ULONGLONG(0);
  clear_has_file_hcontent();
}
inline ::google::protobuf::uint64 CMsgClientUCMPublishedFileSubscribed::file_hcontent() const {
  return file_hcontent_;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_file_hcontent(::google::protobuf::uint64 value) {
  set_has_file_hcontent();
  file_hcontent_ = value;
}

// optional uint32 file_size = 4;
inline bool CMsgClientUCMPublishedFileSubscribed::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUCMPublishedFileSubscribed::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishedFileSubscribed::file_size() const {
  return file_size_;
}
inline void CMsgClientUCMPublishedFileSubscribed::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMPublishedFileUnsubscribed

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMPublishedFileUnsubscribed::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMPublishedFileUnsubscribed::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientUCMPublishedFileUnsubscribed::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishedFileUnsubscribed::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMPublishedFileUnsubscribed::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMPublishedFileDeleted

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMPublishedFileDeleted::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMPublishedFileDeleted::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMPublishedFileDeleted::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMPublishedFileDeleted::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMPublishedFileDeleted::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMPublishedFileDeleted::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientUCMPublishedFileDeleted::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMPublishedFileDeleted::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMPublishedFileDeleted::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMPublishedFileDeleted::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMPublishedFileDeleted::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMPublishedFileDeleted::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMGetPublishedFilesForUser

// optional uint32 app_id = 1;
inline bool CMsgClientUCMGetPublishedFilesForUser::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFilesForUser::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional fixed64 creator_steam_id = 2;
inline bool CMsgClientUCMGetPublishedFilesForUser::has_creator_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_has_creator_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_has_creator_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_creator_steam_id() {
  creator_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_creator_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFilesForUser::creator_steam_id() const {
  return creator_steam_id_;
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_creator_steam_id(::google::protobuf::uint64 value) {
  set_has_creator_steam_id();
  creator_steam_id_ = value;
}

// repeated string required_tags = 3;
inline int CMsgClientUCMGetPublishedFilesForUser::required_tags_size() const {
  return required_tags_.size();
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_required_tags() {
  required_tags_.Clear();
}
inline const ::std::string& CMsgClientUCMGetPublishedFilesForUser::required_tags(int index) const {
  return required_tags_.Get(index);
}
inline ::std::string* CMsgClientUCMGetPublishedFilesForUser::mutable_required_tags(int index) {
  return required_tags_.Mutable(index);
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_required_tags(int index, const ::std::string& value) {
  required_tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_required_tags(int index, const char* value) {
  required_tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_required_tags(int index, const char* value, size_t size) {
  required_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFilesForUser::add_required_tags() {
  return required_tags_.Add();
}
inline void CMsgClientUCMGetPublishedFilesForUser::add_required_tags(const ::std::string& value) {
  required_tags_.Add()->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::add_required_tags(const char* value) {
  required_tags_.Add()->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::add_required_tags(const char* value, size_t size) {
  required_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientUCMGetPublishedFilesForUser::required_tags() const {
  return required_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientUCMGetPublishedFilesForUser::mutable_required_tags() {
  return &required_tags_;
}

// repeated string excluded_tags = 4;
inline int CMsgClientUCMGetPublishedFilesForUser::excluded_tags_size() const {
  return excluded_tags_.size();
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_excluded_tags() {
  excluded_tags_.Clear();
}
inline const ::std::string& CMsgClientUCMGetPublishedFilesForUser::excluded_tags(int index) const {
  return excluded_tags_.Get(index);
}
inline ::std::string* CMsgClientUCMGetPublishedFilesForUser::mutable_excluded_tags(int index) {
  return excluded_tags_.Mutable(index);
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_excluded_tags(int index, const ::std::string& value) {
  excluded_tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_excluded_tags(int index, const char* value) {
  excluded_tags_.Mutable(index)->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_excluded_tags(int index, const char* value, size_t size) {
  excluded_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUCMGetPublishedFilesForUser::add_excluded_tags() {
  return excluded_tags_.Add();
}
inline void CMsgClientUCMGetPublishedFilesForUser::add_excluded_tags(const ::std::string& value) {
  excluded_tags_.Add()->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::add_excluded_tags(const char* value) {
  excluded_tags_.Add()->assign(value);
}
inline void CMsgClientUCMGetPublishedFilesForUser::add_excluded_tags(const char* value, size_t size) {
  excluded_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgClientUCMGetPublishedFilesForUser::excluded_tags() const {
  return excluded_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgClientUCMGetPublishedFilesForUser::mutable_excluded_tags() {
  return &excluded_tags_;
}

// optional uint32 start_index = 5;
inline bool CMsgClientUCMGetPublishedFilesForUser::has_start_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_has_start_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUCMGetPublishedFilesForUser::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFilesForUser::start_index() const {
  return start_index_;
}
inline void CMsgClientUCMGetPublishedFilesForUser::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMGetPublishedFilesForUserResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMGetPublishedFilesForUserResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMGetPublishedFilesForUserResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId published_files = 2;
inline int CMsgClientUCMGetPublishedFilesForUserResponse::published_files_size() const {
  return published_files_.size();
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::clear_published_files() {
  published_files_.Clear();
}
inline const ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId& CMsgClientUCMGetPublishedFilesForUserResponse::published_files(int index) const {
  return published_files_.Get(index);
}
inline ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* CMsgClientUCMGetPublishedFilesForUserResponse::mutable_published_files(int index) {
  return published_files_.Mutable(index);
}
inline ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId* CMsgClientUCMGetPublishedFilesForUserResponse::add_published_files() {
  return published_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId >&
CMsgClientUCMGetPublishedFilesForUserResponse::published_files() const {
  return published_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId >*
CMsgClientUCMGetPublishedFilesForUserResponse::mutable_published_files() {
  return &published_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgClientUCMGetPublishedFilesForUserResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgClientUCMGetPublishedFilesForUserResponse::total_results() const {
  return total_results_;
}
inline void CMsgClientUCMGetPublishedFilesForUserResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMSetUserPublishedFileAction

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMSetUserPublishedFileAction::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMSetUserPublishedFileAction::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMSetUserPublishedFileAction::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMSetUserPublishedFileAction::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMSetUserPublishedFileAction::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMSetUserPublishedFileAction::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientUCMSetUserPublishedFileAction::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMSetUserPublishedFileAction::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMSetUserPublishedFileAction::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMSetUserPublishedFileAction::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMSetUserPublishedFileAction::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMSetUserPublishedFileAction::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 action = 3;
inline bool CMsgClientUCMSetUserPublishedFileAction::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMSetUserPublishedFileAction::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMSetUserPublishedFileAction::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMSetUserPublishedFileAction::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 CMsgClientUCMSetUserPublishedFileAction::action() const {
  return action_;
}
inline void CMsgClientUCMSetUserPublishedFileAction::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMSetUserPublishedFileActionResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMSetUserPublishedFileActionResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMSetUserPublishedFileActionResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMSetUserPublishedFileActionResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMSetUserPublishedFileActionResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMSetUserPublishedFileActionResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMSetUserPublishedFileActionResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumeratePublishedFilesByUserAction

// optional uint32 app_id = 1;
inline bool CMsgClientUCMEnumeratePublishedFilesByUserAction::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumeratePublishedFilesByUserAction::app_id() const {
  return app_id_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 start_index = 2;
inline bool CMsgClientUCMEnumeratePublishedFilesByUserAction::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumeratePublishedFilesByUserAction::start_index() const {
  return start_index_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional int32 action = 3;
inline bool CMsgClientUCMEnumeratePublishedFilesByUserAction::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 CMsgClientUCMEnumeratePublishedFilesByUserAction::action() const {
  return action_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserAction::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional fixed32 rtime_time_stamp = 2 [default = 0];
inline bool CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::has_rtime_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::set_has_rtime_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::clear_has_rtime_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::clear_rtime_time_stamp() {
  rtime_time_stamp_ = 0u;
  clear_has_rtime_time_stamp();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::rtime_time_stamp() const {
  return rtime_time_stamp_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::set_rtime_time_stamp(::google::protobuf::uint32 value) {
  set_has_rtime_time_stamp();
  rtime_time_stamp_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUCMEnumeratePublishedFilesByUserActionResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId published_files = 2;
inline int CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::published_files_size() const {
  return published_files_.size();
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::clear_published_files() {
  published_files_.Clear();
}
inline const ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId& CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::published_files(int index) const {
  return published_files_.Get(index);
}
inline ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::mutable_published_files(int index) {
  return published_files_.Mutable(index);
}
inline ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId* CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::add_published_files() {
  return published_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId >&
CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::published_files() const {
  return published_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId >*
CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::mutable_published_files() {
  return &published_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::total_results() const {
  return total_results_;
}
inline void CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgClientScreenshotsChanged

// -------------------------------------------------------------------

// CMsgClientUpdateUserGameInfo

// optional fixed64 steamid_idgs = 1;
inline bool CMsgClientUpdateUserGameInfo::has_steamid_idgs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUpdateUserGameInfo::set_has_steamid_idgs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUpdateUserGameInfo::clear_has_steamid_idgs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUpdateUserGameInfo::clear_steamid_idgs() {
  steamid_idgs_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_idgs();
}
inline ::google::protobuf::uint64 CMsgClientUpdateUserGameInfo::steamid_idgs() const {
  return steamid_idgs_;
}
inline void CMsgClientUpdateUserGameInfo::set_steamid_idgs(::google::protobuf::uint64 value) {
  set_has_steamid_idgs();
  steamid_idgs_ = value;
}

// optional fixed64 gameid = 2;
inline bool CMsgClientUpdateUserGameInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUpdateUserGameInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUpdateUserGameInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUpdateUserGameInfo::clear_gameid() {
  gameid_ = GOOGLE_ULONGLONG(0);
  clear_has_gameid();
}
inline ::google::protobuf::uint64 CMsgClientUpdateUserGameInfo::gameid() const {
  return gameid_;
}
inline void CMsgClientUpdateUserGameInfo::set_gameid(::google::protobuf::uint64 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 game_ip = 3;
inline bool CMsgClientUpdateUserGameInfo::has_game_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUpdateUserGameInfo::set_has_game_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUpdateUserGameInfo::clear_has_game_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUpdateUserGameInfo::clear_game_ip() {
  game_ip_ = 0u;
  clear_has_game_ip();
}
inline ::google::protobuf::uint32 CMsgClientUpdateUserGameInfo::game_ip() const {
  return game_ip_;
}
inline void CMsgClientUpdateUserGameInfo::set_game_ip(::google::protobuf::uint32 value) {
  set_has_game_ip();
  game_ip_ = value;
}

// optional uint32 game_port = 4;
inline bool CMsgClientUpdateUserGameInfo::has_game_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUpdateUserGameInfo::set_has_game_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUpdateUserGameInfo::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUpdateUserGameInfo::clear_game_port() {
  game_port_ = 0u;
  clear_has_game_port();
}
inline ::google::protobuf::uint32 CMsgClientUpdateUserGameInfo::game_port() const {
  return game_port_;
}
inline void CMsgClientUpdateUserGameInfo::set_game_port(::google::protobuf::uint32 value) {
  set_has_game_port();
  game_port_ = value;
}

// optional bytes token = 5;
inline bool CMsgClientUpdateUserGameInfo::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUpdateUserGameInfo::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUpdateUserGameInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUpdateUserGameInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgClientUpdateUserGameInfo::token() const {
  return *token_;
}
inline void CMsgClientUpdateUserGameInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientUpdateUserGameInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientUpdateUserGameInfo::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateUserGameInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgClientUpdateUserGameInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateUserGameInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRichPresenceUpload

// optional bytes rich_presence_kv = 1;
inline bool CMsgClientRichPresenceUpload::has_rich_presence_kv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRichPresenceUpload::set_has_rich_presence_kv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRichPresenceUpload::clear_has_rich_presence_kv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRichPresenceUpload::clear_rich_presence_kv() {
  if (rich_presence_kv_ != &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_->clear();
  }
  clear_has_rich_presence_kv();
}
inline const ::std::string& CMsgClientRichPresenceUpload::rich_presence_kv() const {
  return *rich_presence_kv_;
}
inline void CMsgClientRichPresenceUpload::set_rich_presence_kv(const ::std::string& value) {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  rich_presence_kv_->assign(value);
}
inline void CMsgClientRichPresenceUpload::set_rich_presence_kv(const char* value) {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  rich_presence_kv_->assign(value);
}
inline void CMsgClientRichPresenceUpload::set_rich_presence_kv(const void* value, size_t size) {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  rich_presence_kv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRichPresenceUpload::mutable_rich_presence_kv() {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  return rich_presence_kv_;
}
inline ::std::string* CMsgClientRichPresenceUpload::release_rich_presence_kv() {
  clear_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rich_presence_kv_;
    rich_presence_kv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRichPresenceUpload::set_allocated_rich_presence_kv(::std::string* rich_presence_kv) {
  if (rich_presence_kv_ != &::google::protobuf::internal::kEmptyString) {
    delete rich_presence_kv_;
  }
  if (rich_presence_kv) {
    set_has_rich_presence_kv();
    rich_presence_kv_ = rich_presence_kv;
  } else {
    clear_has_rich_presence_kv();
    rich_presence_kv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated fixed64 steamid_broadcast = 2;
inline int CMsgClientRichPresenceUpload::steamid_broadcast_size() const {
  return steamid_broadcast_.size();
}
inline void CMsgClientRichPresenceUpload::clear_steamid_broadcast() {
  steamid_broadcast_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientRichPresenceUpload::steamid_broadcast(int index) const {
  return steamid_broadcast_.Get(index);
}
inline void CMsgClientRichPresenceUpload::set_steamid_broadcast(int index, ::google::protobuf::uint64 value) {
  steamid_broadcast_.Set(index, value);
}
inline void CMsgClientRichPresenceUpload::add_steamid_broadcast(::google::protobuf::uint64 value) {
  steamid_broadcast_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientRichPresenceUpload::steamid_broadcast() const {
  return steamid_broadcast_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientRichPresenceUpload::mutable_steamid_broadcast() {
  return &steamid_broadcast_;
}

// -------------------------------------------------------------------

// CMsgClientRichPresenceRequest

// repeated fixed64 steamid_request = 1;
inline int CMsgClientRichPresenceRequest::steamid_request_size() const {
  return steamid_request_.size();
}
inline void CMsgClientRichPresenceRequest::clear_steamid_request() {
  steamid_request_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientRichPresenceRequest::steamid_request(int index) const {
  return steamid_request_.Get(index);
}
inline void CMsgClientRichPresenceRequest::set_steamid_request(int index, ::google::protobuf::uint64 value) {
  steamid_request_.Set(index, value);
}
inline void CMsgClientRichPresenceRequest::add_steamid_request(::google::protobuf::uint64 value) {
  steamid_request_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientRichPresenceRequest::steamid_request() const {
  return steamid_request_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientRichPresenceRequest::mutable_steamid_request() {
  return &steamid_request_;
}

// -------------------------------------------------------------------

// CMsgClientRichPresenceInfo_RichPresence

// optional fixed64 steamid_user = 1;
inline bool CMsgClientRichPresenceInfo_RichPresence::has_steamid_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_has_steamid_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRichPresenceInfo_RichPresence::clear_has_steamid_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRichPresenceInfo_RichPresence::clear_steamid_user() {
  steamid_user_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid_user();
}
inline ::google::protobuf::uint64 CMsgClientRichPresenceInfo_RichPresence::steamid_user() const {
  return steamid_user_;
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_steamid_user(::google::protobuf::uint64 value) {
  set_has_steamid_user();
  steamid_user_ = value;
}

// optional bytes rich_presence_kv = 2;
inline bool CMsgClientRichPresenceInfo_RichPresence::has_rich_presence_kv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_has_rich_presence_kv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRichPresenceInfo_RichPresence::clear_has_rich_presence_kv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRichPresenceInfo_RichPresence::clear_rich_presence_kv() {
  if (rich_presence_kv_ != &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_->clear();
  }
  clear_has_rich_presence_kv();
}
inline const ::std::string& CMsgClientRichPresenceInfo_RichPresence::rich_presence_kv() const {
  return *rich_presence_kv_;
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_rich_presence_kv(const ::std::string& value) {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  rich_presence_kv_->assign(value);
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_rich_presence_kv(const char* value) {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  rich_presence_kv_->assign(value);
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_rich_presence_kv(const void* value, size_t size) {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  rich_presence_kv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRichPresenceInfo_RichPresence::mutable_rich_presence_kv() {
  set_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    rich_presence_kv_ = new ::std::string;
  }
  return rich_presence_kv_;
}
inline ::std::string* CMsgClientRichPresenceInfo_RichPresence::release_rich_presence_kv() {
  clear_has_rich_presence_kv();
  if (rich_presence_kv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rich_presence_kv_;
    rich_presence_kv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRichPresenceInfo_RichPresence::set_allocated_rich_presence_kv(::std::string* rich_presence_kv) {
  if (rich_presence_kv_ != &::google::protobuf::internal::kEmptyString) {
    delete rich_presence_kv_;
  }
  if (rich_presence_kv) {
    set_has_rich_presence_kv();
    rich_presence_kv_ = rich_presence_kv;
  } else {
    clear_has_rich_presence_kv();
    rich_presence_kv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRichPresenceInfo

// repeated .Sc.CMsgClientRichPresenceInfo.RichPresence rich_presence = 1;
inline int CMsgClientRichPresenceInfo::rich_presence_size() const {
  return rich_presence_.size();
}
inline void CMsgClientRichPresenceInfo::clear_rich_presence() {
  rich_presence_.Clear();
}
inline const ::Sc::CMsgClientRichPresenceInfo_RichPresence& CMsgClientRichPresenceInfo::rich_presence(int index) const {
  return rich_presence_.Get(index);
}
inline ::Sc::CMsgClientRichPresenceInfo_RichPresence* CMsgClientRichPresenceInfo::mutable_rich_presence(int index) {
  return rich_presence_.Mutable(index);
}
inline ::Sc::CMsgClientRichPresenceInfo_RichPresence* CMsgClientRichPresenceInfo::add_rich_presence() {
  return rich_presence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRichPresenceInfo_RichPresence >&
CMsgClientRichPresenceInfo::rich_presence() const {
  return rich_presence_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientRichPresenceInfo_RichPresence >*
CMsgClientRichPresenceInfo::mutable_rich_presence() {
  return &rich_presence_;
}

// -------------------------------------------------------------------

// CMsgClientCheckFileSignature

// optional uint32 app_id = 1;
inline bool CMsgClientCheckFileSignature::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientCheckFileSignature::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientCheckFileSignature::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientCheckFileSignature::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignature::app_id() const {
  return app_id_;
}
inline void CMsgClientCheckFileSignature::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientCheckFileSignatureResponse

// optional uint32 app_id = 1;
inline bool CMsgClientCheckFileSignatureResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientCheckFileSignatureResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 pid = 2;
inline bool CMsgClientCheckFileSignatureResponse::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::pid() const {
  return pid_;
}
inline void CMsgClientCheckFileSignatureResponse::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
}

// optional uint32 eresult = 3;
inline bool CMsgClientCheckFileSignatureResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientCheckFileSignatureResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string filename = 4;
inline bool CMsgClientCheckFileSignatureResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientCheckFileSignatureResponse::filename() const {
  return *filename_;
}
inline void CMsgClientCheckFileSignatureResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientCheckFileSignatureResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientCheckFileSignatureResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientCheckFileSignatureResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientCheckFileSignatureResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientCheckFileSignatureResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 esignatureresult = 5;
inline bool CMsgClientCheckFileSignatureResponse::has_esignatureresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_esignatureresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_esignatureresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_esignatureresult() {
  esignatureresult_ = 0u;
  clear_has_esignatureresult();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::esignatureresult() const {
  return esignatureresult_;
}
inline void CMsgClientCheckFileSignatureResponse::set_esignatureresult(::google::protobuf::uint32 value) {
  set_has_esignatureresult();
  esignatureresult_ = value;
}

// optional bytes sha_file = 6;
inline bool CMsgClientCheckFileSignatureResponse::has_sha_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_sha_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientCheckFileSignatureResponse::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientCheckFileSignatureResponse::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientCheckFileSignatureResponse::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientCheckFileSignatureResponse::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientCheckFileSignatureResponse::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientCheckFileSignatureResponse::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientCheckFileSignatureResponse::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signatureheader = 7;
inline bool CMsgClientCheckFileSignatureResponse::has_signatureheader() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_signatureheader() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_signatureheader() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_signatureheader() {
  if (signatureheader_ != &::google::protobuf::internal::kEmptyString) {
    signatureheader_->clear();
  }
  clear_has_signatureheader();
}
inline const ::std::string& CMsgClientCheckFileSignatureResponse::signatureheader() const {
  return *signatureheader_;
}
inline void CMsgClientCheckFileSignatureResponse::set_signatureheader(const ::std::string& value) {
  set_has_signatureheader();
  if (signatureheader_ == &::google::protobuf::internal::kEmptyString) {
    signatureheader_ = new ::std::string;
  }
  signatureheader_->assign(value);
}
inline void CMsgClientCheckFileSignatureResponse::set_signatureheader(const char* value) {
  set_has_signatureheader();
  if (signatureheader_ == &::google::protobuf::internal::kEmptyString) {
    signatureheader_ = new ::std::string;
  }
  signatureheader_->assign(value);
}
inline void CMsgClientCheckFileSignatureResponse::set_signatureheader(const void* value, size_t size) {
  set_has_signatureheader();
  if (signatureheader_ == &::google::protobuf::internal::kEmptyString) {
    signatureheader_ = new ::std::string;
  }
  signatureheader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientCheckFileSignatureResponse::mutable_signatureheader() {
  set_has_signatureheader();
  if (signatureheader_ == &::google::protobuf::internal::kEmptyString) {
    signatureheader_ = new ::std::string;
  }
  return signatureheader_;
}
inline ::std::string* CMsgClientCheckFileSignatureResponse::release_signatureheader() {
  clear_has_signatureheader();
  if (signatureheader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signatureheader_;
    signatureheader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientCheckFileSignatureResponse::set_allocated_signatureheader(::std::string* signatureheader) {
  if (signatureheader_ != &::google::protobuf::internal::kEmptyString) {
    delete signatureheader_;
  }
  if (signatureheader) {
    set_has_signatureheader();
    signatureheader_ = signatureheader;
  } else {
    clear_has_signatureheader();
    signatureheader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 filesize = 8;
inline bool CMsgClientCheckFileSignatureResponse::has_filesize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_filesize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::filesize() const {
  return filesize_;
}
inline void CMsgClientCheckFileSignatureResponse::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional uint32 getlasterror = 9;
inline bool CMsgClientCheckFileSignatureResponse::has_getlasterror() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_getlasterror() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_getlasterror() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_getlasterror() {
  getlasterror_ = 0u;
  clear_has_getlasterror();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::getlasterror() const {
  return getlasterror_;
}
inline void CMsgClientCheckFileSignatureResponse::set_getlasterror(::google::protobuf::uint32 value) {
  set_has_getlasterror();
  getlasterror_ = value;
}

// optional uint32 evalvesignaturecheckdetail = 10;
inline bool CMsgClientCheckFileSignatureResponse::has_evalvesignaturecheckdetail() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientCheckFileSignatureResponse::set_has_evalvesignaturecheckdetail() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_has_evalvesignaturecheckdetail() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientCheckFileSignatureResponse::clear_evalvesignaturecheckdetail() {
  evalvesignaturecheckdetail_ = 0u;
  clear_has_evalvesignaturecheckdetail();
}
inline ::google::protobuf::uint32 CMsgClientCheckFileSignatureResponse::evalvesignaturecheckdetail() const {
  return evalvesignaturecheckdetail_;
}
inline void CMsgClientCheckFileSignatureResponse::set_evalvesignaturecheckdetail(::google::protobuf::uint32 value) {
  set_has_evalvesignaturecheckdetail();
  evalvesignaturecheckdetail_ = value;
}

// -------------------------------------------------------------------

// CMsgClientReadMachineAuth

// optional string filename = 1;
inline bool CMsgClientReadMachineAuth::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientReadMachineAuth::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientReadMachineAuth::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientReadMachineAuth::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientReadMachineAuth::filename() const {
  return *filename_;
}
inline void CMsgClientReadMachineAuth::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientReadMachineAuth::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientReadMachineAuth::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientReadMachineAuth::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientReadMachineAuth::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientReadMachineAuth::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 offset = 2;
inline bool CMsgClientReadMachineAuth::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientReadMachineAuth::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientReadMachineAuth::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientReadMachineAuth::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuth::offset() const {
  return offset_;
}
inline void CMsgClientReadMachineAuth::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// optional uint32 cubtoread = 3;
inline bool CMsgClientReadMachineAuth::has_cubtoread() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientReadMachineAuth::set_has_cubtoread() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientReadMachineAuth::clear_has_cubtoread() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientReadMachineAuth::clear_cubtoread() {
  cubtoread_ = 0u;
  clear_has_cubtoread();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuth::cubtoread() const {
  return cubtoread_;
}
inline void CMsgClientReadMachineAuth::set_cubtoread(::google::protobuf::uint32 value) {
  set_has_cubtoread();
  cubtoread_ = value;
}

// -------------------------------------------------------------------

// CMsgClientReadMachineAuthResponse

// optional string filename = 1;
inline bool CMsgClientReadMachineAuthResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientReadMachineAuthResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientReadMachineAuthResponse::filename() const {
  return *filename_;
}
inline void CMsgClientReadMachineAuthResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientReadMachineAuthResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientReadMachineAuthResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientReadMachineAuthResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 eresult = 2;
inline bool CMsgClientReadMachineAuthResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientReadMachineAuthResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuthResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientReadMachineAuthResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 filesize = 3;
inline bool CMsgClientReadMachineAuthResponse::has_filesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_filesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientReadMachineAuthResponse::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuthResponse::filesize() const {
  return filesize_;
}
inline void CMsgClientReadMachineAuthResponse::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional bytes sha_file = 4;
inline bool CMsgClientReadMachineAuthResponse::has_sha_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_sha_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientReadMachineAuthResponse::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientReadMachineAuthResponse::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientReadMachineAuthResponse::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientReadMachineAuthResponse::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientReadMachineAuthResponse::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientReadMachineAuthResponse::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 getlasterror = 5;
inline bool CMsgClientReadMachineAuthResponse::has_getlasterror() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_getlasterror() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_getlasterror() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientReadMachineAuthResponse::clear_getlasterror() {
  getlasterror_ = 0u;
  clear_has_getlasterror();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuthResponse::getlasterror() const {
  return getlasterror_;
}
inline void CMsgClientReadMachineAuthResponse::set_getlasterror(::google::protobuf::uint32 value) {
  set_has_getlasterror();
  getlasterror_ = value;
}

// optional uint32 offset = 6;
inline bool CMsgClientReadMachineAuthResponse::has_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientReadMachineAuthResponse::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuthResponse::offset() const {
  return offset_;
}
inline void CMsgClientReadMachineAuthResponse::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// optional uint32 cubread = 7;
inline bool CMsgClientReadMachineAuthResponse::has_cubread() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_cubread() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_cubread() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientReadMachineAuthResponse::clear_cubread() {
  cubread_ = 0u;
  clear_has_cubread();
}
inline ::google::protobuf::uint32 CMsgClientReadMachineAuthResponse::cubread() const {
  return cubread_;
}
inline void CMsgClientReadMachineAuthResponse::set_cubread(::google::protobuf::uint32 value) {
  set_has_cubread();
  cubread_ = value;
}

// optional bytes bytes_read = 8;
inline bool CMsgClientReadMachineAuthResponse::has_bytes_read() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_bytes_read() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_bytes_read() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientReadMachineAuthResponse::clear_bytes_read() {
  if (bytes_read_ != &::google::protobuf::internal::kEmptyString) {
    bytes_read_->clear();
  }
  clear_has_bytes_read();
}
inline const ::std::string& CMsgClientReadMachineAuthResponse::bytes_read() const {
  return *bytes_read_;
}
inline void CMsgClientReadMachineAuthResponse::set_bytes_read(const ::std::string& value) {
  set_has_bytes_read();
  if (bytes_read_ == &::google::protobuf::internal::kEmptyString) {
    bytes_read_ = new ::std::string;
  }
  bytes_read_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_bytes_read(const char* value) {
  set_has_bytes_read();
  if (bytes_read_ == &::google::protobuf::internal::kEmptyString) {
    bytes_read_ = new ::std::string;
  }
  bytes_read_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_bytes_read(const void* value, size_t size) {
  set_has_bytes_read();
  if (bytes_read_ == &::google::protobuf::internal::kEmptyString) {
    bytes_read_ = new ::std::string;
  }
  bytes_read_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientReadMachineAuthResponse::mutable_bytes_read() {
  set_has_bytes_read();
  if (bytes_read_ == &::google::protobuf::internal::kEmptyString) {
    bytes_read_ = new ::std::string;
  }
  return bytes_read_;
}
inline ::std::string* CMsgClientReadMachineAuthResponse::release_bytes_read() {
  clear_has_bytes_read();
  if (bytes_read_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bytes_read_;
    bytes_read_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientReadMachineAuthResponse::set_allocated_bytes_read(::std::string* bytes_read) {
  if (bytes_read_ != &::google::protobuf::internal::kEmptyString) {
    delete bytes_read_;
  }
  if (bytes_read) {
    set_has_bytes_read();
    bytes_read_ = bytes_read;
  } else {
    clear_has_bytes_read();
    bytes_read_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename_sentry = 9;
inline bool CMsgClientReadMachineAuthResponse::has_filename_sentry() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientReadMachineAuthResponse::set_has_filename_sentry() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientReadMachineAuthResponse::clear_has_filename_sentry() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientReadMachineAuthResponse::clear_filename_sentry() {
  if (filename_sentry_ != &::google::protobuf::internal::kEmptyString) {
    filename_sentry_->clear();
  }
  clear_has_filename_sentry();
}
inline const ::std::string& CMsgClientReadMachineAuthResponse::filename_sentry() const {
  return *filename_sentry_;
}
inline void CMsgClientReadMachineAuthResponse::set_filename_sentry(const ::std::string& value) {
  set_has_filename_sentry();
  if (filename_sentry_ == &::google::protobuf::internal::kEmptyString) {
    filename_sentry_ = new ::std::string;
  }
  filename_sentry_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_filename_sentry(const char* value) {
  set_has_filename_sentry();
  if (filename_sentry_ == &::google::protobuf::internal::kEmptyString) {
    filename_sentry_ = new ::std::string;
  }
  filename_sentry_->assign(value);
}
inline void CMsgClientReadMachineAuthResponse::set_filename_sentry(const char* value, size_t size) {
  set_has_filename_sentry();
  if (filename_sentry_ == &::google::protobuf::internal::kEmptyString) {
    filename_sentry_ = new ::std::string;
  }
  filename_sentry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientReadMachineAuthResponse::mutable_filename_sentry() {
  set_has_filename_sentry();
  if (filename_sentry_ == &::google::protobuf::internal::kEmptyString) {
    filename_sentry_ = new ::std::string;
  }
  return filename_sentry_;
}
inline ::std::string* CMsgClientReadMachineAuthResponse::release_filename_sentry() {
  clear_has_filename_sentry();
  if (filename_sentry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_sentry_;
    filename_sentry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientReadMachineAuthResponse::set_allocated_filename_sentry(::std::string* filename_sentry) {
  if (filename_sentry_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_sentry_;
  }
  if (filename_sentry) {
    set_has_filename_sentry();
    filename_sentry_ = filename_sentry;
  } else {
    clear_has_filename_sentry();
    filename_sentry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUpdateMachineAuth

// optional string filename = 1;
inline bool CMsgClientUpdateMachineAuth::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUpdateMachineAuth::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientUpdateMachineAuth::filename() const {
  return *filename_;
}
inline void CMsgClientUpdateMachineAuth::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuth::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientUpdateMachineAuth::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuth::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 offset = 2;
inline bool CMsgClientUpdateMachineAuth::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUpdateMachineAuth::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuth::offset() const {
  return offset_;
}
inline void CMsgClientUpdateMachineAuth::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// optional uint32 cubtowrite = 3;
inline bool CMsgClientUpdateMachineAuth::has_cubtowrite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_cubtowrite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_cubtowrite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUpdateMachineAuth::clear_cubtowrite() {
  cubtowrite_ = 0u;
  clear_has_cubtowrite();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuth::cubtowrite() const {
  return cubtowrite_;
}
inline void CMsgClientUpdateMachineAuth::set_cubtowrite(::google::protobuf::uint32 value) {
  set_has_cubtowrite();
  cubtowrite_ = value;
}

// optional bytes bytes = 4;
inline bool CMsgClientUpdateMachineAuth::has_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUpdateMachineAuth::clear_bytes() {
  if (bytes_ != &::google::protobuf::internal::kEmptyString) {
    bytes_->clear();
  }
  clear_has_bytes();
}
inline const ::std::string& CMsgClientUpdateMachineAuth::bytes() const {
  return *bytes_;
}
inline void CMsgClientUpdateMachineAuth::set_bytes(const ::std::string& value) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_bytes(const char* value) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_bytes(const void* value, size_t size) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuth::mutable_bytes() {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  return bytes_;
}
inline ::std::string* CMsgClientUpdateMachineAuth::release_bytes() {
  clear_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bytes_;
    bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuth::set_allocated_bytes(::std::string* bytes) {
  if (bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete bytes_;
  }
  if (bytes) {
    set_has_bytes();
    bytes_ = bytes;
  } else {
    clear_has_bytes();
    bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 otp_type = 5;
inline bool CMsgClientUpdateMachineAuth::has_otp_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_otp_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_otp_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUpdateMachineAuth::clear_otp_type() {
  otp_type_ = 0u;
  clear_has_otp_type();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuth::otp_type() const {
  return otp_type_;
}
inline void CMsgClientUpdateMachineAuth::set_otp_type(::google::protobuf::uint32 value) {
  set_has_otp_type();
  otp_type_ = value;
}

// optional string otp_identifier = 6;
inline bool CMsgClientUpdateMachineAuth::has_otp_identifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_otp_identifier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_otp_identifier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUpdateMachineAuth::clear_otp_identifier() {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    otp_identifier_->clear();
  }
  clear_has_otp_identifier();
}
inline const ::std::string& CMsgClientUpdateMachineAuth::otp_identifier() const {
  return *otp_identifier_;
}
inline void CMsgClientUpdateMachineAuth::set_otp_identifier(const ::std::string& value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_otp_identifier(const char* value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_otp_identifier(const char* value, size_t size) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuth::mutable_otp_identifier() {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  return otp_identifier_;
}
inline ::std::string* CMsgClientUpdateMachineAuth::release_otp_identifier() {
  clear_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_identifier_;
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuth::set_allocated_otp_identifier(::std::string* otp_identifier) {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_identifier_;
  }
  if (otp_identifier) {
    set_has_otp_identifier();
    otp_identifier_ = otp_identifier;
  } else {
    clear_has_otp_identifier();
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes otp_sharedsecret = 7;
inline bool CMsgClientUpdateMachineAuth::has_otp_sharedsecret() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_otp_sharedsecret() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_otp_sharedsecret() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUpdateMachineAuth::clear_otp_sharedsecret() {
  if (otp_sharedsecret_ != &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_->clear();
  }
  clear_has_otp_sharedsecret();
}
inline const ::std::string& CMsgClientUpdateMachineAuth::otp_sharedsecret() const {
  return *otp_sharedsecret_;
}
inline void CMsgClientUpdateMachineAuth::set_otp_sharedsecret(const ::std::string& value) {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  otp_sharedsecret_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_otp_sharedsecret(const char* value) {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  otp_sharedsecret_->assign(value);
}
inline void CMsgClientUpdateMachineAuth::set_otp_sharedsecret(const void* value, size_t size) {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  otp_sharedsecret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuth::mutable_otp_sharedsecret() {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  return otp_sharedsecret_;
}
inline ::std::string* CMsgClientUpdateMachineAuth::release_otp_sharedsecret() {
  clear_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_sharedsecret_;
    otp_sharedsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuth::set_allocated_otp_sharedsecret(::std::string* otp_sharedsecret) {
  if (otp_sharedsecret_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_sharedsecret_;
  }
  if (otp_sharedsecret) {
    set_has_otp_sharedsecret();
    otp_sharedsecret_ = otp_sharedsecret;
  } else {
    clear_has_otp_sharedsecret();
    otp_sharedsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 otp_timedrift = 8;
inline bool CMsgClientUpdateMachineAuth::has_otp_timedrift() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUpdateMachineAuth::set_has_otp_timedrift() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUpdateMachineAuth::clear_has_otp_timedrift() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUpdateMachineAuth::clear_otp_timedrift() {
  otp_timedrift_ = 0u;
  clear_has_otp_timedrift();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuth::otp_timedrift() const {
  return otp_timedrift_;
}
inline void CMsgClientUpdateMachineAuth::set_otp_timedrift(::google::protobuf::uint32 value) {
  set_has_otp_timedrift();
  otp_timedrift_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUpdateMachineAuthResponse

// optional string filename = 1;
inline bool CMsgClientUpdateMachineAuthResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientUpdateMachineAuthResponse::filename() const {
  return *filename_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUpdateMachineAuthResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientUpdateMachineAuthResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuthResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientUpdateMachineAuthResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuthResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 eresult = 2;
inline bool CMsgClientUpdateMachineAuthResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuthResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 filesize = 3;
inline bool CMsgClientUpdateMachineAuthResponse::has_filesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_filesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuthResponse::filesize() const {
  return filesize_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional bytes sha_file = 4;
inline bool CMsgClientUpdateMachineAuthResponse::has_sha_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_sha_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_sha_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_sha_file() {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    sha_file_->clear();
  }
  clear_has_sha_file();
}
inline const ::std::string& CMsgClientUpdateMachineAuthResponse::sha_file() const {
  return *sha_file_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_sha_file(const ::std::string& value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUpdateMachineAuthResponse::set_sha_file(const char* value) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(value);
}
inline void CMsgClientUpdateMachineAuthResponse::set_sha_file(const void* value, size_t size) {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  sha_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuthResponse::mutable_sha_file() {
  set_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    sha_file_ = new ::std::string;
  }
  return sha_file_;
}
inline ::std::string* CMsgClientUpdateMachineAuthResponse::release_sha_file() {
  clear_has_sha_file();
  if (sha_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_file_;
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuthResponse::set_allocated_sha_file(::std::string* sha_file) {
  if (sha_file_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_file_;
  }
  if (sha_file) {
    set_has_sha_file();
    sha_file_ = sha_file;
  } else {
    clear_has_sha_file();
    sha_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 getlasterror = 5;
inline bool CMsgClientUpdateMachineAuthResponse::has_getlasterror() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_getlasterror() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_getlasterror() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_getlasterror() {
  getlasterror_ = 0u;
  clear_has_getlasterror();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuthResponse::getlasterror() const {
  return getlasterror_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_getlasterror(::google::protobuf::uint32 value) {
  set_has_getlasterror();
  getlasterror_ = value;
}

// optional uint32 offset = 6;
inline bool CMsgClientUpdateMachineAuthResponse::has_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuthResponse::offset() const {
  return offset_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// optional uint32 cubwrote = 7;
inline bool CMsgClientUpdateMachineAuthResponse::has_cubwrote() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_cubwrote() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_cubwrote() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_cubwrote() {
  cubwrote_ = 0u;
  clear_has_cubwrote();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuthResponse::cubwrote() const {
  return cubwrote_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_cubwrote(::google::protobuf::uint32 value) {
  set_has_cubwrote();
  cubwrote_ = value;
}

// optional int32 otp_type = 8;
inline bool CMsgClientUpdateMachineAuthResponse::has_otp_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_otp_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_otp_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_otp_type() {
  otp_type_ = 0;
  clear_has_otp_type();
}
inline ::google::protobuf::int32 CMsgClientUpdateMachineAuthResponse::otp_type() const {
  return otp_type_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_otp_type(::google::protobuf::int32 value) {
  set_has_otp_type();
  otp_type_ = value;
}

// optional uint32 otp_value = 9;
inline bool CMsgClientUpdateMachineAuthResponse::has_otp_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_otp_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_otp_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_otp_value() {
  otp_value_ = 0u;
  clear_has_otp_value();
}
inline ::google::protobuf::uint32 CMsgClientUpdateMachineAuthResponse::otp_value() const {
  return otp_value_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_otp_value(::google::protobuf::uint32 value) {
  set_has_otp_value();
  otp_value_ = value;
}

// optional string otp_identifier = 10;
inline bool CMsgClientUpdateMachineAuthResponse::has_otp_identifier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientUpdateMachineAuthResponse::set_has_otp_identifier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_has_otp_identifier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientUpdateMachineAuthResponse::clear_otp_identifier() {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    otp_identifier_->clear();
  }
  clear_has_otp_identifier();
}
inline const ::std::string& CMsgClientUpdateMachineAuthResponse::otp_identifier() const {
  return *otp_identifier_;
}
inline void CMsgClientUpdateMachineAuthResponse::set_otp_identifier(const ::std::string& value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientUpdateMachineAuthResponse::set_otp_identifier(const char* value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientUpdateMachineAuthResponse::set_otp_identifier(const char* value, size_t size) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateMachineAuthResponse::mutable_otp_identifier() {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  return otp_identifier_;
}
inline ::std::string* CMsgClientUpdateMachineAuthResponse::release_otp_identifier() {
  clear_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_identifier_;
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateMachineAuthResponse::set_allocated_otp_identifier(::std::string* otp_identifier) {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_identifier_;
  }
  if (otp_identifier) {
    set_has_otp_identifier();
    otp_identifier_ = otp_identifier;
  } else {
    clear_has_otp_identifier();
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestMachineAuth

// optional string filename = 1;
inline bool CMsgClientRequestMachineAuth::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestMachineAuth::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestMachineAuth::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CMsgClientRequestMachineAuth::filename() const {
  return *filename_;
}
inline void CMsgClientRequestMachineAuth::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestMachineAuth::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CMsgClientRequestMachineAuth::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestMachineAuth::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 eresult_sentryfile = 2;
inline bool CMsgClientRequestMachineAuth::has_eresult_sentryfile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_eresult_sentryfile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestMachineAuth::clear_has_eresult_sentryfile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestMachineAuth::clear_eresult_sentryfile() {
  eresult_sentryfile_ = 0u;
  clear_has_eresult_sentryfile();
}
inline ::google::protobuf::uint32 CMsgClientRequestMachineAuth::eresult_sentryfile() const {
  return eresult_sentryfile_;
}
inline void CMsgClientRequestMachineAuth::set_eresult_sentryfile(::google::protobuf::uint32 value) {
  set_has_eresult_sentryfile();
  eresult_sentryfile_ = value;
}

// optional uint32 filesize = 3;
inline bool CMsgClientRequestMachineAuth::has_filesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_filesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientRequestMachineAuth::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientRequestMachineAuth::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 CMsgClientRequestMachineAuth::filesize() const {
  return filesize_;
}
inline void CMsgClientRequestMachineAuth::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional bytes sha_sentryfile = 4;
inline bool CMsgClientRequestMachineAuth::has_sha_sentryfile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_sha_sentryfile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientRequestMachineAuth::clear_has_sha_sentryfile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientRequestMachineAuth::clear_sha_sentryfile() {
  if (sha_sentryfile_ != &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_->clear();
  }
  clear_has_sha_sentryfile();
}
inline const ::std::string& CMsgClientRequestMachineAuth::sha_sentryfile() const {
  return *sha_sentryfile_;
}
inline void CMsgClientRequestMachineAuth::set_sha_sentryfile(const ::std::string& value) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_sha_sentryfile(const char* value) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_sha_sentryfile(const void* value, size_t size) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestMachineAuth::mutable_sha_sentryfile() {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  return sha_sentryfile_;
}
inline ::std::string* CMsgClientRequestMachineAuth::release_sha_sentryfile() {
  clear_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_sentryfile_;
    sha_sentryfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestMachineAuth::set_allocated_sha_sentryfile(::std::string* sha_sentryfile) {
  if (sha_sentryfile_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_sentryfile_;
  }
  if (sha_sentryfile) {
    set_has_sha_sentryfile();
    sha_sentryfile_ = sha_sentryfile;
  } else {
    clear_has_sha_sentryfile();
    sha_sentryfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lock_account_action = 6;
inline bool CMsgClientRequestMachineAuth::has_lock_account_action() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_lock_account_action() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientRequestMachineAuth::clear_has_lock_account_action() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientRequestMachineAuth::clear_lock_account_action() {
  lock_account_action_ = 0;
  clear_has_lock_account_action();
}
inline ::google::protobuf::int32 CMsgClientRequestMachineAuth::lock_account_action() const {
  return lock_account_action_;
}
inline void CMsgClientRequestMachineAuth::set_lock_account_action(::google::protobuf::int32 value) {
  set_has_lock_account_action();
  lock_account_action_ = value;
}

// optional uint32 otp_type = 7;
inline bool CMsgClientRequestMachineAuth::has_otp_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_otp_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientRequestMachineAuth::clear_has_otp_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientRequestMachineAuth::clear_otp_type() {
  otp_type_ = 0u;
  clear_has_otp_type();
}
inline ::google::protobuf::uint32 CMsgClientRequestMachineAuth::otp_type() const {
  return otp_type_;
}
inline void CMsgClientRequestMachineAuth::set_otp_type(::google::protobuf::uint32 value) {
  set_has_otp_type();
  otp_type_ = value;
}

// optional string otp_identifier = 8;
inline bool CMsgClientRequestMachineAuth::has_otp_identifier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_otp_identifier() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientRequestMachineAuth::clear_has_otp_identifier() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientRequestMachineAuth::clear_otp_identifier() {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    otp_identifier_->clear();
  }
  clear_has_otp_identifier();
}
inline const ::std::string& CMsgClientRequestMachineAuth::otp_identifier() const {
  return *otp_identifier_;
}
inline void CMsgClientRequestMachineAuth::set_otp_identifier(const ::std::string& value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_otp_identifier(const char* value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_otp_identifier(const char* value, size_t size) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestMachineAuth::mutable_otp_identifier() {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  return otp_identifier_;
}
inline ::std::string* CMsgClientRequestMachineAuth::release_otp_identifier() {
  clear_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_identifier_;
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestMachineAuth::set_allocated_otp_identifier(::std::string* otp_identifier) {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_identifier_;
  }
  if (otp_identifier) {
    set_has_otp_identifier();
    otp_identifier_ = otp_identifier;
  } else {
    clear_has_otp_identifier();
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes otp_sharedsecret = 9;
inline bool CMsgClientRequestMachineAuth::has_otp_sharedsecret() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_otp_sharedsecret() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientRequestMachineAuth::clear_has_otp_sharedsecret() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientRequestMachineAuth::clear_otp_sharedsecret() {
  if (otp_sharedsecret_ != &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_->clear();
  }
  clear_has_otp_sharedsecret();
}
inline const ::std::string& CMsgClientRequestMachineAuth::otp_sharedsecret() const {
  return *otp_sharedsecret_;
}
inline void CMsgClientRequestMachineAuth::set_otp_sharedsecret(const ::std::string& value) {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  otp_sharedsecret_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_otp_sharedsecret(const char* value) {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  otp_sharedsecret_->assign(value);
}
inline void CMsgClientRequestMachineAuth::set_otp_sharedsecret(const void* value, size_t size) {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  otp_sharedsecret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestMachineAuth::mutable_otp_sharedsecret() {
  set_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    otp_sharedsecret_ = new ::std::string;
  }
  return otp_sharedsecret_;
}
inline ::std::string* CMsgClientRequestMachineAuth::release_otp_sharedsecret() {
  clear_has_otp_sharedsecret();
  if (otp_sharedsecret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_sharedsecret_;
    otp_sharedsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestMachineAuth::set_allocated_otp_sharedsecret(::std::string* otp_sharedsecret) {
  if (otp_sharedsecret_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_sharedsecret_;
  }
  if (otp_sharedsecret) {
    set_has_otp_sharedsecret();
    otp_sharedsecret_ = otp_sharedsecret;
  } else {
    clear_has_otp_sharedsecret();
    otp_sharedsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 otp_value = 10;
inline bool CMsgClientRequestMachineAuth::has_otp_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientRequestMachineAuth::set_has_otp_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientRequestMachineAuth::clear_has_otp_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientRequestMachineAuth::clear_otp_value() {
  otp_value_ = 0u;
  clear_has_otp_value();
}
inline ::google::protobuf::uint32 CMsgClientRequestMachineAuth::otp_value() const {
  return otp_value_;
}
inline void CMsgClientRequestMachineAuth::set_otp_value(::google::protobuf::uint32 value) {
  set_has_otp_value();
  otp_value_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestMachineAuthResponse

// optional uint32 eresult = 1;
inline bool CMsgClientRequestMachineAuthResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestMachineAuthResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestMachineAuthResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestMachineAuthResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRequestMachineAuthResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestMachineAuthResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientChangeSteamGuardOptions

// optional uint32 steamguard_provider = 1;
inline bool CMsgClientChangeSteamGuardOptions::has_steamguard_provider() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientChangeSteamGuardOptions::set_has_steamguard_provider() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientChangeSteamGuardOptions::clear_has_steamguard_provider() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientChangeSteamGuardOptions::clear_steamguard_provider() {
  steamguard_provider_ = 0u;
  clear_has_steamguard_provider();
}
inline ::google::protobuf::uint32 CMsgClientChangeSteamGuardOptions::steamguard_provider() const {
  return steamguard_provider_;
}
inline void CMsgClientChangeSteamGuardOptions::set_steamguard_provider(::google::protobuf::uint32 value) {
  set_has_steamguard_provider();
  steamguard_provider_ = value;
}

// optional uint32 steamguard_require_code_default = 2;
inline bool CMsgClientChangeSteamGuardOptions::has_steamguard_require_code_default() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientChangeSteamGuardOptions::set_has_steamguard_require_code_default() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientChangeSteamGuardOptions::clear_has_steamguard_require_code_default() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientChangeSteamGuardOptions::clear_steamguard_require_code_default() {
  steamguard_require_code_default_ = 0u;
  clear_has_steamguard_require_code_default();
}
inline ::google::protobuf::uint32 CMsgClientChangeSteamGuardOptions::steamguard_require_code_default() const {
  return steamguard_require_code_default_;
}
inline void CMsgClientChangeSteamGuardOptions::set_steamguard_require_code_default(::google::protobuf::uint32 value) {
  set_has_steamguard_require_code_default();
  steamguard_require_code_default_ = value;
}

// -------------------------------------------------------------------

// CMsgClientChangeSteamGuardOptionsResponse

// optional uint32 eresult = 1;
inline bool CMsgClientChangeSteamGuardOptionsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientChangeSteamGuardOptionsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientChangeSteamGuardOptionsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientChangeSteamGuardOptionsResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientChangeSteamGuardOptionsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientChangeSteamGuardOptionsResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientCreateFriendsGroup

// optional fixed64 steamid = 1;
inline bool CMsgClientCreateFriendsGroup::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientCreateFriendsGroup::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientCreateFriendsGroup::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientCreateFriendsGroup::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientCreateFriendsGroup::steamid() const {
  return steamid_;
}
inline void CMsgClientCreateFriendsGroup::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional string groupname = 2;
inline bool CMsgClientCreateFriendsGroup::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientCreateFriendsGroup::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientCreateFriendsGroup::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientCreateFriendsGroup::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CMsgClientCreateFriendsGroup::groupname() const {
  return *groupname_;
}
inline void CMsgClientCreateFriendsGroup::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CMsgClientCreateFriendsGroup::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CMsgClientCreateFriendsGroup::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientCreateFriendsGroup::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CMsgClientCreateFriendsGroup::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientCreateFriendsGroup::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientCreateFriendsGroupResponse

// optional uint32 eresult = 1;
inline bool CMsgClientCreateFriendsGroupResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientCreateFriendsGroupResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientCreateFriendsGroupResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientCreateFriendsGroupResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientCreateFriendsGroupResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientCreateFriendsGroupResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 groupid = 2;
inline bool CMsgClientCreateFriendsGroupResponse::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientCreateFriendsGroupResponse::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientCreateFriendsGroupResponse::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientCreateFriendsGroupResponse::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 CMsgClientCreateFriendsGroupResponse::groupid() const {
  return groupid_;
}
inline void CMsgClientCreateFriendsGroupResponse::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientDeleteFriendsGroup

// optional fixed64 steamid = 1;
inline bool CMsgClientDeleteFriendsGroup::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDeleteFriendsGroup::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDeleteFriendsGroup::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDeleteFriendsGroup::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientDeleteFriendsGroup::steamid() const {
  return steamid_;
}
inline void CMsgClientDeleteFriendsGroup::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional int32 groupid = 2;
inline bool CMsgClientDeleteFriendsGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientDeleteFriendsGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientDeleteFriendsGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientDeleteFriendsGroup::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 CMsgClientDeleteFriendsGroup::groupid() const {
  return groupid_;
}
inline void CMsgClientDeleteFriendsGroup::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientDeleteFriendsGroupResponse

// optional uint32 eresult = 1;
inline bool CMsgClientDeleteFriendsGroupResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDeleteFriendsGroupResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDeleteFriendsGroupResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDeleteFriendsGroupResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientDeleteFriendsGroupResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientDeleteFriendsGroupResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRenameFriendsGroup

// optional int32 groupid = 1;
inline bool CMsgClientRenameFriendsGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRenameFriendsGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRenameFriendsGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRenameFriendsGroup::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 CMsgClientRenameFriendsGroup::groupid() const {
  return groupid_;
}
inline void CMsgClientRenameFriendsGroup::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional string groupname = 2;
inline bool CMsgClientRenameFriendsGroup::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRenameFriendsGroup::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRenameFriendsGroup::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRenameFriendsGroup::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& CMsgClientRenameFriendsGroup::groupname() const {
  return *groupname_;
}
inline void CMsgClientRenameFriendsGroup::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CMsgClientRenameFriendsGroup::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void CMsgClientRenameFriendsGroup::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRenameFriendsGroup::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* CMsgClientRenameFriendsGroup::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRenameFriendsGroup::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRenameFriendsGroupResponse

// optional uint32 eresult = 1;
inline bool CMsgClientRenameFriendsGroupResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRenameFriendsGroupResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRenameFriendsGroupResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRenameFriendsGroupResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRenameFriendsGroupResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRenameFriendsGroupResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAddFriendToGroup

// optional int32 groupid = 1;
inline bool CMsgClientAddFriendToGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAddFriendToGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAddFriendToGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAddFriendToGroup::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 CMsgClientAddFriendToGroup::groupid() const {
  return groupid_;
}
inline void CMsgClientAddFriendToGroup::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional fixed64 steamiduser = 2;
inline bool CMsgClientAddFriendToGroup::has_steamiduser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAddFriendToGroup::set_has_steamiduser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAddFriendToGroup::clear_has_steamiduser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAddFriendToGroup::clear_steamiduser() {
  steamiduser_ = GOOGLE_ULONGLONG(0);
  clear_has_steamiduser();
}
inline ::google::protobuf::uint64 CMsgClientAddFriendToGroup::steamiduser() const {
  return steamiduser_;
}
inline void CMsgClientAddFriendToGroup::set_steamiduser(::google::protobuf::uint64 value) {
  set_has_steamiduser();
  steamiduser_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAddFriendToGroupResponse

// optional uint32 eresult = 1;
inline bool CMsgClientAddFriendToGroupResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAddFriendToGroupResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAddFriendToGroupResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAddFriendToGroupResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientAddFriendToGroupResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientAddFriendToGroupResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRemoveFriendFromGroup

// optional int32 groupid = 1;
inline bool CMsgClientRemoveFriendFromGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRemoveFriendFromGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRemoveFriendFromGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRemoveFriendFromGroup::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 CMsgClientRemoveFriendFromGroup::groupid() const {
  return groupid_;
}
inline void CMsgClientRemoveFriendFromGroup::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional fixed64 steamiduser = 2;
inline bool CMsgClientRemoveFriendFromGroup::has_steamiduser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRemoveFriendFromGroup::set_has_steamiduser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRemoveFriendFromGroup::clear_has_steamiduser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRemoveFriendFromGroup::clear_steamiduser() {
  steamiduser_ = GOOGLE_ULONGLONG(0);
  clear_has_steamiduser();
}
inline ::google::protobuf::uint64 CMsgClientRemoveFriendFromGroup::steamiduser() const {
  return steamiduser_;
}
inline void CMsgClientRemoveFriendFromGroup::set_steamiduser(::google::protobuf::uint64 value) {
  set_has_steamiduser();
  steamiduser_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRemoveFriendFromGroupResponse

// optional uint32 eresult = 1;
inline bool CMsgClientRemoveFriendFromGroupResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRemoveFriendFromGroupResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRemoveFriendFromGroupResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRemoveFriendFromGroupResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRemoveFriendFromGroupResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRemoveFriendFromGroupResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRegisterKey

// optional string key = 1;
inline bool CMsgClientRegisterKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRegisterKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRegisterKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRegisterKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CMsgClientRegisterKey::key() const {
  return *key_;
}
inline void CMsgClientRegisterKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CMsgClientRegisterKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CMsgClientRegisterKey::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRegisterKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CMsgClientRegisterKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRegisterKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientPurchaseResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientPurchaseResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPurchaseResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPurchaseResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPurchaseResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientPurchaseResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientPurchaseResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 purchase_result_details = 2;
inline bool CMsgClientPurchaseResponse::has_purchase_result_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPurchaseResponse::set_has_purchase_result_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPurchaseResponse::clear_has_purchase_result_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPurchaseResponse::clear_purchase_result_details() {
  purchase_result_details_ = 0;
  clear_has_purchase_result_details();
}
inline ::google::protobuf::int32 CMsgClientPurchaseResponse::purchase_result_details() const {
  return purchase_result_details_;
}
inline void CMsgClientPurchaseResponse::set_purchase_result_details(::google::protobuf::int32 value) {
  set_has_purchase_result_details();
  purchase_result_details_ = value;
}

// optional bytes purchase_receipt_info = 3;
inline bool CMsgClientPurchaseResponse::has_purchase_receipt_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientPurchaseResponse::set_has_purchase_receipt_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientPurchaseResponse::clear_has_purchase_receipt_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientPurchaseResponse::clear_purchase_receipt_info() {
  if (purchase_receipt_info_ != &::google::protobuf::internal::kEmptyString) {
    purchase_receipt_info_->clear();
  }
  clear_has_purchase_receipt_info();
}
inline const ::std::string& CMsgClientPurchaseResponse::purchase_receipt_info() const {
  return *purchase_receipt_info_;
}
inline void CMsgClientPurchaseResponse::set_purchase_receipt_info(const ::std::string& value) {
  set_has_purchase_receipt_info();
  if (purchase_receipt_info_ == &::google::protobuf::internal::kEmptyString) {
    purchase_receipt_info_ = new ::std::string;
  }
  purchase_receipt_info_->assign(value);
}
inline void CMsgClientPurchaseResponse::set_purchase_receipt_info(const char* value) {
  set_has_purchase_receipt_info();
  if (purchase_receipt_info_ == &::google::protobuf::internal::kEmptyString) {
    purchase_receipt_info_ = new ::std::string;
  }
  purchase_receipt_info_->assign(value);
}
inline void CMsgClientPurchaseResponse::set_purchase_receipt_info(const void* value, size_t size) {
  set_has_purchase_receipt_info();
  if (purchase_receipt_info_ == &::google::protobuf::internal::kEmptyString) {
    purchase_receipt_info_ = new ::std::string;
  }
  purchase_receipt_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPurchaseResponse::mutable_purchase_receipt_info() {
  set_has_purchase_receipt_info();
  if (purchase_receipt_info_ == &::google::protobuf::internal::kEmptyString) {
    purchase_receipt_info_ = new ::std::string;
  }
  return purchase_receipt_info_;
}
inline ::std::string* CMsgClientPurchaseResponse::release_purchase_receipt_info() {
  clear_has_purchase_receipt_info();
  if (purchase_receipt_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = purchase_receipt_info_;
    purchase_receipt_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPurchaseResponse::set_allocated_purchase_receipt_info(::std::string* purchase_receipt_info) {
  if (purchase_receipt_info_ != &::google::protobuf::internal::kEmptyString) {
    delete purchase_receipt_info_;
  }
  if (purchase_receipt_info) {
    set_has_purchase_receipt_info();
    purchase_receipt_info_ = purchase_receipt_info;
  } else {
    clear_has_purchase_receipt_info();
    purchase_receipt_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientActivateOEMLicense

// optional string bios_manufacturer = 1;
inline bool CMsgClientActivateOEMLicense::has_bios_manufacturer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientActivateOEMLicense::set_has_bios_manufacturer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientActivateOEMLicense::clear_has_bios_manufacturer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientActivateOEMLicense::clear_bios_manufacturer() {
  if (bios_manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    bios_manufacturer_->clear();
  }
  clear_has_bios_manufacturer();
}
inline const ::std::string& CMsgClientActivateOEMLicense::bios_manufacturer() const {
  return *bios_manufacturer_;
}
inline void CMsgClientActivateOEMLicense::set_bios_manufacturer(const ::std::string& value) {
  set_has_bios_manufacturer();
  if (bios_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    bios_manufacturer_ = new ::std::string;
  }
  bios_manufacturer_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_bios_manufacturer(const char* value) {
  set_has_bios_manufacturer();
  if (bios_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    bios_manufacturer_ = new ::std::string;
  }
  bios_manufacturer_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_bios_manufacturer(const char* value, size_t size) {
  set_has_bios_manufacturer();
  if (bios_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    bios_manufacturer_ = new ::std::string;
  }
  bios_manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientActivateOEMLicense::mutable_bios_manufacturer() {
  set_has_bios_manufacturer();
  if (bios_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    bios_manufacturer_ = new ::std::string;
  }
  return bios_manufacturer_;
}
inline ::std::string* CMsgClientActivateOEMLicense::release_bios_manufacturer() {
  clear_has_bios_manufacturer();
  if (bios_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bios_manufacturer_;
    bios_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientActivateOEMLicense::set_allocated_bios_manufacturer(::std::string* bios_manufacturer) {
  if (bios_manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete bios_manufacturer_;
  }
  if (bios_manufacturer) {
    set_has_bios_manufacturer();
    bios_manufacturer_ = bios_manufacturer;
  } else {
    clear_has_bios_manufacturer();
    bios_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bios_serialnumber = 2;
inline bool CMsgClientActivateOEMLicense::has_bios_serialnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientActivateOEMLicense::set_has_bios_serialnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientActivateOEMLicense::clear_has_bios_serialnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientActivateOEMLicense::clear_bios_serialnumber() {
  if (bios_serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    bios_serialnumber_->clear();
  }
  clear_has_bios_serialnumber();
}
inline const ::std::string& CMsgClientActivateOEMLicense::bios_serialnumber() const {
  return *bios_serialnumber_;
}
inline void CMsgClientActivateOEMLicense::set_bios_serialnumber(const ::std::string& value) {
  set_has_bios_serialnumber();
  if (bios_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    bios_serialnumber_ = new ::std::string;
  }
  bios_serialnumber_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_bios_serialnumber(const char* value) {
  set_has_bios_serialnumber();
  if (bios_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    bios_serialnumber_ = new ::std::string;
  }
  bios_serialnumber_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_bios_serialnumber(const char* value, size_t size) {
  set_has_bios_serialnumber();
  if (bios_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    bios_serialnumber_ = new ::std::string;
  }
  bios_serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientActivateOEMLicense::mutable_bios_serialnumber() {
  set_has_bios_serialnumber();
  if (bios_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    bios_serialnumber_ = new ::std::string;
  }
  return bios_serialnumber_;
}
inline ::std::string* CMsgClientActivateOEMLicense::release_bios_serialnumber() {
  clear_has_bios_serialnumber();
  if (bios_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bios_serialnumber_;
    bios_serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientActivateOEMLicense::set_allocated_bios_serialnumber(::std::string* bios_serialnumber) {
  if (bios_serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete bios_serialnumber_;
  }
  if (bios_serialnumber) {
    set_has_bios_serialnumber();
    bios_serialnumber_ = bios_serialnumber;
  } else {
    clear_has_bios_serialnumber();
    bios_serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes license_file = 3;
inline bool CMsgClientActivateOEMLicense::has_license_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientActivateOEMLicense::set_has_license_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientActivateOEMLicense::clear_has_license_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientActivateOEMLicense::clear_license_file() {
  if (license_file_ != &::google::protobuf::internal::kEmptyString) {
    license_file_->clear();
  }
  clear_has_license_file();
}
inline const ::std::string& CMsgClientActivateOEMLicense::license_file() const {
  return *license_file_;
}
inline void CMsgClientActivateOEMLicense::set_license_file(const ::std::string& value) {
  set_has_license_file();
  if (license_file_ == &::google::protobuf::internal::kEmptyString) {
    license_file_ = new ::std::string;
  }
  license_file_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_license_file(const char* value) {
  set_has_license_file();
  if (license_file_ == &::google::protobuf::internal::kEmptyString) {
    license_file_ = new ::std::string;
  }
  license_file_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_license_file(const void* value, size_t size) {
  set_has_license_file();
  if (license_file_ == &::google::protobuf::internal::kEmptyString) {
    license_file_ = new ::std::string;
  }
  license_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientActivateOEMLicense::mutable_license_file() {
  set_has_license_file();
  if (license_file_ == &::google::protobuf::internal::kEmptyString) {
    license_file_ = new ::std::string;
  }
  return license_file_;
}
inline ::std::string* CMsgClientActivateOEMLicense::release_license_file() {
  clear_has_license_file();
  if (license_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_file_;
    license_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientActivateOEMLicense::set_allocated_license_file(::std::string* license_file) {
  if (license_file_ != &::google::protobuf::internal::kEmptyString) {
    delete license_file_;
  }
  if (license_file) {
    set_has_license_file();
    license_file_ = license_file;
  } else {
    clear_has_license_file();
    license_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mainboard_manufacturer = 4;
inline bool CMsgClientActivateOEMLicense::has_mainboard_manufacturer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientActivateOEMLicense::set_has_mainboard_manufacturer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientActivateOEMLicense::clear_has_mainboard_manufacturer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientActivateOEMLicense::clear_mainboard_manufacturer() {
  if (mainboard_manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    mainboard_manufacturer_->clear();
  }
  clear_has_mainboard_manufacturer();
}
inline const ::std::string& CMsgClientActivateOEMLicense::mainboard_manufacturer() const {
  return *mainboard_manufacturer_;
}
inline void CMsgClientActivateOEMLicense::set_mainboard_manufacturer(const ::std::string& value) {
  set_has_mainboard_manufacturer();
  if (mainboard_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_manufacturer_ = new ::std::string;
  }
  mainboard_manufacturer_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_mainboard_manufacturer(const char* value) {
  set_has_mainboard_manufacturer();
  if (mainboard_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_manufacturer_ = new ::std::string;
  }
  mainboard_manufacturer_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_mainboard_manufacturer(const char* value, size_t size) {
  set_has_mainboard_manufacturer();
  if (mainboard_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_manufacturer_ = new ::std::string;
  }
  mainboard_manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientActivateOEMLicense::mutable_mainboard_manufacturer() {
  set_has_mainboard_manufacturer();
  if (mainboard_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_manufacturer_ = new ::std::string;
  }
  return mainboard_manufacturer_;
}
inline ::std::string* CMsgClientActivateOEMLicense::release_mainboard_manufacturer() {
  clear_has_mainboard_manufacturer();
  if (mainboard_manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mainboard_manufacturer_;
    mainboard_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientActivateOEMLicense::set_allocated_mainboard_manufacturer(::std::string* mainboard_manufacturer) {
  if (mainboard_manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete mainboard_manufacturer_;
  }
  if (mainboard_manufacturer) {
    set_has_mainboard_manufacturer();
    mainboard_manufacturer_ = mainboard_manufacturer;
  } else {
    clear_has_mainboard_manufacturer();
    mainboard_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mainboard_product = 5;
inline bool CMsgClientActivateOEMLicense::has_mainboard_product() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientActivateOEMLicense::set_has_mainboard_product() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientActivateOEMLicense::clear_has_mainboard_product() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientActivateOEMLicense::clear_mainboard_product() {
  if (mainboard_product_ != &::google::protobuf::internal::kEmptyString) {
    mainboard_product_->clear();
  }
  clear_has_mainboard_product();
}
inline const ::std::string& CMsgClientActivateOEMLicense::mainboard_product() const {
  return *mainboard_product_;
}
inline void CMsgClientActivateOEMLicense::set_mainboard_product(const ::std::string& value) {
  set_has_mainboard_product();
  if (mainboard_product_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_product_ = new ::std::string;
  }
  mainboard_product_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_mainboard_product(const char* value) {
  set_has_mainboard_product();
  if (mainboard_product_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_product_ = new ::std::string;
  }
  mainboard_product_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_mainboard_product(const char* value, size_t size) {
  set_has_mainboard_product();
  if (mainboard_product_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_product_ = new ::std::string;
  }
  mainboard_product_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientActivateOEMLicense::mutable_mainboard_product() {
  set_has_mainboard_product();
  if (mainboard_product_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_product_ = new ::std::string;
  }
  return mainboard_product_;
}
inline ::std::string* CMsgClientActivateOEMLicense::release_mainboard_product() {
  clear_has_mainboard_product();
  if (mainboard_product_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mainboard_product_;
    mainboard_product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientActivateOEMLicense::set_allocated_mainboard_product(::std::string* mainboard_product) {
  if (mainboard_product_ != &::google::protobuf::internal::kEmptyString) {
    delete mainboard_product_;
  }
  if (mainboard_product) {
    set_has_mainboard_product();
    mainboard_product_ = mainboard_product;
  } else {
    clear_has_mainboard_product();
    mainboard_product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mainboard_serialnumber = 6;
inline bool CMsgClientActivateOEMLicense::has_mainboard_serialnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientActivateOEMLicense::set_has_mainboard_serialnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientActivateOEMLicense::clear_has_mainboard_serialnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientActivateOEMLicense::clear_mainboard_serialnumber() {
  if (mainboard_serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    mainboard_serialnumber_->clear();
  }
  clear_has_mainboard_serialnumber();
}
inline const ::std::string& CMsgClientActivateOEMLicense::mainboard_serialnumber() const {
  return *mainboard_serialnumber_;
}
inline void CMsgClientActivateOEMLicense::set_mainboard_serialnumber(const ::std::string& value) {
  set_has_mainboard_serialnumber();
  if (mainboard_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_serialnumber_ = new ::std::string;
  }
  mainboard_serialnumber_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_mainboard_serialnumber(const char* value) {
  set_has_mainboard_serialnumber();
  if (mainboard_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_serialnumber_ = new ::std::string;
  }
  mainboard_serialnumber_->assign(value);
}
inline void CMsgClientActivateOEMLicense::set_mainboard_serialnumber(const char* value, size_t size) {
  set_has_mainboard_serialnumber();
  if (mainboard_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_serialnumber_ = new ::std::string;
  }
  mainboard_serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientActivateOEMLicense::mutable_mainboard_serialnumber() {
  set_has_mainboard_serialnumber();
  if (mainboard_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    mainboard_serialnumber_ = new ::std::string;
  }
  return mainboard_serialnumber_;
}
inline ::std::string* CMsgClientActivateOEMLicense::release_mainboard_serialnumber() {
  clear_has_mainboard_serialnumber();
  if (mainboard_serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mainboard_serialnumber_;
    mainboard_serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientActivateOEMLicense::set_allocated_mainboard_serialnumber(::std::string* mainboard_serialnumber) {
  if (mainboard_serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete mainboard_serialnumber_;
  }
  if (mainboard_serialnumber) {
    set_has_mainboard_serialnumber();
    mainboard_serialnumber_ = mainboard_serialnumber;
  } else {
    clear_has_mainboard_serialnumber();
    mainboard_serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientPurchaseWithMachineID

// optional uint32 package_id = 1;
inline bool CMsgClientPurchaseWithMachineID::has_package_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientPurchaseWithMachineID::set_has_package_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientPurchaseWithMachineID::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientPurchaseWithMachineID::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 CMsgClientPurchaseWithMachineID::package_id() const {
  return package_id_;
}
inline void CMsgClientPurchaseWithMachineID::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
}

// optional bytes machine_info = 2;
inline bool CMsgClientPurchaseWithMachineID::has_machine_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientPurchaseWithMachineID::set_has_machine_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientPurchaseWithMachineID::clear_has_machine_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientPurchaseWithMachineID::clear_machine_info() {
  if (machine_info_ != &::google::protobuf::internal::kEmptyString) {
    machine_info_->clear();
  }
  clear_has_machine_info();
}
inline const ::std::string& CMsgClientPurchaseWithMachineID::machine_info() const {
  return *machine_info_;
}
inline void CMsgClientPurchaseWithMachineID::set_machine_info(const ::std::string& value) {
  set_has_machine_info();
  if (machine_info_ == &::google::protobuf::internal::kEmptyString) {
    machine_info_ = new ::std::string;
  }
  machine_info_->assign(value);
}
inline void CMsgClientPurchaseWithMachineID::set_machine_info(const char* value) {
  set_has_machine_info();
  if (machine_info_ == &::google::protobuf::internal::kEmptyString) {
    machine_info_ = new ::std::string;
  }
  machine_info_->assign(value);
}
inline void CMsgClientPurchaseWithMachineID::set_machine_info(const void* value, size_t size) {
  set_has_machine_info();
  if (machine_info_ == &::google::protobuf::internal::kEmptyString) {
    machine_info_ = new ::std::string;
  }
  machine_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientPurchaseWithMachineID::mutable_machine_info() {
  set_has_machine_info();
  if (machine_info_ == &::google::protobuf::internal::kEmptyString) {
    machine_info_ = new ::std::string;
  }
  return machine_info_;
}
inline ::std::string* CMsgClientPurchaseWithMachineID::release_machine_info() {
  clear_has_machine_info();
  if (machine_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_info_;
    machine_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientPurchaseWithMachineID::set_allocated_machine_info(::std::string* machine_info) {
  if (machine_info_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_info_;
  }
  if (machine_info) {
    set_has_machine_info();
    machine_info_ = machine_info;
  } else {
    clear_has_machine_info();
    machine_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgTrading_InitiateTradeRequest

// optional uint32 trade_request_id = 1;
inline bool CMsgTrading_InitiateTradeRequest::has_trade_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTrading_InitiateTradeRequest::set_has_trade_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTrading_InitiateTradeRequest::clear_has_trade_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTrading_InitiateTradeRequest::clear_trade_request_id() {
  trade_request_id_ = 0u;
  clear_has_trade_request_id();
}
inline ::google::protobuf::uint32 CMsgTrading_InitiateTradeRequest::trade_request_id() const {
  return trade_request_id_;
}
inline void CMsgTrading_InitiateTradeRequest::set_trade_request_id(::google::protobuf::uint32 value) {
  set_has_trade_request_id();
  trade_request_id_ = value;
}

// optional uint64 other_steamid = 2;
inline bool CMsgTrading_InitiateTradeRequest::has_other_steamid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTrading_InitiateTradeRequest::set_has_other_steamid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTrading_InitiateTradeRequest::clear_has_other_steamid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTrading_InitiateTradeRequest::clear_other_steamid() {
  other_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_other_steamid();
}
inline ::google::protobuf::uint64 CMsgTrading_InitiateTradeRequest::other_steamid() const {
  return other_steamid_;
}
inline void CMsgTrading_InitiateTradeRequest::set_other_steamid(::google::protobuf::uint64 value) {
  set_has_other_steamid();
  other_steamid_ = value;
}

// optional string other_name = 3;
inline bool CMsgTrading_InitiateTradeRequest::has_other_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTrading_InitiateTradeRequest::set_has_other_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTrading_InitiateTradeRequest::clear_has_other_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTrading_InitiateTradeRequest::clear_other_name() {
  if (other_name_ != &::google::protobuf::internal::kEmptyString) {
    other_name_->clear();
  }
  clear_has_other_name();
}
inline const ::std::string& CMsgTrading_InitiateTradeRequest::other_name() const {
  return *other_name_;
}
inline void CMsgTrading_InitiateTradeRequest::set_other_name(const ::std::string& value) {
  set_has_other_name();
  if (other_name_ == &::google::protobuf::internal::kEmptyString) {
    other_name_ = new ::std::string;
  }
  other_name_->assign(value);
}
inline void CMsgTrading_InitiateTradeRequest::set_other_name(const char* value) {
  set_has_other_name();
  if (other_name_ == &::google::protobuf::internal::kEmptyString) {
    other_name_ = new ::std::string;
  }
  other_name_->assign(value);
}
inline void CMsgTrading_InitiateTradeRequest::set_other_name(const char* value, size_t size) {
  set_has_other_name();
  if (other_name_ == &::google::protobuf::internal::kEmptyString) {
    other_name_ = new ::std::string;
  }
  other_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgTrading_InitiateTradeRequest::mutable_other_name() {
  set_has_other_name();
  if (other_name_ == &::google::protobuf::internal::kEmptyString) {
    other_name_ = new ::std::string;
  }
  return other_name_;
}
inline ::std::string* CMsgTrading_InitiateTradeRequest::release_other_name() {
  clear_has_other_name();
  if (other_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = other_name_;
    other_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgTrading_InitiateTradeRequest::set_allocated_other_name(::std::string* other_name) {
  if (other_name_ != &::google::protobuf::internal::kEmptyString) {
    delete other_name_;
  }
  if (other_name) {
    set_has_other_name();
    other_name_ = other_name;
  } else {
    clear_has_other_name();
    other_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgTrading_InitiateTradeResponse

// optional uint32 response = 1;
inline bool CMsgTrading_InitiateTradeResponse::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTrading_InitiateTradeResponse::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_response() {
  response_ = 0u;
  clear_has_response();
}
inline ::google::protobuf::uint32 CMsgTrading_InitiateTradeResponse::response() const {
  return response_;
}
inline void CMsgTrading_InitiateTradeResponse::set_response(::google::protobuf::uint32 value) {
  set_has_response();
  response_ = value;
}

// optional uint32 trade_request_id = 2;
inline bool CMsgTrading_InitiateTradeResponse::has_trade_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgTrading_InitiateTradeResponse::set_has_trade_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_has_trade_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_trade_request_id() {
  trade_request_id_ = 0u;
  clear_has_trade_request_id();
}
inline ::google::protobuf::uint32 CMsgTrading_InitiateTradeResponse::trade_request_id() const {
  return trade_request_id_;
}
inline void CMsgTrading_InitiateTradeResponse::set_trade_request_id(::google::protobuf::uint32 value) {
  set_has_trade_request_id();
  trade_request_id_ = value;
}

// optional uint64 other_steamid = 3;
inline bool CMsgTrading_InitiateTradeResponse::has_other_steamid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgTrading_InitiateTradeResponse::set_has_other_steamid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_has_other_steamid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_other_steamid() {
  other_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_other_steamid();
}
inline ::google::protobuf::uint64 CMsgTrading_InitiateTradeResponse::other_steamid() const {
  return other_steamid_;
}
inline void CMsgTrading_InitiateTradeResponse::set_other_steamid(::google::protobuf::uint64 value) {
  set_has_other_steamid();
  other_steamid_ = value;
}

// optional uint32 steamguard_required_days = 4;
inline bool CMsgTrading_InitiateTradeResponse::has_steamguard_required_days() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgTrading_InitiateTradeResponse::set_has_steamguard_required_days() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_has_steamguard_required_days() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgTrading_InitiateTradeResponse::clear_steamguard_required_days() {
  steamguard_required_days_ = 0u;
  clear_has_steamguard_required_days();
}
inline ::google::protobuf::uint32 CMsgTrading_InitiateTradeResponse::steamguard_required_days() const {
  return steamguard_required_days_;
}
inline void CMsgTrading_InitiateTradeResponse::set_steamguard_required_days(::google::protobuf::uint32 value) {
  set_has_steamguard_required_days();
  steamguard_required_days_ = value;
}

// -------------------------------------------------------------------

// CMsgTrading_CancelTradeRequest

// optional uint64 other_steamid = 1;
inline bool CMsgTrading_CancelTradeRequest::has_other_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTrading_CancelTradeRequest::set_has_other_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTrading_CancelTradeRequest::clear_has_other_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTrading_CancelTradeRequest::clear_other_steamid() {
  other_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_other_steamid();
}
inline ::google::protobuf::uint64 CMsgTrading_CancelTradeRequest::other_steamid() const {
  return other_steamid_;
}
inline void CMsgTrading_CancelTradeRequest::set_other_steamid(::google::protobuf::uint64 value) {
  set_has_other_steamid();
  other_steamid_ = value;
}

// -------------------------------------------------------------------

// CMsgTrading_StartSession

// optional uint64 other_steamid = 1;
inline bool CMsgTrading_StartSession::has_other_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgTrading_StartSession::set_has_other_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgTrading_StartSession::clear_has_other_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgTrading_StartSession::clear_other_steamid() {
  other_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_other_steamid();
}
inline ::google::protobuf::uint64 CMsgTrading_StartSession::other_steamid() const {
  return other_steamid_;
}
inline void CMsgTrading_StartSession::set_other_steamid(::google::protobuf::uint64 value) {
  set_has_other_steamid();
  other_steamid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSInitDepotBuildRequest

// optional uint32 depot_id = 1;
inline bool CMsgClientMDSInitDepotBuildRequest::has_depot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_has_depot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSInitDepotBuildRequest::depot_id() const {
  return depot_id_;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional bytes encrypted_aes_key = 2;
inline bool CMsgClientMDSInitDepotBuildRequest::has_encrypted_aes_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_has_encrypted_aes_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_has_encrypted_aes_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_encrypted_aes_key() {
  if (encrypted_aes_key_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_aes_key_->clear();
  }
  clear_has_encrypted_aes_key();
}
inline const ::std::string& CMsgClientMDSInitDepotBuildRequest::encrypted_aes_key() const {
  return *encrypted_aes_key_;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_encrypted_aes_key(const ::std::string& value) {
  set_has_encrypted_aes_key();
  if (encrypted_aes_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_aes_key_ = new ::std::string;
  }
  encrypted_aes_key_->assign(value);
}
inline void CMsgClientMDSInitDepotBuildRequest::set_encrypted_aes_key(const char* value) {
  set_has_encrypted_aes_key();
  if (encrypted_aes_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_aes_key_ = new ::std::string;
  }
  encrypted_aes_key_->assign(value);
}
inline void CMsgClientMDSInitDepotBuildRequest::set_encrypted_aes_key(const void* value, size_t size) {
  set_has_encrypted_aes_key();
  if (encrypted_aes_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_aes_key_ = new ::std::string;
  }
  encrypted_aes_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSInitDepotBuildRequest::mutable_encrypted_aes_key() {
  set_has_encrypted_aes_key();
  if (encrypted_aes_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_aes_key_ = new ::std::string;
  }
  return encrypted_aes_key_;
}
inline ::std::string* CMsgClientMDSInitDepotBuildRequest::release_encrypted_aes_key() {
  clear_has_encrypted_aes_key();
  if (encrypted_aes_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_aes_key_;
    encrypted_aes_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSInitDepotBuildRequest::set_allocated_encrypted_aes_key(::std::string* encrypted_aes_key) {
  if (encrypted_aes_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_aes_key_;
  }
  if (encrypted_aes_key) {
    set_has_encrypted_aes_key();
    encrypted_aes_key_ = encrypted_aes_key;
  } else {
    clear_has_encrypted_aes_key();
    encrypted_aes_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 build_id = 4;
inline bool CMsgClientMDSInitDepotBuildRequest::has_build_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_has_build_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_has_build_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_build_id() {
  build_id_ = 0u;
  clear_has_build_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSInitDepotBuildRequest::build_id() const {
  return build_id_;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_build_id(::google::protobuf::uint32 value) {
  set_has_build_id();
  build_id_ = value;
}

// optional bool for_local_cs = 5;
inline bool CMsgClientMDSInitDepotBuildRequest::has_for_local_cs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_has_for_local_cs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_has_for_local_cs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_for_local_cs() {
  for_local_cs_ = false;
  clear_has_for_local_cs();
}
inline bool CMsgClientMDSInitDepotBuildRequest::for_local_cs() const {
  return for_local_cs_;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_for_local_cs(bool value) {
  set_has_for_local_cs();
  for_local_cs_ = value;
}

// optional bool no_baseline = 6;
inline bool CMsgClientMDSInitDepotBuildRequest::has_no_baseline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_has_no_baseline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_has_no_baseline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMDSInitDepotBuildRequest::clear_no_baseline() {
  no_baseline_ = false;
  clear_has_no_baseline();
}
inline bool CMsgClientMDSInitDepotBuildRequest::no_baseline() const {
  return no_baseline_;
}
inline void CMsgClientMDSInitDepotBuildRequest::set_no_baseline(bool value) {
  set_has_no_baseline();
  no_baseline_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSInitDepotBuildResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSInitDepotBuildResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSInitDepotBuildResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 default_chunk_size = 2;
inline bool CMsgClientMDSInitDepotBuildResponse::has_default_chunk_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_has_default_chunk_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_has_default_chunk_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_default_chunk_size() {
  default_chunk_size_ = 0u;
  clear_has_default_chunk_size();
}
inline ::google::protobuf::uint32 CMsgClientMDSInitDepotBuildResponse::default_chunk_size() const {
  return default_chunk_size_;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_default_chunk_size(::google::protobuf::uint32 value) {
  set_has_default_chunk_size();
  default_chunk_size_ = value;
}

// optional fixed64 base_manifest = 3;
inline bool CMsgClientMDSInitDepotBuildResponse::has_base_manifest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_has_base_manifest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_has_base_manifest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_base_manifest() {
  base_manifest_ = GOOGLE_ULONGLONG(0);
  clear_has_base_manifest();
}
inline ::google::protobuf::uint64 CMsgClientMDSInitDepotBuildResponse::base_manifest() const {
  return base_manifest_;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_base_manifest(::google::protobuf::uint64 value) {
  set_has_base_manifest();
  base_manifest_ = value;
}

// optional bytes encrypted_depot_key = 4;
inline bool CMsgClientMDSInitDepotBuildResponse::has_encrypted_depot_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_has_encrypted_depot_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_has_encrypted_depot_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMDSInitDepotBuildResponse::clear_encrypted_depot_key() {
  if (encrypted_depot_key_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_depot_key_->clear();
  }
  clear_has_encrypted_depot_key();
}
inline const ::std::string& CMsgClientMDSInitDepotBuildResponse::encrypted_depot_key() const {
  return *encrypted_depot_key_;
}
inline void CMsgClientMDSInitDepotBuildResponse::set_encrypted_depot_key(const ::std::string& value) {
  set_has_encrypted_depot_key();
  if (encrypted_depot_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_depot_key_ = new ::std::string;
  }
  encrypted_depot_key_->assign(value);
}
inline void CMsgClientMDSInitDepotBuildResponse::set_encrypted_depot_key(const char* value) {
  set_has_encrypted_depot_key();
  if (encrypted_depot_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_depot_key_ = new ::std::string;
  }
  encrypted_depot_key_->assign(value);
}
inline void CMsgClientMDSInitDepotBuildResponse::set_encrypted_depot_key(const void* value, size_t size) {
  set_has_encrypted_depot_key();
  if (encrypted_depot_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_depot_key_ = new ::std::string;
  }
  encrypted_depot_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSInitDepotBuildResponse::mutable_encrypted_depot_key() {
  set_has_encrypted_depot_key();
  if (encrypted_depot_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_depot_key_ = new ::std::string;
  }
  return encrypted_depot_key_;
}
inline ::std::string* CMsgClientMDSInitDepotBuildResponse::release_encrypted_depot_key() {
  clear_has_encrypted_depot_key();
  if (encrypted_depot_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_depot_key_;
    encrypted_depot_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSInitDepotBuildResponse::set_allocated_encrypted_depot_key(::std::string* encrypted_depot_key) {
  if (encrypted_depot_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_depot_key_;
  }
  if (encrypted_depot_key) {
    set_has_encrypted_depot_key();
    encrypted_depot_key_ = encrypted_depot_key;
  } else {
    clear_has_encrypted_depot_key();
    encrypted_depot_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMDSLoginRequest

// optional bytes encrypted_session_key = 1;
inline bool CMsgClientMDSLoginRequest::has_encrypted_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSLoginRequest::set_has_encrypted_session_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSLoginRequest::clear_has_encrypted_session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSLoginRequest::clear_encrypted_session_key() {
  if (encrypted_session_key_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_session_key_->clear();
  }
  clear_has_encrypted_session_key();
}
inline const ::std::string& CMsgClientMDSLoginRequest::encrypted_session_key() const {
  return *encrypted_session_key_;
}
inline void CMsgClientMDSLoginRequest::set_encrypted_session_key(const ::std::string& value) {
  set_has_encrypted_session_key();
  if (encrypted_session_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_session_key_ = new ::std::string;
  }
  encrypted_session_key_->assign(value);
}
inline void CMsgClientMDSLoginRequest::set_encrypted_session_key(const char* value) {
  set_has_encrypted_session_key();
  if (encrypted_session_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_session_key_ = new ::std::string;
  }
  encrypted_session_key_->assign(value);
}
inline void CMsgClientMDSLoginRequest::set_encrypted_session_key(const void* value, size_t size) {
  set_has_encrypted_session_key();
  if (encrypted_session_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_session_key_ = new ::std::string;
  }
  encrypted_session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSLoginRequest::mutable_encrypted_session_key() {
  set_has_encrypted_session_key();
  if (encrypted_session_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_session_key_ = new ::std::string;
  }
  return encrypted_session_key_;
}
inline ::std::string* CMsgClientMDSLoginRequest::release_encrypted_session_key() {
  clear_has_encrypted_session_key();
  if (encrypted_session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_session_key_;
    encrypted_session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSLoginRequest::set_allocated_encrypted_session_key(::std::string* encrypted_session_key) {
  if (encrypted_session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_session_key_;
  }
  if (encrypted_session_key) {
    set_has_encrypted_session_key();
    encrypted_session_key_ = encrypted_session_key;
  } else {
    clear_has_encrypted_session_key();
    encrypted_session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMDSLoginResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSLoginResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSLoginResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSLoginResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSLoginResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSLoginResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSLoginResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadDepotChunks_ChunkUploadData

// optional bytes sha = 1;
inline bool CMsgClientMDSUploadDepotChunks_ChunkUploadData::has_sha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_has_sha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_has_sha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_sha() {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    sha_->clear();
  }
  clear_has_sha();
}
inline const ::std::string& CMsgClientMDSUploadDepotChunks_ChunkUploadData::sha() const {
  return *sha_;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_sha(const ::std::string& value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_sha(const char* value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_sha(const void* value, size_t size) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSUploadDepotChunks_ChunkUploadData::mutable_sha() {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    sha_ = new ::std::string;
  }
  return sha_;
}
inline ::std::string* CMsgClientMDSUploadDepotChunks_ChunkUploadData::release_sha() {
  clear_has_sha();
  if (sha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_;
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_allocated_sha(::std::string* sha) {
  if (sha_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_;
  }
  if (sha) {
    set_has_sha();
    sha_ = sha;
  } else {
    clear_has_sha();
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rolling_crc = 2;
inline bool CMsgClientMDSUploadDepotChunks_ChunkUploadData::has_rolling_crc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_has_rolling_crc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_has_rolling_crc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_rolling_crc() {
  rolling_crc_ = 0u;
  clear_has_rolling_crc();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadDepotChunks_ChunkUploadData::rolling_crc() const {
  return rolling_crc_;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_rolling_crc(::google::protobuf::uint32 value) {
  set_has_rolling_crc();
  rolling_crc_ = value;
}

// optional uint32 original_chunk_size = 3;
inline bool CMsgClientMDSUploadDepotChunks_ChunkUploadData::has_original_chunk_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_has_original_chunk_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_has_original_chunk_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_original_chunk_size() {
  original_chunk_size_ = 0u;
  clear_has_original_chunk_size();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadDepotChunks_ChunkUploadData::original_chunk_size() const {
  return original_chunk_size_;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_original_chunk_size(::google::protobuf::uint32 value) {
  set_has_original_chunk_size();
  original_chunk_size_ = value;
}

// optional bytes data = 4;
inline bool CMsgClientMDSUploadDepotChunks_ChunkUploadData::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientMDSUploadDepotChunks_ChunkUploadData::data() const {
  return *data_;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSUploadDepotChunks_ChunkUploadData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientMDSUploadDepotChunks_ChunkUploadData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 compressed_chunk_size = 5;
inline bool CMsgClientMDSUploadDepotChunks_ChunkUploadData::has_compressed_chunk_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_has_compressed_chunk_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_has_compressed_chunk_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_compressed_chunk_size() {
  compressed_chunk_size_ = 0u;
  clear_has_compressed_chunk_size();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadDepotChunks_ChunkUploadData::compressed_chunk_size() const {
  return compressed_chunk_size_;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_compressed_chunk_size(::google::protobuf::uint32 value) {
  set_has_compressed_chunk_size();
  compressed_chunk_size_ = value;
}

// optional uint32 compressed_crc = 6;
inline bool CMsgClientMDSUploadDepotChunks_ChunkUploadData::has_compressed_crc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_has_compressed_crc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_has_compressed_crc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::clear_compressed_crc() {
  compressed_crc_ = 0u;
  clear_has_compressed_crc();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadDepotChunks_ChunkUploadData::compressed_crc() const {
  return compressed_crc_;
}
inline void CMsgClientMDSUploadDepotChunks_ChunkUploadData::set_compressed_crc(::google::protobuf::uint32 value) {
  set_has_compressed_crc();
  compressed_crc_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadDepotChunks

// optional uint32 depot_id = 1;
inline bool CMsgClientMDSUploadDepotChunks::has_depot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks::set_has_depot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadDepotChunks::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadDepotChunks::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadDepotChunks::depot_id() const {
  return depot_id_;
}
inline void CMsgClientMDSUploadDepotChunks::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// repeated .Sc.CMsgClientMDSUploadDepotChunks.ChunkUploadData chunks = 2;
inline int CMsgClientMDSUploadDepotChunks::chunks_size() const {
  return chunks_.size();
}
inline void CMsgClientMDSUploadDepotChunks::clear_chunks() {
  chunks_.Clear();
}
inline const ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData& CMsgClientMDSUploadDepotChunks::chunks(int index) const {
  return chunks_.Get(index);
}
inline ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData* CMsgClientMDSUploadDepotChunks::mutable_chunks(int index) {
  return chunks_.Mutable(index);
}
inline ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData* CMsgClientMDSUploadDepotChunks::add_chunks() {
  return chunks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData >&
CMsgClientMDSUploadDepotChunks::chunks() const {
  return chunks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientMDSUploadDepotChunks_ChunkUploadData >*
CMsgClientMDSUploadDepotChunks::mutable_chunks() {
  return &chunks_;
}

// optional bool only_meta_data = 3;
inline bool CMsgClientMDSUploadDepotChunks::has_only_meta_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSUploadDepotChunks::set_has_only_meta_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSUploadDepotChunks::clear_has_only_meta_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSUploadDepotChunks::clear_only_meta_data() {
  only_meta_data_ = false;
  clear_has_only_meta_data();
}
inline bool CMsgClientMDSUploadDepotChunks::only_meta_data() const {
  return only_meta_data_;
}
inline void CMsgClientMDSUploadDepotChunks::set_only_meta_data(bool value) {
  set_has_only_meta_data();
  only_meta_data_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadDepotChunksResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSUploadDepotChunksResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadDepotChunksResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadDepotChunksResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadDepotChunksResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSUploadDepotChunksResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSUploadDepotChunksResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadRateTest

// optional uint32 serial_number = 1;
inline bool CMsgClientMDSUploadRateTest::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadRateTest::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadRateTest::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadRateTest::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadRateTest::serial_number() const {
  return serial_number_;
}
inline void CMsgClientMDSUploadRateTest::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
}

// optional bytes test_data = 2;
inline bool CMsgClientMDSUploadRateTest::has_test_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSUploadRateTest::set_has_test_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSUploadRateTest::clear_has_test_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSUploadRateTest::clear_test_data() {
  if (test_data_ != &::google::protobuf::internal::kEmptyString) {
    test_data_->clear();
  }
  clear_has_test_data();
}
inline const ::std::string& CMsgClientMDSUploadRateTest::test_data() const {
  return *test_data_;
}
inline void CMsgClientMDSUploadRateTest::set_test_data(const ::std::string& value) {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::kEmptyString) {
    test_data_ = new ::std::string;
  }
  test_data_->assign(value);
}
inline void CMsgClientMDSUploadRateTest::set_test_data(const char* value) {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::kEmptyString) {
    test_data_ = new ::std::string;
  }
  test_data_->assign(value);
}
inline void CMsgClientMDSUploadRateTest::set_test_data(const void* value, size_t size) {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::kEmptyString) {
    test_data_ = new ::std::string;
  }
  test_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSUploadRateTest::mutable_test_data() {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::kEmptyString) {
    test_data_ = new ::std::string;
  }
  return test_data_;
}
inline ::std::string* CMsgClientMDSUploadRateTest::release_test_data() {
  clear_has_test_data();
  if (test_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_data_;
    test_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSUploadRateTest::set_allocated_test_data(::std::string* test_data) {
  if (test_data_ != &::google::protobuf::internal::kEmptyString) {
    delete test_data_;
  }
  if (test_data) {
    set_has_test_data();
    test_data_ = test_data;
  } else {
    clear_has_test_data();
    test_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 test_data_size = 3;
inline bool CMsgClientMDSUploadRateTest::has_test_data_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSUploadRateTest::set_has_test_data_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSUploadRateTest::clear_has_test_data_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSUploadRateTest::clear_test_data_size() {
  test_data_size_ = 0u;
  clear_has_test_data_size();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadRateTest::test_data_size() const {
  return test_data_size_;
}
inline void CMsgClientMDSUploadRateTest::set_test_data_size(::google::protobuf::uint32 value) {
  set_has_test_data_size();
  test_data_size_ = value;
}

// optional uint32 test_data_crc = 4;
inline bool CMsgClientMDSUploadRateTest::has_test_data_crc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMDSUploadRateTest::set_has_test_data_crc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMDSUploadRateTest::clear_has_test_data_crc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMDSUploadRateTest::clear_test_data_crc() {
  test_data_crc_ = 0u;
  clear_has_test_data_crc();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadRateTest::test_data_crc() const {
  return test_data_crc_;
}
inline void CMsgClientMDSUploadRateTest::set_test_data_crc(::google::protobuf::uint32 value) {
  set_has_test_data_crc();
  test_data_crc_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadRateTestResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSUploadRateTestResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadRateTestResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadRateTestResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadRateTestResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSUploadRateTestResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSUploadRateTestResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 serial_number = 2;
inline bool CMsgClientMDSUploadRateTestResponse::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSUploadRateTestResponse::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSUploadRateTestResponse::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSUploadRateTestResponse::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadRateTestResponse::serial_number() const {
  return serial_number_;
}
inline void CMsgClientMDSUploadRateTestResponse::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSTransmitManifestDataChunk

// optional int32 offset = 1;
inline bool CMsgClientMDSTransmitManifestDataChunk::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSTransmitManifestDataChunk::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSTransmitManifestDataChunk::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 CMsgClientMDSTransmitManifestDataChunk::offset() const {
  return offset_;
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional bytes data = 2;
inline bool CMsgClientMDSTransmitManifestDataChunk::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSTransmitManifestDataChunk::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSTransmitManifestDataChunk::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientMDSTransmitManifestDataChunk::data() const {
  return *data_;
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSTransmitManifestDataChunk::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientMDSTransmitManifestDataChunk::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSTransmitManifestDataChunk::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadManifestRequest

// optional uint32 depot_id = 1;
inline bool CMsgClientMDSUploadManifestRequest::has_depot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadManifestRequest::set_has_depot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestRequest::depot_id() const {
  return depot_id_;
}
inline void CMsgClientMDSUploadManifestRequest::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional uint32 manifest_size_compressed = 2;
inline bool CMsgClientMDSUploadManifestRequest::has_manifest_size_compressed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSUploadManifestRequest::set_has_manifest_size_compressed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_has_manifest_size_compressed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_manifest_size_compressed() {
  manifest_size_compressed_ = 0u;
  clear_has_manifest_size_compressed();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestRequest::manifest_size_compressed() const {
  return manifest_size_compressed_;
}
inline void CMsgClientMDSUploadManifestRequest::set_manifest_size_compressed(::google::protobuf::uint32 value) {
  set_has_manifest_size_compressed();
  manifest_size_compressed_ = value;
}

// optional bool make_public = 4;
inline bool CMsgClientMDSUploadManifestRequest::has_make_public() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSUploadManifestRequest::set_has_make_public() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_has_make_public() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_make_public() {
  make_public_ = false;
  clear_has_make_public();
}
inline bool CMsgClientMDSUploadManifestRequest::make_public() const {
  return make_public_;
}
inline void CMsgClientMDSUploadManifestRequest::set_make_public(bool value) {
  set_has_make_public();
  make_public_ = value;
}

// optional uint32 build_id = 6;
inline bool CMsgClientMDSUploadManifestRequest::has_build_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMDSUploadManifestRequest::set_has_build_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_has_build_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_build_id() {
  build_id_ = 0u;
  clear_has_build_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestRequest::build_id() const {
  return build_id_;
}
inline void CMsgClientMDSUploadManifestRequest::set_build_id(::google::protobuf::uint32 value) {
  set_has_build_id();
  build_id_ = value;
}

// optional uint32 manifest_version = 7;
inline bool CMsgClientMDSUploadManifestRequest::has_manifest_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMDSUploadManifestRequest::set_has_manifest_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_has_manifest_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_manifest_version() {
  manifest_version_ = 0u;
  clear_has_manifest_version();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestRequest::manifest_version() const {
  return manifest_version_;
}
inline void CMsgClientMDSUploadManifestRequest::set_manifest_version(::google::protobuf::uint32 value) {
  set_has_manifest_version();
  manifest_version_ = value;
}

// optional bool local_cs_build = 9;
inline bool CMsgClientMDSUploadManifestRequest::has_local_cs_build() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMDSUploadManifestRequest::set_has_local_cs_build() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_has_local_cs_build() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMDSUploadManifestRequest::clear_local_cs_build() {
  local_cs_build_ = false;
  clear_has_local_cs_build();
}
inline bool CMsgClientMDSUploadManifestRequest::local_cs_build() const {
  return local_cs_build_;
}
inline void CMsgClientMDSUploadManifestRequest::set_local_cs_build(bool value) {
  set_has_local_cs_build();
  local_cs_build_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSUploadManifestResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSUploadManifestResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSUploadManifestResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSUploadManifestResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed64 new_manifest = 2;
inline bool CMsgClientMDSUploadManifestResponse::has_new_manifest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_new_manifest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_new_manifest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_new_manifest() {
  new_manifest_ = GOOGLE_ULONGLONG(0);
  clear_has_new_manifest();
}
inline ::google::protobuf::uint64 CMsgClientMDSUploadManifestResponse::new_manifest() const {
  return new_manifest_;
}
inline void CMsgClientMDSUploadManifestResponse::set_new_manifest(::google::protobuf::uint64 value) {
  set_has_new_manifest();
  new_manifest_ = value;
}

// optional uint32 unique_chunks = 3;
inline bool CMsgClientMDSUploadManifestResponse::has_unique_chunks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_unique_chunks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_unique_chunks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_unique_chunks() {
  unique_chunks_ = 0u;
  clear_has_unique_chunks();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestResponse::unique_chunks() const {
  return unique_chunks_;
}
inline void CMsgClientMDSUploadManifestResponse::set_unique_chunks(::google::protobuf::uint32 value) {
  set_has_unique_chunks();
  unique_chunks_ = value;
}

// optional uint32 missing_chunks = 4;
inline bool CMsgClientMDSUploadManifestResponse::has_missing_chunks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_missing_chunks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_missing_chunks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_missing_chunks() {
  missing_chunks_ = 0u;
  clear_has_missing_chunks();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestResponse::missing_chunks() const {
  return missing_chunks_;
}
inline void CMsgClientMDSUploadManifestResponse::set_missing_chunks(::google::protobuf::uint32 value) {
  set_has_missing_chunks();
  missing_chunks_ = value;
}

// optional uint32 bitstring_size_uncompressed = 5;
inline bool CMsgClientMDSUploadManifestResponse::has_bitstring_size_uncompressed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_bitstring_size_uncompressed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_bitstring_size_uncompressed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_bitstring_size_uncompressed() {
  bitstring_size_uncompressed_ = 0u;
  clear_has_bitstring_size_uncompressed();
}
inline ::google::protobuf::uint32 CMsgClientMDSUploadManifestResponse::bitstring_size_uncompressed() const {
  return bitstring_size_uncompressed_;
}
inline void CMsgClientMDSUploadManifestResponse::set_bitstring_size_uncompressed(::google::protobuf::uint32 value) {
  set_has_bitstring_size_uncompressed();
  bitstring_size_uncompressed_ = value;
}

// optional bytes bitstring = 6;
inline bool CMsgClientMDSUploadManifestResponse::has_bitstring() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_bitstring() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_bitstring() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_bitstring() {
  if (bitstring_ != &::google::protobuf::internal::kEmptyString) {
    bitstring_->clear();
  }
  clear_has_bitstring();
}
inline const ::std::string& CMsgClientMDSUploadManifestResponse::bitstring() const {
  return *bitstring_;
}
inline void CMsgClientMDSUploadManifestResponse::set_bitstring(const ::std::string& value) {
  set_has_bitstring();
  if (bitstring_ == &::google::protobuf::internal::kEmptyString) {
    bitstring_ = new ::std::string;
  }
  bitstring_->assign(value);
}
inline void CMsgClientMDSUploadManifestResponse::set_bitstring(const char* value) {
  set_has_bitstring();
  if (bitstring_ == &::google::protobuf::internal::kEmptyString) {
    bitstring_ = new ::std::string;
  }
  bitstring_->assign(value);
}
inline void CMsgClientMDSUploadManifestResponse::set_bitstring(const void* value, size_t size) {
  set_has_bitstring();
  if (bitstring_ == &::google::protobuf::internal::kEmptyString) {
    bitstring_ = new ::std::string;
  }
  bitstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSUploadManifestResponse::mutable_bitstring() {
  set_has_bitstring();
  if (bitstring_ == &::google::protobuf::internal::kEmptyString) {
    bitstring_ = new ::std::string;
  }
  return bitstring_;
}
inline ::std::string* CMsgClientMDSUploadManifestResponse::release_bitstring() {
  clear_has_bitstring();
  if (bitstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bitstring_;
    bitstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSUploadManifestResponse::set_allocated_bitstring(::std::string* bitstring) {
  if (bitstring_ != &::google::protobuf::internal::kEmptyString) {
    delete bitstring_;
  }
  if (bitstring) {
    set_has_bitstring();
    bitstring_ = bitstring;
  } else {
    clear_has_bitstring();
    bitstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_prev_manifest = 7;
inline bool CMsgClientMDSUploadManifestResponse::has_is_prev_manifest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientMDSUploadManifestResponse::set_has_is_prev_manifest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_has_is_prev_manifest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientMDSUploadManifestResponse::clear_is_prev_manifest() {
  is_prev_manifest_ = false;
  clear_has_is_prev_manifest();
}
inline bool CMsgClientMDSUploadManifestResponse::is_prev_manifest() const {
  return is_prev_manifest_;
}
inline void CMsgClientMDSUploadManifestResponse::set_is_prev_manifest(bool value) {
  set_has_is_prev_manifest();
  is_prev_manifest_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSGetDepotManifest

// optional uint32 depot_id = 1;
inline bool CMsgClientMDSGetDepotManifest::has_depot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSGetDepotManifest::set_has_depot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSGetDepotManifest::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSGetDepotManifest::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSGetDepotManifest::depot_id() const {
  return depot_id_;
}
inline void CMsgClientMDSGetDepotManifest::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional fixed64 manifest_id = 2;
inline bool CMsgClientMDSGetDepotManifest::has_manifest_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSGetDepotManifest::set_has_manifest_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSGetDepotManifest::clear_has_manifest_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSGetDepotManifest::clear_manifest_id() {
  manifest_id_ = GOOGLE_ULONGLONG(0);
  clear_has_manifest_id();
}
inline ::google::protobuf::uint64 CMsgClientMDSGetDepotManifest::manifest_id() const {
  return manifest_id_;
}
inline void CMsgClientMDSGetDepotManifest::set_manifest_id(::google::protobuf::uint64 value) {
  set_has_manifest_id();
  manifest_id_ = value;
}

// optional uint32 manifest_version = 3;
inline bool CMsgClientMDSGetDepotManifest::has_manifest_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSGetDepotManifest::set_has_manifest_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSGetDepotManifest::clear_has_manifest_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSGetDepotManifest::clear_manifest_version() {
  manifest_version_ = 0u;
  clear_has_manifest_version();
}
inline ::google::protobuf::uint32 CMsgClientMDSGetDepotManifest::manifest_version() const {
  return manifest_version_;
}
inline void CMsgClientMDSGetDepotManifest::set_manifest_version(::google::protobuf::uint32 value) {
  set_has_manifest_version();
  manifest_version_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSGetDepotManifestResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSGetDepotManifestResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSGetDepotManifestResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSGetDepotManifestResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSGetDepotManifestResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSGetDepotManifestResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSGetDepotManifestResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 manifest_size_compressed = 3;
inline bool CMsgClientMDSGetDepotManifestResponse::has_manifest_size_compressed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSGetDepotManifestResponse::set_has_manifest_size_compressed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSGetDepotManifestResponse::clear_has_manifest_size_compressed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSGetDepotManifestResponse::clear_manifest_size_compressed() {
  manifest_size_compressed_ = 0u;
  clear_has_manifest_size_compressed();
}
inline ::google::protobuf::uint32 CMsgClientMDSGetDepotManifestResponse::manifest_size_compressed() const {
  return manifest_size_compressed_;
}
inline void CMsgClientMDSGetDepotManifestResponse::set_manifest_size_compressed(::google::protobuf::uint32 value) {
  set_has_manifest_size_compressed();
  manifest_size_compressed_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSGetDepotManifestChunk

// optional uint32 offset = 1;
inline bool CMsgClientMDSGetDepotManifestChunk::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSGetDepotManifestChunk::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSGetDepotManifestChunk::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSGetDepotManifestChunk::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CMsgClientMDSGetDepotManifestChunk::offset() const {
  return offset_;
}
inline void CMsgClientMDSGetDepotManifestChunk::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// optional bytes data = 3;
inline bool CMsgClientMDSGetDepotManifestChunk::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSGetDepotManifestChunk::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSGetDepotManifestChunk::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSGetDepotManifestChunk::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientMDSGetDepotManifestChunk::data() const {
  return *data_;
}
inline void CMsgClientMDSGetDepotManifestChunk::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSGetDepotManifestChunk::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSGetDepotManifestChunk::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSGetDepotManifestChunk::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientMDSGetDepotManifestChunk::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSGetDepotManifestChunk::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMDSRegisterAppBuild

// optional int32 app_id = 1;
inline bool CMsgClientMDSRegisterAppBuild::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSRegisterAppBuild::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSRegisterAppBuild::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSRegisterAppBuild::clear_app_id() {
  app_id_ = 0;
  clear_has_app_id();
}
inline ::google::protobuf::int32 CMsgClientMDSRegisterAppBuild::app_id() const {
  return app_id_;
}
inline void CMsgClientMDSRegisterAppBuild::set_app_id(::google::protobuf::int32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string description = 2;
inline bool CMsgClientMDSRegisterAppBuild::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSRegisterAppBuild::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSRegisterAppBuild::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSRegisterAppBuild::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CMsgClientMDSRegisterAppBuild::description() const {
  return *description_;
}
inline void CMsgClientMDSRegisterAppBuild::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientMDSRegisterAppBuild::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMsgClientMDSRegisterAppBuild::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSRegisterAppBuild::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CMsgClientMDSRegisterAppBuild::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSRegisterAppBuild::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool for_local_cs = 5;
inline bool CMsgClientMDSRegisterAppBuild::has_for_local_cs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSRegisterAppBuild::set_has_for_local_cs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSRegisterAppBuild::clear_has_for_local_cs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSRegisterAppBuild::clear_for_local_cs() {
  for_local_cs_ = false;
  clear_has_for_local_cs();
}
inline bool CMsgClientMDSRegisterAppBuild::for_local_cs() const {
  return for_local_cs_;
}
inline void CMsgClientMDSRegisterAppBuild::set_for_local_cs(bool value) {
  set_has_for_local_cs();
  for_local_cs_ = value;
}

// -------------------------------------------------------------------

// CMsgClientMDSRegisterAppBuildResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSRegisterAppBuildResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSRegisterAppBuildResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSRegisterAppBuildResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSRegisterAppBuildResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSRegisterAppBuildResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSRegisterAppBuildResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 build_id = 2;
inline bool CMsgClientMDSRegisterAppBuildResponse::has_build_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSRegisterAppBuildResponse::set_has_build_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSRegisterAppBuildResponse::clear_has_build_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSRegisterAppBuildResponse::clear_build_id() {
  build_id_ = 0u;
  clear_has_build_id();
}
inline ::google::protobuf::uint32 CMsgClientMDSRegisterAppBuildResponse::build_id() const {
  return build_id_;
}
inline void CMsgClientMDSRegisterAppBuildResponse::set_build_id(::google::protobuf::uint32 value) {
  set_has_build_id();
  build_id_ = value;
}

// -------------------------------------------------------------------

// CMsgMDSSetAppBuildLive

// optional uint32 build_id = 1;
inline bool CMsgMDSSetAppBuildLive::has_build_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgMDSSetAppBuildLive::set_has_build_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgMDSSetAppBuildLive::clear_has_build_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgMDSSetAppBuildLive::clear_build_id() {
  build_id_ = 0u;
  clear_has_build_id();
}
inline ::google::protobuf::uint32 CMsgMDSSetAppBuildLive::build_id() const {
  return build_id_;
}
inline void CMsgMDSSetAppBuildLive::set_build_id(::google::protobuf::uint32 value) {
  set_has_build_id();
  build_id_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgMDSSetAppBuildLive::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgMDSSetAppBuildLive::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgMDSSetAppBuildLive::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgMDSSetAppBuildLive::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgMDSSetAppBuildLive::app_id() const {
  return app_id_;
}
inline void CMsgMDSSetAppBuildLive::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string beta_key = 3;
inline bool CMsgMDSSetAppBuildLive::has_beta_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgMDSSetAppBuildLive::set_has_beta_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgMDSSetAppBuildLive::clear_has_beta_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgMDSSetAppBuildLive::clear_beta_key() {
  if (beta_key_ != &::google::protobuf::internal::kEmptyString) {
    beta_key_->clear();
  }
  clear_has_beta_key();
}
inline const ::std::string& CMsgMDSSetAppBuildLive::beta_key() const {
  return *beta_key_;
}
inline void CMsgMDSSetAppBuildLive::set_beta_key(const ::std::string& value) {
  set_has_beta_key();
  if (beta_key_ == &::google::protobuf::internal::kEmptyString) {
    beta_key_ = new ::std::string;
  }
  beta_key_->assign(value);
}
inline void CMsgMDSSetAppBuildLive::set_beta_key(const char* value) {
  set_has_beta_key();
  if (beta_key_ == &::google::protobuf::internal::kEmptyString) {
    beta_key_ = new ::std::string;
  }
  beta_key_->assign(value);
}
inline void CMsgMDSSetAppBuildLive::set_beta_key(const char* value, size_t size) {
  set_has_beta_key();
  if (beta_key_ == &::google::protobuf::internal::kEmptyString) {
    beta_key_ = new ::std::string;
  }
  beta_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgMDSSetAppBuildLive::mutable_beta_key() {
  set_has_beta_key();
  if (beta_key_ == &::google::protobuf::internal::kEmptyString) {
    beta_key_ = new ::std::string;
  }
  return beta_key_;
}
inline ::std::string* CMsgMDSSetAppBuildLive::release_beta_key() {
  clear_has_beta_key();
  if (beta_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beta_key_;
    beta_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgMDSSetAppBuildLive::set_allocated_beta_key(::std::string* beta_key) {
  if (beta_key_ != &::google::protobuf::internal::kEmptyString) {
    delete beta_key_;
  }
  if (beta_key) {
    set_has_beta_key();
    beta_key_ = beta_key;
  } else {
    clear_has_beta_key();
    beta_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string beta_password = 5;
inline bool CMsgMDSSetAppBuildLive::has_beta_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgMDSSetAppBuildLive::set_has_beta_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgMDSSetAppBuildLive::clear_has_beta_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgMDSSetAppBuildLive::clear_beta_password() {
  if (beta_password_ != &::google::protobuf::internal::kEmptyString) {
    beta_password_->clear();
  }
  clear_has_beta_password();
}
inline const ::std::string& CMsgMDSSetAppBuildLive::beta_password() const {
  return *beta_password_;
}
inline void CMsgMDSSetAppBuildLive::set_beta_password(const ::std::string& value) {
  set_has_beta_password();
  if (beta_password_ == &::google::protobuf::internal::kEmptyString) {
    beta_password_ = new ::std::string;
  }
  beta_password_->assign(value);
}
inline void CMsgMDSSetAppBuildLive::set_beta_password(const char* value) {
  set_has_beta_password();
  if (beta_password_ == &::google::protobuf::internal::kEmptyString) {
    beta_password_ = new ::std::string;
  }
  beta_password_->assign(value);
}
inline void CMsgMDSSetAppBuildLive::set_beta_password(const char* value, size_t size) {
  set_has_beta_password();
  if (beta_password_ == &::google::protobuf::internal::kEmptyString) {
    beta_password_ = new ::std::string;
  }
  beta_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgMDSSetAppBuildLive::mutable_beta_password() {
  set_has_beta_password();
  if (beta_password_ == &::google::protobuf::internal::kEmptyString) {
    beta_password_ = new ::std::string;
  }
  return beta_password_;
}
inline ::std::string* CMsgMDSSetAppBuildLive::release_beta_password() {
  clear_has_beta_password();
  if (beta_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beta_password_;
    beta_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgMDSSetAppBuildLive::set_allocated_beta_password(::std::string* beta_password) {
  if (beta_password_ != &::google::protobuf::internal::kEmptyString) {
    delete beta_password_;
  }
  if (beta_password) {
    set_has_beta_password();
    beta_password_ = beta_password;
  } else {
    clear_has_beta_password();
    beta_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool only_finish = 6;
inline bool CMsgMDSSetAppBuildLive::has_only_finish() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgMDSSetAppBuildLive::set_has_only_finish() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgMDSSetAppBuildLive::clear_has_only_finish() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgMDSSetAppBuildLive::clear_only_finish() {
  only_finish_ = false;
  clear_has_only_finish();
}
inline bool CMsgMDSSetAppBuildLive::only_finish() const {
  return only_finish_;
}
inline void CMsgMDSSetAppBuildLive::set_only_finish(bool value) {
  set_has_only_finish();
  only_finish_ = value;
}

// optional uint32 num_skip_depots = 7;
inline bool CMsgMDSSetAppBuildLive::has_num_skip_depots() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgMDSSetAppBuildLive::set_has_num_skip_depots() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgMDSSetAppBuildLive::clear_has_num_skip_depots() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgMDSSetAppBuildLive::clear_num_skip_depots() {
  num_skip_depots_ = 0u;
  clear_has_num_skip_depots();
}
inline ::google::protobuf::uint32 CMsgMDSSetAppBuildLive::num_skip_depots() const {
  return num_skip_depots_;
}
inline void CMsgMDSSetAppBuildLive::set_num_skip_depots(::google::protobuf::uint32 value) {
  set_has_num_skip_depots();
  num_skip_depots_ = value;
}

// -------------------------------------------------------------------

// CMsgMDSSetAppBuildLiveResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgMDSSetAppBuildLiveResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgMDSSetAppBuildLiveResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgMDSSetAppBuildLiveResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgMDSSetAppBuildLiveResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgMDSSetAppBuildLiveResponse::eresult() const {
  return eresult_;
}
inline void CMsgMDSSetAppBuildLiveResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string error_string = 2;
inline bool CMsgMDSSetAppBuildLiveResponse::has_error_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgMDSSetAppBuildLiveResponse::set_has_error_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgMDSSetAppBuildLiveResponse::clear_has_error_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgMDSSetAppBuildLiveResponse::clear_error_string() {
  if (error_string_ != &::google::protobuf::internal::kEmptyString) {
    error_string_->clear();
  }
  clear_has_error_string();
}
inline const ::std::string& CMsgMDSSetAppBuildLiveResponse::error_string() const {
  return *error_string_;
}
inline void CMsgMDSSetAppBuildLiveResponse::set_error_string(const ::std::string& value) {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  error_string_->assign(value);
}
inline void CMsgMDSSetAppBuildLiveResponse::set_error_string(const char* value) {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  error_string_->assign(value);
}
inline void CMsgMDSSetAppBuildLiveResponse::set_error_string(const char* value, size_t size) {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  error_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgMDSSetAppBuildLiveResponse::mutable_error_string() {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  return error_string_;
}
inline ::std::string* CMsgMDSSetAppBuildLiveResponse::release_error_string() {
  clear_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_string_;
    error_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgMDSSetAppBuildLiveResponse::set_allocated_error_string(::std::string* error_string) {
  if (error_string_ != &::google::protobuf::internal::kEmptyString) {
    delete error_string_;
  }
  if (error_string) {
    set_has_error_string();
    error_string_ = error_string;
  } else {
    clear_has_error_string();
    error_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMDSSignInstallScript

// optional int32 depot_id = 1;
inline bool CMsgClientMDSSignInstallScript::has_depot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSSignInstallScript::set_has_depot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSSignInstallScript::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSSignInstallScript::clear_depot_id() {
  depot_id_ = 0;
  clear_has_depot_id();
}
inline ::google::protobuf::int32 CMsgClientMDSSignInstallScript::depot_id() const {
  return depot_id_;
}
inline void CMsgClientMDSSignInstallScript::set_depot_id(::google::protobuf::int32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional string data = 2;
inline bool CMsgClientMDSSignInstallScript::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSSignInstallScript::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSSignInstallScript::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSSignInstallScript::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientMDSSignInstallScript::data() const {
  return *data_;
}
inline void CMsgClientMDSSignInstallScript::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSSignInstallScript::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSSignInstallScript::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSSignInstallScript::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientMDSSignInstallScript::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSSignInstallScript::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientMDSSignInstallScriptResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientMDSSignInstallScriptResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientMDSSignInstallScriptResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientMDSSignInstallScriptResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientMDSSignInstallScriptResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientMDSSignInstallScriptResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientMDSSignInstallScriptResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string error_string = 2;
inline bool CMsgClientMDSSignInstallScriptResponse::has_error_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientMDSSignInstallScriptResponse::set_has_error_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientMDSSignInstallScriptResponse::clear_has_error_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientMDSSignInstallScriptResponse::clear_error_string() {
  if (error_string_ != &::google::protobuf::internal::kEmptyString) {
    error_string_->clear();
  }
  clear_has_error_string();
}
inline const ::std::string& CMsgClientMDSSignInstallScriptResponse::error_string() const {
  return *error_string_;
}
inline void CMsgClientMDSSignInstallScriptResponse::set_error_string(const ::std::string& value) {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  error_string_->assign(value);
}
inline void CMsgClientMDSSignInstallScriptResponse::set_error_string(const char* value) {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  error_string_->assign(value);
}
inline void CMsgClientMDSSignInstallScriptResponse::set_error_string(const char* value, size_t size) {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  error_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSSignInstallScriptResponse::mutable_error_string() {
  set_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    error_string_ = new ::std::string;
  }
  return error_string_;
}
inline ::std::string* CMsgClientMDSSignInstallScriptResponse::release_error_string() {
  clear_has_error_string();
  if (error_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_string_;
    error_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSSignInstallScriptResponse::set_allocated_error_string(::std::string* error_string) {
  if (error_string_ != &::google::protobuf::internal::kEmptyString) {
    delete error_string_;
  }
  if (error_string) {
    set_has_error_string();
    error_string_ = error_string;
  } else {
    clear_has_error_string();
    error_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data = 3;
inline bool CMsgClientMDSSignInstallScriptResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientMDSSignInstallScriptResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientMDSSignInstallScriptResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientMDSSignInstallScriptResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientMDSSignInstallScriptResponse::data() const {
  return *data_;
}
inline void CMsgClientMDSSignInstallScriptResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSSignInstallScriptResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientMDSSignInstallScriptResponse::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientMDSSignInstallScriptResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientMDSSignInstallScriptResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientMDSSignInstallScriptResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientEmailChange

// optional string password = 1;
inline bool CMsgClientEmailChange::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientEmailChange::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientEmailChange::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientEmailChange::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgClientEmailChange::password() const {
  return *password_;
}
inline void CMsgClientEmailChange::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CMsgClientEmailChange::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CMsgClientEmailChange::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientEmailChange::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CMsgClientEmailChange::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientEmailChange::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 2;
inline bool CMsgClientEmailChange::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientEmailChange::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientEmailChange::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientEmailChange::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& CMsgClientEmailChange::email() const {
  return *email_;
}
inline void CMsgClientEmailChange::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CMsgClientEmailChange::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CMsgClientEmailChange::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientEmailChange::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* CMsgClientEmailChange::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientEmailChange::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string code = 3;
inline bool CMsgClientEmailChange::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientEmailChange::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientEmailChange::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientEmailChange::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& CMsgClientEmailChange::code() const {
  return *code_;
}
inline void CMsgClientEmailChange::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void CMsgClientEmailChange::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void CMsgClientEmailChange::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientEmailChange::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* CMsgClientEmailChange::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientEmailChange::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool final = 4;
inline bool CMsgClientEmailChange::has_final() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientEmailChange::set_has_final() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientEmailChange::clear_has_final() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientEmailChange::clear_final() {
  final_ = false;
  clear_has_final();
}
inline bool CMsgClientEmailChange::final() const {
  return final_;
}
inline void CMsgClientEmailChange::set_final(bool value) {
  set_has_final();
  final_ = value;
}

// optional bool newmethod = 5;
inline bool CMsgClientEmailChange::has_newmethod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientEmailChange::set_has_newmethod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientEmailChange::clear_has_newmethod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientEmailChange::clear_newmethod() {
  newmethod_ = false;
  clear_has_newmethod();
}
inline bool CMsgClientEmailChange::newmethod() const {
  return newmethod_;
}
inline void CMsgClientEmailChange::set_newmethod(bool value) {
  set_has_newmethod();
  newmethod_ = value;
}

// -------------------------------------------------------------------

// CMsgClientEmailChangeResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientEmailChangeResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientEmailChangeResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientEmailChangeResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientEmailChangeResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientEmailChangeResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientEmailChangeResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetCDNAuthToken

// optional uint32 app_id = 1;
inline bool CMsgClientGetCDNAuthToken::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetCDNAuthToken::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetCDNAuthToken::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetCDNAuthToken::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGetCDNAuthToken::app_id() const {
  return app_id_;
}
inline void CMsgClientGetCDNAuthToken::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string host_name = 2;
inline bool CMsgClientGetCDNAuthToken::has_host_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetCDNAuthToken::set_has_host_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetCDNAuthToken::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetCDNAuthToken::clear_host_name() {
  if (host_name_ != &::google::protobuf::internal::kEmptyString) {
    host_name_->clear();
  }
  clear_has_host_name();
}
inline const ::std::string& CMsgClientGetCDNAuthToken::host_name() const {
  return *host_name_;
}
inline void CMsgClientGetCDNAuthToken::set_host_name(const ::std::string& value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
}
inline void CMsgClientGetCDNAuthToken::set_host_name(const char* value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
}
inline void CMsgClientGetCDNAuthToken::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetCDNAuthToken::mutable_host_name() {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    host_name_ = new ::std::string;
  }
  return host_name_;
}
inline ::std::string* CMsgClientGetCDNAuthToken::release_host_name() {
  clear_has_host_name();
  if (host_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_name_;
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetCDNAuthToken::set_allocated_host_name(::std::string* host_name) {
  if (host_name_ != &::google::protobuf::internal::kEmptyString) {
    delete host_name_;
  }
  if (host_name) {
    set_has_host_name();
    host_name_ = host_name;
  } else {
    clear_has_host_name();
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientGetDepotDecryptionKey

// optional uint32 depot_id = 1;
inline bool CMsgClientGetDepotDecryptionKey::has_depot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetDepotDecryptionKey::set_has_depot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetDepotDecryptionKey::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetDepotDecryptionKey::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientGetDepotDecryptionKey::depot_id() const {
  return depot_id_;
}
inline void CMsgClientGetDepotDecryptionKey::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientGetDepotDecryptionKey::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetDepotDecryptionKey::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetDepotDecryptionKey::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetDepotDecryptionKey::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGetDepotDecryptionKey::app_id() const {
  return app_id_;
}
inline void CMsgClientGetDepotDecryptionKey::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetDepotDecryptionKeyResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientGetDepotDecryptionKeyResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientGetDepotDecryptionKeyResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 depot_id = 2;
inline bool CMsgClientGetDepotDecryptionKeyResponse::has_depot_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_has_depot_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::clear_has_depot_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::clear_depot_id() {
  depot_id_ = 0u;
  clear_has_depot_id();
}
inline ::google::protobuf::uint32 CMsgClientGetDepotDecryptionKeyResponse::depot_id() const {
  return depot_id_;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_depot_id(::google::protobuf::uint32 value) {
  set_has_depot_id();
  depot_id_ = value;
}

// optional bytes depot_encryption_key = 3;
inline bool CMsgClientGetDepotDecryptionKeyResponse::has_depot_encryption_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_has_depot_encryption_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::clear_has_depot_encryption_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::clear_depot_encryption_key() {
  if (depot_encryption_key_ != &::google::protobuf::internal::kEmptyString) {
    depot_encryption_key_->clear();
  }
  clear_has_depot_encryption_key();
}
inline const ::std::string& CMsgClientGetDepotDecryptionKeyResponse::depot_encryption_key() const {
  return *depot_encryption_key_;
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_depot_encryption_key(const ::std::string& value) {
  set_has_depot_encryption_key();
  if (depot_encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    depot_encryption_key_ = new ::std::string;
  }
  depot_encryption_key_->assign(value);
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_depot_encryption_key(const char* value) {
  set_has_depot_encryption_key();
  if (depot_encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    depot_encryption_key_ = new ::std::string;
  }
  depot_encryption_key_->assign(value);
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_depot_encryption_key(const void* value, size_t size) {
  set_has_depot_encryption_key();
  if (depot_encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    depot_encryption_key_ = new ::std::string;
  }
  depot_encryption_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetDepotDecryptionKeyResponse::mutable_depot_encryption_key() {
  set_has_depot_encryption_key();
  if (depot_encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    depot_encryption_key_ = new ::std::string;
  }
  return depot_encryption_key_;
}
inline ::std::string* CMsgClientGetDepotDecryptionKeyResponse::release_depot_encryption_key() {
  clear_has_depot_encryption_key();
  if (depot_encryption_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = depot_encryption_key_;
    depot_encryption_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetDepotDecryptionKeyResponse::set_allocated_depot_encryption_key(::std::string* depot_encryption_key) {
  if (depot_encryption_key_ != &::google::protobuf::internal::kEmptyString) {
    delete depot_encryption_key_;
  }
  if (depot_encryption_key) {
    set_has_depot_encryption_key();
    depot_encryption_key_ = depot_encryption_key;
  } else {
    clear_has_depot_encryption_key();
    depot_encryption_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientGetAppBetaPasswords

// optional uint32 app_id = 1;
inline bool CMsgClientGetAppBetaPasswords::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetAppBetaPasswords::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetAppBetaPasswords::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetAppBetaPasswords::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGetAppBetaPasswords::app_id() const {
  return app_id_;
}
inline void CMsgClientGetAppBetaPasswords::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetAppBetaPasswordsResponse_BetaPassword

// optional string betaname = 1;
inline bool CMsgClientGetAppBetaPasswordsResponse_BetaPassword::has_betaname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_has_betaname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::clear_has_betaname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::clear_betaname() {
  if (betaname_ != &::google::protobuf::internal::kEmptyString) {
    betaname_->clear();
  }
  clear_has_betaname();
}
inline const ::std::string& CMsgClientGetAppBetaPasswordsResponse_BetaPassword::betaname() const {
  return *betaname_;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_betaname(const ::std::string& value) {
  set_has_betaname();
  if (betaname_ == &::google::protobuf::internal::kEmptyString) {
    betaname_ = new ::std::string;
  }
  betaname_->assign(value);
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_betaname(const char* value) {
  set_has_betaname();
  if (betaname_ == &::google::protobuf::internal::kEmptyString) {
    betaname_ = new ::std::string;
  }
  betaname_->assign(value);
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_betaname(const char* value, size_t size) {
  set_has_betaname();
  if (betaname_ == &::google::protobuf::internal::kEmptyString) {
    betaname_ = new ::std::string;
  }
  betaname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetAppBetaPasswordsResponse_BetaPassword::mutable_betaname() {
  set_has_betaname();
  if (betaname_ == &::google::protobuf::internal::kEmptyString) {
    betaname_ = new ::std::string;
  }
  return betaname_;
}
inline ::std::string* CMsgClientGetAppBetaPasswordsResponse_BetaPassword::release_betaname() {
  clear_has_betaname();
  if (betaname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = betaname_;
    betaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_allocated_betaname(::std::string* betaname) {
  if (betaname_ != &::google::protobuf::internal::kEmptyString) {
    delete betaname_;
  }
  if (betaname) {
    set_has_betaname();
    betaname_ = betaname;
  } else {
    clear_has_betaname();
    betaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string betapassword = 2;
inline bool CMsgClientGetAppBetaPasswordsResponse_BetaPassword::has_betapassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_has_betapassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::clear_has_betapassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::clear_betapassword() {
  if (betapassword_ != &::google::protobuf::internal::kEmptyString) {
    betapassword_->clear();
  }
  clear_has_betapassword();
}
inline const ::std::string& CMsgClientGetAppBetaPasswordsResponse_BetaPassword::betapassword() const {
  return *betapassword_;
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_betapassword(const ::std::string& value) {
  set_has_betapassword();
  if (betapassword_ == &::google::protobuf::internal::kEmptyString) {
    betapassword_ = new ::std::string;
  }
  betapassword_->assign(value);
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_betapassword(const char* value) {
  set_has_betapassword();
  if (betapassword_ == &::google::protobuf::internal::kEmptyString) {
    betapassword_ = new ::std::string;
  }
  betapassword_->assign(value);
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_betapassword(const char* value, size_t size) {
  set_has_betapassword();
  if (betapassword_ == &::google::protobuf::internal::kEmptyString) {
    betapassword_ = new ::std::string;
  }
  betapassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetAppBetaPasswordsResponse_BetaPassword::mutable_betapassword() {
  set_has_betapassword();
  if (betapassword_ == &::google::protobuf::internal::kEmptyString) {
    betapassword_ = new ::std::string;
  }
  return betapassword_;
}
inline ::std::string* CMsgClientGetAppBetaPasswordsResponse_BetaPassword::release_betapassword() {
  clear_has_betapassword();
  if (betapassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = betapassword_;
    betapassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetAppBetaPasswordsResponse_BetaPassword::set_allocated_betapassword(::std::string* betapassword) {
  if (betapassword_ != &::google::protobuf::internal::kEmptyString) {
    delete betapassword_;
  }
  if (betapassword) {
    set_has_betapassword();
    betapassword_ = betapassword;
  } else {
    clear_has_betapassword();
    betapassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientGetAppBetaPasswordsResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientGetAppBetaPasswordsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetAppBetaPasswordsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetAppBetaPasswordsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetAppBetaPasswordsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientGetAppBetaPasswordsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientGetAppBetaPasswordsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgClientGetAppBetaPasswordsResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetAppBetaPasswordsResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetAppBetaPasswordsResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetAppBetaPasswordsResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGetAppBetaPasswordsResponse::app_id() const {
  return app_id_;
}
inline void CMsgClientGetAppBetaPasswordsResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// repeated .Sc.CMsgClientGetAppBetaPasswordsResponse.BetaPassword betapasswords = 3;
inline int CMsgClientGetAppBetaPasswordsResponse::betapasswords_size() const {
  return betapasswords_.size();
}
inline void CMsgClientGetAppBetaPasswordsResponse::clear_betapasswords() {
  betapasswords_.Clear();
}
inline const ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword& CMsgClientGetAppBetaPasswordsResponse::betapasswords(int index) const {
  return betapasswords_.Get(index);
}
inline ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword* CMsgClientGetAppBetaPasswordsResponse::mutable_betapasswords(int index) {
  return betapasswords_.Mutable(index);
}
inline ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword* CMsgClientGetAppBetaPasswordsResponse::add_betapasswords() {
  return betapasswords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword >&
CMsgClientGetAppBetaPasswordsResponse::betapasswords() const {
  return betapasswords_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientGetAppBetaPasswordsResponse_BetaPassword >*
CMsgClientGetAppBetaPasswordsResponse::mutable_betapasswords() {
  return &betapasswords_;
}

// -------------------------------------------------------------------

// CMsgClientUpdateAppJobReport

// optional uint32 app_id = 1;
inline bool CMsgClientUpdateAppJobReport::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUpdateAppJobReport::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::app_id() const {
  return app_id_;
}
inline void CMsgClientUpdateAppJobReport::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// repeated uint32 depot_ids = 2;
inline int CMsgClientUpdateAppJobReport::depot_ids_size() const {
  return depot_ids_.size();
}
inline void CMsgClientUpdateAppJobReport::clear_depot_ids() {
  depot_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::depot_ids(int index) const {
  return depot_ids_.Get(index);
}
inline void CMsgClientUpdateAppJobReport::set_depot_ids(int index, ::google::protobuf::uint32 value) {
  depot_ids_.Set(index, value);
}
inline void CMsgClientUpdateAppJobReport::add_depot_ids(::google::protobuf::uint32 value) {
  depot_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientUpdateAppJobReport::depot_ids() const {
  return depot_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientUpdateAppJobReport::mutable_depot_ids() {
  return &depot_ids_;
}

// optional uint32 app_state = 3;
inline bool CMsgClientUpdateAppJobReport::has_app_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_app_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_app_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUpdateAppJobReport::clear_app_state() {
  app_state_ = 0u;
  clear_has_app_state();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::app_state() const {
  return app_state_;
}
inline void CMsgClientUpdateAppJobReport::set_app_state(::google::protobuf::uint32 value) {
  set_has_app_state();
  app_state_ = value;
}

// optional uint32 job_app_error = 4;
inline bool CMsgClientUpdateAppJobReport::has_job_app_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_job_app_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_job_app_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUpdateAppJobReport::clear_job_app_error() {
  job_app_error_ = 0u;
  clear_has_job_app_error();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::job_app_error() const {
  return job_app_error_;
}
inline void CMsgClientUpdateAppJobReport::set_job_app_error(::google::protobuf::uint32 value) {
  set_has_job_app_error();
  job_app_error_ = value;
}

// optional string error_details = 5;
inline bool CMsgClientUpdateAppJobReport::has_error_details() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_error_details() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUpdateAppJobReport::clear_error_details() {
  if (error_details_ != &::google::protobuf::internal::kEmptyString) {
    error_details_->clear();
  }
  clear_has_error_details();
}
inline const ::std::string& CMsgClientUpdateAppJobReport::error_details() const {
  return *error_details_;
}
inline void CMsgClientUpdateAppJobReport::set_error_details(const ::std::string& value) {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  error_details_->assign(value);
}
inline void CMsgClientUpdateAppJobReport::set_error_details(const char* value) {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  error_details_->assign(value);
}
inline void CMsgClientUpdateAppJobReport::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  error_details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientUpdateAppJobReport::mutable_error_details() {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  return error_details_;
}
inline ::std::string* CMsgClientUpdateAppJobReport::release_error_details() {
  clear_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_details_;
    error_details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientUpdateAppJobReport::set_allocated_error_details(::std::string* error_details) {
  if (error_details_ != &::google::protobuf::internal::kEmptyString) {
    delete error_details_;
  }
  if (error_details) {
    set_has_error_details();
    error_details_ = error_details;
  } else {
    clear_has_error_details();
    error_details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 job_duration = 6;
inline bool CMsgClientUpdateAppJobReport::has_job_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_job_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_job_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientUpdateAppJobReport::clear_job_duration() {
  job_duration_ = 0u;
  clear_has_job_duration();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::job_duration() const {
  return job_duration_;
}
inline void CMsgClientUpdateAppJobReport::set_job_duration(::google::protobuf::uint32 value) {
  set_has_job_duration();
  job_duration_ = value;
}

// optional uint32 files_validation_failed = 7;
inline bool CMsgClientUpdateAppJobReport::has_files_validation_failed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_files_validation_failed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_files_validation_failed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientUpdateAppJobReport::clear_files_validation_failed() {
  files_validation_failed_ = 0u;
  clear_has_files_validation_failed();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::files_validation_failed() const {
  return files_validation_failed_;
}
inline void CMsgClientUpdateAppJobReport::set_files_validation_failed(::google::protobuf::uint32 value) {
  set_has_files_validation_failed();
  files_validation_failed_ = value;
}

// optional uint64 bytes_downloaded = 8;
inline bool CMsgClientUpdateAppJobReport::has_bytes_downloaded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_bytes_downloaded() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_bytes_downloaded() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientUpdateAppJobReport::clear_bytes_downloaded() {
  bytes_downloaded_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_downloaded();
}
inline ::google::protobuf::uint64 CMsgClientUpdateAppJobReport::bytes_downloaded() const {
  return bytes_downloaded_;
}
inline void CMsgClientUpdateAppJobReport::set_bytes_downloaded(::google::protobuf::uint64 value) {
  set_has_bytes_downloaded();
  bytes_downloaded_ = value;
}

// optional uint64 bytes_staged = 9;
inline bool CMsgClientUpdateAppJobReport::has_bytes_staged() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_bytes_staged() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_bytes_staged() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientUpdateAppJobReport::clear_bytes_staged() {
  bytes_staged_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_staged();
}
inline ::google::protobuf::uint64 CMsgClientUpdateAppJobReport::bytes_staged() const {
  return bytes_staged_;
}
inline void CMsgClientUpdateAppJobReport::set_bytes_staged(::google::protobuf::uint64 value) {
  set_has_bytes_staged();
  bytes_staged_ = value;
}

// optional uint64 bytes_comitted = 10;
inline bool CMsgClientUpdateAppJobReport::has_bytes_comitted() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_bytes_comitted() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_bytes_comitted() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientUpdateAppJobReport::clear_bytes_comitted() {
  bytes_comitted_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_comitted();
}
inline ::google::protobuf::uint64 CMsgClientUpdateAppJobReport::bytes_comitted() const {
  return bytes_comitted_;
}
inline void CMsgClientUpdateAppJobReport::set_bytes_comitted(::google::protobuf::uint64 value) {
  set_has_bytes_comitted();
  bytes_comitted_ = value;
}

// optional uint32 start_app_state = 11;
inline bool CMsgClientUpdateAppJobReport::has_start_app_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientUpdateAppJobReport::set_has_start_app_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientUpdateAppJobReport::clear_has_start_app_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientUpdateAppJobReport::clear_start_app_state() {
  start_app_state_ = 0u;
  clear_has_start_app_state();
}
inline ::google::protobuf::uint32 CMsgClientUpdateAppJobReport::start_app_state() const {
  return start_app_state_;
}
inline void CMsgClientUpdateAppJobReport::set_start_app_state(::google::protobuf::uint32 value) {
  set_has_start_app_state();
  start_app_state_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetCDNAuthTokenResponse

// optional uint32 eresult = 1 [default = 2];
inline bool CMsgClientGetCDNAuthTokenResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetCDNAuthTokenResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetCDNAuthTokenResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetCDNAuthTokenResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientGetCDNAuthTokenResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientGetCDNAuthTokenResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string token = 2;
inline bool CMsgClientGetCDNAuthTokenResponse::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGetCDNAuthTokenResponse::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGetCDNAuthTokenResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGetCDNAuthTokenResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgClientGetCDNAuthTokenResponse::token() const {
  return *token_;
}
inline void CMsgClientGetCDNAuthTokenResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientGetCDNAuthTokenResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientGetCDNAuthTokenResponse::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGetCDNAuthTokenResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgClientGetCDNAuthTokenResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGetCDNAuthTokenResponse::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 expiration_time = 3;
inline bool CMsgClientGetCDNAuthTokenResponse::has_expiration_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGetCDNAuthTokenResponse::set_has_expiration_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGetCDNAuthTokenResponse::clear_has_expiration_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGetCDNAuthTokenResponse::clear_expiration_time() {
  expiration_time_ = 0u;
  clear_has_expiration_time();
}
inline ::google::protobuf::uint32 CMsgClientGetCDNAuthTokenResponse::expiration_time() const {
  return expiration_time_;
}
inline void CMsgClientGetCDNAuthTokenResponse::set_expiration_time(::google::protobuf::uint32 value) {
  set_has_expiration_time();
  expiration_time_ = value;
}

// -------------------------------------------------------------------

// CMsgDownloadRateStatistics_StatsInfo

// optional uint32 source_type = 1;
inline bool CMsgDownloadRateStatistics_StatsInfo::has_source_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_has_source_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_has_source_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_source_type() {
  source_type_ = 0u;
  clear_has_source_type();
}
inline ::google::protobuf::uint32 CMsgDownloadRateStatistics_StatsInfo::source_type() const {
  return source_type_;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_source_type(::google::protobuf::uint32 value) {
  set_has_source_type();
  source_type_ = value;
}

// optional uint32 source_id = 2;
inline bool CMsgDownloadRateStatistics_StatsInfo::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 CMsgDownloadRateStatistics_StatsInfo::source_id() const {
  return source_id_;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
}

// optional uint32 seconds = 3;
inline bool CMsgDownloadRateStatistics_StatsInfo::has_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_has_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 CMsgDownloadRateStatistics_StatsInfo::seconds() const {
  return seconds_;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// optional uint64 bytes = 4;
inline bool CMsgDownloadRateStatistics_StatsInfo::has_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_has_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDownloadRateStatistics_StatsInfo::clear_bytes() {
  bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes();
}
inline ::google::protobuf::uint64 CMsgDownloadRateStatistics_StatsInfo::bytes() const {
  return bytes_;
}
inline void CMsgDownloadRateStatistics_StatsInfo::set_bytes(::google::protobuf::uint64 value) {
  set_has_bytes();
  bytes_ = value;
}

// -------------------------------------------------------------------

// CMsgDownloadRateStatistics

// optional uint32 cell_id = 1;
inline bool CMsgDownloadRateStatistics::has_cell_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDownloadRateStatistics::set_has_cell_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDownloadRateStatistics::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDownloadRateStatistics::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgDownloadRateStatistics::cell_id() const {
  return cell_id_;
}
inline void CMsgDownloadRateStatistics::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// repeated .Sc.CMsgDownloadRateStatistics.StatsInfo stats = 2;
inline int CMsgDownloadRateStatistics::stats_size() const {
  return stats_.size();
}
inline void CMsgDownloadRateStatistics::clear_stats() {
  stats_.Clear();
}
inline const ::Sc::CMsgDownloadRateStatistics_StatsInfo& CMsgDownloadRateStatistics::stats(int index) const {
  return stats_.Get(index);
}
inline ::Sc::CMsgDownloadRateStatistics_StatsInfo* CMsgDownloadRateStatistics::mutable_stats(int index) {
  return stats_.Mutable(index);
}
inline ::Sc::CMsgDownloadRateStatistics_StatsInfo* CMsgDownloadRateStatistics::add_stats() {
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgDownloadRateStatistics_StatsInfo >&
CMsgDownloadRateStatistics::stats() const {
  return stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgDownloadRateStatistics_StatsInfo >*
CMsgDownloadRateStatistics::mutable_stats() {
  return &stats_;
}

// -------------------------------------------------------------------

// CMsgClientRequestAccountData

// optional string account_or_email = 1;
inline bool CMsgClientRequestAccountData::has_account_or_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestAccountData::set_has_account_or_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestAccountData::clear_has_account_or_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestAccountData::clear_account_or_email() {
  if (account_or_email_ != &::google::protobuf::internal::kEmptyString) {
    account_or_email_->clear();
  }
  clear_has_account_or_email();
}
inline const ::std::string& CMsgClientRequestAccountData::account_or_email() const {
  return *account_or_email_;
}
inline void CMsgClientRequestAccountData::set_account_or_email(const ::std::string& value) {
  set_has_account_or_email();
  if (account_or_email_ == &::google::protobuf::internal::kEmptyString) {
    account_or_email_ = new ::std::string;
  }
  account_or_email_->assign(value);
}
inline void CMsgClientRequestAccountData::set_account_or_email(const char* value) {
  set_has_account_or_email();
  if (account_or_email_ == &::google::protobuf::internal::kEmptyString) {
    account_or_email_ = new ::std::string;
  }
  account_or_email_->assign(value);
}
inline void CMsgClientRequestAccountData::set_account_or_email(const char* value, size_t size) {
  set_has_account_or_email();
  if (account_or_email_ == &::google::protobuf::internal::kEmptyString) {
    account_or_email_ = new ::std::string;
  }
  account_or_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestAccountData::mutable_account_or_email() {
  set_has_account_or_email();
  if (account_or_email_ == &::google::protobuf::internal::kEmptyString) {
    account_or_email_ = new ::std::string;
  }
  return account_or_email_;
}
inline ::std::string* CMsgClientRequestAccountData::release_account_or_email() {
  clear_has_account_or_email();
  if (account_or_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_or_email_;
    account_or_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestAccountData::set_allocated_account_or_email(::std::string* account_or_email) {
  if (account_or_email_ != &::google::protobuf::internal::kEmptyString) {
    delete account_or_email_;
  }
  if (account_or_email) {
    set_has_account_or_email();
    account_or_email_ = account_or_email;
  } else {
    clear_has_account_or_email();
    account_or_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 action = 2;
inline bool CMsgClientRequestAccountData::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestAccountData::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestAccountData::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestAccountData::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 CMsgClientRequestAccountData::action() const {
  return action_;
}
inline void CMsgClientRequestAccountData::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestAccountDataResponse

// optional uint32 action = 1;
inline bool CMsgClientRequestAccountDataResponse::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestAccountDataResponse::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 CMsgClientRequestAccountDataResponse::action() const {
  return action_;
}
inline void CMsgClientRequestAccountDataResponse::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// optional uint32 eresult = 2;
inline bool CMsgClientRequestAccountDataResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestAccountDataResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRequestAccountDataResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestAccountDataResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string account_name = 3;
inline bool CMsgClientRequestAccountDataResponse::has_account_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_account_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_account_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientRequestAccountDataResponse::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& CMsgClientRequestAccountDataResponse::account_name() const {
  return *account_name_;
}
inline void CMsgClientRequestAccountDataResponse::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name(const char* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestAccountDataResponse::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  return account_name_;
}
inline ::std::string* CMsgClientRequestAccountDataResponse::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestAccountDataResponse::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ct_matches = 4;
inline bool CMsgClientRequestAccountDataResponse::has_ct_matches() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_ct_matches() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_ct_matches() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientRequestAccountDataResponse::clear_ct_matches() {
  ct_matches_ = 0u;
  clear_has_ct_matches();
}
inline ::google::protobuf::uint32 CMsgClientRequestAccountDataResponse::ct_matches() const {
  return ct_matches_;
}
inline void CMsgClientRequestAccountDataResponse::set_ct_matches(::google::protobuf::uint32 value) {
  set_has_ct_matches();
  ct_matches_ = value;
}

// optional string account_name_suggestion1 = 5;
inline bool CMsgClientRequestAccountDataResponse::has_account_name_suggestion1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_account_name_suggestion1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_account_name_suggestion1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientRequestAccountDataResponse::clear_account_name_suggestion1() {
  if (account_name_suggestion1_ != &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion1_->clear();
  }
  clear_has_account_name_suggestion1();
}
inline const ::std::string& CMsgClientRequestAccountDataResponse::account_name_suggestion1() const {
  return *account_name_suggestion1_;
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion1(const ::std::string& value) {
  set_has_account_name_suggestion1();
  if (account_name_suggestion1_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion1_ = new ::std::string;
  }
  account_name_suggestion1_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion1(const char* value) {
  set_has_account_name_suggestion1();
  if (account_name_suggestion1_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion1_ = new ::std::string;
  }
  account_name_suggestion1_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion1(const char* value, size_t size) {
  set_has_account_name_suggestion1();
  if (account_name_suggestion1_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion1_ = new ::std::string;
  }
  account_name_suggestion1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestAccountDataResponse::mutable_account_name_suggestion1() {
  set_has_account_name_suggestion1();
  if (account_name_suggestion1_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion1_ = new ::std::string;
  }
  return account_name_suggestion1_;
}
inline ::std::string* CMsgClientRequestAccountDataResponse::release_account_name_suggestion1() {
  clear_has_account_name_suggestion1();
  if (account_name_suggestion1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_suggestion1_;
    account_name_suggestion1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestAccountDataResponse::set_allocated_account_name_suggestion1(::std::string* account_name_suggestion1) {
  if (account_name_suggestion1_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_suggestion1_;
  }
  if (account_name_suggestion1) {
    set_has_account_name_suggestion1();
    account_name_suggestion1_ = account_name_suggestion1;
  } else {
    clear_has_account_name_suggestion1();
    account_name_suggestion1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account_name_suggestion2 = 6;
inline bool CMsgClientRequestAccountDataResponse::has_account_name_suggestion2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_account_name_suggestion2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_account_name_suggestion2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientRequestAccountDataResponse::clear_account_name_suggestion2() {
  if (account_name_suggestion2_ != &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion2_->clear();
  }
  clear_has_account_name_suggestion2();
}
inline const ::std::string& CMsgClientRequestAccountDataResponse::account_name_suggestion2() const {
  return *account_name_suggestion2_;
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion2(const ::std::string& value) {
  set_has_account_name_suggestion2();
  if (account_name_suggestion2_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion2_ = new ::std::string;
  }
  account_name_suggestion2_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion2(const char* value) {
  set_has_account_name_suggestion2();
  if (account_name_suggestion2_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion2_ = new ::std::string;
  }
  account_name_suggestion2_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion2(const char* value, size_t size) {
  set_has_account_name_suggestion2();
  if (account_name_suggestion2_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion2_ = new ::std::string;
  }
  account_name_suggestion2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestAccountDataResponse::mutable_account_name_suggestion2() {
  set_has_account_name_suggestion2();
  if (account_name_suggestion2_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion2_ = new ::std::string;
  }
  return account_name_suggestion2_;
}
inline ::std::string* CMsgClientRequestAccountDataResponse::release_account_name_suggestion2() {
  clear_has_account_name_suggestion2();
  if (account_name_suggestion2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_suggestion2_;
    account_name_suggestion2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestAccountDataResponse::set_allocated_account_name_suggestion2(::std::string* account_name_suggestion2) {
  if (account_name_suggestion2_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_suggestion2_;
  }
  if (account_name_suggestion2) {
    set_has_account_name_suggestion2();
    account_name_suggestion2_ = account_name_suggestion2;
  } else {
    clear_has_account_name_suggestion2();
    account_name_suggestion2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account_name_suggestion3 = 7;
inline bool CMsgClientRequestAccountDataResponse::has_account_name_suggestion3() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientRequestAccountDataResponse::set_has_account_name_suggestion3() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientRequestAccountDataResponse::clear_has_account_name_suggestion3() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientRequestAccountDataResponse::clear_account_name_suggestion3() {
  if (account_name_suggestion3_ != &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion3_->clear();
  }
  clear_has_account_name_suggestion3();
}
inline const ::std::string& CMsgClientRequestAccountDataResponse::account_name_suggestion3() const {
  return *account_name_suggestion3_;
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion3(const ::std::string& value) {
  set_has_account_name_suggestion3();
  if (account_name_suggestion3_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion3_ = new ::std::string;
  }
  account_name_suggestion3_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion3(const char* value) {
  set_has_account_name_suggestion3();
  if (account_name_suggestion3_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion3_ = new ::std::string;
  }
  account_name_suggestion3_->assign(value);
}
inline void CMsgClientRequestAccountDataResponse::set_account_name_suggestion3(const char* value, size_t size) {
  set_has_account_name_suggestion3();
  if (account_name_suggestion3_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion3_ = new ::std::string;
  }
  account_name_suggestion3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestAccountDataResponse::mutable_account_name_suggestion3() {
  set_has_account_name_suggestion3();
  if (account_name_suggestion3_ == &::google::protobuf::internal::kEmptyString) {
    account_name_suggestion3_ = new ::std::string;
  }
  return account_name_suggestion3_;
}
inline ::std::string* CMsgClientRequestAccountDataResponse::release_account_name_suggestion3() {
  clear_has_account_name_suggestion3();
  if (account_name_suggestion3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_suggestion3_;
    account_name_suggestion3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestAccountDataResponse::set_allocated_account_name_suggestion3(::std::string* account_name_suggestion3) {
  if (account_name_suggestion3_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_suggestion3_;
  }
  if (account_name_suggestion3) {
    set_has_account_name_suggestion3();
    account_name_suggestion3_ = account_name_suggestion3;
  } else {
    clear_has_account_name_suggestion3();
    account_name_suggestion3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUGSGetGlobalStats

// optional uint64 gameid = 1;
inline bool CMsgClientUGSGetGlobalStats::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUGSGetGlobalStats::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUGSGetGlobalStats::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUGSGetGlobalStats::clear_gameid() {
  gameid_ = GOOGLE_ULONGLONG(0);
  clear_has_gameid();
}
inline ::google::protobuf::uint64 CMsgClientUGSGetGlobalStats::gameid() const {
  return gameid_;
}
inline void CMsgClientUGSGetGlobalStats::set_gameid(::google::protobuf::uint64 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 history_days_requested = 2;
inline bool CMsgClientUGSGetGlobalStats::has_history_days_requested() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUGSGetGlobalStats::set_has_history_days_requested() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUGSGetGlobalStats::clear_has_history_days_requested() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUGSGetGlobalStats::clear_history_days_requested() {
  history_days_requested_ = 0u;
  clear_has_history_days_requested();
}
inline ::google::protobuf::uint32 CMsgClientUGSGetGlobalStats::history_days_requested() const {
  return history_days_requested_;
}
inline void CMsgClientUGSGetGlobalStats::set_history_days_requested(::google::protobuf::uint32 value) {
  set_has_history_days_requested();
  history_days_requested_ = value;
}

// optional fixed32 time_last_requested = 3;
inline bool CMsgClientUGSGetGlobalStats::has_time_last_requested() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUGSGetGlobalStats::set_has_time_last_requested() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUGSGetGlobalStats::clear_has_time_last_requested() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUGSGetGlobalStats::clear_time_last_requested() {
  time_last_requested_ = 0u;
  clear_has_time_last_requested();
}
inline ::google::protobuf::uint32 CMsgClientUGSGetGlobalStats::time_last_requested() const {
  return time_last_requested_;
}
inline void CMsgClientUGSGetGlobalStats::set_time_last_requested(::google::protobuf::uint32 value) {
  set_has_time_last_requested();
  time_last_requested_ = value;
}

// optional uint32 first_day_cached = 4;
inline bool CMsgClientUGSGetGlobalStats::has_first_day_cached() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientUGSGetGlobalStats::set_has_first_day_cached() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientUGSGetGlobalStats::clear_has_first_day_cached() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientUGSGetGlobalStats::clear_first_day_cached() {
  first_day_cached_ = 0u;
  clear_has_first_day_cached();
}
inline ::google::protobuf::uint32 CMsgClientUGSGetGlobalStats::first_day_cached() const {
  return first_day_cached_;
}
inline void CMsgClientUGSGetGlobalStats::set_first_day_cached(::google::protobuf::uint32 value) {
  set_has_first_day_cached();
  first_day_cached_ = value;
}

// optional uint32 days_cached = 5;
inline bool CMsgClientUGSGetGlobalStats::has_days_cached() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientUGSGetGlobalStats::set_has_days_cached() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientUGSGetGlobalStats::clear_has_days_cached() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientUGSGetGlobalStats::clear_days_cached() {
  days_cached_ = 0u;
  clear_has_days_cached();
}
inline ::google::protobuf::uint32 CMsgClientUGSGetGlobalStats::days_cached() const {
  return days_cached_;
}
inline void CMsgClientUGSGetGlobalStats::set_days_cached(::google::protobuf::uint32 value) {
  set_has_days_cached();
  days_cached_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUGSGetGlobalStatsResponse_Day_Stat

// optional int32 stat_id = 1;
inline bool CMsgClientUGSGetGlobalStatsResponse_Day_Stat::has_stat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::set_has_stat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::clear_has_stat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::clear_stat_id() {
  stat_id_ = 0;
  clear_has_stat_id();
}
inline ::google::protobuf::int32 CMsgClientUGSGetGlobalStatsResponse_Day_Stat::stat_id() const {
  return stat_id_;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::set_stat_id(::google::protobuf::int32 value) {
  set_has_stat_id();
  stat_id_ = value;
}

// optional int64 data = 2;
inline bool CMsgClientUGSGetGlobalStatsResponse_Day_Stat::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::clear_data() {
  data_ = GOOGLE_LONGLONG(0);
  clear_has_data();
}
inline ::google::protobuf::int64 CMsgClientUGSGetGlobalStatsResponse_Day_Stat::data() const {
  return data_;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day_Stat::set_data(::google::protobuf::int64 value) {
  set_has_data();
  data_ = value;
}

// -------------------------------------------------------------------

// CMsgClientUGSGetGlobalStatsResponse_Day

// optional uint32 day_id = 1;
inline bool CMsgClientUGSGetGlobalStatsResponse_Day::has_day_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day::set_has_day_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day::clear_has_day_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day::clear_day_id() {
  day_id_ = 0u;
  clear_has_day_id();
}
inline ::google::protobuf::uint32 CMsgClientUGSGetGlobalStatsResponse_Day::day_id() const {
  return day_id_;
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day::set_day_id(::google::protobuf::uint32 value) {
  set_has_day_id();
  day_id_ = value;
}

// repeated .Sc.CMsgClientUGSGetGlobalStatsResponse.Day.Stat stats = 2;
inline int CMsgClientUGSGetGlobalStatsResponse_Day::stats_size() const {
  return stats_.size();
}
inline void CMsgClientUGSGetGlobalStatsResponse_Day::clear_stats() {
  stats_.Clear();
}
inline const ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat& CMsgClientUGSGetGlobalStatsResponse_Day::stats(int index) const {
  return stats_.Get(index);
}
inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat* CMsgClientUGSGetGlobalStatsResponse_Day::mutable_stats(int index) {
  return stats_.Mutable(index);
}
inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat* CMsgClientUGSGetGlobalStatsResponse_Day::add_stats() {
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat >&
CMsgClientUGSGetGlobalStatsResponse_Day::stats() const {
  return stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day_Stat >*
CMsgClientUGSGetGlobalStatsResponse_Day::mutable_stats() {
  return &stats_;
}

// -------------------------------------------------------------------

// CMsgClientUGSGetGlobalStatsResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientUGSGetGlobalStatsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUGSGetGlobalStatsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientUGSGetGlobalStatsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientUGSGetGlobalStatsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional fixed32 timestamp = 2;
inline bool CMsgClientUGSGetGlobalStatsResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientUGSGetGlobalStatsResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgClientUGSGetGlobalStatsResponse::timestamp() const {
  return timestamp_;
}
inline void CMsgClientUGSGetGlobalStatsResponse::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional int32 day_current = 3;
inline bool CMsgClientUGSGetGlobalStatsResponse::has_day_current() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientUGSGetGlobalStatsResponse::set_has_day_current() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_has_day_current() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_day_current() {
  day_current_ = 0;
  clear_has_day_current();
}
inline ::google::protobuf::int32 CMsgClientUGSGetGlobalStatsResponse::day_current() const {
  return day_current_;
}
inline void CMsgClientUGSGetGlobalStatsResponse::set_day_current(::google::protobuf::int32 value) {
  set_has_day_current();
  day_current_ = value;
}

// repeated .Sc.CMsgClientUGSGetGlobalStatsResponse.Day days = 4;
inline int CMsgClientUGSGetGlobalStatsResponse::days_size() const {
  return days_.size();
}
inline void CMsgClientUGSGetGlobalStatsResponse::clear_days() {
  days_.Clear();
}
inline const ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day& CMsgClientUGSGetGlobalStatsResponse::days(int index) const {
  return days_.Get(index);
}
inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day* CMsgClientUGSGetGlobalStatsResponse::mutable_days(int index) {
  return days_.Mutable(index);
}
inline ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day* CMsgClientUGSGetGlobalStatsResponse::add_days() {
  return days_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day >&
CMsgClientUGSGetGlobalStatsResponse::days() const {
  return days_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientUGSGetGlobalStatsResponse_Day >*
CMsgClientUGSGetGlobalStatsResponse::mutable_days() {
  return &days_;
}

// -------------------------------------------------------------------

// CMsgGameServerData_Player

// optional fixed64 steam_id = 1;
inline bool CMsgGameServerData_Player::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGameServerData_Player::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGameServerData_Player::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGameServerData_Player::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGameServerData_Player::steam_id() const {
  return steam_id_;
}
inline void CMsgGameServerData_Player::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgGameServerData

// optional fixed64 steam_id_gs = 1;
inline bool CMsgGameServerData::has_steam_id_gs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGameServerData::set_has_steam_id_gs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGameServerData::clear_has_steam_id_gs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGameServerData::clear_steam_id_gs() {
  steam_id_gs_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_gs();
}
inline ::google::protobuf::uint64 CMsgGameServerData::steam_id_gs() const {
  return steam_id_gs_;
}
inline void CMsgGameServerData::set_steam_id_gs(::google::protobuf::uint64 value) {
  set_has_steam_id_gs();
  steam_id_gs_ = value;
}

// optional uint32 ip = 2;
inline bool CMsgGameServerData::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGameServerData::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGameServerData::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGameServerData::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 CMsgGameServerData::ip() const {
  return ip_;
}
inline void CMsgGameServerData::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 query_port = 3;
inline bool CMsgGameServerData::has_query_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGameServerData::set_has_query_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGameServerData::clear_has_query_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGameServerData::clear_query_port() {
  query_port_ = 0u;
  clear_has_query_port();
}
inline ::google::protobuf::uint32 CMsgGameServerData::query_port() const {
  return query_port_;
}
inline void CMsgGameServerData::set_query_port(::google::protobuf::uint32 value) {
  set_has_query_port();
  query_port_ = value;
}

// optional uint32 game_port = 4;
inline bool CMsgGameServerData::has_game_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgGameServerData::set_has_game_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgGameServerData::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgGameServerData::clear_game_port() {
  game_port_ = 0u;
  clear_has_game_port();
}
inline ::google::protobuf::uint32 CMsgGameServerData::game_port() const {
  return game_port_;
}
inline void CMsgGameServerData::set_game_port(::google::protobuf::uint32 value) {
  set_has_game_port();
  game_port_ = value;
}

// optional uint32 sourcetv_port = 5;
inline bool CMsgGameServerData::has_sourcetv_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgGameServerData::set_has_sourcetv_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgGameServerData::clear_has_sourcetv_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgGameServerData::clear_sourcetv_port() {
  sourcetv_port_ = 0u;
  clear_has_sourcetv_port();
}
inline ::google::protobuf::uint32 CMsgGameServerData::sourcetv_port() const {
  return sourcetv_port_;
}
inline void CMsgGameServerData::set_sourcetv_port(::google::protobuf::uint32 value) {
  set_has_sourcetv_port();
  sourcetv_port_ = value;
}

// optional string name = 22;
inline bool CMsgGameServerData::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgGameServerData::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgGameServerData::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgGameServerData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CMsgGameServerData::name() const {
  return *name_;
}
inline void CMsgGameServerData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMsgGameServerData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMsgGameServerData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CMsgGameServerData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 app_id = 6;
inline bool CMsgGameServerData::has_app_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgGameServerData::set_has_app_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgGameServerData::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgGameServerData::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgGameServerData::app_id() const {
  return app_id_;
}
inline void CMsgGameServerData::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional string gamedir = 7;
inline bool CMsgGameServerData::has_gamedir() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgGameServerData::set_has_gamedir() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgGameServerData::clear_has_gamedir() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgGameServerData::clear_gamedir() {
  if (gamedir_ != &::google::protobuf::internal::kEmptyString) {
    gamedir_->clear();
  }
  clear_has_gamedir();
}
inline const ::std::string& CMsgGameServerData::gamedir() const {
  return *gamedir_;
}
inline void CMsgGameServerData::set_gamedir(const ::std::string& value) {
  set_has_gamedir();
  if (gamedir_ == &::google::protobuf::internal::kEmptyString) {
    gamedir_ = new ::std::string;
  }
  gamedir_->assign(value);
}
inline void CMsgGameServerData::set_gamedir(const char* value) {
  set_has_gamedir();
  if (gamedir_ == &::google::protobuf::internal::kEmptyString) {
    gamedir_ = new ::std::string;
  }
  gamedir_->assign(value);
}
inline void CMsgGameServerData::set_gamedir(const char* value, size_t size) {
  set_has_gamedir();
  if (gamedir_ == &::google::protobuf::internal::kEmptyString) {
    gamedir_ = new ::std::string;
  }
  gamedir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_gamedir() {
  set_has_gamedir();
  if (gamedir_ == &::google::protobuf::internal::kEmptyString) {
    gamedir_ = new ::std::string;
  }
  return gamedir_;
}
inline ::std::string* CMsgGameServerData::release_gamedir() {
  clear_has_gamedir();
  if (gamedir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedir_;
    gamedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_gamedir(::std::string* gamedir) {
  if (gamedir_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedir_;
  }
  if (gamedir) {
    set_has_gamedir();
    gamedir_ = gamedir;
  } else {
    clear_has_gamedir();
    gamedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 8;
inline bool CMsgGameServerData::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgGameServerData::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgGameServerData::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgGameServerData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CMsgGameServerData::version() const {
  return *version_;
}
inline void CMsgGameServerData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CMsgGameServerData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CMsgGameServerData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* CMsgGameServerData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string product = 9;
inline bool CMsgGameServerData::has_product() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgGameServerData::set_has_product() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgGameServerData::clear_has_product() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgGameServerData::clear_product() {
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& CMsgGameServerData::product() const {
  return *product_;
}
inline void CMsgGameServerData::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void CMsgGameServerData::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void CMsgGameServerData::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  return product_;
}
inline ::std::string* CMsgGameServerData::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string region = 10;
inline bool CMsgGameServerData::has_region() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgGameServerData::set_has_region() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgGameServerData::clear_has_region() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgGameServerData::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& CMsgGameServerData::region() const {
  return *region_;
}
inline void CMsgGameServerData::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void CMsgGameServerData::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void CMsgGameServerData::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* CMsgGameServerData::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_region(::std::string* region) {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    delete region_;
  }
  if (region) {
    set_has_region();
    region_ = region;
  } else {
    clear_has_region();
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Sc.CMsgGameServerData.Player players = 11;
inline int CMsgGameServerData::players_size() const {
  return players_.size();
}
inline void CMsgGameServerData::clear_players() {
  players_.Clear();
}
inline const ::Sc::CMsgGameServerData_Player& CMsgGameServerData::players(int index) const {
  return players_.Get(index);
}
inline ::Sc::CMsgGameServerData_Player* CMsgGameServerData::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::Sc::CMsgGameServerData_Player* CMsgGameServerData::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerData_Player >&
CMsgGameServerData::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerData_Player >*
CMsgGameServerData::mutable_players() {
  return &players_;
}

// optional uint32 max_players = 12;
inline bool CMsgGameServerData::has_max_players() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgGameServerData::set_has_max_players() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgGameServerData::clear_has_max_players() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgGameServerData::clear_max_players() {
  max_players_ = 0u;
  clear_has_max_players();
}
inline ::google::protobuf::uint32 CMsgGameServerData::max_players() const {
  return max_players_;
}
inline void CMsgGameServerData::set_max_players(::google::protobuf::uint32 value) {
  set_has_max_players();
  max_players_ = value;
}

// optional uint32 bot_count = 13;
inline bool CMsgGameServerData::has_bot_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgGameServerData::set_has_bot_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgGameServerData::clear_has_bot_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgGameServerData::clear_bot_count() {
  bot_count_ = 0u;
  clear_has_bot_count();
}
inline ::google::protobuf::uint32 CMsgGameServerData::bot_count() const {
  return bot_count_;
}
inline void CMsgGameServerData::set_bot_count(::google::protobuf::uint32 value) {
  set_has_bot_count();
  bot_count_ = value;
}

// optional bool password = 14;
inline bool CMsgGameServerData::has_password() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgGameServerData::set_has_password() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgGameServerData::clear_has_password() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgGameServerData::clear_password() {
  password_ = false;
  clear_has_password();
}
inline bool CMsgGameServerData::password() const {
  return password_;
}
inline void CMsgGameServerData::set_password(bool value) {
  set_has_password();
  password_ = value;
}

// optional bool secure = 15;
inline bool CMsgGameServerData::has_secure() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgGameServerData::set_has_secure() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgGameServerData::clear_has_secure() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgGameServerData::clear_secure() {
  secure_ = false;
  clear_has_secure();
}
inline bool CMsgGameServerData::secure() const {
  return secure_;
}
inline void CMsgGameServerData::set_secure(bool value) {
  set_has_secure();
  secure_ = value;
}

// optional bool dedicated = 16;
inline bool CMsgGameServerData::has_dedicated() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgGameServerData::set_has_dedicated() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgGameServerData::clear_has_dedicated() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgGameServerData::clear_dedicated() {
  dedicated_ = false;
  clear_has_dedicated();
}
inline bool CMsgGameServerData::dedicated() const {
  return dedicated_;
}
inline void CMsgGameServerData::set_dedicated(bool value) {
  set_has_dedicated();
  dedicated_ = value;
}

// optional string os = 17;
inline bool CMsgGameServerData::has_os() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgGameServerData::set_has_os() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgGameServerData::clear_has_os() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgGameServerData::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& CMsgGameServerData::os() const {
  return *os_;
}
inline void CMsgGameServerData::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void CMsgGameServerData::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void CMsgGameServerData::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* CMsgGameServerData::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string game_data = 18;
inline bool CMsgGameServerData::has_game_data() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgGameServerData::set_has_game_data() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgGameServerData::clear_has_game_data() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgGameServerData::clear_game_data() {
  if (game_data_ != &::google::protobuf::internal::kEmptyString) {
    game_data_->clear();
  }
  clear_has_game_data();
}
inline const ::std::string& CMsgGameServerData::game_data() const {
  return *game_data_;
}
inline void CMsgGameServerData::set_game_data(const ::std::string& value) {
  set_has_game_data();
  if (game_data_ == &::google::protobuf::internal::kEmptyString) {
    game_data_ = new ::std::string;
  }
  game_data_->assign(value);
}
inline void CMsgGameServerData::set_game_data(const char* value) {
  set_has_game_data();
  if (game_data_ == &::google::protobuf::internal::kEmptyString) {
    game_data_ = new ::std::string;
  }
  game_data_->assign(value);
}
inline void CMsgGameServerData::set_game_data(const char* value, size_t size) {
  set_has_game_data();
  if (game_data_ == &::google::protobuf::internal::kEmptyString) {
    game_data_ = new ::std::string;
  }
  game_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_game_data() {
  set_has_game_data();
  if (game_data_ == &::google::protobuf::internal::kEmptyString) {
    game_data_ = new ::std::string;
  }
  return game_data_;
}
inline ::std::string* CMsgGameServerData::release_game_data() {
  clear_has_game_data();
  if (game_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_data_;
    game_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_game_data(::std::string* game_data) {
  if (game_data_ != &::google::protobuf::internal::kEmptyString) {
    delete game_data_;
  }
  if (game_data) {
    set_has_game_data();
    game_data_ = game_data;
  } else {
    clear_has_game_data();
    game_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 game_data_version = 19;
inline bool CMsgGameServerData::has_game_data_version() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgGameServerData::set_has_game_data_version() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CMsgGameServerData::clear_has_game_data_version() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CMsgGameServerData::clear_game_data_version() {
  game_data_version_ = 0u;
  clear_has_game_data_version();
}
inline ::google::protobuf::uint32 CMsgGameServerData::game_data_version() const {
  return game_data_version_;
}
inline void CMsgGameServerData::set_game_data_version(::google::protobuf::uint32 value) {
  set_has_game_data_version();
  game_data_version_ = value;
}

// optional string game_type = 20;
inline bool CMsgGameServerData::has_game_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgGameServerData::set_has_game_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CMsgGameServerData::clear_has_game_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CMsgGameServerData::clear_game_type() {
  if (game_type_ != &::google::protobuf::internal::kEmptyString) {
    game_type_->clear();
  }
  clear_has_game_type();
}
inline const ::std::string& CMsgGameServerData::game_type() const {
  return *game_type_;
}
inline void CMsgGameServerData::set_game_type(const ::std::string& value) {
  set_has_game_type();
  if (game_type_ == &::google::protobuf::internal::kEmptyString) {
    game_type_ = new ::std::string;
  }
  game_type_->assign(value);
}
inline void CMsgGameServerData::set_game_type(const char* value) {
  set_has_game_type();
  if (game_type_ == &::google::protobuf::internal::kEmptyString) {
    game_type_ = new ::std::string;
  }
  game_type_->assign(value);
}
inline void CMsgGameServerData::set_game_type(const char* value, size_t size) {
  set_has_game_type();
  if (game_type_ == &::google::protobuf::internal::kEmptyString) {
    game_type_ = new ::std::string;
  }
  game_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_game_type() {
  set_has_game_type();
  if (game_type_ == &::google::protobuf::internal::kEmptyString) {
    game_type_ = new ::std::string;
  }
  return game_type_;
}
inline ::std::string* CMsgGameServerData::release_game_type() {
  clear_has_game_type();
  if (game_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_type_;
    game_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_game_type(::std::string* game_type) {
  if (game_type_ != &::google::protobuf::internal::kEmptyString) {
    delete game_type_;
  }
  if (game_type) {
    set_has_game_type();
    game_type_ = game_type;
  } else {
    clear_has_game_type();
    game_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string map = 21;
inline bool CMsgGameServerData::has_map() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgGameServerData::set_has_map() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CMsgGameServerData::clear_has_map() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CMsgGameServerData::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& CMsgGameServerData::map() const {
  return *map_;
}
inline void CMsgGameServerData::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void CMsgGameServerData::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void CMsgGameServerData::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerData::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* CMsgGameServerData::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerData::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgGameServerRemove

// optional fixed64 steam_id = 1;
inline bool CMsgGameServerRemove::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGameServerRemove::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGameServerRemove::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGameServerRemove::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgGameServerRemove::steam_id() const {
  return steam_id_;
}
inline void CMsgGameServerRemove::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// optional uint32 ip = 2;
inline bool CMsgGameServerRemove::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGameServerRemove::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGameServerRemove::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGameServerRemove::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 CMsgGameServerRemove::ip() const {
  return ip_;
}
inline void CMsgGameServerRemove::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 query_port = 3;
inline bool CMsgGameServerRemove::has_query_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGameServerRemove::set_has_query_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGameServerRemove::clear_has_query_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGameServerRemove::clear_query_port() {
  query_port_ = 0u;
  clear_has_query_port();
}
inline ::google::protobuf::uint32 CMsgGameServerRemove::query_port() const {
  return query_port_;
}
inline void CMsgGameServerRemove::set_query_port(::google::protobuf::uint32 value) {
  set_has_query_port();
  query_port_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGMSServerQuery

// optional uint32 app_id = 1;
inline bool CMsgClientGMSServerQuery::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGMSServerQuery::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGMSServerQuery::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGMSServerQuery::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientGMSServerQuery::app_id() const {
  return app_id_;
}
inline void CMsgClientGMSServerQuery::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 geo_location_ip = 2;
inline bool CMsgClientGMSServerQuery::has_geo_location_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientGMSServerQuery::set_has_geo_location_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientGMSServerQuery::clear_has_geo_location_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientGMSServerQuery::clear_geo_location_ip() {
  geo_location_ip_ = 0u;
  clear_has_geo_location_ip();
}
inline ::google::protobuf::uint32 CMsgClientGMSServerQuery::geo_location_ip() const {
  return geo_location_ip_;
}
inline void CMsgClientGMSServerQuery::set_geo_location_ip(::google::protobuf::uint32 value) {
  set_has_geo_location_ip();
  geo_location_ip_ = value;
}

// optional uint32 region_code = 3;
inline bool CMsgClientGMSServerQuery::has_region_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientGMSServerQuery::set_has_region_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientGMSServerQuery::clear_has_region_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientGMSServerQuery::clear_region_code() {
  region_code_ = 0u;
  clear_has_region_code();
}
inline ::google::protobuf::uint32 CMsgClientGMSServerQuery::region_code() const {
  return region_code_;
}
inline void CMsgClientGMSServerQuery::set_region_code(::google::protobuf::uint32 value) {
  set_has_region_code();
  region_code_ = value;
}

// optional string filter_text = 4;
inline bool CMsgClientGMSServerQuery::has_filter_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientGMSServerQuery::set_has_filter_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientGMSServerQuery::clear_has_filter_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientGMSServerQuery::clear_filter_text() {
  if (filter_text_ != &::google::protobuf::internal::kEmptyString) {
    filter_text_->clear();
  }
  clear_has_filter_text();
}
inline const ::std::string& CMsgClientGMSServerQuery::filter_text() const {
  return *filter_text_;
}
inline void CMsgClientGMSServerQuery::set_filter_text(const ::std::string& value) {
  set_has_filter_text();
  if (filter_text_ == &::google::protobuf::internal::kEmptyString) {
    filter_text_ = new ::std::string;
  }
  filter_text_->assign(value);
}
inline void CMsgClientGMSServerQuery::set_filter_text(const char* value) {
  set_has_filter_text();
  if (filter_text_ == &::google::protobuf::internal::kEmptyString) {
    filter_text_ = new ::std::string;
  }
  filter_text_->assign(value);
}
inline void CMsgClientGMSServerQuery::set_filter_text(const char* value, size_t size) {
  set_has_filter_text();
  if (filter_text_ == &::google::protobuf::internal::kEmptyString) {
    filter_text_ = new ::std::string;
  }
  filter_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientGMSServerQuery::mutable_filter_text() {
  set_has_filter_text();
  if (filter_text_ == &::google::protobuf::internal::kEmptyString) {
    filter_text_ = new ::std::string;
  }
  return filter_text_;
}
inline ::std::string* CMsgClientGMSServerQuery::release_filter_text() {
  clear_has_filter_text();
  if (filter_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_text_;
    filter_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientGMSServerQuery::set_allocated_filter_text(::std::string* filter_text) {
  if (filter_text_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_text_;
  }
  if (filter_text) {
    set_has_filter_text();
    filter_text_ = filter_text;
  } else {
    clear_has_filter_text();
    filter_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 max_servers = 5;
inline bool CMsgClientGMSServerQuery::has_max_servers() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientGMSServerQuery::set_has_max_servers() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientGMSServerQuery::clear_has_max_servers() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientGMSServerQuery::clear_max_servers() {
  max_servers_ = 0u;
  clear_has_max_servers();
}
inline ::google::protobuf::uint32 CMsgClientGMSServerQuery::max_servers() const {
  return max_servers_;
}
inline void CMsgClientGMSServerQuery::set_max_servers(::google::protobuf::uint32 value) {
  set_has_max_servers();
  max_servers_ = value;
}

// -------------------------------------------------------------------

// CMsgGMSClientServerQueryResponse_Server

// optional uint32 server_ip = 1;
inline bool CMsgGMSClientServerQueryResponse_Server::has_server_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_has_server_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_server_ip() {
  server_ip_ = 0u;
  clear_has_server_ip();
}
inline ::google::protobuf::uint32 CMsgGMSClientServerQueryResponse_Server::server_ip() const {
  return server_ip_;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_server_ip(::google::protobuf::uint32 value) {
  set_has_server_ip();
  server_ip_ = value;
}

// optional uint32 server_port = 2;
inline bool CMsgGMSClientServerQueryResponse_Server::has_server_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_has_server_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_server_port() {
  server_port_ = 0u;
  clear_has_server_port();
}
inline ::google::protobuf::uint32 CMsgGMSClientServerQueryResponse_Server::server_port() const {
  return server_port_;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_server_port(::google::protobuf::uint32 value) {
  set_has_server_port();
  server_port_ = value;
}

// optional uint32 auth_players = 3;
inline bool CMsgGMSClientServerQueryResponse_Server::has_auth_players() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_has_auth_players() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_has_auth_players() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_auth_players() {
  auth_players_ = 0u;
  clear_has_auth_players();
}
inline ::google::protobuf::uint32 CMsgGMSClientServerQueryResponse_Server::auth_players() const {
  return auth_players_;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_auth_players(::google::protobuf::uint32 value) {
  set_has_auth_players();
  auth_players_ = value;
}

// -------------------------------------------------------------------

// CMsgGMSClientServerQueryResponse

// repeated .Sc.CMsgGMSClientServerQueryResponse.Server servers = 1;
inline int CMsgGMSClientServerQueryResponse::servers_size() const {
  return servers_.size();
}
inline void CMsgGMSClientServerQueryResponse::clear_servers() {
  servers_.Clear();
}
inline const ::Sc::CMsgGMSClientServerQueryResponse_Server& CMsgGMSClientServerQueryResponse::servers(int index) const {
  return servers_.Get(index);
}
inline ::Sc::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::mutable_servers(int index) {
  return servers_.Mutable(index);
}
inline ::Sc::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::add_servers() {
  return servers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGMSClientServerQueryResponse_Server >&
CMsgGMSClientServerQueryResponse::servers() const {
  return servers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGMSClientServerQueryResponse_Server >*
CMsgGMSClientServerQueryResponse::mutable_servers() {
  return &servers_;
}

// optional string error = 2;
inline bool CMsgGMSClientServerQueryResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGMSClientServerQueryResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGMSClientServerQueryResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGMSClientServerQueryResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& CMsgGMSClientServerQueryResponse::error() const {
  return *error_;
}
inline void CMsgGMSClientServerQueryResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void CMsgGMSClientServerQueryResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void CMsgGMSClientServerQueryResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGMSClientServerQueryResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* CMsgGMSClientServerQueryResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGMSClientServerQueryResponse::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgGameServerOutOfDate

// optional fixed64 steam_id_gs = 1;
inline bool CMsgGameServerOutOfDate::has_steam_id_gs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGameServerOutOfDate::set_has_steam_id_gs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGameServerOutOfDate::clear_has_steam_id_gs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGameServerOutOfDate::clear_steam_id_gs() {
  steam_id_gs_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_gs();
}
inline ::google::protobuf::uint64 CMsgGameServerOutOfDate::steam_id_gs() const {
  return steam_id_gs_;
}
inline void CMsgGameServerOutOfDate::set_steam_id_gs(::google::protobuf::uint64 value) {
  set_has_steam_id_gs();
  steam_id_gs_ = value;
}

// optional bool reject = 2;
inline bool CMsgGameServerOutOfDate::has_reject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGameServerOutOfDate::set_has_reject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGameServerOutOfDate::clear_has_reject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGameServerOutOfDate::clear_reject() {
  reject_ = false;
  clear_has_reject();
}
inline bool CMsgGameServerOutOfDate::reject() const {
  return reject_;
}
inline void CMsgGameServerOutOfDate::set_reject(bool value) {
  set_has_reject();
  reject_ = value;
}

// optional string message = 3;
inline bool CMsgGameServerOutOfDate::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGameServerOutOfDate::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGameServerOutOfDate::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGameServerOutOfDate::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CMsgGameServerOutOfDate::message() const {
  return *message_;
}
inline void CMsgGameServerOutOfDate::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgGameServerOutOfDate::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgGameServerOutOfDate::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGameServerOutOfDate::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* CMsgGameServerOutOfDate::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGameServerOutOfDate::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRedeemGuestPass

// optional fixed64 guest_pass_id = 1;
inline bool CMsgClientRedeemGuestPass::has_guest_pass_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRedeemGuestPass::set_has_guest_pass_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRedeemGuestPass::clear_has_guest_pass_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRedeemGuestPass::clear_guest_pass_id() {
  guest_pass_id_ = GOOGLE_ULONGLONG(0);
  clear_has_guest_pass_id();
}
inline ::google::protobuf::uint64 CMsgClientRedeemGuestPass::guest_pass_id() const {
  return guest_pass_id_;
}
inline void CMsgClientRedeemGuestPass::set_guest_pass_id(::google::protobuf::uint64 value) {
  set_has_guest_pass_id();
  guest_pass_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRedeemGuestPassResponse

// optional uint32 eresult = 1 [default = 2];
inline bool CMsgClientRedeemGuestPassResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRedeemGuestPassResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRedeemGuestPassResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRedeemGuestPassResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRedeemGuestPassResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRedeemGuestPassResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 package_id = 2;
inline bool CMsgClientRedeemGuestPassResponse::has_package_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRedeemGuestPassResponse::set_has_package_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRedeemGuestPassResponse::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRedeemGuestPassResponse::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 CMsgClientRedeemGuestPassResponse::package_id() const {
  return package_id_;
}
inline void CMsgClientRedeemGuestPassResponse::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
}

// optional uint32 must_own_appid = 3;
inline bool CMsgClientRedeemGuestPassResponse::has_must_own_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientRedeemGuestPassResponse::set_has_must_own_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientRedeemGuestPassResponse::clear_has_must_own_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientRedeemGuestPassResponse::clear_must_own_appid() {
  must_own_appid_ = 0u;
  clear_has_must_own_appid();
}
inline ::google::protobuf::uint32 CMsgClientRedeemGuestPassResponse::must_own_appid() const {
  return must_own_appid_;
}
inline void CMsgClientRedeemGuestPassResponse::set_must_own_appid(::google::protobuf::uint32 value) {
  set_has_must_own_appid();
  must_own_appid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientGetClanActivityCounts

// repeated uint64 steamid_clans = 1;
inline int CMsgClientGetClanActivityCounts::steamid_clans_size() const {
  return steamid_clans_.size();
}
inline void CMsgClientGetClanActivityCounts::clear_steamid_clans() {
  steamid_clans_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientGetClanActivityCounts::steamid_clans(int index) const {
  return steamid_clans_.Get(index);
}
inline void CMsgClientGetClanActivityCounts::set_steamid_clans(int index, ::google::protobuf::uint64 value) {
  steamid_clans_.Set(index, value);
}
inline void CMsgClientGetClanActivityCounts::add_steamid_clans(::google::protobuf::uint64 value) {
  steamid_clans_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientGetClanActivityCounts::steamid_clans() const {
  return steamid_clans_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientGetClanActivityCounts::mutable_steamid_clans() {
  return &steamid_clans_;
}

// -------------------------------------------------------------------

// CMsgClientGetClanActivityCountsResponse

// optional uint32 eresult = 1 [default = 2];
inline bool CMsgClientGetClanActivityCountsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientGetClanActivityCountsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientGetClanActivityCountsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientGetClanActivityCountsResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientGetClanActivityCountsResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientGetClanActivityCountsResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientOGSReportString

// optional bool accumulated = 1;
inline bool CMsgClientOGSReportString::has_accumulated() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientOGSReportString::set_has_accumulated() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientOGSReportString::clear_has_accumulated() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientOGSReportString::clear_accumulated() {
  accumulated_ = false;
  clear_has_accumulated();
}
inline bool CMsgClientOGSReportString::accumulated() const {
  return accumulated_;
}
inline void CMsgClientOGSReportString::set_accumulated(bool value) {
  set_has_accumulated();
  accumulated_ = value;
}

// optional uint64 sessionid = 2;
inline bool CMsgClientOGSReportString::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientOGSReportString::set_has_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientOGSReportString::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientOGSReportString::clear_sessionid() {
  sessionid_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::uint64 CMsgClientOGSReportString::sessionid() const {
  return sessionid_;
}
inline void CMsgClientOGSReportString::set_sessionid(::google::protobuf::uint64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional int32 severity = 3;
inline bool CMsgClientOGSReportString::has_severity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientOGSReportString::set_has_severity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientOGSReportString::clear_has_severity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientOGSReportString::clear_severity() {
  severity_ = 0;
  clear_has_severity();
}
inline ::google::protobuf::int32 CMsgClientOGSReportString::severity() const {
  return severity_;
}
inline void CMsgClientOGSReportString::set_severity(::google::protobuf::int32 value) {
  set_has_severity();
  severity_ = value;
}

// optional string formatter = 4;
inline bool CMsgClientOGSReportString::has_formatter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientOGSReportString::set_has_formatter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientOGSReportString::clear_has_formatter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientOGSReportString::clear_formatter() {
  if (formatter_ != &::google::protobuf::internal::kEmptyString) {
    formatter_->clear();
  }
  clear_has_formatter();
}
inline const ::std::string& CMsgClientOGSReportString::formatter() const {
  return *formatter_;
}
inline void CMsgClientOGSReportString::set_formatter(const ::std::string& value) {
  set_has_formatter();
  if (formatter_ == &::google::protobuf::internal::kEmptyString) {
    formatter_ = new ::std::string;
  }
  formatter_->assign(value);
}
inline void CMsgClientOGSReportString::set_formatter(const char* value) {
  set_has_formatter();
  if (formatter_ == &::google::protobuf::internal::kEmptyString) {
    formatter_ = new ::std::string;
  }
  formatter_->assign(value);
}
inline void CMsgClientOGSReportString::set_formatter(const char* value, size_t size) {
  set_has_formatter();
  if (formatter_ == &::google::protobuf::internal::kEmptyString) {
    formatter_ = new ::std::string;
  }
  formatter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientOGSReportString::mutable_formatter() {
  set_has_formatter();
  if (formatter_ == &::google::protobuf::internal::kEmptyString) {
    formatter_ = new ::std::string;
  }
  return formatter_;
}
inline ::std::string* CMsgClientOGSReportString::release_formatter() {
  clear_has_formatter();
  if (formatter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formatter_;
    formatter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientOGSReportString::set_allocated_formatter(::std::string* formatter) {
  if (formatter_ != &::google::protobuf::internal::kEmptyString) {
    delete formatter_;
  }
  if (formatter) {
    set_has_formatter();
    formatter_ = formatter;
  } else {
    clear_has_formatter();
    formatter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes varargs = 5;
inline bool CMsgClientOGSReportString::has_varargs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientOGSReportString::set_has_varargs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientOGSReportString::clear_has_varargs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientOGSReportString::clear_varargs() {
  if (varargs_ != &::google::protobuf::internal::kEmptyString) {
    varargs_->clear();
  }
  clear_has_varargs();
}
inline const ::std::string& CMsgClientOGSReportString::varargs() const {
  return *varargs_;
}
inline void CMsgClientOGSReportString::set_varargs(const ::std::string& value) {
  set_has_varargs();
  if (varargs_ == &::google::protobuf::internal::kEmptyString) {
    varargs_ = new ::std::string;
  }
  varargs_->assign(value);
}
inline void CMsgClientOGSReportString::set_varargs(const char* value) {
  set_has_varargs();
  if (varargs_ == &::google::protobuf::internal::kEmptyString) {
    varargs_ = new ::std::string;
  }
  varargs_->assign(value);
}
inline void CMsgClientOGSReportString::set_varargs(const void* value, size_t size) {
  set_has_varargs();
  if (varargs_ == &::google::protobuf::internal::kEmptyString) {
    varargs_ = new ::std::string;
  }
  varargs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientOGSReportString::mutable_varargs() {
  set_has_varargs();
  if (varargs_ == &::google::protobuf::internal::kEmptyString) {
    varargs_ = new ::std::string;
  }
  return varargs_;
}
inline ::std::string* CMsgClientOGSReportString::release_varargs() {
  clear_has_varargs();
  if (varargs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = varargs_;
    varargs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientOGSReportString::set_allocated_varargs(::std::string* varargs) {
  if (varargs_ != &::google::protobuf::internal::kEmptyString) {
    delete varargs_;
  }
  if (varargs) {
    set_has_varargs();
    varargs_ = varargs;
  } else {
    clear_has_varargs();
    varargs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientOGSReportBug

// optional uint64 sessionid = 1;
inline bool CMsgClientOGSReportBug::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientOGSReportBug::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientOGSReportBug::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientOGSReportBug::clear_sessionid() {
  sessionid_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::uint64 CMsgClientOGSReportBug::sessionid() const {
  return sessionid_;
}
inline void CMsgClientOGSReportBug::set_sessionid(::google::protobuf::uint64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string bugtext = 2;
inline bool CMsgClientOGSReportBug::has_bugtext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientOGSReportBug::set_has_bugtext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientOGSReportBug::clear_has_bugtext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientOGSReportBug::clear_bugtext() {
  if (bugtext_ != &::google::protobuf::internal::kEmptyString) {
    bugtext_->clear();
  }
  clear_has_bugtext();
}
inline const ::std::string& CMsgClientOGSReportBug::bugtext() const {
  return *bugtext_;
}
inline void CMsgClientOGSReportBug::set_bugtext(const ::std::string& value) {
  set_has_bugtext();
  if (bugtext_ == &::google::protobuf::internal::kEmptyString) {
    bugtext_ = new ::std::string;
  }
  bugtext_->assign(value);
}
inline void CMsgClientOGSReportBug::set_bugtext(const char* value) {
  set_has_bugtext();
  if (bugtext_ == &::google::protobuf::internal::kEmptyString) {
    bugtext_ = new ::std::string;
  }
  bugtext_->assign(value);
}
inline void CMsgClientOGSReportBug::set_bugtext(const char* value, size_t size) {
  set_has_bugtext();
  if (bugtext_ == &::google::protobuf::internal::kEmptyString) {
    bugtext_ = new ::std::string;
  }
  bugtext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientOGSReportBug::mutable_bugtext() {
  set_has_bugtext();
  if (bugtext_ == &::google::protobuf::internal::kEmptyString) {
    bugtext_ = new ::std::string;
  }
  return bugtext_;
}
inline ::std::string* CMsgClientOGSReportBug::release_bugtext() {
  clear_has_bugtext();
  if (bugtext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bugtext_;
    bugtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientOGSReportBug::set_allocated_bugtext(::std::string* bugtext) {
  if (bugtext_ != &::google::protobuf::internal::kEmptyString) {
    delete bugtext_;
  }
  if (bugtext) {
    set_has_bugtext();
    bugtext_ = bugtext;
  } else {
    clear_has_bugtext();
    bugtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes screenshot = 3;
inline bool CMsgClientOGSReportBug::has_screenshot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientOGSReportBug::set_has_screenshot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientOGSReportBug::clear_has_screenshot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientOGSReportBug::clear_screenshot() {
  if (screenshot_ != &::google::protobuf::internal::kEmptyString) {
    screenshot_->clear();
  }
  clear_has_screenshot();
}
inline const ::std::string& CMsgClientOGSReportBug::screenshot() const {
  return *screenshot_;
}
inline void CMsgClientOGSReportBug::set_screenshot(const ::std::string& value) {
  set_has_screenshot();
  if (screenshot_ == &::google::protobuf::internal::kEmptyString) {
    screenshot_ = new ::std::string;
  }
  screenshot_->assign(value);
}
inline void CMsgClientOGSReportBug::set_screenshot(const char* value) {
  set_has_screenshot();
  if (screenshot_ == &::google::protobuf::internal::kEmptyString) {
    screenshot_ = new ::std::string;
  }
  screenshot_->assign(value);
}
inline void CMsgClientOGSReportBug::set_screenshot(const void* value, size_t size) {
  set_has_screenshot();
  if (screenshot_ == &::google::protobuf::internal::kEmptyString) {
    screenshot_ = new ::std::string;
  }
  screenshot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientOGSReportBug::mutable_screenshot() {
  set_has_screenshot();
  if (screenshot_ == &::google::protobuf::internal::kEmptyString) {
    screenshot_ = new ::std::string;
  }
  return screenshot_;
}
inline ::std::string* CMsgClientOGSReportBug::release_screenshot() {
  clear_has_screenshot();
  if (screenshot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screenshot_;
    screenshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientOGSReportBug::set_allocated_screenshot(::std::string* screenshot) {
  if (screenshot_ != &::google::protobuf::internal::kEmptyString) {
    delete screenshot_;
  }
  if (screenshot) {
    set_has_screenshot();
    screenshot_ = screenshot;
  } else {
    clear_has_screenshot();
    screenshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgGSAssociateWithClan

// optional fixed64 steam_id_clan = 1;
inline bool CMsgGSAssociateWithClan::has_steam_id_clan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSAssociateWithClan::set_has_steam_id_clan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSAssociateWithClan::clear_has_steam_id_clan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSAssociateWithClan::clear_steam_id_clan() {
  steam_id_clan_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_clan();
}
inline ::google::protobuf::uint64 CMsgGSAssociateWithClan::steam_id_clan() const {
  return steam_id_clan_;
}
inline void CMsgGSAssociateWithClan::set_steam_id_clan(::google::protobuf::uint64 value) {
  set_has_steam_id_clan();
  steam_id_clan_ = value;
}

// -------------------------------------------------------------------

// CMsgGSAssociateWithClanResponse

// optional fixed64 steam_id_clan = 1;
inline bool CMsgGSAssociateWithClanResponse::has_steam_id_clan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSAssociateWithClanResponse::set_has_steam_id_clan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSAssociateWithClanResponse::clear_has_steam_id_clan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSAssociateWithClanResponse::clear_steam_id_clan() {
  steam_id_clan_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_clan();
}
inline ::google::protobuf::uint64 CMsgGSAssociateWithClanResponse::steam_id_clan() const {
  return steam_id_clan_;
}
inline void CMsgGSAssociateWithClanResponse::set_steam_id_clan(::google::protobuf::uint64 value) {
  set_has_steam_id_clan();
  steam_id_clan_ = value;
}

// optional uint32 eresult = 2 [default = 2];
inline bool CMsgGSAssociateWithClanResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSAssociateWithClanResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSAssociateWithClanResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSAssociateWithClanResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgGSAssociateWithClanResponse::eresult() const {
  return eresult_;
}
inline void CMsgGSAssociateWithClanResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgGSComputeNewPlayerCompatibility

// optional fixed64 steam_id_candidate = 1;
inline bool CMsgGSComputeNewPlayerCompatibility::has_steam_id_candidate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibility::set_has_steam_id_candidate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSComputeNewPlayerCompatibility::clear_has_steam_id_candidate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSComputeNewPlayerCompatibility::clear_steam_id_candidate() {
  steam_id_candidate_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_candidate();
}
inline ::google::protobuf::uint64 CMsgGSComputeNewPlayerCompatibility::steam_id_candidate() const {
  return steam_id_candidate_;
}
inline void CMsgGSComputeNewPlayerCompatibility::set_steam_id_candidate(::google::protobuf::uint64 value) {
  set_has_steam_id_candidate();
  steam_id_candidate_ = value;
}

// -------------------------------------------------------------------

// CMsgGSComputeNewPlayerCompatibilityResponse

// optional fixed64 steam_id_candidate = 1;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_steam_id_candidate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_has_steam_id_candidate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_has_steam_id_candidate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_steam_id_candidate() {
  steam_id_candidate_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id_candidate();
}
inline ::google::protobuf::uint64 CMsgGSComputeNewPlayerCompatibilityResponse::steam_id_candidate() const {
  return steam_id_candidate_;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_steam_id_candidate(::google::protobuf::uint64 value) {
  set_has_steam_id_candidate();
  steam_id_candidate_ = value;
}

// optional uint32 eresult = 2 [default = 2];
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgGSComputeNewPlayerCompatibilityResponse::eresult() const {
  return eresult_;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional bool is_clan_member = 3;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_is_clan_member() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_has_is_clan_member() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_has_is_clan_member() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_is_clan_member() {
  is_clan_member_ = false;
  clear_has_is_clan_member();
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::is_clan_member() const {
  return is_clan_member_;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_is_clan_member(bool value) {
  set_has_is_clan_member();
  is_clan_member_ = value;
}

// optional int32 ct_dont_like_you = 4;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_ct_dont_like_you() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_has_ct_dont_like_you() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_has_ct_dont_like_you() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_ct_dont_like_you() {
  ct_dont_like_you_ = 0;
  clear_has_ct_dont_like_you();
}
inline ::google::protobuf::int32 CMsgGSComputeNewPlayerCompatibilityResponse::ct_dont_like_you() const {
  return ct_dont_like_you_;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_ct_dont_like_you(::google::protobuf::int32 value) {
  set_has_ct_dont_like_you();
  ct_dont_like_you_ = value;
}

// optional int32 ct_you_dont_like = 5;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_ct_you_dont_like() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_has_ct_you_dont_like() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_has_ct_you_dont_like() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_ct_you_dont_like() {
  ct_you_dont_like_ = 0;
  clear_has_ct_you_dont_like();
}
inline ::google::protobuf::int32 CMsgGSComputeNewPlayerCompatibilityResponse::ct_you_dont_like() const {
  return ct_you_dont_like_;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_ct_you_dont_like(::google::protobuf::int32 value) {
  set_has_ct_you_dont_like();
  ct_you_dont_like_ = value;
}

// optional int32 ct_clanmembers_dont_like_you = 6;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_ct_clanmembers_dont_like_you() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_has_ct_clanmembers_dont_like_you() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_has_ct_clanmembers_dont_like_you() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_ct_clanmembers_dont_like_you() {
  ct_clanmembers_dont_like_you_ = 0;
  clear_has_ct_clanmembers_dont_like_you();
}
inline ::google::protobuf::int32 CMsgGSComputeNewPlayerCompatibilityResponse::ct_clanmembers_dont_like_you() const {
  return ct_clanmembers_dont_like_you_;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_ct_clanmembers_dont_like_you(::google::protobuf::int32 value) {
  set_has_ct_clanmembers_dont_like_you();
  ct_clanmembers_dont_like_you_ = value;
}

// -------------------------------------------------------------------

// CMsgClientSentLogs

// -------------------------------------------------------------------

// CMsgGCClient

// optional uint32 appid = 1;
inline bool CMsgGCClient::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGCClient::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGCClient::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGCClient::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgGCClient::appid() const {
  return appid_;
}
inline void CMsgGCClient::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional uint32 msgtype = 2;
inline bool CMsgGCClient::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGCClient::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGCClient::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGCClient::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 CMsgGCClient::msgtype() const {
  return msgtype_;
}
inline void CMsgGCClient::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// optional bytes payload = 3;
inline bool CMsgGCClient::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGCClient::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGCClient::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGCClient::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& CMsgGCClient::payload() const {
  return *payload_;
}
inline void CMsgGCClient::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void CMsgGCClient::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void CMsgGCClient::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGCClient::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* CMsgGCClient::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGCClient::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 steamid = 4;
inline bool CMsgGCClient::has_steamid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgGCClient::set_has_steamid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgGCClient::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgGCClient::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgGCClient::steamid() const {
  return steamid_;
}
inline void CMsgGCClient::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional string gcname = 5;
inline bool CMsgGCClient::has_gcname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgGCClient::set_has_gcname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgGCClient::clear_has_gcname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgGCClient::clear_gcname() {
  if (gcname_ != &::google::protobuf::internal::kEmptyString) {
    gcname_->clear();
  }
  clear_has_gcname();
}
inline const ::std::string& CMsgGCClient::gcname() const {
  return *gcname_;
}
inline void CMsgGCClient::set_gcname(const ::std::string& value) {
  set_has_gcname();
  if (gcname_ == &::google::protobuf::internal::kEmptyString) {
    gcname_ = new ::std::string;
  }
  gcname_->assign(value);
}
inline void CMsgGCClient::set_gcname(const char* value) {
  set_has_gcname();
  if (gcname_ == &::google::protobuf::internal::kEmptyString) {
    gcname_ = new ::std::string;
  }
  gcname_->assign(value);
}
inline void CMsgGCClient::set_gcname(const char* value, size_t size) {
  set_has_gcname();
  if (gcname_ == &::google::protobuf::internal::kEmptyString) {
    gcname_ = new ::std::string;
  }
  gcname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgGCClient::mutable_gcname() {
  set_has_gcname();
  if (gcname_ == &::google::protobuf::internal::kEmptyString) {
    gcname_ = new ::std::string;
  }
  return gcname_;
}
inline ::std::string* CMsgGCClient::release_gcname() {
  clear_has_gcname();
  if (gcname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gcname_;
    gcname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgGCClient::set_allocated_gcname(::std::string* gcname) {
  if (gcname_ != &::google::protobuf::internal::kEmptyString) {
    delete gcname_;
  }
  if (gcname) {
    set_has_gcname();
    gcname_ = gcname;
  } else {
    clear_has_gcname();
    gcname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestFreeLicense

// optional uint32 app_id = 1;
inline bool CMsgClientRequestFreeLicense::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestFreeLicense::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestFreeLicense::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestFreeLicense::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgClientRequestFreeLicense::app_id() const {
  return app_id_;
}
inline void CMsgClientRequestFreeLicense::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestFreeLicenseResponse

// optional uint32 eresult = 1 [default = 2];
inline bool CMsgClientRequestFreeLicenseResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestFreeLicenseResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestFreeLicenseResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestFreeLicenseResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRequestFreeLicenseResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestFreeLicenseResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 package_id = 2;
inline bool CMsgClientRequestFreeLicenseResponse::has_package_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestFreeLicenseResponse::set_has_package_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestFreeLicenseResponse::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestFreeLicenseResponse::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 CMsgClientRequestFreeLicenseResponse::package_id() const {
  return package_id_;
}
inline void CMsgClientRequestFreeLicenseResponse::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
}

// -------------------------------------------------------------------

// CMsgDRMDownloadRequestWithCrashData

// optional uint32 download_flags = 1;
inline bool CMsgDRMDownloadRequestWithCrashData::has_download_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_download_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_download_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_download_flags() {
  download_flags_ = 0u;
  clear_has_download_flags();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadRequestWithCrashData::download_flags() const {
  return download_flags_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_download_flags(::google::protobuf::uint32 value) {
  set_has_download_flags();
  download_flags_ = value;
}

// optional uint32 download_types_known = 2;
inline bool CMsgDRMDownloadRequestWithCrashData::has_download_types_known() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_download_types_known() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_download_types_known() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_download_types_known() {
  download_types_known_ = 0u;
  clear_has_download_types_known();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadRequestWithCrashData::download_types_known() const {
  return download_types_known_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_download_types_known(::google::protobuf::uint32 value) {
  set_has_download_types_known();
  download_types_known_ = value;
}

// optional bytes guid_drm = 3;
inline bool CMsgDRMDownloadRequestWithCrashData::has_guid_drm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_guid_drm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_guid_drm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_guid_drm() {
  if (guid_drm_ != &::google::protobuf::internal::kEmptyString) {
    guid_drm_->clear();
  }
  clear_has_guid_drm();
}
inline const ::std::string& CMsgDRMDownloadRequestWithCrashData::guid_drm() const {
  return *guid_drm_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_drm(const ::std::string& value) {
  set_has_guid_drm();
  if (guid_drm_ == &::google::protobuf::internal::kEmptyString) {
    guid_drm_ = new ::std::string;
  }
  guid_drm_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_drm(const char* value) {
  set_has_guid_drm();
  if (guid_drm_ == &::google::protobuf::internal::kEmptyString) {
    guid_drm_ = new ::std::string;
  }
  guid_drm_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_drm(const void* value, size_t size) {
  set_has_guid_drm();
  if (guid_drm_ == &::google::protobuf::internal::kEmptyString) {
    guid_drm_ = new ::std::string;
  }
  guid_drm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::mutable_guid_drm() {
  set_has_guid_drm();
  if (guid_drm_ == &::google::protobuf::internal::kEmptyString) {
    guid_drm_ = new ::std::string;
  }
  return guid_drm_;
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::release_guid_drm() {
  clear_has_guid_drm();
  if (guid_drm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_drm_;
    guid_drm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadRequestWithCrashData::set_allocated_guid_drm(::std::string* guid_drm) {
  if (guid_drm_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_drm_;
  }
  if (guid_drm) {
    set_has_guid_drm();
    guid_drm_ = guid_drm;
  } else {
    clear_has_guid_drm();
    guid_drm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes guid_split = 4;
inline bool CMsgDRMDownloadRequestWithCrashData::has_guid_split() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_guid_split() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_guid_split() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_guid_split() {
  if (guid_split_ != &::google::protobuf::internal::kEmptyString) {
    guid_split_->clear();
  }
  clear_has_guid_split();
}
inline const ::std::string& CMsgDRMDownloadRequestWithCrashData::guid_split() const {
  return *guid_split_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_split(const ::std::string& value) {
  set_has_guid_split();
  if (guid_split_ == &::google::protobuf::internal::kEmptyString) {
    guid_split_ = new ::std::string;
  }
  guid_split_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_split(const char* value) {
  set_has_guid_split();
  if (guid_split_ == &::google::protobuf::internal::kEmptyString) {
    guid_split_ = new ::std::string;
  }
  guid_split_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_split(const void* value, size_t size) {
  set_has_guid_split();
  if (guid_split_ == &::google::protobuf::internal::kEmptyString) {
    guid_split_ = new ::std::string;
  }
  guid_split_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::mutable_guid_split() {
  set_has_guid_split();
  if (guid_split_ == &::google::protobuf::internal::kEmptyString) {
    guid_split_ = new ::std::string;
  }
  return guid_split_;
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::release_guid_split() {
  clear_has_guid_split();
  if (guid_split_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_split_;
    guid_split_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadRequestWithCrashData::set_allocated_guid_split(::std::string* guid_split) {
  if (guid_split_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_split_;
  }
  if (guid_split) {
    set_has_guid_split();
    guid_split_ = guid_split;
  } else {
    clear_has_guid_split();
    guid_split_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes guid_merge = 5;
inline bool CMsgDRMDownloadRequestWithCrashData::has_guid_merge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_guid_merge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_guid_merge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_guid_merge() {
  if (guid_merge_ != &::google::protobuf::internal::kEmptyString) {
    guid_merge_->clear();
  }
  clear_has_guid_merge();
}
inline const ::std::string& CMsgDRMDownloadRequestWithCrashData::guid_merge() const {
  return *guid_merge_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_merge(const ::std::string& value) {
  set_has_guid_merge();
  if (guid_merge_ == &::google::protobuf::internal::kEmptyString) {
    guid_merge_ = new ::std::string;
  }
  guid_merge_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_merge(const char* value) {
  set_has_guid_merge();
  if (guid_merge_ == &::google::protobuf::internal::kEmptyString) {
    guid_merge_ = new ::std::string;
  }
  guid_merge_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_guid_merge(const void* value, size_t size) {
  set_has_guid_merge();
  if (guid_merge_ == &::google::protobuf::internal::kEmptyString) {
    guid_merge_ = new ::std::string;
  }
  guid_merge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::mutable_guid_merge() {
  set_has_guid_merge();
  if (guid_merge_ == &::google::protobuf::internal::kEmptyString) {
    guid_merge_ = new ::std::string;
  }
  return guid_merge_;
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::release_guid_merge() {
  clear_has_guid_merge();
  if (guid_merge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_merge_;
    guid_merge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadRequestWithCrashData::set_allocated_guid_merge(::std::string* guid_merge) {
  if (guid_merge_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_merge_;
  }
  if (guid_merge) {
    set_has_guid_merge();
    guid_merge_ = guid_merge;
  } else {
    clear_has_guid_merge();
    guid_merge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string module_name = 6;
inline bool CMsgDRMDownloadRequestWithCrashData::has_module_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_module_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& CMsgDRMDownloadRequestWithCrashData::module_name() const {
  return *module_name_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadRequestWithCrashData::set_allocated_module_name(::std::string* module_name) {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    delete module_name_;
  }
  if (module_name) {
    set_has_module_name();
    module_name_ = module_name;
  } else {
    clear_has_module_name();
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string module_path = 7;
inline bool CMsgDRMDownloadRequestWithCrashData::has_module_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_module_path() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_module_path() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_module_path() {
  if (module_path_ != &::google::protobuf::internal::kEmptyString) {
    module_path_->clear();
  }
  clear_has_module_path();
}
inline const ::std::string& CMsgDRMDownloadRequestWithCrashData::module_path() const {
  return *module_path_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_module_path(const ::std::string& value) {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  module_path_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_module_path(const char* value) {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  module_path_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_module_path(const char* value, size_t size) {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  module_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::mutable_module_path() {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  return module_path_;
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::release_module_path() {
  clear_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_path_;
    module_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadRequestWithCrashData::set_allocated_module_path(::std::string* module_path) {
  if (module_path_ != &::google::protobuf::internal::kEmptyString) {
    delete module_path_;
  }
  if (module_path) {
    set_has_module_path();
    module_path_ = module_path;
  } else {
    clear_has_module_path();
    module_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes crash_data = 8;
inline bool CMsgDRMDownloadRequestWithCrashData::has_crash_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_has_crash_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_has_crash_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDRMDownloadRequestWithCrashData::clear_crash_data() {
  if (crash_data_ != &::google::protobuf::internal::kEmptyString) {
    crash_data_->clear();
  }
  clear_has_crash_data();
}
inline const ::std::string& CMsgDRMDownloadRequestWithCrashData::crash_data() const {
  return *crash_data_;
}
inline void CMsgDRMDownloadRequestWithCrashData::set_crash_data(const ::std::string& value) {
  set_has_crash_data();
  if (crash_data_ == &::google::protobuf::internal::kEmptyString) {
    crash_data_ = new ::std::string;
  }
  crash_data_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_crash_data(const char* value) {
  set_has_crash_data();
  if (crash_data_ == &::google::protobuf::internal::kEmptyString) {
    crash_data_ = new ::std::string;
  }
  crash_data_->assign(value);
}
inline void CMsgDRMDownloadRequestWithCrashData::set_crash_data(const void* value, size_t size) {
  set_has_crash_data();
  if (crash_data_ == &::google::protobuf::internal::kEmptyString) {
    crash_data_ = new ::std::string;
  }
  crash_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::mutable_crash_data() {
  set_has_crash_data();
  if (crash_data_ == &::google::protobuf::internal::kEmptyString) {
    crash_data_ = new ::std::string;
  }
  return crash_data_;
}
inline ::std::string* CMsgDRMDownloadRequestWithCrashData::release_crash_data() {
  clear_has_crash_data();
  if (crash_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crash_data_;
    crash_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadRequestWithCrashData::set_allocated_crash_data(::std::string* crash_data) {
  if (crash_data_ != &::google::protobuf::internal::kEmptyString) {
    delete crash_data_;
  }
  if (crash_data) {
    set_has_crash_data();
    crash_data_ = crash_data;
  } else {
    clear_has_crash_data();
    crash_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgDRMDownloadResponse

// optional uint32 eresult = 1 [default = 2];
inline bool CMsgDRMDownloadResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDRMDownloadResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDRMDownloadResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadResponse::eresult() const {
  return eresult_;
}
inline void CMsgDRMDownloadResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgDRMDownloadResponse::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDRMDownloadResponse::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDRMDownloadResponse::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadResponse::app_id() const {
  return app_id_;
}
inline void CMsgDRMDownloadResponse::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 blob_download_type = 3;
inline bool CMsgDRMDownloadResponse::has_blob_download_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_blob_download_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDRMDownloadResponse::clear_has_blob_download_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDRMDownloadResponse::clear_blob_download_type() {
  blob_download_type_ = 0u;
  clear_has_blob_download_type();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadResponse::blob_download_type() const {
  return blob_download_type_;
}
inline void CMsgDRMDownloadResponse::set_blob_download_type(::google::protobuf::uint32 value) {
  set_has_blob_download_type();
  blob_download_type_ = value;
}

// optional bytes merge_guid = 4;
inline bool CMsgDRMDownloadResponse::has_merge_guid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_merge_guid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDRMDownloadResponse::clear_has_merge_guid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDRMDownloadResponse::clear_merge_guid() {
  if (merge_guid_ != &::google::protobuf::internal::kEmptyString) {
    merge_guid_->clear();
  }
  clear_has_merge_guid();
}
inline const ::std::string& CMsgDRMDownloadResponse::merge_guid() const {
  return *merge_guid_;
}
inline void CMsgDRMDownloadResponse::set_merge_guid(const ::std::string& value) {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  merge_guid_->assign(value);
}
inline void CMsgDRMDownloadResponse::set_merge_guid(const char* value) {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  merge_guid_->assign(value);
}
inline void CMsgDRMDownloadResponse::set_merge_guid(const void* value, size_t size) {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  merge_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadResponse::mutable_merge_guid() {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  return merge_guid_;
}
inline ::std::string* CMsgDRMDownloadResponse::release_merge_guid() {
  clear_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merge_guid_;
    merge_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadResponse::set_allocated_merge_guid(::std::string* merge_guid) {
  if (merge_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete merge_guid_;
  }
  if (merge_guid) {
    set_has_merge_guid();
    merge_guid_ = merge_guid;
  } else {
    clear_has_merge_guid();
    merge_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 download_file_dfs_ip = 5;
inline bool CMsgDRMDownloadResponse::has_download_file_dfs_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_download_file_dfs_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDRMDownloadResponse::clear_has_download_file_dfs_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDRMDownloadResponse::clear_download_file_dfs_ip() {
  download_file_dfs_ip_ = 0u;
  clear_has_download_file_dfs_ip();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadResponse::download_file_dfs_ip() const {
  return download_file_dfs_ip_;
}
inline void CMsgDRMDownloadResponse::set_download_file_dfs_ip(::google::protobuf::uint32 value) {
  set_has_download_file_dfs_ip();
  download_file_dfs_ip_ = value;
}

// optional uint32 download_file_dfs_port = 6;
inline bool CMsgDRMDownloadResponse::has_download_file_dfs_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_download_file_dfs_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDRMDownloadResponse::clear_has_download_file_dfs_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDRMDownloadResponse::clear_download_file_dfs_port() {
  download_file_dfs_port_ = 0u;
  clear_has_download_file_dfs_port();
}
inline ::google::protobuf::uint32 CMsgDRMDownloadResponse::download_file_dfs_port() const {
  return download_file_dfs_port_;
}
inline void CMsgDRMDownloadResponse::set_download_file_dfs_port(::google::protobuf::uint32 value) {
  set_has_download_file_dfs_port();
  download_file_dfs_port_ = value;
}

// optional string download_file_url = 7;
inline bool CMsgDRMDownloadResponse::has_download_file_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_download_file_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDRMDownloadResponse::clear_has_download_file_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDRMDownloadResponse::clear_download_file_url() {
  if (download_file_url_ != &::google::protobuf::internal::kEmptyString) {
    download_file_url_->clear();
  }
  clear_has_download_file_url();
}
inline const ::std::string& CMsgDRMDownloadResponse::download_file_url() const {
  return *download_file_url_;
}
inline void CMsgDRMDownloadResponse::set_download_file_url(const ::std::string& value) {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  download_file_url_->assign(value);
}
inline void CMsgDRMDownloadResponse::set_download_file_url(const char* value) {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  download_file_url_->assign(value);
}
inline void CMsgDRMDownloadResponse::set_download_file_url(const char* value, size_t size) {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  download_file_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadResponse::mutable_download_file_url() {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  return download_file_url_;
}
inline ::std::string* CMsgDRMDownloadResponse::release_download_file_url() {
  clear_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = download_file_url_;
    download_file_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadResponse::set_allocated_download_file_url(::std::string* download_file_url) {
  if (download_file_url_ != &::google::protobuf::internal::kEmptyString) {
    delete download_file_url_;
  }
  if (download_file_url) {
    set_has_download_file_url();
    download_file_url_ = download_file_url;
  } else {
    clear_has_download_file_url();
    download_file_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string module_path = 8;
inline bool CMsgDRMDownloadResponse::has_module_path() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDRMDownloadResponse::set_has_module_path() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDRMDownloadResponse::clear_has_module_path() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDRMDownloadResponse::clear_module_path() {
  if (module_path_ != &::google::protobuf::internal::kEmptyString) {
    module_path_->clear();
  }
  clear_has_module_path();
}
inline const ::std::string& CMsgDRMDownloadResponse::module_path() const {
  return *module_path_;
}
inline void CMsgDRMDownloadResponse::set_module_path(const ::std::string& value) {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  module_path_->assign(value);
}
inline void CMsgDRMDownloadResponse::set_module_path(const char* value) {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  module_path_->assign(value);
}
inline void CMsgDRMDownloadResponse::set_module_path(const char* value, size_t size) {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  module_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMDownloadResponse::mutable_module_path() {
  set_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    module_path_ = new ::std::string;
  }
  return module_path_;
}
inline ::std::string* CMsgDRMDownloadResponse::release_module_path() {
  clear_has_module_path();
  if (module_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_path_;
    module_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMDownloadResponse::set_allocated_module_path(::std::string* module_path) {
  if (module_path_ != &::google::protobuf::internal::kEmptyString) {
    delete module_path_;
  }
  if (module_path) {
    set_has_module_path();
    module_path_ = module_path;
  } else {
    clear_has_module_path();
    module_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgDRMFinalResult

// optional uint32 eResult = 1 [default = 2];
inline bool CMsgDRMFinalResult::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDRMFinalResult::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDRMFinalResult::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDRMFinalResult::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgDRMFinalResult::eresult() const {
  return eresult_;
}
inline void CMsgDRMFinalResult::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 app_id = 2;
inline bool CMsgDRMFinalResult::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDRMFinalResult::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDRMFinalResult::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDRMFinalResult::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgDRMFinalResult::app_id() const {
  return app_id_;
}
inline void CMsgDRMFinalResult::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 blob_download_type = 3;
inline bool CMsgDRMFinalResult::has_blob_download_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDRMFinalResult::set_has_blob_download_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDRMFinalResult::clear_has_blob_download_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDRMFinalResult::clear_blob_download_type() {
  blob_download_type_ = 0u;
  clear_has_blob_download_type();
}
inline ::google::protobuf::uint32 CMsgDRMFinalResult::blob_download_type() const {
  return blob_download_type_;
}
inline void CMsgDRMFinalResult::set_blob_download_type(::google::protobuf::uint32 value) {
  set_has_blob_download_type();
  blob_download_type_ = value;
}

// optional uint32 error_detail = 4;
inline bool CMsgDRMFinalResult::has_error_detail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDRMFinalResult::set_has_error_detail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDRMFinalResult::clear_has_error_detail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDRMFinalResult::clear_error_detail() {
  error_detail_ = 0u;
  clear_has_error_detail();
}
inline ::google::protobuf::uint32 CMsgDRMFinalResult::error_detail() const {
  return error_detail_;
}
inline void CMsgDRMFinalResult::set_error_detail(::google::protobuf::uint32 value) {
  set_has_error_detail();
  error_detail_ = value;
}

// optional bytes merge_guid = 5;
inline bool CMsgDRMFinalResult::has_merge_guid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDRMFinalResult::set_has_merge_guid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDRMFinalResult::clear_has_merge_guid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDRMFinalResult::clear_merge_guid() {
  if (merge_guid_ != &::google::protobuf::internal::kEmptyString) {
    merge_guid_->clear();
  }
  clear_has_merge_guid();
}
inline const ::std::string& CMsgDRMFinalResult::merge_guid() const {
  return *merge_guid_;
}
inline void CMsgDRMFinalResult::set_merge_guid(const ::std::string& value) {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  merge_guid_->assign(value);
}
inline void CMsgDRMFinalResult::set_merge_guid(const char* value) {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  merge_guid_->assign(value);
}
inline void CMsgDRMFinalResult::set_merge_guid(const void* value, size_t size) {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  merge_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMFinalResult::mutable_merge_guid() {
  set_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    merge_guid_ = new ::std::string;
  }
  return merge_guid_;
}
inline ::std::string* CMsgDRMFinalResult::release_merge_guid() {
  clear_has_merge_guid();
  if (merge_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merge_guid_;
    merge_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMFinalResult::set_allocated_merge_guid(::std::string* merge_guid) {
  if (merge_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete merge_guid_;
  }
  if (merge_guid) {
    set_has_merge_guid();
    merge_guid_ = merge_guid;
  } else {
    clear_has_merge_guid();
    merge_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 download_file_dfs_ip = 6;
inline bool CMsgDRMFinalResult::has_download_file_dfs_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDRMFinalResult::set_has_download_file_dfs_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDRMFinalResult::clear_has_download_file_dfs_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDRMFinalResult::clear_download_file_dfs_ip() {
  download_file_dfs_ip_ = 0u;
  clear_has_download_file_dfs_ip();
}
inline ::google::protobuf::uint32 CMsgDRMFinalResult::download_file_dfs_ip() const {
  return download_file_dfs_ip_;
}
inline void CMsgDRMFinalResult::set_download_file_dfs_ip(::google::protobuf::uint32 value) {
  set_has_download_file_dfs_ip();
  download_file_dfs_ip_ = value;
}

// optional uint32 download_file_dfs_port = 7;
inline bool CMsgDRMFinalResult::has_download_file_dfs_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDRMFinalResult::set_has_download_file_dfs_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDRMFinalResult::clear_has_download_file_dfs_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDRMFinalResult::clear_download_file_dfs_port() {
  download_file_dfs_port_ = 0u;
  clear_has_download_file_dfs_port();
}
inline ::google::protobuf::uint32 CMsgDRMFinalResult::download_file_dfs_port() const {
  return download_file_dfs_port_;
}
inline void CMsgDRMFinalResult::set_download_file_dfs_port(::google::protobuf::uint32 value) {
  set_has_download_file_dfs_port();
  download_file_dfs_port_ = value;
}

// optional string download_file_url = 8;
inline bool CMsgDRMFinalResult::has_download_file_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDRMFinalResult::set_has_download_file_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDRMFinalResult::clear_has_download_file_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDRMFinalResult::clear_download_file_url() {
  if (download_file_url_ != &::google::protobuf::internal::kEmptyString) {
    download_file_url_->clear();
  }
  clear_has_download_file_url();
}
inline const ::std::string& CMsgDRMFinalResult::download_file_url() const {
  return *download_file_url_;
}
inline void CMsgDRMFinalResult::set_download_file_url(const ::std::string& value) {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  download_file_url_->assign(value);
}
inline void CMsgDRMFinalResult::set_download_file_url(const char* value) {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  download_file_url_->assign(value);
}
inline void CMsgDRMFinalResult::set_download_file_url(const char* value, size_t size) {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  download_file_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgDRMFinalResult::mutable_download_file_url() {
  set_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    download_file_url_ = new ::std::string;
  }
  return download_file_url_;
}
inline ::std::string* CMsgDRMFinalResult::release_download_file_url() {
  clear_has_download_file_url();
  if (download_file_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = download_file_url_;
    download_file_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgDRMFinalResult::set_allocated_download_file_url(::std::string* download_file_url) {
  if (download_file_url_ != &::google::protobuf::internal::kEmptyString) {
    delete download_file_url_;
  }
  if (download_file_url) {
    set_has_download_file_url();
    download_file_url_ = download_file_url;
  } else {
    clear_has_download_file_url();
    download_file_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientDPCheckSpecialSurvey

// optional uint32 survey_id = 1;
inline bool CMsgClientDPCheckSpecialSurvey::has_survey_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDPCheckSpecialSurvey::set_has_survey_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDPCheckSpecialSurvey::clear_has_survey_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDPCheckSpecialSurvey::clear_survey_id() {
  survey_id_ = 0u;
  clear_has_survey_id();
}
inline ::google::protobuf::uint32 CMsgClientDPCheckSpecialSurvey::survey_id() const {
  return survey_id_;
}
inline void CMsgClientDPCheckSpecialSurvey::set_survey_id(::google::protobuf::uint32 value) {
  set_has_survey_id();
  survey_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientDPCheckSpecialSurveyResponse

// optional uint32 eResult = 1 [default = 2];
inline bool CMsgClientDPCheckSpecialSurveyResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientDPCheckSpecialSurveyResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional uint32 state = 2;
inline bool CMsgClientDPCheckSpecialSurveyResponse::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 CMsgClientDPCheckSpecialSurveyResponse::state() const {
  return state_;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional string name = 3;
inline bool CMsgClientDPCheckSpecialSurveyResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CMsgClientDPCheckSpecialSurveyResponse::name() const {
  return *name_;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientDPCheckSpecialSurveyResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CMsgClientDPCheckSpecialSurveyResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string custom_url = 4;
inline bool CMsgClientDPCheckSpecialSurveyResponse::has_custom_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_has_custom_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_has_custom_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_custom_url() {
  if (custom_url_ != &::google::protobuf::internal::kEmptyString) {
    custom_url_->clear();
  }
  clear_has_custom_url();
}
inline const ::std::string& CMsgClientDPCheckSpecialSurveyResponse::custom_url() const {
  return *custom_url_;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_custom_url(const ::std::string& value) {
  set_has_custom_url();
  if (custom_url_ == &::google::protobuf::internal::kEmptyString) {
    custom_url_ = new ::std::string;
  }
  custom_url_->assign(value);
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_custom_url(const char* value) {
  set_has_custom_url();
  if (custom_url_ == &::google::protobuf::internal::kEmptyString) {
    custom_url_ = new ::std::string;
  }
  custom_url_->assign(value);
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_custom_url(const char* value, size_t size) {
  set_has_custom_url();
  if (custom_url_ == &::google::protobuf::internal::kEmptyString) {
    custom_url_ = new ::std::string;
  }
  custom_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientDPCheckSpecialSurveyResponse::mutable_custom_url() {
  set_has_custom_url();
  if (custom_url_ == &::google::protobuf::internal::kEmptyString) {
    custom_url_ = new ::std::string;
  }
  return custom_url_;
}
inline ::std::string* CMsgClientDPCheckSpecialSurveyResponse::release_custom_url() {
  clear_has_custom_url();
  if (custom_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_url_;
    custom_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_allocated_custom_url(::std::string* custom_url) {
  if (custom_url_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_url_;
  }
  if (custom_url) {
    set_has_custom_url();
    custom_url_ = custom_url;
  } else {
    clear_has_custom_url();
    custom_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool include_software = 5;
inline bool CMsgClientDPCheckSpecialSurveyResponse::has_include_software() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_has_include_software() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_has_include_software() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_include_software() {
  include_software_ = false;
  clear_has_include_software();
}
inline bool CMsgClientDPCheckSpecialSurveyResponse::include_software() const {
  return include_software_;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_include_software(bool value) {
  set_has_include_software();
  include_software_ = value;
}

// optional bytes token = 6;
inline bool CMsgClientDPCheckSpecialSurveyResponse::has_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_has_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgClientDPCheckSpecialSurveyResponse::token() const {
  return *token_;
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientDPCheckSpecialSurveyResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgClientDPCheckSpecialSurveyResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientDPCheckSpecialSurveyResponse::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientDPSendSpecialSurveyResponse

// optional uint32 survey_id = 1;
inline bool CMsgClientDPSendSpecialSurveyResponse::has_survey_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_has_survey_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDPSendSpecialSurveyResponse::clear_has_survey_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDPSendSpecialSurveyResponse::clear_survey_id() {
  survey_id_ = 0u;
  clear_has_survey_id();
}
inline ::google::protobuf::uint32 CMsgClientDPSendSpecialSurveyResponse::survey_id() const {
  return survey_id_;
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_survey_id(::google::protobuf::uint32 value) {
  set_has_survey_id();
  survey_id_ = value;
}

// optional bytes data = 2;
inline bool CMsgClientDPSendSpecialSurveyResponse::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientDPSendSpecialSurveyResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientDPSendSpecialSurveyResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CMsgClientDPSendSpecialSurveyResponse::data() const {
  return *data_;
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientDPSendSpecialSurveyResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CMsgClientDPSendSpecialSurveyResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientDPSendSpecialSurveyResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientDPSendSpecialSurveyResponseReply

// optional uint32 eResult = 1 [default = 2];
inline bool CMsgClientDPSendSpecialSurveyResponseReply::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::clear_eresult() {
  eresult_ = 2u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientDPSendSpecialSurveyResponseReply::eresult() const {
  return eresult_;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional bytes token = 2;
inline bool CMsgClientDPSendSpecialSurveyResponseReply::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsgClientDPSendSpecialSurveyResponseReply::token() const {
  return *token_;
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientDPSendSpecialSurveyResponseReply::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CMsgClientDPSendSpecialSurveyResponseReply::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientDPSendSpecialSurveyResponseReply::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestForgottenPasswordEmail

// optional string account_name = 1;
inline bool CMsgClientRequestForgottenPasswordEmail::has_account_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestForgottenPasswordEmail::set_has_account_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestForgottenPasswordEmail::clear_has_account_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestForgottenPasswordEmail::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& CMsgClientRequestForgottenPasswordEmail::account_name() const {
  return *account_name_;
}
inline void CMsgClientRequestForgottenPasswordEmail::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientRequestForgottenPasswordEmail::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientRequestForgottenPasswordEmail::set_account_name(const char* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestForgottenPasswordEmail::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  return account_name_;
}
inline ::std::string* CMsgClientRequestForgottenPasswordEmail::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestForgottenPasswordEmail::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password_tried = 2;
inline bool CMsgClientRequestForgottenPasswordEmail::has_password_tried() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestForgottenPasswordEmail::set_has_password_tried() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestForgottenPasswordEmail::clear_has_password_tried() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestForgottenPasswordEmail::clear_password_tried() {
  if (password_tried_ != &::google::protobuf::internal::kEmptyString) {
    password_tried_->clear();
  }
  clear_has_password_tried();
}
inline const ::std::string& CMsgClientRequestForgottenPasswordEmail::password_tried() const {
  return *password_tried_;
}
inline void CMsgClientRequestForgottenPasswordEmail::set_password_tried(const ::std::string& value) {
  set_has_password_tried();
  if (password_tried_ == &::google::protobuf::internal::kEmptyString) {
    password_tried_ = new ::std::string;
  }
  password_tried_->assign(value);
}
inline void CMsgClientRequestForgottenPasswordEmail::set_password_tried(const char* value) {
  set_has_password_tried();
  if (password_tried_ == &::google::protobuf::internal::kEmptyString) {
    password_tried_ = new ::std::string;
  }
  password_tried_->assign(value);
}
inline void CMsgClientRequestForgottenPasswordEmail::set_password_tried(const char* value, size_t size) {
  set_has_password_tried();
  if (password_tried_ == &::google::protobuf::internal::kEmptyString) {
    password_tried_ = new ::std::string;
  }
  password_tried_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestForgottenPasswordEmail::mutable_password_tried() {
  set_has_password_tried();
  if (password_tried_ == &::google::protobuf::internal::kEmptyString) {
    password_tried_ = new ::std::string;
  }
  return password_tried_;
}
inline ::std::string* CMsgClientRequestForgottenPasswordEmail::release_password_tried() {
  clear_has_password_tried();
  if (password_tried_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_tried_;
    password_tried_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestForgottenPasswordEmail::set_allocated_password_tried(::std::string* password_tried) {
  if (password_tried_ != &::google::protobuf::internal::kEmptyString) {
    delete password_tried_;
  }
  if (password_tried) {
    set_has_password_tried();
    password_tried_ = password_tried;
  } else {
    clear_has_password_tried();
    password_tried_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientRequestForgottenPasswordEmailResponse

// optional uint32 eResult = 1;
inline bool CMsgClientRequestForgottenPasswordEmailResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::clear_eresult() {
  eresult_ = 0u;
  clear_has_eresult();
}
inline ::google::protobuf::uint32 CMsgClientRequestForgottenPasswordEmailResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::set_eresult(::google::protobuf::uint32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional bool use_secret_question = 2;
inline bool CMsgClientRequestForgottenPasswordEmailResponse::has_use_secret_question() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::set_has_use_secret_question() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::clear_has_use_secret_question() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::clear_use_secret_question() {
  use_secret_question_ = false;
  clear_has_use_secret_question();
}
inline bool CMsgClientRequestForgottenPasswordEmailResponse::use_secret_question() const {
  return use_secret_question_;
}
inline void CMsgClientRequestForgottenPasswordEmailResponse::set_use_secret_question(bool value) {
  set_has_use_secret_question();
  use_secret_question_ = value;
}

// -------------------------------------------------------------------

// CMsgClientItemAnnouncements

// optional uint32 count_new_items = 1;
inline bool CMsgClientItemAnnouncements::has_count_new_items() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientItemAnnouncements::set_has_count_new_items() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientItemAnnouncements::clear_has_count_new_items() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientItemAnnouncements::clear_count_new_items() {
  count_new_items_ = 0u;
  clear_has_count_new_items();
}
inline ::google::protobuf::uint32 CMsgClientItemAnnouncements::count_new_items() const {
  return count_new_items_;
}
inline void CMsgClientItemAnnouncements::set_count_new_items(::google::protobuf::uint32 value) {
  set_has_count_new_items();
  count_new_items_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestItemAnnouncements

// -------------------------------------------------------------------

// CMsgClientCommentNotifications

// optional uint32 count_new_comments = 1;
inline bool CMsgClientCommentNotifications::has_count_new_comments() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientCommentNotifications::set_has_count_new_comments() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientCommentNotifications::clear_has_count_new_comments() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientCommentNotifications::clear_count_new_comments() {
  count_new_comments_ = 0u;
  clear_has_count_new_comments();
}
inline ::google::protobuf::uint32 CMsgClientCommentNotifications::count_new_comments() const {
  return count_new_comments_;
}
inline void CMsgClientCommentNotifications::set_count_new_comments(::google::protobuf::uint32 value) {
  set_has_count_new_comments();
  count_new_comments_ = value;
}

// optional uint32 count_new_comments_owner = 2;
inline bool CMsgClientCommentNotifications::has_count_new_comments_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientCommentNotifications::set_has_count_new_comments_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientCommentNotifications::clear_has_count_new_comments_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientCommentNotifications::clear_count_new_comments_owner() {
  count_new_comments_owner_ = 0u;
  clear_has_count_new_comments_owner();
}
inline ::google::protobuf::uint32 CMsgClientCommentNotifications::count_new_comments_owner() const {
  return count_new_comments_owner_;
}
inline void CMsgClientCommentNotifications::set_count_new_comments_owner(::google::protobuf::uint32 value) {
  set_has_count_new_comments_owner();
  count_new_comments_owner_ = value;
}

// optional uint32 count_new_comments_subscriptions = 3;
inline bool CMsgClientCommentNotifications::has_count_new_comments_subscriptions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientCommentNotifications::set_has_count_new_comments_subscriptions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientCommentNotifications::clear_has_count_new_comments_subscriptions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientCommentNotifications::clear_count_new_comments_subscriptions() {
  count_new_comments_subscriptions_ = 0u;
  clear_has_count_new_comments_subscriptions();
}
inline ::google::protobuf::uint32 CMsgClientCommentNotifications::count_new_comments_subscriptions() const {
  return count_new_comments_subscriptions_;
}
inline void CMsgClientCommentNotifications::set_count_new_comments_subscriptions(::google::protobuf::uint32 value) {
  set_has_count_new_comments_subscriptions();
  count_new_comments_subscriptions_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestCommentNotifications

// -------------------------------------------------------------------

// CMsgClientOfflineMessageNotification

// optional uint32 offline_messages = 1;
inline bool CMsgClientOfflineMessageNotification::has_offline_messages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientOfflineMessageNotification::set_has_offline_messages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientOfflineMessageNotification::clear_has_offline_messages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientOfflineMessageNotification::clear_offline_messages() {
  offline_messages_ = 0u;
  clear_has_offline_messages();
}
inline ::google::protobuf::uint32 CMsgClientOfflineMessageNotification::offline_messages() const {
  return offline_messages_;
}
inline void CMsgClientOfflineMessageNotification::set_offline_messages(::google::protobuf::uint32 value) {
  set_has_offline_messages();
  offline_messages_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestOfflineMessageCount

// -------------------------------------------------------------------

// CMsgClientFSGetFriendMessageHistory

// optional fixed64 steamid = 1;
inline bool CMsgClientFSGetFriendMessageHistory::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistory::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFSGetFriendMessageHistory::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFSGetFriendMessageHistory::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientFSGetFriendMessageHistory::steamid() const {
  return steamid_;
}
inline void CMsgClientFSGetFriendMessageHistory::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage

// optional uint32 accountid = 1;
inline bool CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::accountid() const {
  return accountid_;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional uint32 timestamp = 2;
inline bool CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::timestamp() const {
  return timestamp_;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string message = 3;
inline bool CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::message() const {
  return *message_;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool unread = 4;
inline bool CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::has_unread() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_has_unread() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_has_unread() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::clear_unread() {
  unread_ = false;
  clear_has_unread();
}
inline bool CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::unread() const {
  return unread_;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage::set_unread(bool value) {
  set_has_unread();
  unread_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFSGetFriendMessageHistoryResponse

// optional fixed64 steamid = 1;
inline bool CMsgClientFSGetFriendMessageHistoryResponse::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientFSGetFriendMessageHistoryResponse::steamid() const {
  return steamid_;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// optional uint32 success = 2;
inline bool CMsgClientFSGetFriendMessageHistoryResponse::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::clear_success() {
  success_ = 0u;
  clear_has_success();
}
inline ::google::protobuf::uint32 CMsgClientFSGetFriendMessageHistoryResponse::success() const {
  return success_;
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::set_success(::google::protobuf::uint32 value) {
  set_has_success();
  success_ = value;
}

// repeated .Sc.CMsgClientFSGetFriendMessageHistoryResponse.FriendMessage messages = 3;
inline int CMsgClientFSGetFriendMessageHistoryResponse::messages_size() const {
  return messages_.size();
}
inline void CMsgClientFSGetFriendMessageHistoryResponse::clear_messages() {
  messages_.Clear();
}
inline const ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage& CMsgClientFSGetFriendMessageHistoryResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* CMsgClientFSGetFriendMessageHistoryResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage* CMsgClientFSGetFriendMessageHistoryResponse::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage >&
CMsgClientFSGetFriendMessageHistoryResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendMessageHistoryResponse_FriendMessage >*
CMsgClientFSGetFriendMessageHistoryResponse::mutable_messages() {
  return &messages_;
}

// -------------------------------------------------------------------

// CMsgClientFSGetFriendMessageHistoryForOfflineMessages

// -------------------------------------------------------------------

// CMsgClientFSGetFriendsSteamLevels

// repeated uint32 accountids = 1;
inline int CMsgClientFSGetFriendsSteamLevels::accountids_size() const {
  return accountids_.size();
}
inline void CMsgClientFSGetFriendsSteamLevels::clear_accountids() {
  accountids_.Clear();
}
inline ::google::protobuf::uint32 CMsgClientFSGetFriendsSteamLevels::accountids(int index) const {
  return accountids_.Get(index);
}
inline void CMsgClientFSGetFriendsSteamLevels::set_accountids(int index, ::google::protobuf::uint32 value) {
  accountids_.Set(index, value);
}
inline void CMsgClientFSGetFriendsSteamLevels::add_accountids(::google::protobuf::uint32 value) {
  accountids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgClientFSGetFriendsSteamLevels::accountids() const {
  return accountids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgClientFSGetFriendsSteamLevels::mutable_accountids() {
  return &accountids_;
}

// -------------------------------------------------------------------

// CMsgClientFSGetFriendsSteamLevelsResponse_Friend

// optional uint32 accountid = 1;
inline bool CMsgClientFSGetFriendsSteamLevelsResponse_Friend::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 CMsgClientFSGetFriendsSteamLevelsResponse_Friend::accountid() const {
  return accountid_;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional uint32 level = 2;
inline bool CMsgClientFSGetFriendsSteamLevelsResponse_Friend::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CMsgClientFSGetFriendsSteamLevelsResponse_Friend::level() const {
  return level_;
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse_Friend::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFSGetFriendsSteamLevelsResponse

// repeated .Sc.CMsgClientFSGetFriendsSteamLevelsResponse.Friend friends = 1;
inline int CMsgClientFSGetFriendsSteamLevelsResponse::friends_size() const {
  return friends_.size();
}
inline void CMsgClientFSGetFriendsSteamLevelsResponse::clear_friends() {
  friends_.Clear();
}
inline const ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend& CMsgClientFSGetFriendsSteamLevelsResponse::friends(int index) const {
  return friends_.Get(index);
}
inline ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend* CMsgClientFSGetFriendsSteamLevelsResponse::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend* CMsgClientFSGetFriendsSteamLevelsResponse::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend >&
CMsgClientFSGetFriendsSteamLevelsResponse::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgClientFSGetFriendsSteamLevelsResponse_Friend >*
CMsgClientFSGetFriendsSteamLevelsResponse::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// CMsgClientEmailAddrInfo

// optional string email_address = 1;
inline bool CMsgClientEmailAddrInfo::has_email_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientEmailAddrInfo::set_has_email_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientEmailAddrInfo::clear_has_email_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientEmailAddrInfo::clear_email_address() {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    email_address_->clear();
  }
  clear_has_email_address();
}
inline const ::std::string& CMsgClientEmailAddrInfo::email_address() const {
  return *email_address_;
}
inline void CMsgClientEmailAddrInfo::set_email_address(const ::std::string& value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void CMsgClientEmailAddrInfo::set_email_address(const char* value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void CMsgClientEmailAddrInfo::set_email_address(const char* value, size_t size) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientEmailAddrInfo::mutable_email_address() {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  return email_address_;
}
inline ::std::string* CMsgClientEmailAddrInfo::release_email_address() {
  clear_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_address_;
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientEmailAddrInfo::set_allocated_email_address(::std::string* email_address) {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    delete email_address_;
  }
  if (email_address) {
    set_has_email_address();
    email_address_ = email_address;
  } else {
    clear_has_email_address();
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool email_is_validated = 2;
inline bool CMsgClientEmailAddrInfo::has_email_is_validated() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientEmailAddrInfo::set_has_email_is_validated() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientEmailAddrInfo::clear_has_email_is_validated() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientEmailAddrInfo::clear_email_is_validated() {
  email_is_validated_ = false;
  clear_has_email_is_validated();
}
inline bool CMsgClientEmailAddrInfo::email_is_validated() const {
  return email_is_validated_;
}
inline void CMsgClientEmailAddrInfo::set_email_is_validated(bool value) {
  set_has_email_is_validated();
  email_is_validated_ = value;
}

// optional bool email_validation_changed = 3;
inline bool CMsgClientEmailAddrInfo::has_email_validation_changed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientEmailAddrInfo::set_has_email_validation_changed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientEmailAddrInfo::clear_has_email_validation_changed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientEmailAddrInfo::clear_email_validation_changed() {
  email_validation_changed_ = false;
  clear_has_email_validation_changed();
}
inline bool CMsgClientEmailAddrInfo::email_validation_changed() const {
  return email_validation_changed_;
}
inline void CMsgClientEmailAddrInfo::set_email_validation_changed(bool value) {
  set_has_email_validation_changed();
  email_validation_changed_ = value;
}

// optional bool credential_change_requires_code = 4;
inline bool CMsgClientEmailAddrInfo::has_credential_change_requires_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientEmailAddrInfo::set_has_credential_change_requires_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientEmailAddrInfo::clear_has_credential_change_requires_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientEmailAddrInfo::clear_credential_change_requires_code() {
  credential_change_requires_code_ = false;
  clear_has_credential_change_requires_code();
}
inline bool CMsgClientEmailAddrInfo::credential_change_requires_code() const {
  return credential_change_requires_code_;
}
inline void CMsgClientEmailAddrInfo::set_credential_change_requires_code(bool value) {
  set_has_credential_change_requires_code();
  credential_change_requires_code_ = value;
}

// optional bool password_or_secretqa_change_requires_code = 5;
inline bool CMsgClientEmailAddrInfo::has_password_or_secretqa_change_requires_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientEmailAddrInfo::set_has_password_or_secretqa_change_requires_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientEmailAddrInfo::clear_has_password_or_secretqa_change_requires_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientEmailAddrInfo::clear_password_or_secretqa_change_requires_code() {
  password_or_secretqa_change_requires_code_ = false;
  clear_has_password_or_secretqa_change_requires_code();
}
inline bool CMsgClientEmailAddrInfo::password_or_secretqa_change_requires_code() const {
  return password_or_secretqa_change_requires_code_;
}
inline void CMsgClientEmailAddrInfo::set_password_or_secretqa_change_requires_code(bool value) {
  set_has_password_or_secretqa_change_requires_code();
  password_or_secretqa_change_requires_code_ = value;
}

// optional bool remind_user_about_email = 6;
inline bool CMsgClientEmailAddrInfo::has_remind_user_about_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientEmailAddrInfo::set_has_remind_user_about_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientEmailAddrInfo::clear_has_remind_user_about_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientEmailAddrInfo::clear_remind_user_about_email() {
  remind_user_about_email_ = false;
  clear_has_remind_user_about_email();
}
inline bool CMsgClientEmailAddrInfo::remind_user_about_email() const {
  return remind_user_about_email_;
}
inline void CMsgClientEmailAddrInfo::set_remind_user_about_email(bool value) {
  set_has_remind_user_about_email();
  remind_user_about_email_ = value;
}

// -------------------------------------------------------------------

// CMsgCREEnumeratePublishedFiles

// optional uint32 app_id = 1;
inline bool CMsgCREEnumeratePublishedFiles::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREEnumeratePublishedFiles::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgCREEnumeratePublishedFiles::app_id() const {
  return app_id_;
}
inline void CMsgCREEnumeratePublishedFiles::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional int32 query_type = 2;
inline bool CMsgCREEnumeratePublishedFiles::has_query_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCREEnumeratePublishedFiles::set_has_query_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_has_query_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_query_type() {
  query_type_ = 0;
  clear_has_query_type();
}
inline ::google::protobuf::int32 CMsgCREEnumeratePublishedFiles::query_type() const {
  return query_type_;
}
inline void CMsgCREEnumeratePublishedFiles::set_query_type(::google::protobuf::int32 value) {
  set_has_query_type();
  query_type_ = value;
}

// optional uint32 start_index = 3;
inline bool CMsgCREEnumeratePublishedFiles::has_start_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCREEnumeratePublishedFiles::set_has_start_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgCREEnumeratePublishedFiles::start_index() const {
  return start_index_;
}
inline void CMsgCREEnumeratePublishedFiles::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional uint32 days = 4;
inline bool CMsgCREEnumeratePublishedFiles::has_days() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCREEnumeratePublishedFiles::set_has_days() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_has_days() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_days() {
  days_ = 0u;
  clear_has_days();
}
inline ::google::protobuf::uint32 CMsgCREEnumeratePublishedFiles::days() const {
  return days_;
}
inline void CMsgCREEnumeratePublishedFiles::set_days(::google::protobuf::uint32 value) {
  set_has_days();
  days_ = value;
}

// optional uint32 count = 5;
inline bool CMsgCREEnumeratePublishedFiles::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgCREEnumeratePublishedFiles::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgCREEnumeratePublishedFiles::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgCREEnumeratePublishedFiles::count() const {
  return count_;
}
inline void CMsgCREEnumeratePublishedFiles::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated string tags = 6;
inline int CMsgCREEnumeratePublishedFiles::tags_size() const {
  return tags_.size();
}
inline void CMsgCREEnumeratePublishedFiles::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CMsgCREEnumeratePublishedFiles::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CMsgCREEnumeratePublishedFiles::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CMsgCREEnumeratePublishedFiles::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgCREEnumeratePublishedFiles::add_tags() {
  return tags_.Add();
}
inline void CMsgCREEnumeratePublishedFiles::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgCREEnumeratePublishedFiles::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgCREEnumeratePublishedFiles::mutable_tags() {
  return &tags_;
}

// repeated string user_tags = 7;
inline int CMsgCREEnumeratePublishedFiles::user_tags_size() const {
  return user_tags_.size();
}
inline void CMsgCREEnumeratePublishedFiles::clear_user_tags() {
  user_tags_.Clear();
}
inline const ::std::string& CMsgCREEnumeratePublishedFiles::user_tags(int index) const {
  return user_tags_.Get(index);
}
inline ::std::string* CMsgCREEnumeratePublishedFiles::mutable_user_tags(int index) {
  return user_tags_.Mutable(index);
}
inline void CMsgCREEnumeratePublishedFiles::set_user_tags(int index, const ::std::string& value) {
  user_tags_.Mutable(index)->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::set_user_tags(int index, const char* value) {
  user_tags_.Mutable(index)->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::set_user_tags(int index, const char* value, size_t size) {
  user_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgCREEnumeratePublishedFiles::add_user_tags() {
  return user_tags_.Add();
}
inline void CMsgCREEnumeratePublishedFiles::add_user_tags(const ::std::string& value) {
  user_tags_.Add()->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::add_user_tags(const char* value) {
  user_tags_.Add()->assign(value);
}
inline void CMsgCREEnumeratePublishedFiles::add_user_tags(const char* value, size_t size) {
  user_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgCREEnumeratePublishedFiles::user_tags() const {
  return user_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgCREEnumeratePublishedFiles::mutable_user_tags() {
  return &user_tags_;
}

// -------------------------------------------------------------------

// CMsgCREEnumeratePublishedFilesResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional int32 votes_for = 2;
inline bool CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::has_votes_for() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_has_votes_for() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_has_votes_for() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_votes_for() {
  votes_for_ = 0;
  clear_has_votes_for();
}
inline ::google::protobuf::int32 CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::votes_for() const {
  return votes_for_;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_votes_for(::google::protobuf::int32 value) {
  set_has_votes_for();
  votes_for_ = value;
}

// optional int32 votes_against = 3;
inline bool CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::has_votes_against() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_has_votes_against() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_has_votes_against() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_votes_against() {
  votes_against_ = 0;
  clear_has_votes_against();
}
inline ::google::protobuf::int32 CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::votes_against() const {
  return votes_against_;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_votes_against(::google::protobuf::int32 value) {
  set_has_votes_against();
  votes_against_ = value;
}

// optional int32 reports = 4;
inline bool CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::has_reports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_has_reports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_has_reports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_reports() {
  reports_ = 0;
  clear_has_reports();
}
inline ::google::protobuf::int32 CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::reports() const {
  return reports_;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_reports(::google::protobuf::int32 value) {
  set_has_reports();
  reports_ = value;
}

// optional float score = 5;
inline bool CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::score() const {
  return score_;
}
inline void CMsgCREEnumeratePublishedFilesResponse_PublishedFileId::set_score(float value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CMsgCREEnumeratePublishedFilesResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgCREEnumeratePublishedFilesResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREEnumeratePublishedFilesResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREEnumeratePublishedFilesResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgCREEnumeratePublishedFilesResponse::eresult() const {
  return eresult_;
}
inline void CMsgCREEnumeratePublishedFilesResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgCREEnumeratePublishedFilesResponse.PublishedFileId published_files = 2;
inline int CMsgCREEnumeratePublishedFilesResponse::published_files_size() const {
  return published_files_.size();
}
inline void CMsgCREEnumeratePublishedFilesResponse::clear_published_files() {
  published_files_.Clear();
}
inline const ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId& CMsgCREEnumeratePublishedFilesResponse::published_files(int index) const {
  return published_files_.Get(index);
}
inline ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* CMsgCREEnumeratePublishedFilesResponse::mutable_published_files(int index) {
  return published_files_.Mutable(index);
}
inline ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId* CMsgCREEnumeratePublishedFilesResponse::add_published_files() {
  return published_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId >&
CMsgCREEnumeratePublishedFilesResponse::published_files() const {
  return published_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREEnumeratePublishedFilesResponse_PublishedFileId >*
CMsgCREEnumeratePublishedFilesResponse::mutable_published_files() {
  return &published_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgCREEnumeratePublishedFilesResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCREEnumeratePublishedFilesResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCREEnumeratePublishedFilesResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCREEnumeratePublishedFilesResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgCREEnumeratePublishedFilesResponse::total_results() const {
  return total_results_;
}
inline void CMsgCREEnumeratePublishedFilesResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgCRERankByVote

// optional uint32 app_id = 1;
inline bool CMsgCRERankByVote::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCRERankByVote::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCRERankByVote::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCRERankByVote::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgCRERankByVote::app_id() const {
  return app_id_;
}
inline void CMsgCRERankByVote::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 start_index = 2;
inline bool CMsgCRERankByVote::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCRERankByVote::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCRERankByVote::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCRERankByVote::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgCRERankByVote::start_index() const {
  return start_index_;
}
inline void CMsgCRERankByVote::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional uint32 count = 3;
inline bool CMsgCRERankByVote::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCRERankByVote::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCRERankByVote::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCRERankByVote::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgCRERankByVote::count() const {
  return count_;
}
inline void CMsgCRERankByVote::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated string tags = 4;
inline int CMsgCRERankByVote::tags_size() const {
  return tags_.size();
}
inline void CMsgCRERankByVote::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CMsgCRERankByVote::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CMsgCRERankByVote::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CMsgCRERankByVote::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByVote::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByVote::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgCRERankByVote::add_tags() {
  return tags_.Add();
}
inline void CMsgCRERankByVote::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CMsgCRERankByVote::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CMsgCRERankByVote::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgCRERankByVote::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgCRERankByVote::mutable_tags() {
  return &tags_;
}

// repeated string user_tags = 5;
inline int CMsgCRERankByVote::user_tags_size() const {
  return user_tags_.size();
}
inline void CMsgCRERankByVote::clear_user_tags() {
  user_tags_.Clear();
}
inline const ::std::string& CMsgCRERankByVote::user_tags(int index) const {
  return user_tags_.Get(index);
}
inline ::std::string* CMsgCRERankByVote::mutable_user_tags(int index) {
  return user_tags_.Mutable(index);
}
inline void CMsgCRERankByVote::set_user_tags(int index, const ::std::string& value) {
  user_tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByVote::set_user_tags(int index, const char* value) {
  user_tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByVote::set_user_tags(int index, const char* value, size_t size) {
  user_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgCRERankByVote::add_user_tags() {
  return user_tags_.Add();
}
inline void CMsgCRERankByVote::add_user_tags(const ::std::string& value) {
  user_tags_.Add()->assign(value);
}
inline void CMsgCRERankByVote::add_user_tags(const char* value) {
  user_tags_.Add()->assign(value);
}
inline void CMsgCRERankByVote::add_user_tags(const char* value, size_t size) {
  user_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgCRERankByVote::user_tags() const {
  return user_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgCRERankByVote::mutable_user_tags() {
  return &user_tags_;
}

// -------------------------------------------------------------------

// CMsgCRERankByVoteResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgCRERankByVoteResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCRERankByVoteResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional int32 votes_for = 2;
inline bool CMsgCRERankByVoteResponse_PublishedFileId::has_votes_for() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_has_votes_for() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_has_votes_for() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_votes_for() {
  votes_for_ = 0;
  clear_has_votes_for();
}
inline ::google::protobuf::int32 CMsgCRERankByVoteResponse_PublishedFileId::votes_for() const {
  return votes_for_;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_votes_for(::google::protobuf::int32 value) {
  set_has_votes_for();
  votes_for_ = value;
}

// optional int32 votes_against = 3;
inline bool CMsgCRERankByVoteResponse_PublishedFileId::has_votes_against() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_has_votes_against() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_has_votes_against() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_votes_against() {
  votes_against_ = 0;
  clear_has_votes_against();
}
inline ::google::protobuf::int32 CMsgCRERankByVoteResponse_PublishedFileId::votes_against() const {
  return votes_against_;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_votes_against(::google::protobuf::int32 value) {
  set_has_votes_against();
  votes_against_ = value;
}

// optional int32 reports = 4;
inline bool CMsgCRERankByVoteResponse_PublishedFileId::has_reports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_has_reports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_has_reports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_reports() {
  reports_ = 0;
  clear_has_reports();
}
inline ::google::protobuf::int32 CMsgCRERankByVoteResponse_PublishedFileId::reports() const {
  return reports_;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_reports(::google::protobuf::int32 value) {
  set_has_reports();
  reports_ = value;
}

// optional float score = 5;
inline bool CMsgCRERankByVoteResponse_PublishedFileId::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgCRERankByVoteResponse_PublishedFileId::score() const {
  return score_;
}
inline void CMsgCRERankByVoteResponse_PublishedFileId::set_score(float value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CMsgCRERankByVoteResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgCRERankByVoteResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCRERankByVoteResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCRERankByVoteResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCRERankByVoteResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgCRERankByVoteResponse::eresult() const {
  return eresult_;
}
inline void CMsgCRERankByVoteResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgCRERankByVoteResponse.PublishedFileId published_files = 2;
inline int CMsgCRERankByVoteResponse::published_files_size() const {
  return published_files_.size();
}
inline void CMsgCRERankByVoteResponse::clear_published_files() {
  published_files_.Clear();
}
inline const ::Sc::CMsgCRERankByVoteResponse_PublishedFileId& CMsgCRERankByVoteResponse::published_files(int index) const {
  return published_files_.Get(index);
}
inline ::Sc::CMsgCRERankByVoteResponse_PublishedFileId* CMsgCRERankByVoteResponse::mutable_published_files(int index) {
  return published_files_.Mutable(index);
}
inline ::Sc::CMsgCRERankByVoteResponse_PublishedFileId* CMsgCRERankByVoteResponse::add_published_files() {
  return published_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByVoteResponse_PublishedFileId >&
CMsgCRERankByVoteResponse::published_files() const {
  return published_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByVoteResponse_PublishedFileId >*
CMsgCRERankByVoteResponse::mutable_published_files() {
  return &published_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgCRERankByVoteResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCRERankByVoteResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCRERankByVoteResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCRERankByVoteResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgCRERankByVoteResponse::total_results() const {
  return total_results_;
}
inline void CMsgCRERankByVoteResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgCRERankByTrend

// optional uint32 app_id = 1;
inline bool CMsgCRERankByTrend::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCRERankByTrend::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCRERankByTrend::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCRERankByTrend::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 CMsgCRERankByTrend::app_id() const {
  return app_id_;
}
inline void CMsgCRERankByTrend::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 start_index = 2;
inline bool CMsgCRERankByTrend::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCRERankByTrend::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCRERankByTrend::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCRERankByTrend::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgCRERankByTrend::start_index() const {
  return start_index_;
}
inline void CMsgCRERankByTrend::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional uint32 days = 3;
inline bool CMsgCRERankByTrend::has_days() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCRERankByTrend::set_has_days() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCRERankByTrend::clear_has_days() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCRERankByTrend::clear_days() {
  days_ = 0u;
  clear_has_days();
}
inline ::google::protobuf::uint32 CMsgCRERankByTrend::days() const {
  return days_;
}
inline void CMsgCRERankByTrend::set_days(::google::protobuf::uint32 value) {
  set_has_days();
  days_ = value;
}

// optional uint32 count = 4;
inline bool CMsgCRERankByTrend::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCRERankByTrend::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgCRERankByTrend::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgCRERankByTrend::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgCRERankByTrend::count() const {
  return count_;
}
inline void CMsgCRERankByTrend::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated string tags = 5;
inline int CMsgCRERankByTrend::tags_size() const {
  return tags_.size();
}
inline void CMsgCRERankByTrend::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CMsgCRERankByTrend::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CMsgCRERankByTrend::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CMsgCRERankByTrend::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByTrend::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByTrend::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgCRERankByTrend::add_tags() {
  return tags_.Add();
}
inline void CMsgCRERankByTrend::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CMsgCRERankByTrend::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CMsgCRERankByTrend::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgCRERankByTrend::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgCRERankByTrend::mutable_tags() {
  return &tags_;
}

// repeated string user_tags = 6;
inline int CMsgCRERankByTrend::user_tags_size() const {
  return user_tags_.size();
}
inline void CMsgCRERankByTrend::clear_user_tags() {
  user_tags_.Clear();
}
inline const ::std::string& CMsgCRERankByTrend::user_tags(int index) const {
  return user_tags_.Get(index);
}
inline ::std::string* CMsgCRERankByTrend::mutable_user_tags(int index) {
  return user_tags_.Mutable(index);
}
inline void CMsgCRERankByTrend::set_user_tags(int index, const ::std::string& value) {
  user_tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByTrend::set_user_tags(int index, const char* value) {
  user_tags_.Mutable(index)->assign(value);
}
inline void CMsgCRERankByTrend::set_user_tags(int index, const char* value, size_t size) {
  user_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgCRERankByTrend::add_user_tags() {
  return user_tags_.Add();
}
inline void CMsgCRERankByTrend::add_user_tags(const ::std::string& value) {
  user_tags_.Add()->assign(value);
}
inline void CMsgCRERankByTrend::add_user_tags(const char* value) {
  user_tags_.Add()->assign(value);
}
inline void CMsgCRERankByTrend::add_user_tags(const char* value, size_t size) {
  user_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMsgCRERankByTrend::user_tags() const {
  return user_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMsgCRERankByTrend::mutable_user_tags() {
  return &user_tags_;
}

// -------------------------------------------------------------------

// CMsgCRERankByTrendResponse_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgCRERankByTrendResponse_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCRERankByTrendResponse_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional int32 votes_for = 2;
inline bool CMsgCRERankByTrendResponse_PublishedFileId::has_votes_for() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_has_votes_for() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_has_votes_for() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_votes_for() {
  votes_for_ = 0;
  clear_has_votes_for();
}
inline ::google::protobuf::int32 CMsgCRERankByTrendResponse_PublishedFileId::votes_for() const {
  return votes_for_;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_votes_for(::google::protobuf::int32 value) {
  set_has_votes_for();
  votes_for_ = value;
}

// optional int32 votes_against = 3;
inline bool CMsgCRERankByTrendResponse_PublishedFileId::has_votes_against() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_has_votes_against() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_has_votes_against() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_votes_against() {
  votes_against_ = 0;
  clear_has_votes_against();
}
inline ::google::protobuf::int32 CMsgCRERankByTrendResponse_PublishedFileId::votes_against() const {
  return votes_against_;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_votes_against(::google::protobuf::int32 value) {
  set_has_votes_against();
  votes_against_ = value;
}

// optional int32 reports = 4;
inline bool CMsgCRERankByTrendResponse_PublishedFileId::has_reports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_has_reports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_has_reports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_reports() {
  reports_ = 0;
  clear_has_reports();
}
inline ::google::protobuf::int32 CMsgCRERankByTrendResponse_PublishedFileId::reports() const {
  return reports_;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_reports(::google::protobuf::int32 value) {
  set_has_reports();
  reports_ = value;
}

// optional float score = 5;
inline bool CMsgCRERankByTrendResponse_PublishedFileId::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgCRERankByTrendResponse_PublishedFileId::score() const {
  return score_;
}
inline void CMsgCRERankByTrendResponse_PublishedFileId::set_score(float value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CMsgCRERankByTrendResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgCRERankByTrendResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCRERankByTrendResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCRERankByTrendResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCRERankByTrendResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgCRERankByTrendResponse::eresult() const {
  return eresult_;
}
inline void CMsgCRERankByTrendResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgCRERankByTrendResponse.PublishedFileId published_files = 2;
inline int CMsgCRERankByTrendResponse::published_files_size() const {
  return published_files_.size();
}
inline void CMsgCRERankByTrendResponse::clear_published_files() {
  published_files_.Clear();
}
inline const ::Sc::CMsgCRERankByTrendResponse_PublishedFileId& CMsgCRERankByTrendResponse::published_files(int index) const {
  return published_files_.Get(index);
}
inline ::Sc::CMsgCRERankByTrendResponse_PublishedFileId* CMsgCRERankByTrendResponse::mutable_published_files(int index) {
  return published_files_.Mutable(index);
}
inline ::Sc::CMsgCRERankByTrendResponse_PublishedFileId* CMsgCRERankByTrendResponse::add_published_files() {
  return published_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByTrendResponse_PublishedFileId >&
CMsgCRERankByTrendResponse::published_files() const {
  return published_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCRERankByTrendResponse_PublishedFileId >*
CMsgCRERankByTrendResponse::mutable_published_files() {
  return &published_files_;
}

// optional uint32 total_results = 3;
inline bool CMsgCRERankByTrendResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCRERankByTrendResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCRERankByTrendResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCRERankByTrendResponse::clear_total_results() {
  total_results_ = 0u;
  clear_has_total_results();
}
inline ::google::protobuf::uint32 CMsgCRERankByTrendResponse::total_results() const {
  return total_results_;
}
inline void CMsgCRERankByTrendResponse::set_total_results(::google::protobuf::uint32 value) {
  set_has_total_results();
  total_results_ = value;
}

// -------------------------------------------------------------------

// CMsgCREItemVoteSummary_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgCREItemVoteSummary_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREItemVoteSummary_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREItemVoteSummary_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREItemVoteSummary_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCREItemVoteSummary_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCREItemVoteSummary_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgCREItemVoteSummary

// repeated .Sc.CMsgCREItemVoteSummary.PublishedFileId published_file_ids = 1;
inline int CMsgCREItemVoteSummary::published_file_ids_size() const {
  return published_file_ids_.size();
}
inline void CMsgCREItemVoteSummary::clear_published_file_ids() {
  published_file_ids_.Clear();
}
inline const ::Sc::CMsgCREItemVoteSummary_PublishedFileId& CMsgCREItemVoteSummary::published_file_ids(int index) const {
  return published_file_ids_.Get(index);
}
inline ::Sc::CMsgCREItemVoteSummary_PublishedFileId* CMsgCREItemVoteSummary::mutable_published_file_ids(int index) {
  return published_file_ids_.Mutable(index);
}
inline ::Sc::CMsgCREItemVoteSummary_PublishedFileId* CMsgCREItemVoteSummary::add_published_file_ids() {
  return published_file_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummary_PublishedFileId >&
CMsgCREItemVoteSummary::published_file_ids() const {
  return published_file_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummary_PublishedFileId >*
CMsgCREItemVoteSummary::mutable_published_file_ids() {
  return &published_file_ids_;
}

// -------------------------------------------------------------------

// CMsgCREItemVoteSummaryResponse_ItemVoteSummary

// optional fixed64 published_file_id = 1;
inline bool CMsgCREItemVoteSummaryResponse_ItemVoteSummary::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCREItemVoteSummaryResponse_ItemVoteSummary::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional int32 votes_for = 2;
inline bool CMsgCREItemVoteSummaryResponse_ItemVoteSummary::has_votes_for() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_has_votes_for() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_has_votes_for() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_votes_for() {
  votes_for_ = 0;
  clear_has_votes_for();
}
inline ::google::protobuf::int32 CMsgCREItemVoteSummaryResponse_ItemVoteSummary::votes_for() const {
  return votes_for_;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_votes_for(::google::protobuf::int32 value) {
  set_has_votes_for();
  votes_for_ = value;
}

// optional int32 votes_against = 3;
inline bool CMsgCREItemVoteSummaryResponse_ItemVoteSummary::has_votes_against() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_has_votes_against() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_has_votes_against() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_votes_against() {
  votes_against_ = 0;
  clear_has_votes_against();
}
inline ::google::protobuf::int32 CMsgCREItemVoteSummaryResponse_ItemVoteSummary::votes_against() const {
  return votes_against_;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_votes_against(::google::protobuf::int32 value) {
  set_has_votes_against();
  votes_against_ = value;
}

// optional int32 reports = 4;
inline bool CMsgCREItemVoteSummaryResponse_ItemVoteSummary::has_reports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_has_reports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_has_reports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_reports() {
  reports_ = 0;
  clear_has_reports();
}
inline ::google::protobuf::int32 CMsgCREItemVoteSummaryResponse_ItemVoteSummary::reports() const {
  return reports_;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_reports(::google::protobuf::int32 value) {
  set_has_reports();
  reports_ = value;
}

// optional float score = 5;
inline bool CMsgCREItemVoteSummaryResponse_ItemVoteSummary::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgCREItemVoteSummaryResponse_ItemVoteSummary::score() const {
  return score_;
}
inline void CMsgCREItemVoteSummaryResponse_ItemVoteSummary::set_score(float value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CMsgCREItemVoteSummaryResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgCREItemVoteSummaryResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREItemVoteSummaryResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREItemVoteSummaryResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREItemVoteSummaryResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgCREItemVoteSummaryResponse::eresult() const {
  return eresult_;
}
inline void CMsgCREItemVoteSummaryResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgCREItemVoteSummaryResponse.ItemVoteSummary item_vote_summaries = 2;
inline int CMsgCREItemVoteSummaryResponse::item_vote_summaries_size() const {
  return item_vote_summaries_.size();
}
inline void CMsgCREItemVoteSummaryResponse::clear_item_vote_summaries() {
  item_vote_summaries_.Clear();
}
inline const ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary& CMsgCREItemVoteSummaryResponse::item_vote_summaries(int index) const {
  return item_vote_summaries_.Get(index);
}
inline ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary* CMsgCREItemVoteSummaryResponse::mutable_item_vote_summaries(int index) {
  return item_vote_summaries_.Mutable(index);
}
inline ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary* CMsgCREItemVoteSummaryResponse::add_item_vote_summaries() {
  return item_vote_summaries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary >&
CMsgCREItemVoteSummaryResponse::item_vote_summaries() const {
  return item_vote_summaries_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREItemVoteSummaryResponse_ItemVoteSummary >*
CMsgCREItemVoteSummaryResponse::mutable_item_vote_summaries() {
  return &item_vote_summaries_;
}

// -------------------------------------------------------------------

// CMsgCREUpdateUserPublishedItemVote

// optional fixed64 published_file_id = 1;
inline bool CMsgCREUpdateUserPublishedItemVote::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREUpdateUserPublishedItemVote::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREUpdateUserPublishedItemVote::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREUpdateUserPublishedItemVote::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCREUpdateUserPublishedItemVote::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCREUpdateUserPublishedItemVote::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional bool vote_up = 2;
inline bool CMsgCREUpdateUserPublishedItemVote::has_vote_up() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCREUpdateUserPublishedItemVote::set_has_vote_up() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCREUpdateUserPublishedItemVote::clear_has_vote_up() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCREUpdateUserPublishedItemVote::clear_vote_up() {
  vote_up_ = false;
  clear_has_vote_up();
}
inline bool CMsgCREUpdateUserPublishedItemVote::vote_up() const {
  return vote_up_;
}
inline void CMsgCREUpdateUserPublishedItemVote::set_vote_up(bool value) {
  set_has_vote_up();
  vote_up_ = value;
}

// -------------------------------------------------------------------

// CMsgCREUpdateUserPublishedItemVoteResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgCREUpdateUserPublishedItemVoteResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREUpdateUserPublishedItemVoteResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREUpdateUserPublishedItemVoteResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREUpdateUserPublishedItemVoteResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgCREUpdateUserPublishedItemVoteResponse::eresult() const {
  return eresult_;
}
inline void CMsgCREUpdateUserPublishedItemVoteResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId

// optional fixed64 published_file_id = 1;
inline bool CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// -------------------------------------------------------------------

// CMsgCREGetUserPublishedItemVoteDetails

// repeated .Sc.CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId published_file_ids = 1;
inline int CMsgCREGetUserPublishedItemVoteDetails::published_file_ids_size() const {
  return published_file_ids_.size();
}
inline void CMsgCREGetUserPublishedItemVoteDetails::clear_published_file_ids() {
  published_file_ids_.Clear();
}
inline const ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId& CMsgCREGetUserPublishedItemVoteDetails::published_file_ids(int index) const {
  return published_file_ids_.Get(index);
}
inline ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* CMsgCREGetUserPublishedItemVoteDetails::mutable_published_file_ids(int index) {
  return published_file_ids_.Mutable(index);
}
inline ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId* CMsgCREGetUserPublishedItemVoteDetails::add_published_file_ids() {
  return published_file_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId >&
CMsgCREGetUserPublishedItemVoteDetails::published_file_ids() const {
  return published_file_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId >*
CMsgCREGetUserPublishedItemVoteDetails::mutable_published_file_ids() {
  return &published_file_ids_;
}

// -------------------------------------------------------------------

// CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail

// optional fixed64 published_file_id = 1;
inline bool CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::has_published_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::set_has_published_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::clear_has_published_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::clear_published_file_id() {
  published_file_id_ = GOOGLE_ULONGLONG(0);
  clear_has_published_file_id();
}
inline ::google::protobuf::uint64 CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::published_file_id() const {
  return published_file_id_;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::set_published_file_id(::google::protobuf::uint64 value) {
  set_has_published_file_id();
  published_file_id_ = value;
}

// optional int32 vote = 2 [default = 0];
inline bool CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::has_vote() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::set_has_vote() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::clear_has_vote() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::clear_vote() {
  vote_ = 0;
  clear_has_vote();
}
inline ::google::protobuf::int32 CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::vote() const {
  return vote_;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::set_vote(::google::protobuf::int32 value) {
  set_has_vote();
  vote_ = value;
}

// -------------------------------------------------------------------

// CMsgCREGetUserPublishedItemVoteDetailsResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgCREGetUserPublishedItemVoteDetailsResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgCREGetUserPublishedItemVoteDetailsResponse::eresult() const {
  return eresult_;
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// repeated .Sc.CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail user_item_vote_details = 2;
inline int CMsgCREGetUserPublishedItemVoteDetailsResponse::user_item_vote_details_size() const {
  return user_item_vote_details_.size();
}
inline void CMsgCREGetUserPublishedItemVoteDetailsResponse::clear_user_item_vote_details() {
  user_item_vote_details_.Clear();
}
inline const ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail& CMsgCREGetUserPublishedItemVoteDetailsResponse::user_item_vote_details(int index) const {
  return user_item_vote_details_.Get(index);
}
inline ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* CMsgCREGetUserPublishedItemVoteDetailsResponse::mutable_user_item_vote_details(int index) {
  return user_item_vote_details_.Mutable(index);
}
inline ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail* CMsgCREGetUserPublishedItemVoteDetailsResponse::add_user_item_vote_details() {
  return user_item_vote_details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail >&
CMsgCREGetUserPublishedItemVoteDetailsResponse::user_item_vote_details() const {
  return user_item_vote_details_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail >*
CMsgCREGetUserPublishedItemVoteDetailsResponse::mutable_user_item_vote_details() {
  return &user_item_vote_details_;
}

// -------------------------------------------------------------------

// CMsgGameServerPingSample_Sample

// optional fixed32 ip = 1;
inline bool CMsgGameServerPingSample_Sample::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGameServerPingSample_Sample::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGameServerPingSample_Sample::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGameServerPingSample_Sample::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 CMsgGameServerPingSample_Sample::ip() const {
  return ip_;
}
inline void CMsgGameServerPingSample_Sample::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 avg_ping_ms = 2;
inline bool CMsgGameServerPingSample_Sample::has_avg_ping_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGameServerPingSample_Sample::set_has_avg_ping_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGameServerPingSample_Sample::clear_has_avg_ping_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGameServerPingSample_Sample::clear_avg_ping_ms() {
  avg_ping_ms_ = 0u;
  clear_has_avg_ping_ms();
}
inline ::google::protobuf::uint32 CMsgGameServerPingSample_Sample::avg_ping_ms() const {
  return avg_ping_ms_;
}
inline void CMsgGameServerPingSample_Sample::set_avg_ping_ms(::google::protobuf::uint32 value) {
  set_has_avg_ping_ms();
  avg_ping_ms_ = value;
}

// optional uint32 stddev_ping_ms_x10 = 3;
inline bool CMsgGameServerPingSample_Sample::has_stddev_ping_ms_x10() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGameServerPingSample_Sample::set_has_stddev_ping_ms_x10() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGameServerPingSample_Sample::clear_has_stddev_ping_ms_x10() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGameServerPingSample_Sample::clear_stddev_ping_ms_x10() {
  stddev_ping_ms_x10_ = 0u;
  clear_has_stddev_ping_ms_x10();
}
inline ::google::protobuf::uint32 CMsgGameServerPingSample_Sample::stddev_ping_ms_x10() const {
  return stddev_ping_ms_x10_;
}
inline void CMsgGameServerPingSample_Sample::set_stddev_ping_ms_x10(::google::protobuf::uint32 value) {
  set_has_stddev_ping_ms_x10();
  stddev_ping_ms_x10_ = value;
}

// -------------------------------------------------------------------

// CMsgGameServerPingSample

// optional fixed32 my_ip = 1;
inline bool CMsgGameServerPingSample::has_my_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGameServerPingSample::set_has_my_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGameServerPingSample::clear_has_my_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGameServerPingSample::clear_my_ip() {
  my_ip_ = 0u;
  clear_has_my_ip();
}
inline ::google::protobuf::uint32 CMsgGameServerPingSample::my_ip() const {
  return my_ip_;
}
inline void CMsgGameServerPingSample::set_my_ip(::google::protobuf::uint32 value) {
  set_has_my_ip();
  my_ip_ = value;
}

// optional int32 gs_app_id = 2;
inline bool CMsgGameServerPingSample::has_gs_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGameServerPingSample::set_has_gs_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGameServerPingSample::clear_has_gs_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGameServerPingSample::clear_gs_app_id() {
  gs_app_id_ = 0;
  clear_has_gs_app_id();
}
inline ::google::protobuf::int32 CMsgGameServerPingSample::gs_app_id() const {
  return gs_app_id_;
}
inline void CMsgGameServerPingSample::set_gs_app_id(::google::protobuf::int32 value) {
  set_has_gs_app_id();
  gs_app_id_ = value;
}

// repeated .Sc.CMsgGameServerPingSample.Sample gs_samples = 3;
inline int CMsgGameServerPingSample::gs_samples_size() const {
  return gs_samples_.size();
}
inline void CMsgGameServerPingSample::clear_gs_samples() {
  gs_samples_.Clear();
}
inline const ::Sc::CMsgGameServerPingSample_Sample& CMsgGameServerPingSample::gs_samples(int index) const {
  return gs_samples_.Get(index);
}
inline ::Sc::CMsgGameServerPingSample_Sample* CMsgGameServerPingSample::mutable_gs_samples(int index) {
  return gs_samples_.Mutable(index);
}
inline ::Sc::CMsgGameServerPingSample_Sample* CMsgGameServerPingSample::add_gs_samples() {
  return gs_samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerPingSample_Sample >&
CMsgGameServerPingSample::gs_samples() const {
  return gs_samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sc::CMsgGameServerPingSample_Sample >*
CMsgGameServerPingSample::mutable_gs_samples() {
  return &gs_samples_;
}

// -------------------------------------------------------------------

// CMsgFSGetFollowerCount

// optional fixed64 steam_id = 1;
inline bool CMsgFSGetFollowerCount::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFSGetFollowerCount::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFSGetFollowerCount::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFSGetFollowerCount::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgFSGetFollowerCount::steam_id() const {
  return steam_id_;
}
inline void CMsgFSGetFollowerCount::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgFSGetFollowerCountResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgFSGetFollowerCountResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFSGetFollowerCountResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFSGetFollowerCountResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFSGetFollowerCountResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgFSGetFollowerCountResponse::eresult() const {
  return eresult_;
}
inline void CMsgFSGetFollowerCountResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 count = 2 [default = 0];
inline bool CMsgFSGetFollowerCountResponse::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgFSGetFollowerCountResponse::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgFSGetFollowerCountResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgFSGetFollowerCountResponse::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CMsgFSGetFollowerCountResponse::count() const {
  return count_;
}
inline void CMsgFSGetFollowerCountResponse::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// CMsgFSGetIsFollowing

// optional fixed64 steam_id = 1;
inline bool CMsgFSGetIsFollowing::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFSGetIsFollowing::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFSGetIsFollowing::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFSGetIsFollowing::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgFSGetIsFollowing::steam_id() const {
  return steam_id_;
}
inline void CMsgFSGetIsFollowing::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
}

// -------------------------------------------------------------------

// CMsgFSGetIsFollowingResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgFSGetIsFollowingResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFSGetIsFollowingResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFSGetIsFollowingResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFSGetIsFollowingResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgFSGetIsFollowingResponse::eresult() const {
  return eresult_;
}
inline void CMsgFSGetIsFollowingResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional bool is_following = 2 [default = false];
inline bool CMsgFSGetIsFollowingResponse::has_is_following() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgFSGetIsFollowingResponse::set_has_is_following() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgFSGetIsFollowingResponse::clear_has_is_following() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgFSGetIsFollowingResponse::clear_is_following() {
  is_following_ = false;
  clear_has_is_following();
}
inline bool CMsgFSGetIsFollowingResponse::is_following() const {
  return is_following_;
}
inline void CMsgFSGetIsFollowingResponse::set_is_following(bool value) {
  set_has_is_following();
  is_following_ = value;
}

// -------------------------------------------------------------------

// CMsgFSEnumerateFollowingList

// optional uint32 start_index = 1;
inline bool CMsgFSEnumerateFollowingList::has_start_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFSEnumerateFollowingList::set_has_start_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFSEnumerateFollowingList::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFSEnumerateFollowingList::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 CMsgFSEnumerateFollowingList::start_index() const {
  return start_index_;
}
inline void CMsgFSEnumerateFollowingList::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// -------------------------------------------------------------------

// CMsgFSEnumerateFollowingListResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgFSEnumerateFollowingListResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFSEnumerateFollowingListResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFSEnumerateFollowingListResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFSEnumerateFollowingListResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgFSEnumerateFollowingListResponse::eresult() const {
  return eresult_;
}
inline void CMsgFSEnumerateFollowingListResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 total_results = 2;
inline bool CMsgFSEnumerateFollowingListResponse::has_total_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgFSEnumerateFollowingListResponse::set_has_total_results() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgFSEnumerateFollowingListResponse::clear_has_total_results() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgFSEnumerateFollowingListResponse::clear_total_results() {
  total_results_ = 0;
  clear_has_total_results();
}
inline ::google::protobuf::int32 CMsgFSEnumerateFollowingListResponse::total_results() const {
  return total_results_;
}
inline void CMsgFSEnumerateFollowingListResponse::set_total_results(::google::protobuf::int32 value) {
  set_has_total_results();
  total_results_ = value;
}

// repeated fixed64 steam_ids = 3;
inline int CMsgFSEnumerateFollowingListResponse::steam_ids_size() const {
  return steam_ids_.size();
}
inline void CMsgFSEnumerateFollowingListResponse::clear_steam_ids() {
  steam_ids_.Clear();
}
inline ::google::protobuf::uint64 CMsgFSEnumerateFollowingListResponse::steam_ids(int index) const {
  return steam_ids_.Get(index);
}
inline void CMsgFSEnumerateFollowingListResponse::set_steam_ids(int index, ::google::protobuf::uint64 value) {
  steam_ids_.Set(index, value);
}
inline void CMsgFSEnumerateFollowingListResponse::add_steam_ids(::google::protobuf::uint64 value) {
  steam_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgFSEnumerateFollowingListResponse::steam_ids() const {
  return steam_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgFSEnumerateFollowingListResponse::mutable_steam_ids() {
  return &steam_ids_;
}

// -------------------------------------------------------------------

// CMsgDPGetNumberOfCurrentPlayers

// optional uint32 appid = 1;
inline bool CMsgDPGetNumberOfCurrentPlayers::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDPGetNumberOfCurrentPlayers::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDPGetNumberOfCurrentPlayers::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDPGetNumberOfCurrentPlayers::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgDPGetNumberOfCurrentPlayers::appid() const {
  return appid_;
}
inline void CMsgDPGetNumberOfCurrentPlayers::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// CMsgDPGetNumberOfCurrentPlayersResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgDPGetNumberOfCurrentPlayersResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgDPGetNumberOfCurrentPlayersResponse::eresult() const {
  return eresult_;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 player_count = 2;
inline bool CMsgDPGetNumberOfCurrentPlayersResponse::has_player_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::set_has_player_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::clear_has_player_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::clear_player_count() {
  player_count_ = 0;
  clear_has_player_count();
}
inline ::google::protobuf::int32 CMsgDPGetNumberOfCurrentPlayersResponse::player_count() const {
  return player_count_;
}
inline void CMsgDPGetNumberOfCurrentPlayersResponse::set_player_count(::google::protobuf::int32 value) {
  set_has_player_count();
  player_count_ = value;
}

// -------------------------------------------------------------------

// CMsgClientFriendUserStatusPublished

// optional fixed64 friend_steamid = 1;
inline bool CMsgClientFriendUserStatusPublished::has_friend_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientFriendUserStatusPublished::set_has_friend_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientFriendUserStatusPublished::clear_has_friend_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientFriendUserStatusPublished::clear_friend_steamid() {
  friend_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_friend_steamid();
}
inline ::google::protobuf::uint64 CMsgClientFriendUserStatusPublished::friend_steamid() const {
  return friend_steamid_;
}
inline void CMsgClientFriendUserStatusPublished::set_friend_steamid(::google::protobuf::uint64 value) {
  set_has_friend_steamid();
  friend_steamid_ = value;
}

// optional uint32 appid = 2;
inline bool CMsgClientFriendUserStatusPublished::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientFriendUserStatusPublished::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientFriendUserStatusPublished::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientFriendUserStatusPublished::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientFriendUserStatusPublished::appid() const {
  return appid_;
}
inline void CMsgClientFriendUserStatusPublished::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string status_text = 3;
inline bool CMsgClientFriendUserStatusPublished::has_status_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientFriendUserStatusPublished::set_has_status_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientFriendUserStatusPublished::clear_has_status_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientFriendUserStatusPublished::clear_status_text() {
  if (status_text_ != &::google::protobuf::internal::kEmptyString) {
    status_text_->clear();
  }
  clear_has_status_text();
}
inline const ::std::string& CMsgClientFriendUserStatusPublished::status_text() const {
  return *status_text_;
}
inline void CMsgClientFriendUserStatusPublished::set_status_text(const ::std::string& value) {
  set_has_status_text();
  if (status_text_ == &::google::protobuf::internal::kEmptyString) {
    status_text_ = new ::std::string;
  }
  status_text_->assign(value);
}
inline void CMsgClientFriendUserStatusPublished::set_status_text(const char* value) {
  set_has_status_text();
  if (status_text_ == &::google::protobuf::internal::kEmptyString) {
    status_text_ = new ::std::string;
  }
  status_text_->assign(value);
}
inline void CMsgClientFriendUserStatusPublished::set_status_text(const char* value, size_t size) {
  set_has_status_text();
  if (status_text_ == &::google::protobuf::internal::kEmptyString) {
    status_text_ = new ::std::string;
  }
  status_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientFriendUserStatusPublished::mutable_status_text() {
  set_has_status_text();
  if (status_text_ == &::google::protobuf::internal::kEmptyString) {
    status_text_ = new ::std::string;
  }
  return status_text_;
}
inline ::std::string* CMsgClientFriendUserStatusPublished::release_status_text() {
  clear_has_status_text();
  if (status_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_text_;
    status_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientFriendUserStatusPublished::set_allocated_status_text(::std::string* status_text) {
  if (status_text_ != &::google::protobuf::internal::kEmptyString) {
    delete status_text_;
  }
  if (status_text) {
    set_has_status_text();
    status_text_ = status_text;
  } else {
    clear_has_status_text();
    status_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientServiceMethod

// optional string method_name = 1;
inline bool CMsgClientServiceMethod::has_method_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientServiceMethod::set_has_method_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientServiceMethod::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientServiceMethod::clear_method_name() {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    method_name_->clear();
  }
  clear_has_method_name();
}
inline const ::std::string& CMsgClientServiceMethod::method_name() const {
  return *method_name_;
}
inline void CMsgClientServiceMethod::set_method_name(const ::std::string& value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void CMsgClientServiceMethod::set_method_name(const char* value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void CMsgClientServiceMethod::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientServiceMethod::mutable_method_name() {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}
inline ::std::string* CMsgClientServiceMethod::release_method_name() {
  clear_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_name_;
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientServiceMethod::set_allocated_method_name(::std::string* method_name) {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    delete method_name_;
  }
  if (method_name) {
    set_has_method_name();
    method_name_ = method_name;
  } else {
    clear_has_method_name();
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serialized_method = 2;
inline bool CMsgClientServiceMethod::has_serialized_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientServiceMethod::set_has_serialized_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientServiceMethod::clear_has_serialized_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientServiceMethod::clear_serialized_method() {
  if (serialized_method_ != &::google::protobuf::internal::kEmptyString) {
    serialized_method_->clear();
  }
  clear_has_serialized_method();
}
inline const ::std::string& CMsgClientServiceMethod::serialized_method() const {
  return *serialized_method_;
}
inline void CMsgClientServiceMethod::set_serialized_method(const ::std::string& value) {
  set_has_serialized_method();
  if (serialized_method_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_ = new ::std::string;
  }
  serialized_method_->assign(value);
}
inline void CMsgClientServiceMethod::set_serialized_method(const char* value) {
  set_has_serialized_method();
  if (serialized_method_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_ = new ::std::string;
  }
  serialized_method_->assign(value);
}
inline void CMsgClientServiceMethod::set_serialized_method(const char* value, size_t size) {
  set_has_serialized_method();
  if (serialized_method_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_ = new ::std::string;
  }
  serialized_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientServiceMethod::mutable_serialized_method() {
  set_has_serialized_method();
  if (serialized_method_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_ = new ::std::string;
  }
  return serialized_method_;
}
inline ::std::string* CMsgClientServiceMethod::release_serialized_method() {
  clear_has_serialized_method();
  if (serialized_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_method_;
    serialized_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientServiceMethod::set_allocated_serialized_method(::std::string* serialized_method) {
  if (serialized_method_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_method_;
  }
  if (serialized_method) {
    set_has_serialized_method();
    serialized_method_ = serialized_method;
  } else {
    clear_has_serialized_method();
    serialized_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_notification = 3;
inline bool CMsgClientServiceMethod::has_is_notification() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientServiceMethod::set_has_is_notification() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientServiceMethod::clear_has_is_notification() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientServiceMethod::clear_is_notification() {
  is_notification_ = false;
  clear_has_is_notification();
}
inline bool CMsgClientServiceMethod::is_notification() const {
  return is_notification_;
}
inline void CMsgClientServiceMethod::set_is_notification(bool value) {
  set_has_is_notification();
  is_notification_ = value;
}

// -------------------------------------------------------------------

// CMsgClientServiceMethodResponse

// optional string method_name = 1;
inline bool CMsgClientServiceMethodResponse::has_method_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientServiceMethodResponse::set_has_method_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientServiceMethodResponse::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientServiceMethodResponse::clear_method_name() {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    method_name_->clear();
  }
  clear_has_method_name();
}
inline const ::std::string& CMsgClientServiceMethodResponse::method_name() const {
  return *method_name_;
}
inline void CMsgClientServiceMethodResponse::set_method_name(const ::std::string& value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void CMsgClientServiceMethodResponse::set_method_name(const char* value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void CMsgClientServiceMethodResponse::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientServiceMethodResponse::mutable_method_name() {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}
inline ::std::string* CMsgClientServiceMethodResponse::release_method_name() {
  clear_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_name_;
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientServiceMethodResponse::set_allocated_method_name(::std::string* method_name) {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    delete method_name_;
  }
  if (method_name) {
    set_has_method_name();
    method_name_ = method_name;
  } else {
    clear_has_method_name();
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serialized_method_response = 2;
inline bool CMsgClientServiceMethodResponse::has_serialized_method_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientServiceMethodResponse::set_has_serialized_method_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientServiceMethodResponse::clear_has_serialized_method_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientServiceMethodResponse::clear_serialized_method_response() {
  if (serialized_method_response_ != &::google::protobuf::internal::kEmptyString) {
    serialized_method_response_->clear();
  }
  clear_has_serialized_method_response();
}
inline const ::std::string& CMsgClientServiceMethodResponse::serialized_method_response() const {
  return *serialized_method_response_;
}
inline void CMsgClientServiceMethodResponse::set_serialized_method_response(const ::std::string& value) {
  set_has_serialized_method_response();
  if (serialized_method_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_response_ = new ::std::string;
  }
  serialized_method_response_->assign(value);
}
inline void CMsgClientServiceMethodResponse::set_serialized_method_response(const char* value) {
  set_has_serialized_method_response();
  if (serialized_method_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_response_ = new ::std::string;
  }
  serialized_method_response_->assign(value);
}
inline void CMsgClientServiceMethodResponse::set_serialized_method_response(const char* value, size_t size) {
  set_has_serialized_method_response();
  if (serialized_method_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_response_ = new ::std::string;
  }
  serialized_method_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientServiceMethodResponse::mutable_serialized_method_response() {
  set_has_serialized_method_response();
  if (serialized_method_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_method_response_ = new ::std::string;
  }
  return serialized_method_response_;
}
inline ::std::string* CMsgClientServiceMethodResponse::release_serialized_method_response() {
  clear_has_serialized_method_response();
  if (serialized_method_response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_method_response_;
    serialized_method_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientServiceMethodResponse::set_allocated_serialized_method_response(::std::string* serialized_method_response) {
  if (serialized_method_response_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_method_response_;
  }
  if (serialized_method_response) {
    set_has_serialized_method_response();
    serialized_method_response_ = serialized_method_response;
  } else {
    clear_has_serialized_method_response();
    serialized_method_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientUIMode

// optional uint32 uimode = 1;
inline bool CMsgClientUIMode::has_uimode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientUIMode::set_has_uimode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientUIMode::clear_has_uimode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientUIMode::clear_uimode() {
  uimode_ = 0u;
  clear_has_uimode();
}
inline ::google::protobuf::uint32 CMsgClientUIMode::uimode() const {
  return uimode_;
}
inline void CMsgClientUIMode::set_uimode(::google::protobuf::uint32 value) {
  set_has_uimode();
  uimode_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Sc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_steammessages_5fclientserver_2eproto__INCLUDED
